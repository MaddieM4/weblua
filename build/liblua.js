// Note: Some Emscripten settings will significantly limit the speed of the generated code.
// Note: Some Emscripten settings may limit the speed of the generated code.
try {
  this['Module'] = Module;
} catch(e) {
  this['Module'] = Module = {};
}

// The environment setup code below is customized to use Module.
// *** Environment setup code ***
var ENVIRONMENT_IS_NODE = typeof process === 'object' && typeof require === 'function';
var ENVIRONMENT_IS_WEB = typeof window === 'object';
var ENVIRONMENT_IS_WORKER = typeof importScripts === 'function';
var ENVIRONMENT_IS_SHELL = !ENVIRONMENT_IS_WEB && !ENVIRONMENT_IS_NODE && !ENVIRONMENT_IS_WORKER;

if (ENVIRONMENT_IS_NODE) {
  // Expose functionality in the same simple way that the shells work
  // Note that we pollute the global namespace here, otherwise we break in node
  Module['print'] = function(x) {
    process['stdout'].write(x + '\n');
  };
  Module['printErr'] = function(x) {
    process['stderr'].write(x + '\n');
  };

  var nodeFS = require('fs');
  var nodePath = require('path');

  Module['read'] = function(filename) {
    filename = nodePath['normalize'](filename);
    var ret = nodeFS['readFileSync'](filename).toString();
    // The path is absolute if the normalized version is the same as the resolved.
    if (!ret && filename != nodePath['resolve'](filename)) {
      filename = path.join(__dirname, '..', 'src', filename);
      ret = nodeFS['readFileSync'](filename).toString();
    }
    return ret;
  };

  Module['load'] = function(f) {
    globalEval(read(f));
  };

  if (!Module['arguments']) {
    Module['arguments'] = process['argv'].slice(2);
  }
}

if (ENVIRONMENT_IS_SHELL) {
  Module['print'] = print;
  if (typeof printErr != 'undefined') Module['printErr'] = printErr; // not present in v8 or older sm

  // Polyfill over SpiderMonkey/V8 differences
  if (typeof read != 'undefined') {
    Module['read'] = read;
  } else {
    Module['read'] = function(f) { snarf(f) };
  }

  if (!Module['arguments']) {
    if (typeof scriptArgs != 'undefined') {
      Module['arguments'] = scriptArgs;
    } else if (typeof arguments != 'undefined') {
      Module['arguments'] = arguments;
    }
  }
}

if (ENVIRONMENT_IS_WEB && !ENVIRONMENT_IS_WORKER) {
  if (!Module['print']) {
    Module['print'] = function(x) {
      console.log(x);
    };
  }

  if (!Module['printErr']) {
    Module['printErr'] = function(x) {
      console.log(x);
    };
  }
}

if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {
  Module['read'] = function(url) {
    var xhr = new XMLHttpRequest();
    xhr.open('GET', url, false);
    xhr.send(null);
    return xhr.responseText;
  };

  if (!Module['arguments']) {
    if (typeof arguments != 'undefined') {
      Module['arguments'] = arguments;
    }
  }
}

if (ENVIRONMENT_IS_WORKER) {
  // We can do very little here...
  var TRY_USE_DUMP = false;
  if (!Module['print']) {
    Module['print'] = (TRY_USE_DUMP && (typeof(dump) !== "undefined") ? (function(x) {
      dump(x);
    }) : (function(x) {
      // self.postMessage(x); // enable this if you want stdout to be sent as messages
    }));
  }

  Module['load'] = importScripts;
}

if (!ENVIRONMENT_IS_WORKER && !ENVIRONMENT_IS_WEB && !ENVIRONMENT_IS_NODE && !ENVIRONMENT_IS_SHELL) {
  // Unreachable because SHELL is dependant on the others
  throw 'Unknown runtime environment. Where are we?';
}

function globalEval(x) {
  eval.call(null, x);
}
if (!Module['load'] == 'undefined' && Module['read']) {
  Module['load'] = function(f) {
    globalEval(Module['read'](f));
  };
}
if (!Module['print']) {
  Module['print'] = function(){};
}
if (!Module['printErr']) {
  Module['printErr'] = Module['print'];
}
if (!Module['arguments']) {
  Module['arguments'] = [];
}
// *** Environment setup code ***

// Closure helpers
Module.print = Module['print'];
Module.printErr = Module['printErr'];

// Callbacks
if (!Module['preRun']) Module['preRun'] = [];
if (!Module['postRun']) Module['postRun'] = [];

  
// === Auto-generated preamble library stuff ===

//========================================
// Runtime code shared with compiler
//========================================

var Runtime = {
  stackSave: function () {
    return STACKTOP;
  },
  stackRestore: function (stackTop) {
    STACKTOP = stackTop;
  },
  forceAlign: function (target, quantum) {
    quantum = quantum || 4;
    if (quantum == 1) return target;
    if (isNumber(target) && isNumber(quantum)) {
      return Math.ceil(target/quantum)*quantum;
    } else if (isNumber(quantum) && isPowerOfTwo(quantum)) {
      var logg = log2(quantum);
      return '((((' +target + ')+' + (quantum-1) + ')>>' + logg + ')<<' + logg + ')';
    }
    return 'Math.ceil((' + target + ')/' + quantum + ')*' + quantum;
  },
  isNumberType: function (type) {
    return type in Runtime.INT_TYPES || type in Runtime.FLOAT_TYPES;
  },
  isPointerType: function isPointerType(type) {
  return type[type.length-1] == '*';
},
  isStructType: function isStructType(type) {
  if (isPointerType(type)) return false;
  if (/^\[\d+\ x\ (.*)\]/.test(type)) return true; // [15 x ?] blocks. Like structs
  if (/<?{ ?[^}]* ?}>?/.test(type)) return true; // { i32, i8 } etc. - anonymous struct types
  // See comment in isStructPointerType()
  return type[0] == '%';
},
  INT_TYPES: {"i1":0,"i8":0,"i16":0,"i32":0,"i64":0},
  FLOAT_TYPES: {"float":0,"double":0},
  BITSHIFT64_SHL: 0,
  BITSHIFT64_ASHR: 1,
  BITSHIFT64_LSHR: 2,
  bitshift64: function (low, high, op, bits) {
    var ret;
    var ander = Math.pow(2, bits)-1;
    if (bits < 32) {
      switch (op) {
        case Runtime.BITSHIFT64_SHL:
          ret = [low << bits, (high << bits) | ((low&(ander << (32 - bits))) >>> (32 - bits))];
          break;
        case Runtime.BITSHIFT64_ASHR:
          ret = [(((low >>> bits ) | ((high&ander) << (32 - bits))) >> 0) >>> 0, (high >> bits) >>> 0];
          break;
        case Runtime.BITSHIFT64_LSHR:
          ret = [((low >>> bits) | ((high&ander) << (32 - bits))) >>> 0, high >>> bits];
          break;
      }
    } else if (bits == 32) {
      switch (op) {
        case Runtime.BITSHIFT64_SHL:
          ret = [0, low];
          break;
        case Runtime.BITSHIFT64_ASHR:
          ret = [high, (high|0) < 0 ? ander : 0];
          break;
        case Runtime.BITSHIFT64_LSHR:
          ret = [high, 0];
          break;
      }
    } else { // bits > 32
      switch (op) {
        case Runtime.BITSHIFT64_SHL:
          ret = [0, low << (bits - 32)];
          break;
        case Runtime.BITSHIFT64_ASHR:
          ret = [(high >> (bits - 32)) >>> 0, (high|0) < 0 ? ander : 0];
          break;
        case Runtime.BITSHIFT64_LSHR:
          ret = [high >>>  (bits - 32) , 0];
          break;
      }
    }
    HEAP32[tempDoublePtr>>2] = ret[0]; // cannot use utility functions since we are in runtime itself
    HEAP32[tempDoublePtr+4>>2] = ret[1];
  },
  or64: function (x, y) {
    var l = (x | 0) | (y | 0);
    var h = (Math.round(x / 4294967296) | Math.round(y / 4294967296)) * 4294967296;
    return l + h;
  },
  and64: function (x, y) {
    var l = (x | 0) & (y | 0);
    var h = (Math.round(x / 4294967296) & Math.round(y / 4294967296)) * 4294967296;
    return l + h;
  },
  xor64: function (x, y) {
    var l = (x | 0) ^ (y | 0);
    var h = (Math.round(x / 4294967296) ^ Math.round(y / 4294967296)) * 4294967296;
    return l + h;
  },
  getNativeTypeSize: function (type, quantumSize) {
    if (Runtime.QUANTUM_SIZE == 1) return 1;
    var size = {
      '%i1': 1,
      '%i8': 1,
      '%i16': 2,
      '%i32': 4,
      '%i64': 8,
      "%float": 4,
      "%double": 8
    }['%'+type]; // add '%' since float and double confuse Closure compiler as keys, and also spidermonkey as a compiler will remove 's from '_i8' etc
    if (!size) {
      if (type.charAt(type.length-1) == '*') {
        size = Runtime.QUANTUM_SIZE; // A pointer
      } else if (type[0] == 'i') {
        var bits = parseInt(type.substr(1));
        assert(bits % 8 == 0);
        size = bits/8;
      }
    }
    return size;
  },
  getNativeFieldSize: function (type) {
    return Math.max(Runtime.getNativeTypeSize(type), Runtime.QUANTUM_SIZE);
  },
  dedup: function dedup(items, ident) {
  var seen = {};
  if (ident) {
    return items.filter(function(item) {
      if (seen[item[ident]]) return false;
      seen[item[ident]] = true;
      return true;
    });
  } else {
    return items.filter(function(item) {
      if (seen[item]) return false;
      seen[item] = true;
      return true;
    });
  }
},
  set: function set() {
  var args = typeof arguments[0] === 'object' ? arguments[0] : arguments;
  var ret = {};
  for (var i = 0; i < args.length; i++) {
    ret[args[i]] = 0;
  }
  return ret;
},
  calculateStructAlignment: function calculateStructAlignment(type) {
    type.flatSize = 0;
    type.alignSize = 0;
    var diffs = [];
    var prev = -1;
    type.flatIndexes = type.fields.map(function(field) {
      var size, alignSize;
      if (Runtime.isNumberType(field) || Runtime.isPointerType(field)) {
        size = Runtime.getNativeTypeSize(field); // pack char; char; in structs, also char[X]s.
        alignSize = size;
      } else if (Runtime.isStructType(field)) {
        size = Types.types[field].flatSize;
        alignSize = Types.types[field].alignSize;
      } else if (field[0] == 'b') {
        // bN, large number field, like a [N x i8]
        size = field.substr(1)|0;
        alignSize = 1;
      } else {
        throw 'Unclear type in struct: ' + field + ', in ' + type.name_ + ' :: ' + dump(Types.types[type.name_]);
      }
      alignSize = type.packed ? 1 : Math.min(alignSize, Runtime.QUANTUM_SIZE);
      type.alignSize = Math.max(type.alignSize, alignSize);
      var curr = Runtime.alignMemory(type.flatSize, alignSize); // if necessary, place this on aligned memory
      type.flatSize = curr + size;
      if (prev >= 0) {
        diffs.push(curr-prev);
      }
      prev = curr;
      return curr;
    });
    type.flatSize = Runtime.alignMemory(type.flatSize, type.alignSize);
    if (diffs.length == 0) {
      type.flatFactor = type.flatSize;
    } else if (Runtime.dedup(diffs).length == 1) {
      type.flatFactor = diffs[0];
    }
    type.needsFlattening = (type.flatFactor != 1);
    return type.flatIndexes;
  },
  generateStructInfo: function (struct, typeName, offset) {
    var type, alignment;
    if (typeName) {
      offset = offset || 0;
      type = (typeof Types === 'undefined' ? Runtime.typeInfo : Types.types)[typeName];
      if (!type) return null;
      if (type.fields.length != struct.length) {
        printErr('Number of named fields must match the type for ' + typeName + ': possibly duplicate struct names. Cannot return structInfo');
        return null;
      }
      alignment = type.flatIndexes;
    } else {
      var type = { fields: struct.map(function(item) { return item[0] }) };
      alignment = Runtime.calculateStructAlignment(type);
    }
    var ret = {
      __size__: type.flatSize
    };
    if (typeName) {
      struct.forEach(function(item, i) {
        if (typeof item === 'string') {
          ret[item] = alignment[i] + offset;
        } else {
          // embedded struct
          var key;
          for (var k in item) key = k;
          ret[key] = Runtime.generateStructInfo(item[key], type.fields[i], alignment[i]);
        }
      });
    } else {
      struct.forEach(function(item, i) {
        ret[item[1]] = alignment[i];
      });
    }
    return ret;
  },
  dynCall: function (sig, ptr, args) {
    if (args && args.length) {
      return FUNCTION_TABLE[ptr].apply(null, args);
    } else {
      return FUNCTION_TABLE[ptr]();
    }
  },
  addFunction: function (func, sig) {
    //assert(sig); // TODO: support asm
    var table = FUNCTION_TABLE; // TODO: support asm
    var ret = table.length;
    table.push(func);
    table.push(0);
    return ret;
  },
  warnOnce: function (text) {
    if (!Runtime.warnOnce.shown) Runtime.warnOnce.shown = {};
    if (!Runtime.warnOnce.shown[text]) {
      Runtime.warnOnce.shown[text] = 1;
      Module.printErr(text);
    }
  },
  funcWrappers: {},
  getFuncWrapper: function (func, sig) {
    assert(sig);
    if (!Runtime.funcWrappers[func]) {
      Runtime.funcWrappers[func] = function() {
        Runtime.dynCall(sig, func, arguments);
      };
    }
    return Runtime.funcWrappers[func];
  },
  UTF8Processor: function () {
    var buffer = [];
    var needed = 0;
    this.processCChar = function (code) {
      code = code & 0xff;
      if (needed) {
        buffer.push(code);
        needed--;
      }
      if (buffer.length == 0) {
        if (code < 128) return String.fromCharCode(code);
        buffer.push(code);
        if (code > 191 && code < 224) {
          needed = 1;
        } else {
          needed = 2;
        }
        return '';
      }
      if (needed > 0) return '';
      var c1 = buffer[0];
      var c2 = buffer[1];
      var c3 = buffer[2];
      var ret;
      if (c1 > 191 && c1 < 224) {
        ret = String.fromCharCode(((c1 & 31) << 6) | (c2 & 63));
      } else {
        ret = String.fromCharCode(((c1 & 15) << 12) | ((c2 & 63) << 6) | (c3 & 63));
      }
      buffer.length = 0;
      return ret;
    }
    this.processJSString = function(string) {
      string = unescape(encodeURIComponent(string));
      var ret = [];
      for (var i = 0; i < string.length; i++) {
        ret.push(string.charCodeAt(i));
      }
      return ret;
    }
  },
  stackAlloc: function stackAlloc(size) { var ret = STACKTOP;_memset(STACKTOP, 0, size);STACKTOP = (STACKTOP + size)|0;STACKTOP = ((((STACKTOP)+3)>>2)<<2); return ret; },
  staticAlloc: function staticAlloc(size) { var ret = STATICTOP;STATICTOP = (STATICTOP + size)|0;STATICTOP = ((((STATICTOP)+3)>>2)<<2); if (STATICTOP >= TOTAL_MEMORY) enlargeMemory();; return ret; },
  alignMemory: function alignMemory(size,quantum) { var ret = size = Math.ceil((size)/(quantum ? quantum : 4))*(quantum ? quantum : 4); return ret; },
  makeBigInt: function makeBigInt(low,high,unsigned) { var ret = (unsigned ? (((low)>>>0)+(((high)>>>0)*4294967296)) : (((low)>>>0)+(((high)|0)*4294967296))); return ret; },
  QUANTUM_SIZE: 4,
  __dummy__: 0
}





//========================================
// Debugging tools - Code flow progress
//========================================
var INDENT = '';


//========================================
// Runtime essentials
//========================================

var __THREW__ = 0; // Used in checking for thrown exceptions.
var setjmpId = 1; // Used in setjmp/longjmp
var setjmpLabels = {};

var ABORT = false;

var undef = 0;
// tempInt is used for 32-bit signed values or smaller. tempBigInt is used
// for 32-bit unsigned values or more than 32 bits. TODO: audit all uses of tempInt
var tempValue, tempInt, tempBigInt, tempInt2, tempBigInt2, tempPair, tempBigIntI, tempBigIntR, tempBigIntS, tempBigIntP, tempBigIntD;
var tempI64, tempI64b;
var tempRet0, tempRet1, tempRet2, tempRet3, tempRet4, tempRet5, tempRet6, tempRet7, tempRet8, tempRet9;

function abort(text) {
  Module.print(text + ':\n' + (new Error).stack);
  ABORT = true;
  throw "Assertion: " + text;
}

function assert(condition, text) {
  if (!condition) {
    abort('Assertion failed: ' + text);
  }
}

var globalScope = this;

// C calling interface. A convenient way to call C functions (in C files, or
// defined with extern "C").
//
// Note: LLVM optimizations can inline and remove functions, after which you will not be
//       able to call them. Closure can also do so. To avoid that, add your function to
//       the exports using something like
//
//         -s EXPORTED_FUNCTIONS='["_main", "_myfunc"]'
//
// @param ident      The name of the C function (note that C++ functions will be name-mangled - use extern "C")
// @param returnType The return type of the function, one of the JS types 'number', 'string' or 'array' (use 'number' for any C pointer, and
//                   'array' for JavaScript arrays and typed arrays).
// @param argTypes   An array of the types of arguments for the function (if there are no arguments, this can be ommitted). Types are as in returnType,
//                   except that 'array' is not possible (there is no way for us to know the length of the array)
// @param args       An array of the arguments to the function, as native JS values (as in returnType)
//                   Note that string arguments will be stored on the stack (the JS string will become a C string on the stack).
// @return           The return value, as a native JS value (as in returnType)
function ccall(ident, returnType, argTypes, args) {
  return ccallFunc(getCFunc(ident), returnType, argTypes, args);
}
Module["ccall"] = ccall;

// Returns the C function with a specified identifier (for C++, you need to do manual name mangling)
function getCFunc(ident) {
  try {
    var func = eval('_' + ident);
  } catch(e) {
    try {
      func = globalScope['Module']['_' + ident]; // closure exported function
    } catch(e) {}
  }
  assert(func, 'Cannot call unknown function ' + ident + ' (perhaps LLVM optimizations or closure removed it?)');
  return func;
}

// Internal function that does a C call using a function, not an identifier
function ccallFunc(func, returnType, argTypes, args) {
  var stack = 0;
  function toC(value, type) {
    if (type == 'string') {
      if (value === null || value === undefined || value === 0) return 0; // null string
      if (!stack) stack = Runtime.stackSave();
      var ret = Runtime.stackAlloc(value.length+1);
      writeStringToMemory(value, ret);
      return ret;
    } else if (type == 'array') {
      if (!stack) stack = Runtime.stackSave();
      var ret = Runtime.stackAlloc(value.length);
      writeArrayToMemory(value, ret);
      return ret;
    }
    return value;
  }
  function fromC(value, type) {
    if (type == 'string') {
      return Pointer_stringify(value);
    }
    assert(type != 'array');
    return value;
  }
  var i = 0;
  var cArgs = args ? args.map(function(arg) {
    return toC(arg, argTypes[i++]);
  }) : [];
  var ret = fromC(func.apply(null, cArgs), returnType);
  if (stack) Runtime.stackRestore(stack);
  return ret;
}

// Returns a native JS wrapper for a C function. This is similar to ccall, but
// returns a function you can call repeatedly in a normal way. For example:
//
//   var my_function = cwrap('my_c_function', 'number', ['number', 'number']);
//   alert(my_function(5, 22));
//   alert(my_function(99, 12));
//
function cwrap(ident, returnType, argTypes) {
  var func = getCFunc(ident);
  return function() {
    return ccallFunc(func, returnType, argTypes, Array.prototype.slice.call(arguments));
  }
}
Module["cwrap"] = cwrap;

// Sets a value in memory in a dynamic way at run-time. Uses the
// type data. This is the same as makeSetValue, except that
// makeSetValue is done at compile-time and generates the needed
// code then, whereas this function picks the right code at
// run-time.
// Note that setValue and getValue only do *aligned* writes and reads!
// Note that ccall uses JS types as for defining types, while setValue and
// getValue need LLVM types ('i8', 'i32') - this is a lower-level operation
function setValue(ptr, value, type, noSafe) {
  type = type || 'i8';
  if (type.charAt(type.length-1) === '*') type = 'i32'; // pointers are 32-bit
    switch(type) {
      case 'i1': HEAP8[(ptr)]=value; break;
      case 'i8': HEAP8[(ptr)]=value; break;
      case 'i16': HEAP16[((ptr)>>1)]=value; break;
      case 'i32': HEAP32[((ptr)>>2)]=value; break;
      case 'i64': (tempI64 = [value>>>0,Math.min(Math.floor((value)/4294967296), 4294967295)>>>0],HEAP32[((ptr)>>2)]=tempI64[0],HEAP32[(((ptr)+(4))>>2)]=tempI64[1]); break;
      case 'float': HEAPF32[((ptr)>>2)]=value; break;
      case 'double': (HEAPF64[(tempDoublePtr)>>3]=value,HEAP32[((ptr)>>2)]=HEAP32[((tempDoublePtr)>>2)],HEAP32[(((ptr)+(4))>>2)]=HEAP32[(((tempDoublePtr)+(4))>>2)]); break;
      default: abort('invalid type for setValue: ' + type);
    }
}
Module['setValue'] = setValue;

// Parallel to setValue.
function getValue(ptr, type, noSafe) {
  type = type || 'i8';
  if (type.charAt(type.length-1) === '*') type = 'i32'; // pointers are 32-bit
    switch(type) {
      case 'i1': return HEAP8[(ptr)];
      case 'i8': return HEAP8[(ptr)];
      case 'i16': return HEAP16[((ptr)>>1)];
      case 'i32': return HEAP32[((ptr)>>2)];
      case 'i64': return HEAP32[((ptr)>>2)];
      case 'float': return HEAPF32[((ptr)>>2)];
      case 'double': return (HEAP32[((tempDoublePtr)>>2)]=HEAP32[((ptr)>>2)],HEAP32[(((tempDoublePtr)+(4))>>2)]=HEAP32[(((ptr)+(4))>>2)],HEAPF64[(tempDoublePtr)>>3]);
      default: abort('invalid type for setValue: ' + type);
    }
  return null;
}
Module['getValue'] = getValue;

var ALLOC_NORMAL = 0; // Tries to use _malloc()
var ALLOC_STACK = 1; // Lives for the duration of the current function call
var ALLOC_STATIC = 2; // Cannot be freed
var ALLOC_NONE = 3; // Do not allocate
Module['ALLOC_NORMAL'] = ALLOC_NORMAL;
Module['ALLOC_STACK'] = ALLOC_STACK;
Module['ALLOC_STATIC'] = ALLOC_STATIC;
Module['ALLOC_NONE'] = ALLOC_NONE;

// Simple unoptimized memset - necessary during startup
var _memset = function(ptr, value, num) {
  var stop = ptr + num;
  while (ptr < stop) {
    HEAP8[((ptr++)|0)]=value;
  }
}

// allocate(): This is for internal use. You can use it yourself as well, but the interface
//             is a little tricky (see docs right below). The reason is that it is optimized
//             for multiple syntaxes to save space in generated code. So you should
//             normally not use allocate(), and instead allocate memory using _malloc(),
//             initialize it with setValue(), and so forth.
// @slab: An array of data, or a number. If a number, then the size of the block to allocate,
//        in *bytes* (note that this is sometimes confusing: the next parameter does not
//        affect this!)
// @types: Either an array of types, one for each byte (or 0 if no type at that position),
//         or a single type which is used for the entire block. This only matters if there
//         is initial data - if @slab is a number, then this does not matter at all and is
//         ignored.
// @allocator: How to allocate memory, see ALLOC_*
function allocate(slab, types, allocator, ptr) {
  var zeroinit, size;
  if (typeof slab === 'number') {
    zeroinit = true;
    size = slab;
  } else {
    zeroinit = false;
    size = slab.length;
  }

  var singleType = typeof types === 'string' ? types : null;

  var ret;
  if (allocator == ALLOC_NONE) {
    ret = ptr;
  } else {
    ret = [_malloc, Runtime.stackAlloc, Runtime.staticAlloc][allocator === undefined ? ALLOC_STATIC : allocator](Math.max(size, singleType ? 1 : types.length));
  }

  if (zeroinit) {
    _memset(ret, 0, size);
    return ret;
  }

  if (singleType === 'i8') {
    HEAPU8.set(new Uint8Array(slab), ret);
    return ret;
  }

  var i = 0, type;
  while (i < size) {
    var curr = slab[i];

    if (typeof curr === 'function') {
      curr = Runtime.getFunctionIndex(curr);
    }

    type = singleType || types[i];
    if (type === 0) {
      i++;
      continue;
    }

    if (type == 'i64') type = 'i32'; // special case: we have one i32 here, and one i32 later

    setValue(ret+i, curr, type);
    i += Runtime.getNativeTypeSize(type);
  }

  return ret;
}
Module['allocate'] = allocate;

function Pointer_stringify(ptr, /* optional */ length) {
  var utf8 = new Runtime.UTF8Processor();
  var nullTerminated = typeof(length) == "undefined";
  var ret = "";
  var i = 0;
  var t;
  while (1) {
    t = HEAPU8[(((ptr)+(i))|0)];
    if (nullTerminated && t == 0) break;
    ret += utf8.processCChar(t);
    i += 1;
    if (!nullTerminated && i == length) break;
  }
  return ret;
}
Module['Pointer_stringify'] = Pointer_stringify;

function Array_stringify(array) {
  var ret = "";
  for (var i = 0; i < array.length; i++) {
    ret += String.fromCharCode(array[i]);
  }
  return ret;
}
Module['Array_stringify'] = Array_stringify;

// Memory management

var PAGE_SIZE = 4096;
function alignMemoryPage(x) {
  return ((x+4095)>>12)<<12;
}

var HEAP;
var HEAP8, HEAPU8, HEAP16, HEAPU16, HEAP32, HEAPU32, HEAPF32, HEAPF64;

var STACK_ROOT, STACKTOP, STACK_MAX;
var STATICTOP;
function enlargeMemory() {
  abort('Cannot enlarge memory arrays. Either (1) compile with -s TOTAL_MEMORY=X with X higher than the current value, (2) compile with ALLOW_MEMORY_GROWTH which adjusts the size at runtime but prevents some optimizations, or (3) set Module.TOTAL_MEMORY before the program runs.');
}

var TOTAL_STACK = Module['TOTAL_STACK'] || 5242880;
var TOTAL_MEMORY = Module['TOTAL_MEMORY'] || 16777216;
var FAST_MEMORY = Module['FAST_MEMORY'] || 2097152;

// Initialize the runtime's memory
// check for full engine support (use string 'subarray' to avoid closure compiler confusion)
assert(!!Int32Array && !!Float64Array && !!(new Int32Array(1)['subarray']) && !!(new Int32Array(1)['set']),
       'Cannot fallback to non-typed array case: Code is too specialized');

var buffer = new ArrayBuffer(TOTAL_MEMORY);
HEAP8 = new Int8Array(buffer);
HEAP16 = new Int16Array(buffer);
HEAP32 = new Int32Array(buffer);
HEAPU8 = new Uint8Array(buffer);
HEAPU16 = new Uint16Array(buffer);
HEAPU32 = new Uint32Array(buffer);
HEAPF32 = new Float32Array(buffer);
HEAPF64 = new Float64Array(buffer);

// Endianness check (note: assumes compiler arch was little-endian)
HEAP32[0] = 255;
assert(HEAPU8[0] === 255 && HEAPU8[3] === 0, 'Typed arrays 2 must be run on a little-endian system');

Module['HEAP'] = HEAP;
Module['HEAP8'] = HEAP8;
Module['HEAP16'] = HEAP16;
Module['HEAP32'] = HEAP32;
Module['HEAPU8'] = HEAPU8;
Module['HEAPU16'] = HEAPU16;
Module['HEAPU32'] = HEAPU32;
Module['HEAPF32'] = HEAPF32;
Module['HEAPF64'] = HEAPF64;

STACK_ROOT = STACKTOP = Runtime.alignMemory(1);
STACK_MAX = TOTAL_STACK; // we lose a little stack here, but TOTAL_STACK is nice and round so use that as the max

var tempDoublePtr = Runtime.alignMemory(allocate(12, 'i8', ALLOC_STACK), 8);
assert(tempDoublePtr % 8 == 0);
function copyTempFloat(ptr) { // functions, because inlining this code increases code size too much
  HEAP8[tempDoublePtr] = HEAP8[ptr];
  HEAP8[tempDoublePtr+1] = HEAP8[ptr+1];
  HEAP8[tempDoublePtr+2] = HEAP8[ptr+2];
  HEAP8[tempDoublePtr+3] = HEAP8[ptr+3];
}
function copyTempDouble(ptr) {
  HEAP8[tempDoublePtr] = HEAP8[ptr];
  HEAP8[tempDoublePtr+1] = HEAP8[ptr+1];
  HEAP8[tempDoublePtr+2] = HEAP8[ptr+2];
  HEAP8[tempDoublePtr+3] = HEAP8[ptr+3];
  HEAP8[tempDoublePtr+4] = HEAP8[ptr+4];
  HEAP8[tempDoublePtr+5] = HEAP8[ptr+5];
  HEAP8[tempDoublePtr+6] = HEAP8[ptr+6];
  HEAP8[tempDoublePtr+7] = HEAP8[ptr+7];
}

STATICTOP = STACK_MAX;
assert(STATICTOP < TOTAL_MEMORY); // Stack must fit in TOTAL_MEMORY; allocations from here on may enlarge TOTAL_MEMORY

var nullString = allocate(intArrayFromString('(null)'), 'i8', ALLOC_STACK);

function callRuntimeCallbacks(callbacks) {
  while(callbacks.length > 0) {
    var callback = callbacks.shift();
    var func = callback.func;
    if (typeof func === 'number') {
      if (callback.arg === undefined) {
        Runtime.dynCall('v', func);
      } else {
        Runtime.dynCall('vi', func, [callback.arg]);
      }
    } else {
      func(callback.arg === undefined ? null : callback.arg);
    }
  }
}

var __ATINIT__ = []; // functions called during startup
var __ATMAIN__ = []; // functions called when main() is to be run
var __ATEXIT__ = []; // functions called during shutdown

function initRuntime() {
  callRuntimeCallbacks(__ATINIT__);
}
function preMain() {
  callRuntimeCallbacks(__ATMAIN__);
}
function exitRuntime() {
  callRuntimeCallbacks(__ATEXIT__);
}

// Tools

// This processes a JS string into a C-line array of numbers, 0-terminated.
// For LLVM-originating strings, see parser.js:parseLLVMString function
function intArrayFromString(stringy, dontAddNull, length /* optional */) {
  var ret = (new Runtime.UTF8Processor()).processJSString(stringy);
  if (length) {
    ret.length = length;
  }
  if (!dontAddNull) {
    ret.push(0);
  }
  return ret;
}
Module['intArrayFromString'] = intArrayFromString;

function intArrayToString(array) {
  var ret = [];
  for (var i = 0; i < array.length; i++) {
    var chr = array[i];
    if (chr > 0xFF) {
      chr &= 0xFF;
    }
    ret.push(String.fromCharCode(chr));
  }
  return ret.join('');
}
Module['intArrayToString'] = intArrayToString;

// Write a Javascript array to somewhere in the heap
function writeStringToMemory(string, buffer, dontAddNull) {
  var array = intArrayFromString(string, dontAddNull);
  var i = 0;
  while (i < array.length) {
    var chr = array[i];
    HEAP8[(((buffer)+(i))|0)]=chr
    i = i + 1;
  }
}
Module['writeStringToMemory'] = writeStringToMemory;

function writeArrayToMemory(array, buffer) {
  for (var i = 0; i < array.length; i++) {
    HEAP8[(((buffer)+(i))|0)]=array[i];
  }
}
Module['writeArrayToMemory'] = writeArrayToMemory;

function unSign(value, bits, ignore, sig) {
  if (value >= 0) {
    return value;
  }
  return bits <= 32 ? 2*Math.abs(1 << (bits-1)) + value // Need some trickery, since if bits == 32, we are right at the limit of the bits JS uses in bitshifts
                    : Math.pow(2, bits)         + value;
}
function reSign(value, bits, ignore, sig) {
  if (value <= 0) {
    return value;
  }
  var half = bits <= 32 ? Math.abs(1 << (bits-1)) // abs is needed if bits == 32
                        : Math.pow(2, bits-1);
  if (value >= half && (bits <= 32 || value > half)) { // for huge values, we can hit the precision limit and always get true here. so don't do that
                                                       // but, in general there is no perfect solution here. With 64-bit ints, we get rounding and errors
                                                       // TODO: In i64 mode 1, resign the two parts separately and safely
    value = -2*half + value; // Cannot bitshift half, as it may be at the limit of the bits JS uses in bitshifts
  }
  return value;
}

if (!Math.imul) Math.imul = function(a, b) {
  var ah  = a >>> 16;
  var al = a & 0xffff;
  var bh  = b >>> 16;
  var bl = b & 0xffff;
  return (al*bl + ((ah*bl + al*bh) << 16))|0;
};

// A counter of dependencies for calling run(). If we need to
// do asynchronous work before running, increment this and
// decrement it. Incrementing must happen in a place like
// PRE_RUN_ADDITIONS (used by emcc to add file preloading).
// Note that you can add dependencies in preRun, even though
// it happens right before run - run will be postponed until
// the dependencies are met.
var runDependencies = 0;
var runDependencyTracking = {};
var calledRun = false;
var runDependencyWatcher = null;
function addRunDependency(id) {
  runDependencies++;
  if (Module['monitorRunDependencies']) {
    Module['monitorRunDependencies'](runDependencies);
  }
  if (id) {
    assert(!runDependencyTracking[id]);
    runDependencyTracking[id] = 1;
    if (runDependencyWatcher === null && typeof setInterval !== 'undefined') {
      // Check for missing dependencies every few seconds
      runDependencyWatcher = setInterval(function() {
        var shown = false;
        for (var dep in runDependencyTracking) {
          if (!shown) {
            shown = true;
            Module.printErr('still waiting on run dependencies:');
          }
          Module.printErr('dependency: ' + dep);
        }
        if (shown) {
          Module.printErr('(end of list)');
        }
      }, 6000);
    }
  } else {
    Module.printErr('warning: run dependency added without ID');
  }
}
Module['addRunDependency'] = addRunDependency;
function removeRunDependency(id) {
  runDependencies--;
  if (Module['monitorRunDependencies']) {
    Module['monitorRunDependencies'](runDependencies);
  }
  if (id) {
    assert(runDependencyTracking[id]);
    delete runDependencyTracking[id];
  } else {
    Module.printErr('warning: run dependency removed without ID');
  }
  if (runDependencies == 0) {
    if (runDependencyWatcher !== null) {
      clearInterval(runDependencyWatcher);
      runDependencyWatcher = null;
    } 
    // If run has never been called, and we should call run (INVOKE_RUN is true, and Module.noInitialRun is not false)
    if (!calledRun && shouldRunNow) run();
  }
}
Module['removeRunDependency'] = removeRunDependency;

Module["preloadedImages"] = {}; // maps url to image data
Module["preloadedAudios"] = {}; // maps url to audio data

// === Body ===



assert(STATICTOP == STACK_MAX); assert(STACK_MAX == TOTAL_STACK);

STATICTOP += 4344;

assert(STATICTOP < TOTAL_MEMORY);


























































































































































































































































allocate([117,115,101,114,100,97,116,97,0] /* userdata\00 */, "i8", ALLOC_NONE, 5242880);
allocate([6,6,6,6,7,7,7,7,7,7,10,9,5,4,3,3,3,3,3,3,3,3,3,3,3,3,2,2,1,1], "i8", ALLOC_NONE, 5242892);
allocate([0,0,0,0,0,0,0,0,0,0,8,8,8,8,8,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,12,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,22,22,22,22,22,22,22,22,22,22,4,4,4,4,4,4,4,21,21,21,21,21,21,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,4,4,4,4,5,4,21,21,21,21,21,21,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,4,4,4,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0] /* \00\00\00\00\00\00\0 */, "i8", ALLOC_NONE, 5242924);
allocate([0,0,0,0,0,96,127,64], "i8", ALLOC_NONE, 5243184);
allocate([33,0,0,0,0,0,56,195], "i8", ALLOC_NONE, 5243192);
allocate([36,76,117,97,86,101,114,115,105,111,110,58,32,76,117,97,32,53,46,50,46,49,32,32,67,111,112,121,114,105,103,104,116,32,40,67,41,32,49,57,57,52,45,50,48,49,50,32,76,117,97,46,111,114,103,44,32,80,85,67,45,82,105,111,32,36,36,76,117,97,65,117,116,104,111,114,115,58,32,82,46,32,73,101,114,117,115,97,108,105,109,115,99,104,121,44,32,76,46,32,72,46,32,100,101,32,70,105,103,117,101,105,114,101,100,111,44,32,87,46,32,67,101,108,101,115,32,36,0] /* $LuaVersion: Lua 5.2 */, "i8", ALLOC_NONE, 5243200);
allocate(132, "i8", ALLOC_NONE, 5243332);
allocate(48, "i8", ALLOC_NONE, 5243464);
allocate(68, "i8", ALLOC_NONE, 5243512);
allocate(164, "i8", ALLOC_NONE, 5243580);
allocate([96,113,65,84,80,80,92,108,60,16,60,84,108,124,124,124,124,124,124,96,96,96,104,34,188,188,188,132,228,84,84,16,98,98,4,98,20,81,80,23] /* `qATPP\5Cl_\10_Tl||| */, "i8", ALLOC_NONE, 5243744);
allocate(12, "i8", ALLOC_NONE, 5243784);
allocate([0,1,2,2,3,3,3,3,4,4,4,4,4,4,4,4,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8] /* \00\01\02\02\03\03\0 */, "i8", ALLOC_NONE, 5243796);
allocate([33,0,0,0,0,0,56,195], "i8", ALLOC_NONE, 5244052);
allocate(28, "i8", ALLOC_NONE, 5244060);
allocate([33,0,0,0,0,0,56,195], "i8", ALLOC_NONE, 5244088);
allocate([33,0,0,0,0,0,56,195], "i8", ALLOC_NONE, 5244096);
allocate([43,45,0] /* +-\00 */, "i8", ALLOC_NONE, 5244104);
allocate([99,97,110,110,111,116,32,114,101,115,117,109,101,32,110,111,110,45,115,117,115,112,101,110,100,101,100,32,99,111,114,111,117,116,105,110,101,0] /* cannot resume non-su */, "i8", ALLOC_NONE, 5244108);
allocate([118,101,114,115,105,111,110,32,109,105,115,109,97,116,99,104,32,105,110,0] /* version mismatch in\ */, "i8", ALLOC_NONE, 5244148);
allocate([117,112,118,97,108,0] /* upval\00 */, "i8", ALLOC_NONE, 5244168);
allocate([115,101,108,102,0] /* self\00 */, "i8", ALLOC_NONE, 5244176);
allocate([83,69,84,85,80,86,65,76,0] /* SETUPVAL\00 */, "i8", ALLOC_NONE, 5244184);
allocate([103,108,111,98,97,108,0] /* global\00 */, "i8", ALLOC_NONE, 5244196);
allocate([80,112,0] /* Pp\00 */, "i8", ALLOC_NONE, 5244204);
allocate([101,114,114,111,114,32,105,110,32,101,114,114,111,114,32,104,97,110,100,108,105,110,103,0] /* error in error handl */, "i8", ALLOC_NONE, 5244208);
allocate([39,102,111,114,39,32,115,116,101,112,32,109,117,115,116,32,98,101,32,97,32,110,117,109,98,101,114,0] /* 'for' step must be a */, "i8", ALLOC_NONE, 5244232);
allocate([110,111,116,32,97,0] /* not a\00 */, "i8", ALLOC_NONE, 5244260);
allocate([112,114,111,116,111,0] /* proto\00 */, "i8", ALLOC_NONE, 5244268);
allocate([99,97,110,110,111,116,32,117,115,101,32,39,46,46,46,39,32,111,117,116,115,105,100,101,32,97,32,118,97,114,97,114,103,32,102,117,110,99,116,105,111,110,0] /* cannot use '...' out */, "i8", ALLOC_NONE, 5244276);
allocate([83,69,84,84,65,66,85,80,0] /* SETTABUP\00 */, "i8", ALLOC_NONE, 5244320);
allocate([34,93,0] /* \22]\00 */, "i8", ALLOC_NONE, 5244332);
allocate([95,69,78,86,0] /* _ENV\00 */, "i8", ALLOC_NONE, 5244336);
allocate([39,37,99,39,0] /* '%c'\00 */, "i8", ALLOC_NONE, 5244344);
allocate([88,120,0] /* Xx\00 */, "i8", ALLOC_NONE, 5244352);
allocate([97,116,116,101,109,112,116,32,116,111,32,108,111,97,100,32,97,32,37,115,32,99,104,117,110,107,32,40,109,111,100,101,32,105,115,32,39,37,115,39,41,0] /* attempt to load a %s */, "i8", ALLOC_NONE, 5244356);
allocate([39,102,111,114,39,32,108,105,109,105,116,32,109,117,115,116,32,98,101,32,97,32,110,117,109,98,101,114,0] /* 'for' limit must be  */, "i8", ALLOC_NONE, 5244400);
allocate([99,111,114,114,117,112,116,101,100,0] /* corrupted\00 */, "i8", ALLOC_NONE, 5244432);
allocate([116,104,114,101,97,100,0] /* thread\00 */, "i8", ALLOC_NONE, 5244444);
allocate([67,32,108,101,118,101,108,115,0] /* C levels\00 */, "i8", ALLOC_NONE, 5244452);
allocate([71,69,84,84,65,66,76,69,0] /* GETTABLE\00 */, "i8", ALLOC_NONE, 5244464);
allocate([91,115,116,114,105,110,103,32,34,0] /* [string \22\00 */, "i8", ALLOC_NONE, 5244476);
allocate([108,111,99,97,108,0] /* local\00 */, "i8", ALLOC_NONE, 5244488);
allocate([69,101,0] /* Ee\00 */, "i8", ALLOC_NONE, 5244496);
allocate([39,102,111,114,39,32,105,110,105,116,105,97,108,32,118,97,108,117,101,32,109,117,115,116,32,98,101,32,97,32,110,117,109,98,101,114,0] /* 'for' initial value  */, "i8", ALLOC_NONE, 5244500);
allocate([116,101,120,116,0] /* text\00 */, "i8", ALLOC_NONE, 5244540);
allocate([37,115,58,32,37,115,32,112,114,101,99,111,109,112,105,108,101,100,32,99,104,117,110,107,0] /* %s: %s precompiled c */, "i8", ALLOC_NONE, 5244548);
allocate([102,117,110,99,116,105,111,110,0] /* function\00 */, "i8", ALLOC_NONE, 5244576);
allocate([115,121,110,116,97,120,32,101,114,114,111,114,0] /* syntax error\00 */, "i8", ALLOC_NONE, 5244588);
allocate([71,69,84,84,65,66,85,80,0] /* GETTABUP\00 */, "i8", ALLOC_NONE, 5244604);
allocate([46,46,46,0] /* ...\00 */, "i8", ALLOC_NONE, 5244616);
allocate([37,115,58,37,100,58,32,37,115,0] /* %s:%d: %s\00 */, "i8", ALLOC_NONE, 5244620);
allocate([110,111,32,109,101,115,115,97,103,101,0] /* no message\00 */, "i8", ALLOC_NONE, 5244632);
allocate([46,0] /* .\00 */, "i8", ALLOC_NONE, 5244644);
allocate([103,101,116,32,108,101,110,103,116,104,32,111,102,0] /* get length of\00 */, "i8", ALLOC_NONE, 5244648);
allocate([98,105,110,97,114,121,0] /* binary\00 */, "i8", ALLOC_NONE, 5244664);
allocate([60,115,116,114,105,110,103,62,0] /* _string_\00 */, "i8", ALLOC_NONE, 5244672);
allocate([116,114,117,110,99,97,116,101,100,0] /* truncated\00 */, "i8", ALLOC_NONE, 5244684);
allocate([116,97,98,108,101,0] /* table\00 */, "i8", ALLOC_NONE, 5244696);
allocate([60,110,97,109,101,62,0] /* _name_\00 */, "i8", ALLOC_NONE, 5244704);
allocate([37,115,32,101,120,112,101,99,116,101,100,0] /* %s expected\00 */, "i8", ALLOC_NONE, 5244712);
allocate([71,69,84,85,80,86,65,76,0] /* GETUPVAL\00 */, "i8", ALLOC_NONE, 5244724);
allocate([105,110,118,97,108,105,100,32,111,112,116,105,111,110,32,39,37,37,37,99,39,32,116,111,32,39,108,117,97,95,112,117,115,104,102,115,116,114,105,110,103,39,0] /* invalid option '%%%c */, "i8", ALLOC_NONE, 5244736);
allocate([97,116,116,101,109,112,116,32,116,111,32,99,111,109,112,97,114,101,32,37,115,32,119,105,116,104,32,37,115,0] /* attempt to compare % */, "i8", ALLOC_NONE, 5244780);
allocate([60,110,117,109,98,101,114,62,0] /* _number_\00 */, "i8", ALLOC_NONE, 5244812);
allocate([60,101,111,102,62,0] /* _eof_\00 */, "i8", ALLOC_NONE, 5244824);
allocate([97,116,116,101,109,112,116,32,116,111,32,37,115,32,37,115,32,39,37,115,39,32,40,97,32,37,115,32,118,97,108,117,101,41,0] /* attempt to %s %s '%s */, "i8", ALLOC_NONE, 5244832);
allocate([58,58,0] /* ::\00 */, "i8", ALLOC_NONE, 5244868);
allocate([97,116,116,101,109,112,116,32,116,111,32,99,111,109,112,97,114,101,32,116,119,111,32,37,115,32,118,97,108,117,101,115,0] /* attempt to compare t */, "i8", ALLOC_NONE, 5244872);
allocate([105,110,118,97,108,105,100,32,108,111,110,103,32,115,116,114,105,110,103,32,100,101,108,105,109,105,116,101,114,0] /* invalid long string  */, "i8", ALLOC_NONE, 5244908);
allocate([126,61,0] /* ~=\00 */, "i8", ALLOC_NONE, 5244940);
allocate([60,61,0] /* _=\00 */, "i8", ALLOC_NONE, 5244944);
allocate([62,61,0] /* _=\00 */, "i8", ALLOC_NONE, 5244948);
allocate([61,61,0] /* ==\00 */, "i8", ALLOC_NONE, 5244952);
allocate([46,46,46,0] /* ...\00 */, "i8", ALLOC_NONE, 5244956);
allocate([115,116,114,105,110,103,32,108,101,110,103,116,104,32,111,118,101,114,102,108,111,119,0] /* string length overfl */, "i8", ALLOC_NONE, 5244960);
allocate([46,46,0] /* ..\00 */, "i8", ALLOC_NONE, 5244984);
allocate([25,147,13,10,26,10,0] /* \19\93\0D\0A\1A\0A\0 */, "i8", ALLOC_NONE, 5244988);
allocate([27,76,117,97,0] /* \1BLua\00 */, "i8", ALLOC_NONE, 5244996);
allocate([115,116,114,105,110,103,0] /* string\00 */, "i8", ALLOC_NONE, 5245004);
allocate([119,104,105,108,101,0] /* while\00 */, "i8", ALLOC_NONE, 5245012);
allocate([108,97,98,101,108,115,47,103,111,116,111,115,0] /* labels/gotos\00 */, "i8", ALLOC_NONE, 5245020);
allocate([76,79,65,68,78,73,76,0] /* LOADNIL\00 */, "i8", ALLOC_NONE, 5245036);
allocate([37,0] /* %\00 */, "i8", ALLOC_NONE, 5245044);
allocate([117,110,116,105,108,0] /* until\00 */, "i8", ALLOC_NONE, 5245048);
allocate([116,114,117,101,0] /* true\00 */, "i8", ALLOC_NONE, 5245056);
allocate([99,111,110,116,114,111,108,32,115,116,114,117,99,116,117,114,101,32,116,111,111,32,108,111,110,103,0] /* control structure to */, "i8", ALLOC_NONE, 5245064);
allocate([69,88,84,82,65,65,82,71,0] /* EXTRAARG\00 */, "i8", ALLOC_NONE, 5245092);
allocate([116,104,101,110,0] /* then\00 */, "i8", ALLOC_NONE, 5245104);
allocate([95,69,78,86,0] /* _ENV\00 */, "i8", ALLOC_NONE, 5245112);
allocate([86,65,82,65,82,71,0] /* VARARG\00 */, "i8", ALLOC_NONE, 5245120);
allocate([114,101,116,117,114,110,0] /* return\00 */, "i8", ALLOC_NONE, 5245128);
allocate([112,101,114,102,111,114,109,32,97,114,105,116,104,109,101,116,105,99,32,111,110,0] /* perform arithmetic o */, "i8", ALLOC_NONE, 5245136);
allocate([67,76,79,83,85,82,69,0] /* CLOSURE\00 */, "i8", ALLOC_NONE, 5245160);
allocate([114,101,112,101,97,116,0] /* repeat\00 */, "i8", ALLOC_NONE, 5245168);
allocate([83,69,84,76,73,83,84,0] /* SETLIST\00 */, "i8", ALLOC_NONE, 5245176);
allocate([111,114,0] /* or\00 */, "i8", ALLOC_NONE, 5245184);
allocate([84,70,79,82,76,79,79,80,0] /* TFORLOOP\00 */, "i8", ALLOC_NONE, 5245188);
allocate([110,111,116,0] /* not\00 */, "i8", ALLOC_NONE, 5245200);
allocate([84,70,79,82,67,65,76,76,0] /* TFORCALL\00 */, "i8", ALLOC_NONE, 5245204);
allocate([110,105,108,0] /* nil\00 */, "i8", ALLOC_NONE, 5245216);
allocate([70,79,82,80,82,69,80,0] /* FORPREP\00 */, "i8", ALLOC_NONE, 5245220);
allocate([108,111,111,112,32,105,110,32,115,101,116,116,97,98,108,101,0] /* loop in settable\00 */, "i8", ALLOC_NONE, 5245228);
allocate([108,111,99,97,108,0] /* local\00 */, "i8", ALLOC_NONE, 5245248);
allocate([50,0] /* 2\00 */, "i8", ALLOC_NONE, 5245256);
allocate([97,116,116,101,109,112,116,32,116,111,32,121,105,101,108,100,32,102,114,111,109,32,111,117,116,115,105,100,101,32,97,32,99,111,114,111,117,116,105,110,101,0] /* attempt to yield fro */, "i8", ALLOC_NONE, 5245260);
allocate([110,117,109,98,101,114,0] /* number\00 */, "i8", ALLOC_NONE, 5245304);
allocate([105,110,118,97,108,105,100,32,107,101,121,32,116,111,32,39,110,101,120,116,39,0] /* invalid key to 'next */, "i8", ALLOC_NONE, 5245312);
allocate([70,79,82,76,79,79,80,0] /* FORLOOP\00 */, "i8", ALLOC_NONE, 5245336);
allocate([105,110,0] /* in\00 */, "i8", ALLOC_NONE, 5245344);
allocate([98,114,101,97,107,0] /* break\00 */, "i8", ALLOC_NONE, 5245348);
allocate([76,79,65,68,66,79,79,76,0] /* LOADBOOL\00 */, "i8", ALLOC_NONE, 5245356);
allocate([37,112,0] /* %p\00 */, "i8", ALLOC_NONE, 5245368);
allocate([82,69,84,85,82,78,0] /* RETURN\00 */, "i8", ALLOC_NONE, 5245372);
allocate([105,102,0] /* if\00 */, "i8", ALLOC_NONE, 5245380);
allocate([37,46,49,52,103,0] /* %.14g\00 */, "i8", ALLOC_NONE, 5245384);
allocate([84,65,73,76,67,65,76,76,0] /* TAILCALL\00 */, "i8", ALLOC_NONE, 5245392);
allocate([103,111,116,111,0] /* goto\00 */, "i8", ALLOC_NONE, 5245404);
allocate([111,112,99,111,100,101,115,0] /* opcodes\00 */, "i8", ALLOC_NONE, 5245412);
allocate([27,76,117,97,0] /* \1BLua\00 */, "i8", ALLOC_NONE, 5245420);
allocate([67,65,76,76,0] /* CALL\00 */, "i8", ALLOC_NONE, 5245428);
allocate([102,117,110,99,116,105,111,110,0] /* function\00 */, "i8", ALLOC_NONE, 5245436);
allocate([117,112,118,97,108,117,101,115,0] /* upvalues\00 */, "i8", ALLOC_NONE, 5245448);
allocate([84,69,83,84,83,69,84,0] /* TESTSET\00 */, "i8", ALLOC_NONE, 5245460);
allocate([39,37,115,39,0] /* '%s'\00 */, "i8", ALLOC_NONE, 5245468);
allocate([102,111,114,0] /* for\00 */, "i8", ALLOC_NONE, 5245476);
allocate([37,115,32,101,120,112,101,99,116,101,100,32,40,116,111,32,99,108,111,115,101,32,37,115,32,97,116,32,108,105,110,101,32,37,100,41,0] /* %s expected (to clos */, "i8", ALLOC_NONE, 5245480);
allocate([84,69,83,84,0] /* TEST\00 */, "i8", ALLOC_NONE, 5245520);
allocate([102,97,108,115,101,0] /* false\00 */, "i8", ALLOC_NONE, 5245528);
allocate([99,111,110,99,97,116,101,110,97,116,101,0] /* concatenate\00 */, "i8", ALLOC_NONE, 5245536);
allocate([95,95,99,97,108,108,0] /* __call\00 */, "i8", ALLOC_NONE, 5245548);
allocate([40,102,111,114,32,115,116,101,112,41,0] /* (for step)\00 */, "i8", ALLOC_NONE, 5245556);
allocate([76,69,0] /* LE\00 */, "i8", ALLOC_NONE, 5245568);
allocate([101,110,100,0] /* end\00 */, "i8", ALLOC_NONE, 5245572);
allocate([110,111,32,118,97,108,117,101,0] /* no value\00 */, "i8", ALLOC_NONE, 5245576);
allocate([95,95,99,111,110,99,97,116,0] /* __concat\00 */, "i8", ALLOC_NONE, 5245588);
allocate([40,102,111,114,32,108,105,109,105,116,41,0] /* (for limit)\00 */, "i8", ALLOC_NONE, 5245600);
allocate([76,84,0] /* LT\00 */, "i8", ALLOC_NONE, 5245612);
allocate([101,108,115,101,105,102,0] /* elseif\00 */, "i8", ALLOC_NONE, 5245616);
allocate([115,116,97,99,107,32,111,118,101,114,102,108,111,119,0] /* stack overflow\00 */, "i8", ALLOC_NONE, 5245624);
allocate([95,95,108,101,0] /* __le\00 */, "i8", ALLOC_NONE, 5245640);
allocate([40,102,111,114,32,105,110,100,101,120,41,0] /* (for index)\00 */, "i8", ALLOC_NONE, 5245648);
allocate([69,81,0] /* EQ\00 */, "i8", ALLOC_NONE, 5245660);
allocate([40,42,118,97,114,97,114,103,41,0] /* (_vararg)\00 */, "i8", ALLOC_NONE, 5245664);
allocate([101,108,115,101,0] /* else\00 */, "i8", ALLOC_NONE, 5245676);
allocate([99,111,110,115,116,97,110,116,115,0] /* constants\00 */, "i8", ALLOC_NONE, 5245684);
allocate([116,97,98,108,101,32,105,110,100,101,120,32,105,115,32,110,105,108,0] /* table index is nil\0 */, "i8", ALLOC_NONE, 5245696);
allocate([95,95,108,116,0] /* __lt\00 */, "i8", ALLOC_NONE, 5245716);
allocate([40,102,111,114,32,99,111,110,116,114,111,108,41,0] /* (for control)\00 */, "i8", ALLOC_NONE, 5245724);
allocate([74,77,80,0] /* JMP\00 */, "i8", ALLOC_NONE, 5245740);
allocate([100,111,0] /* do\00 */, "i8", ALLOC_NONE, 5245744);
allocate([108,111,111,112,32,105,110,32,103,101,116,116,97,98,108,101,0] /* loop in gettable\00 */, "i8", ALLOC_NONE, 5245748);
allocate([40,42,116,101,109,112,111,114,97,114,121,41,0] /* (_temporary)\00 */, "i8", ALLOC_NONE, 5245768);
allocate([53,0] /* 5\00 */, "i8", ALLOC_NONE, 5245784);
allocate([97,116,116,101,109,112,116,32,116,111,32,121,105,101,108,100,32,97,99,114,111,115,115,32,109,101,116,97,109,101,116,104,111,100,47,67,45,99,97,108,108,32,98,111,117,110,100,97,114,121,0] /* attempt to yield acr */, "i8", ALLOC_NONE, 5245788);
allocate([98,111,111,108,101,97,110,0] /* boolean\00 */, "i8", ALLOC_NONE, 5245840);
allocate([116,97,98,108,101,32,111,118,101,114,102,108,111,119,0] /* table overflow\00 */, "i8", ALLOC_NONE, 5245848);
allocate([95,95,117,110,109,0] /* __unm\00 */, "i8", ALLOC_NONE, 5245864);
allocate([40,102,111,114,32,115,116,97,116,101,41,0] /* (for state)\00 */, "i8", ALLOC_NONE, 5245872);
allocate([67,79,78,67,65,84,0] /* CONCAT\00 */, "i8", ALLOC_NONE, 5245884);
allocate([98,114,101,97,107,0] /* break\00 */, "i8", ALLOC_NONE, 5245892);
allocate([76,117,97,0] /* Lua\00 */, "i8", ALLOC_NONE, 5245900);
allocate([60,103,111,116,111,32,37,115,62,32,97,116,32,108,105,110,101,32,37,100,32,106,117,109,112,115,32,105,110,116,111,32,116,104,101,32,115,99,111,112,101,32,111,102,32,108,111,99,97,108,32,39,37,115,39,0] /* _goto %s_ at line %d */, "i8", ALLOC_NONE, 5245904);
allocate([76,79,65,68,75,88,0] /* LOADKX\00 */, "i8", ALLOC_NONE, 5245960);
allocate([110,111,116,32,101,110,111,117,103,104,32,109,101,109,111,114,121,0] /* not enough memory\00 */, "i8", ALLOC_NONE, 5245968);
allocate([95,95,112,111,119,0] /* __pow\00 */, "i8", ALLOC_NONE, 5245988);
allocate([40,110,117,108,108,41,0] /* (null)\00 */, "i8", ALLOC_NONE, 5245996);
allocate([40,102,111,114,32,103,101,110,101,114,97,116,111,114,41,0] /* (for generator)\00 */, "i8", ALLOC_NONE, 5246004);
allocate([76,69,78,0] /* LEN\00 */, "i8", ALLOC_NONE, 5246020);
allocate([97,110,100,0] /* and\00 */, "i8", ALLOC_NONE, 5246024);
allocate([109,97,105,110,0] /* main\00 */, "i8", ALLOC_NONE, 5246028);
allocate([37,115,32,110,101,97,114,32,37,115,0] /* %s near %s\00 */, "i8", ALLOC_NONE, 5246036);
allocate([95,95,109,111,100,0] /* __mod\00 */, "i8", ALLOC_NONE, 5246048);
allocate([39,61,39,32,111,114,32,39,105,110,39,32,101,120,112,101,99,116,101,100,0] /* '=' or 'in' expected */, "i8", ALLOC_NONE, 5246056);
allocate([78,79,84,0] /* NOT\00 */, "i8", ALLOC_NONE, 5246080);
allocate([61,63,0] /* =?\00 */, "i8", ALLOC_NONE, 5246084);
allocate([102,117,110,99,116,105,111,110,32,111,114,32,101,120,112,114,101,115,115,105,111,110,32,116,111,111,32,99,111,109,112,108,101,120,0] /* function or expressi */, "i8", ALLOC_NONE, 5246088);
allocate([37,115,58,37,100,58,32,37,115,0] /* %s:%d: %s\00 */, "i8", ALLOC_NONE, 5246124);
allocate([95,95,100,105,118,0] /* __div\00 */, "i8", ALLOC_NONE, 5246136);
allocate([108,97,98,101,108,32,39,37,115,39,32,97,108,114,101,97,100,121,32,100,101,102,105,110,101,100,32,111,110,32,108,105,110,101,32,37,100,0] /* label '%s' already d */, "i8", ALLOC_NONE, 5246144);
allocate([85,78,77,0] /* UNM\00 */, "i8", ALLOC_NONE, 5246184);
allocate([67,0] /* C\00 */, "i8", ALLOC_NONE, 5246188);
allocate([99,104,117,110,107,32,104,97,115,32,116,111,111,32,109,97,110,121,32,108,105,110,101,115,0] /* chunk has too many l */, "i8", ALLOC_NONE, 5246192);
allocate([60,37,115,62,32,97,116,32,108,105,110,101,32,37,100,32,110,111,116,32,105,110,115,105,100,101,32,97,32,108,111,111,112,0] /* _%s_ at line %d not  */, "i8", ALLOC_NONE, 5246220);
allocate([95,95,109,117,108,0] /* __mul\00 */, "i8", ALLOC_NONE, 5246256);
allocate([117,110,101,120,112,101,99,116,101,100,32,115,121,109,98,111,108,0] /* unexpected symbol\00 */, "i8", ALLOC_NONE, 5246264);
allocate([80,79,87,0] /* POW\00 */, "i8", ALLOC_NONE, 5246284);
allocate([99,104,97,114,40,37,100,41,0] /* char(%d)\00 */, "i8", ALLOC_NONE, 5246288);
allocate([61,91,67,93,0] /* =[C]\00 */, "i8", ALLOC_NONE, 5246300);
allocate([117,110,102,105,110,105,115,104,101,100,32,108,111,110,103,32,99,111,109,109,101,110,116,0] /* unfinished long comm */, "i8", ALLOC_NONE, 5246308);
allocate([95,95,115,117,98,0] /* __sub\00 */, "i8", ALLOC_NONE, 5246332);
allocate([102,117,110,99,116,105,111,110,32,97,114,103,117,109,101,110,116,115,32,101,120,112,101,99,116,101,100,0] /* function arguments e */, "i8", ALLOC_NONE, 5246340);
allocate([77,79,68,0] /* MOD\00 */, "i8", ALLOC_NONE, 5246368);
allocate([109,101,116,97,109,101,116,104,111,100,0] /* metamethod\00 */, "i8", ALLOC_NONE, 5246372);
allocate([117,110,102,105,110,105,115,104,101,100,32,108,111,110,103,32,115,116,114,105,110,103,0] /* unfinished long stri */, "i8", ALLOC_NONE, 5246384);
allocate([95,95,97,100,100,0] /* __add\00 */, "i8", ALLOC_NONE, 5246408);
allocate([116,111,111,32,109,97,110,121,32,37,115,32,40,108,105,109,105,116,32,105,115,32,37,100,41,32,105,110,32,37,115,0] /* too many %s (limit i */, "i8", ALLOC_NONE, 5246416);
allocate([68,73,86,0] /* DIV\00 */, "i8", ALLOC_NONE, 5246448);
allocate([102,111,114,32,105,116,101,114,97,116,111,114,0] /* for iterator\00 */, "i8", ALLOC_NONE, 5246452);
allocate([101,114,114,111,114,32,105,110,32,95,95,103,99,32,109,101,116,97,109,101,116,104,111,100,32,40,37,115,41,0] /* error in __gc metame */, "i8", ALLOC_NONE, 5246468);
allocate([97,116,116,101,109,112,116,32,116,111,32,37,115,32,97,32,37,115,32,118,97,108,117,101,0] /* attempt to %s a %s v */, "i8", ALLOC_NONE, 5246500);
allocate([104,101,120,97,100,101,99,105,109,97,108,32,100,105,103,105,116,32,101,120,112,101,99,116,101,100,0] /* hexadecimal digit ex */, "i8", ALLOC_NONE, 5246528);
allocate([95,95,101,113,0] /* __eq\00 */, "i8", ALLOC_NONE, 5246556);
allocate([102,117,110,99,116,105,111,110,32,97,116,32,108,105,110,101,32,37,100,0] /* function at line %d\ */, "i8", ALLOC_NONE, 5246564);
allocate([77,85,76,0] /* MUL\00 */, "i8", ALLOC_NONE, 5246584);
allocate(1, "i8", ALLOC_NONE, 5246588);
allocate([100,101,99,105,109,97,108,32,101,115,99,97,112,101,32,116,111,111,32,108,97,114,103,101,0] /* decimal escape too l */, "i8", ALLOC_NONE, 5246592);
allocate([95,95,108,101,110,0] /* __len\00 */, "i8", ALLOC_NONE, 5246620);
allocate([109,97,105,110,32,102,117,110,99,116,105,111,110,0] /* main function\00 */, "i8", ALLOC_NONE, 5246628);
allocate([83,85,66,0] /* SUB\00 */, "i8", ALLOC_NONE, 5246644);
allocate([77,79,86,69,0] /* MOVE\00 */, "i8", ALLOC_NONE, 5246648);
allocate([63,0] /* ?\00 */, "i8", ALLOC_NONE, 5246656);
allocate([105,110,118,97,108,105,100,32,101,115,99,97,112,101,32,115,101,113,117,101,110,99,101,0] /* invalid escape seque */, "i8", ALLOC_NONE, 5246660);
allocate([95,95,109,111,100,101,0] /* __mode\00 */, "i8", ALLOC_NONE, 5246684);
allocate([105,116,101,109,115,32,105,110,32,97,32,99,111,110,115,116,114,117,99,116,111,114,0] /* items in a construct */, "i8", ALLOC_NONE, 5246692);
allocate([65,68,68,0] /* ADD\00 */, "i8", ALLOC_NONE, 5246716);
allocate([109,101,116,104,111,100,0] /* method\00 */, "i8", ALLOC_NONE, 5246720);
allocate([105,110,100,101,120,0] /* index\00 */, "i8", ALLOC_NONE, 5246728);
allocate([99,111,110,115,116,114,117,99,116,111,114,32,116,111,111,32,108,111,110,103,0] /* constructor too long */, "i8", ALLOC_NONE, 5246736);
allocate([98,105,110,97,114,121,32,115,116,114,105,110,103,0] /* binary string\00 */, "i8", ALLOC_NONE, 5246760);
allocate([117,110,102,105,110,105,115,104,101,100,32,115,116,114,105,110,103,0] /* unfinished string\00 */, "i8", ALLOC_NONE, 5246776);
allocate([67,32,115,116,97,99,107,32,111,118,101,114,102,108,111,119,0] /* C stack overflow\00 */, "i8", ALLOC_NONE, 5246796);
allocate([110,105,108,0] /* nil\00 */, "i8", ALLOC_NONE, 5246816);
allocate([116,97,98,108,101,32,105,110,100,101,120,32,105,115,32,78,97,78,0] /* table index is NaN\0 */, "i8", ALLOC_NONE, 5246820);
allocate([95,95,103,99,0] /* __gc\00 */, "i8", ALLOC_NONE, 5246840);
allocate([102,117,110,99,116,105,111,110,115,0] /* functions\00 */, "i8", ALLOC_NONE, 5246848);
allocate([83,69,76,70,0] /* SELF\00 */, "i8", ALLOC_NONE, 5246860);
allocate([110,78,0] /* nN\00 */, "i8", ALLOC_NONE, 5246868);
allocate([99,111,110,115,116,97,110,116,0] /* constant\00 */, "i8", ALLOC_NONE, 5246872);
allocate([108,101,120,105,99,97,108,32,101,108,101,109,101,110,116,32,116,111,111,32,108,111,110,103,0] /* lexical element too  */, "i8", ALLOC_NONE, 5246884);
allocate([110,111,32,118,105,115,105,98,108,101,32,108,97,98,101,108,32,39,37,115,39,32,102,111,114,32,60,103,111,116,111,62,32,97,116,32,108,105,110,101,32,37,100,0] /* no visible label '%s */, "i8", ALLOC_NONE, 5246912);
allocate([76,79,65,68,75,0] /* LOADK\00 */, "i8", ALLOC_NONE, 5246956);
allocate([99,97,108,108,0] /* call\00 */, "i8", ALLOC_NONE, 5246964);
allocate([95,95,110,101,119,105,110,100,101,120,0] /* __newindex\00 */, "i8", ALLOC_NONE, 5246972);
allocate([120,88,0] /* xX\00 */, "i8", ALLOC_NONE, 5246984);
allocate([108,111,99,97,108,32,118,97,114,105,97,98,108,101,115,0] /* local variables\00 */, "i8", ALLOC_NONE, 5246988);
allocate([78,69,87,84,65,66,76,69,0] /* NEWTABLE\00 */, "i8", ALLOC_NONE, 5247004);
allocate([109,101,109,111,114,121,32,97,108,108,111,99,97,116,105,111,110,32,101,114,114,111,114,58,32,98,108,111,99,107,32,116,111,111,32,98,105,103,0] /* memory allocation er */, "i8", ALLOC_NONE, 5247016);
allocate([116,111,111,32,109,97,110,121,32,37,115,32,40,108,105,109,105,116,32,105,115,32,37,100,41,0] /* too many %s (limit i */, "i8", ALLOC_NONE, 5247056);
allocate([117,112,118,97,108,117,101,0] /* upvalue\00 */, "i8", ALLOC_NONE, 5247084);
allocate([109,97,108,102,111,114,109,101,100,32,110,117,109,98,101,114,0] /* malformed number\00 */, "i8", ALLOC_NONE, 5247092);
allocate([99,97,110,110,111,116,32,114,101,115,117,109,101,32,100,101,97,100,32,99,111,114,111,117,116,105,110,101,0] /* cannot resume dead c */, "i8", ALLOC_NONE, 5247112);
allocate([105,110,99,111,109,112,97,116,105,98,108,101,0] /* incompatible\00 */, "i8", ALLOC_NONE, 5247144);
allocate([95,95,105,110,100,101,120,0] /* __index\00 */, "i8", ALLOC_NONE, 5247160);
allocate([60,110,97,109,101,62,32,111,114,32,39,46,46,46,39,32,101,120,112,101,99,116,101,100,0] /* _name_ or '...' expe */, "i8", ALLOC_NONE, 5247168);
allocate([83,69,84,84,65,66,76,69,0] /* SETTABLE\00 */, "i8", ALLOC_NONE, 5247196);
allocate([102,105,101,108,100,0] /* field\00 */, "i8", ALLOC_NONE, 5247208);
allocate(1, "i8", ALLOC_NONE, 5247216);
allocate([63,0] /* ?\00 */, "i8", ALLOC_NONE, 5247220);
HEAP32[((5243332)>>2)]=((5246024)|0);
HEAP32[((5243336)>>2)]=((5245892)|0);
HEAP32[((5243340)>>2)]=((5245744)|0);
HEAP32[((5243344)>>2)]=((5245676)|0);
HEAP32[((5243348)>>2)]=((5245616)|0);
HEAP32[((5243352)>>2)]=((5245572)|0);
HEAP32[((5243356)>>2)]=((5245528)|0);
HEAP32[((5243360)>>2)]=((5245476)|0);
HEAP32[((5243364)>>2)]=((5245436)|0);
HEAP32[((5243368)>>2)]=((5245404)|0);
HEAP32[((5243372)>>2)]=((5245380)|0);
HEAP32[((5243376)>>2)]=((5245344)|0);
HEAP32[((5243380)>>2)]=((5245248)|0);
HEAP32[((5243384)>>2)]=((5245216)|0);
HEAP32[((5243388)>>2)]=((5245200)|0);
HEAP32[((5243392)>>2)]=((5245184)|0);
HEAP32[((5243396)>>2)]=((5245168)|0);
HEAP32[((5243400)>>2)]=((5245128)|0);
HEAP32[((5243404)>>2)]=((5245104)|0);
HEAP32[((5243408)>>2)]=((5245056)|0);
HEAP32[((5243412)>>2)]=((5245048)|0);
HEAP32[((5243416)>>2)]=((5245012)|0);
HEAP32[((5243420)>>2)]=((5244984)|0);
HEAP32[((5243424)>>2)]=((5244956)|0);
HEAP32[((5243428)>>2)]=((5244952)|0);
HEAP32[((5243432)>>2)]=((5244948)|0);
HEAP32[((5243436)>>2)]=((5244944)|0);
HEAP32[((5243440)>>2)]=((5244940)|0);
HEAP32[((5243444)>>2)]=((5244868)|0);
HEAP32[((5243448)>>2)]=((5244824)|0);
HEAP32[((5243452)>>2)]=((5244812)|0);
HEAP32[((5243456)>>2)]=((5244704)|0);
HEAP32[((5243460)>>2)]=((5244672)|0);
HEAP32[((5243464)>>2)]=((5245576)|0);
HEAP32[((5243468)>>2)]=((5246816)|0);
HEAP32[((5243472)>>2)]=((5245840)|0);
HEAP32[((5243476)>>2)]=((5242880)|0);
HEAP32[((5243480)>>2)]=((5245304)|0);
HEAP32[((5243484)>>2)]=((5245004)|0);
HEAP32[((5243488)>>2)]=((5244696)|0);
HEAP32[((5243492)>>2)]=((5244576)|0);
HEAP32[((5243496)>>2)]=((5242880)|0);
HEAP32[((5243500)>>2)]=((5244444)|0);
HEAP32[((5243504)>>2)]=((5244268)|0);
HEAP32[((5243508)>>2)]=((5244168)|0);
HEAP32[((5243512)>>2)]=((5247160)|0);
HEAP32[((5243516)>>2)]=((5246972)|0);
HEAP32[((5243520)>>2)]=((5246840)|0);
HEAP32[((5243524)>>2)]=((5246684)|0);
HEAP32[((5243528)>>2)]=((5246620)|0);
HEAP32[((5243532)>>2)]=((5246556)|0);
HEAP32[((5243536)>>2)]=((5246408)|0);
HEAP32[((5243540)>>2)]=((5246332)|0);
HEAP32[((5243544)>>2)]=((5246256)|0);
HEAP32[((5243548)>>2)]=((5246136)|0);
HEAP32[((5243552)>>2)]=((5246048)|0);
HEAP32[((5243556)>>2)]=((5245988)|0);
HEAP32[((5243560)>>2)]=((5245864)|0);
HEAP32[((5243564)>>2)]=((5245716)|0);
HEAP32[((5243568)>>2)]=((5245640)|0);
HEAP32[((5243572)>>2)]=((5245588)|0);
HEAP32[((5243576)>>2)]=((5245548)|0);
HEAP32[((5243580)>>2)]=((5246648)|0);
HEAP32[((5243584)>>2)]=((5246956)|0);
HEAP32[((5243588)>>2)]=((5245960)|0);
HEAP32[((5243592)>>2)]=((5245356)|0);
HEAP32[((5243596)>>2)]=((5245036)|0);
HEAP32[((5243600)>>2)]=((5244724)|0);
HEAP32[((5243604)>>2)]=((5244604)|0);
HEAP32[((5243608)>>2)]=((5244464)|0);
HEAP32[((5243612)>>2)]=((5244320)|0);
HEAP32[((5243616)>>2)]=((5244184)|0);
HEAP32[((5243620)>>2)]=((5247196)|0);
HEAP32[((5243624)>>2)]=((5247004)|0);
HEAP32[((5243628)>>2)]=((5246860)|0);
HEAP32[((5243632)>>2)]=((5246716)|0);
HEAP32[((5243636)>>2)]=((5246644)|0);
HEAP32[((5243640)>>2)]=((5246584)|0);
HEAP32[((5243644)>>2)]=((5246448)|0);
HEAP32[((5243648)>>2)]=((5246368)|0);
HEAP32[((5243652)>>2)]=((5246284)|0);
HEAP32[((5243656)>>2)]=((5246184)|0);
HEAP32[((5243660)>>2)]=((5246080)|0);
HEAP32[((5243664)>>2)]=((5246020)|0);
HEAP32[((5243668)>>2)]=((5245884)|0);
HEAP32[((5243672)>>2)]=((5245740)|0);
HEAP32[((5243676)>>2)]=((5245660)|0);
HEAP32[((5243680)>>2)]=((5245612)|0);
HEAP32[((5243684)>>2)]=((5245568)|0);
HEAP32[((5243688)>>2)]=((5245520)|0);
HEAP32[((5243692)>>2)]=((5245460)|0);
HEAP32[((5243696)>>2)]=((5245428)|0);
HEAP32[((5243700)>>2)]=((5245392)|0);
HEAP32[((5243704)>>2)]=((5245372)|0);
HEAP32[((5243708)>>2)]=((5245336)|0);
HEAP32[((5243712)>>2)]=((5245220)|0);
HEAP32[((5243716)>>2)]=((5245204)|0);
HEAP32[((5243720)>>2)]=((5245188)|0);
HEAP32[((5243724)>>2)]=((5245176)|0);
HEAP32[((5243728)>>2)]=((5245160)|0);
HEAP32[((5243732)>>2)]=((5245120)|0);
HEAP32[((5243736)>>2)]=((5245092)|0);

  
  function _memcpy(dest, src, num) {
      dest = dest|0; src = src|0; num = num|0;
      var ret = 0;
      ret = dest|0;
      if ((dest&3) == (src&3)) {
        while (dest & 3) {
          if ((num|0) == 0) return ret|0;
          HEAP8[(dest)]=HEAP8[(src)];
          dest = (dest+1)|0;
          src = (src+1)|0;
          num = (num-1)|0;
        }
        while ((num|0) >= 4) {
          HEAP32[((dest)>>2)]=HEAP32[((src)>>2)];
          dest = (dest+4)|0;
          src = (src+4)|0;
          num = (num-4)|0;
        }
      }
      while ((num|0) > 0) {
        HEAP8[(dest)]=HEAP8[(src)];
        dest = (dest+1)|0;
        src = (src+1)|0;
        num = (num-1)|0;
      }
      return ret|0;
    }var _llvm_memcpy_p0i8_p0i8_i32=_memcpy;
var _llvm_va_start; // stub for _llvm_va_start

  function _llvm_va_end() {}

  var _abs=Math.abs;

  function _strchr(ptr, chr) {
      ptr--;
      do {
        ptr++;
        var val = HEAP8[(ptr)];
        if (val == chr) return ptr;
      } while (val);
      return 0;
    }

  
  function _strncmp(px, py, n) {
      var i = 0;
      while (i < n) {
        var x = HEAPU8[(((px)+(i))|0)];
        var y = HEAPU8[(((py)+(i))|0)];
        if (x == y && x == 0) return 0;
        if (x == 0) return -1;
        if (y == 0) return 1;
        if (x == y) {
          i ++;
          continue;
        } else {
          return x > y ? 1 : -1;
        }
      }
      return 0;
    }function _strcmp(px, py) {
      return _strncmp(px, py, TOTAL_MEMORY);
    }

  function _longjmp(env, value) {
      throw { longjmp: true, id: HEAP32[((env)>>2)], value: value || 1 };
    }

  function _abort() {
      ABORT = true;
      throw 'abort() at ' + (new Error().stack);
    }
var _setjmp; // stub for _setjmp

  function _localeconv() {
      // %struct.timeval = type { char* decimal point, other stuff... }
      // var indexes = Runtime.calculateStructAlignment({ fields: ['i32', 'i32'] });
      var me = _localeconv;
      if (!me.ret) {
        me.ret = allocate([allocate(intArrayFromString('.'), 'i8', ALLOC_NORMAL)], 'i8*', ALLOC_NORMAL); // just decimal point, for now
      }
      return me.ret;
    }

  var _floor=Math.floor;

  var _llvm_pow_f64=Math.pow;

  function _strpbrk(ptr1, ptr2) {
      var curr;
      var searchSet = {};
      while (1) {
        var curr = HEAP8[((ptr2++)|0)];
        if (!curr) break;
        searchSet[curr] = 1;
      }
      while (1) {
        curr = HEAP8[(ptr1)];
        if (!curr) break;
        if (curr in searchSet) return ptr1;
        ptr1++;
      }
      return 0;
    }

  
  function _isspace(chr) {
      return chr in { 32: 0, 9: 0, 10: 0, 11: 0, 12: 0, 13: 0 };
    }
  
  function _isdigit(chr) {
      return chr >= '0'.charCodeAt(0) && chr <= '9'.charCodeAt(0);
    }function _strtod(str, endptr) {
      var origin = str;
  
      // Skip space.
      while (_isspace(HEAP8[(str)])) str++;
  
      // Check for a plus/minus sign.
      var multiplier = 1;
      if (HEAP8[(str)] == '-'.charCodeAt(0)) {
        multiplier = -1;
        str++;
      } else if (HEAP8[(str)] == '+'.charCodeAt(0)) {
        str++;
      }
  
      var chr;
      var ret = 0;
  
      // Get whole part.
      var whole = false;
      while(1) {
        chr = HEAP8[(str)];
        if (!_isdigit(chr)) break;
        whole = true;
        ret = ret*10 + chr - '0'.charCodeAt(0);
        str++;
      }
  
      // Get fractional part.
      var fraction = false;
      if (HEAP8[(str)] == '.'.charCodeAt(0)) {
        str++;
        var mul = 1/10;
        while(1) {
          chr = HEAP8[(str)];
          if (!_isdigit(chr)) break;
          fraction = true;
          ret += mul*(chr - '0'.charCodeAt(0));
          mul /= 10;
          str++;
        }
      }
  
      if (!whole && !fraction) {
        if (endptr) {
          HEAP32[((endptr)>>2)]=origin
        }
        return 0;
      }
  
      // Get exponent part.
      chr = HEAP8[(str)];
      if (chr == 'e'.charCodeAt(0) || chr == 'E'.charCodeAt(0)) {
        str++;
        var exponent = 0;
        var expNegative = false;
        chr = HEAP8[(str)];
        if (chr == '-'.charCodeAt(0)) {
          expNegative = true;
          str++;
        } else if (chr == '+'.charCodeAt(0)) {
          str++;
        }
        chr = HEAP8[(str)];
        while(1) {
          if (!_isdigit(chr)) break;
          exponent = exponent*10 + chr - '0'.charCodeAt(0);
          str++;
          chr = HEAP8[(str)];
        }
        if (expNegative) exponent = -exponent;
        ret *= Math.pow(10, exponent);
      }
  
      // Set end pointer.
      if (endptr) {
        HEAP32[((endptr)>>2)]=str
      }
  
      return ret * multiplier;
    }

  function _strlen(ptr) {
      ptr = ptr|0;
      var curr = 0;
      curr = ptr;
      while (HEAP8[(curr)]|0 != 0) {
        curr = (curr + 1)|0;
      }
      return (curr - ptr)|0;
    }

  
  
  function __formatString(format, varargs) {
      var textIndex = format;
      var argIndex = 0;
      function getNextArg(type) {
        // NOTE: Explicitly ignoring type safety. Otherwise this fails:
        //       int x = 4; printf("%c\n", (char)x);
        var ret;
        if (type === 'double') {
          ret = (HEAP32[((tempDoublePtr)>>2)]=HEAP32[(((varargs)+(argIndex))>>2)],HEAP32[(((tempDoublePtr)+(4))>>2)]=HEAP32[(((varargs)+((argIndex)+(4)))>>2)],HEAPF64[(tempDoublePtr)>>3]);
        } else if (type == 'i64') {
          ret = [HEAP32[(((varargs)+(argIndex))>>2)],
                 HEAP32[(((varargs)+(argIndex+4))>>2)]];
        } else {
          type = 'i32'; // varargs are always i32, i64, or double
          ret = HEAP32[(((varargs)+(argIndex))>>2)];
        }
        argIndex += Runtime.getNativeFieldSize(type);
        return ret;
      }
  
      var ret = [];
      var curr, next, currArg;
      while(1) {
        var startTextIndex = textIndex;
        curr = HEAP8[(textIndex)];
        if (curr === 0) break;
        next = HEAP8[((textIndex+1)|0)];
        if (curr == '%'.charCodeAt(0)) {
          // Handle flags.
          var flagAlwaysSigned = false;
          var flagLeftAlign = false;
          var flagAlternative = false;
          var flagZeroPad = false;
          flagsLoop: while (1) {
            switch (next) {
              case '+'.charCodeAt(0):
                flagAlwaysSigned = true;
                break;
              case '-'.charCodeAt(0):
                flagLeftAlign = true;
                break;
              case '#'.charCodeAt(0):
                flagAlternative = true;
                break;
              case '0'.charCodeAt(0):
                if (flagZeroPad) {
                  break flagsLoop;
                } else {
                  flagZeroPad = true;
                  break;
                }
              default:
                break flagsLoop;
            }
            textIndex++;
            next = HEAP8[((textIndex+1)|0)];
          }
  
          // Handle width.
          var width = 0;
          if (next == '*'.charCodeAt(0)) {
            width = getNextArg('i32');
            textIndex++;
            next = HEAP8[((textIndex+1)|0)];
          } else {
            while (next >= '0'.charCodeAt(0) && next <= '9'.charCodeAt(0)) {
              width = width * 10 + (next - '0'.charCodeAt(0));
              textIndex++;
              next = HEAP8[((textIndex+1)|0)];
            }
          }
  
          // Handle precision.
          var precisionSet = false;
          if (next == '.'.charCodeAt(0)) {
            var precision = 0;
            precisionSet = true;
            textIndex++;
            next = HEAP8[((textIndex+1)|0)];
            if (next == '*'.charCodeAt(0)) {
              precision = getNextArg('i32');
              textIndex++;
            } else {
              while(1) {
                var precisionChr = HEAP8[((textIndex+1)|0)];
                if (precisionChr < '0'.charCodeAt(0) ||
                    precisionChr > '9'.charCodeAt(0)) break;
                precision = precision * 10 + (precisionChr - '0'.charCodeAt(0));
                textIndex++;
              }
            }
            next = HEAP8[((textIndex+1)|0)];
          } else {
            var precision = 6; // Standard default.
          }
  
          // Handle integer sizes. WARNING: These assume a 32-bit architecture!
          var argSize;
          switch (String.fromCharCode(next)) {
            case 'h':
              var nextNext = HEAP8[((textIndex+2)|0)];
              if (nextNext == 'h'.charCodeAt(0)) {
                textIndex++;
                argSize = 1; // char (actually i32 in varargs)
              } else {
                argSize = 2; // short (actually i32 in varargs)
              }
              break;
            case 'l':
              var nextNext = HEAP8[((textIndex+2)|0)];
              if (nextNext == 'l'.charCodeAt(0)) {
                textIndex++;
                argSize = 8; // long long
              } else {
                argSize = 4; // long
              }
              break;
            case 'L': // long long
            case 'q': // int64_t
            case 'j': // intmax_t
              argSize = 8;
              break;
            case 'z': // size_t
            case 't': // ptrdiff_t
            case 'I': // signed ptrdiff_t or unsigned size_t
              argSize = 4;
              break;
            default:
              argSize = null;
          }
          if (argSize) textIndex++;
          next = HEAP8[((textIndex+1)|0)];
  
          // Handle type specifier.
          if (['d', 'i', 'u', 'o', 'x', 'X', 'p'].indexOf(String.fromCharCode(next)) != -1) {
            // Integer.
            var signed = next == 'd'.charCodeAt(0) || next == 'i'.charCodeAt(0);
            argSize = argSize || 4;
            var currArg = getNextArg('i' + (argSize * 8));
            var origArg = currArg;
            var argText;
            // Flatten i64-1 [low, high] into a (slightly rounded) double
            if (argSize == 8) {
              currArg = Runtime.makeBigInt(currArg[0], currArg[1], next == 'u'.charCodeAt(0));
            }
            // Truncate to requested size.
            if (argSize <= 4) {
              var limit = Math.pow(256, argSize) - 1;
              currArg = (signed ? reSign : unSign)(currArg & limit, argSize * 8);
            }
            // Format the number.
            var currAbsArg = Math.abs(currArg);
            var prefix = '';
            if (next == 'd'.charCodeAt(0) || next == 'i'.charCodeAt(0)) {
              if (argSize == 8 && i64Math) argText = i64Math.stringify(origArg[0], origArg[1], null); else
              argText = reSign(currArg, 8 * argSize, 1).toString(10);
            } else if (next == 'u'.charCodeAt(0)) {
              if (argSize == 8 && i64Math) argText = i64Math.stringify(origArg[0], origArg[1], true); else
              argText = unSign(currArg, 8 * argSize, 1).toString(10);
              currArg = Math.abs(currArg);
            } else if (next == 'o'.charCodeAt(0)) {
              argText = (flagAlternative ? '0' : '') + currAbsArg.toString(8);
            } else if (next == 'x'.charCodeAt(0) || next == 'X'.charCodeAt(0)) {
              prefix = flagAlternative ? '0x' : '';
              if (argSize == 8 && i64Math) argText = (origArg[1]>>>0).toString(16) + (origArg[0]>>>0).toString(16); else
              if (currArg < 0) {
                // Represent negative numbers in hex as 2's complement.
                currArg = -currArg;
                argText = (currAbsArg - 1).toString(16);
                var buffer = [];
                for (var i = 0; i < argText.length; i++) {
                  buffer.push((0xF - parseInt(argText[i], 16)).toString(16));
                }
                argText = buffer.join('');
                while (argText.length < argSize * 2) argText = 'f' + argText;
              } else {
                argText = currAbsArg.toString(16);
              }
              if (next == 'X'.charCodeAt(0)) {
                prefix = prefix.toUpperCase();
                argText = argText.toUpperCase();
              }
            } else if (next == 'p'.charCodeAt(0)) {
              if (currAbsArg === 0) {
                argText = '(nil)';
              } else {
                prefix = '0x';
                argText = currAbsArg.toString(16);
              }
            }
            if (precisionSet) {
              while (argText.length < precision) {
                argText = '0' + argText;
              }
            }
  
            // Add sign if needed
            if (flagAlwaysSigned) {
              if (currArg < 0) {
                prefix = '-' + prefix;
              } else {
                prefix = '+' + prefix;
              }
            }
  
            // Add padding.
            while (prefix.length + argText.length < width) {
              if (flagLeftAlign) {
                argText += ' ';
              } else {
                if (flagZeroPad) {
                  argText = '0' + argText;
                } else {
                  prefix = ' ' + prefix;
                }
              }
            }
  
            // Insert the result into the buffer.
            argText = prefix + argText;
            argText.split('').forEach(function(chr) {
              ret.push(chr.charCodeAt(0));
            });
          } else if (['f', 'F', 'e', 'E', 'g', 'G'].indexOf(String.fromCharCode(next)) != -1) {
            // Float.
            var currArg = getNextArg('double');
            var argText;
  
            if (isNaN(currArg)) {
              argText = 'nan';
              flagZeroPad = false;
            } else if (!isFinite(currArg)) {
              argText = (currArg < 0 ? '-' : '') + 'inf';
              flagZeroPad = false;
            } else {
              var isGeneral = false;
              var effectivePrecision = Math.min(precision, 20);
  
              // Convert g/G to f/F or e/E, as per:
              // http://pubs.opengroup.org/onlinepubs/9699919799/functions/printf.html
              if (next == 'g'.charCodeAt(0) || next == 'G'.charCodeAt(0)) {
                isGeneral = true;
                precision = precision || 1;
                var exponent = parseInt(currArg.toExponential(effectivePrecision).split('e')[1], 10);
                if (precision > exponent && exponent >= -4) {
                  next = ((next == 'g'.charCodeAt(0)) ? 'f' : 'F').charCodeAt(0);
                  precision -= exponent + 1;
                } else {
                  next = ((next == 'g'.charCodeAt(0)) ? 'e' : 'E').charCodeAt(0);
                  precision--;
                }
                effectivePrecision = Math.min(precision, 20);
              }
  
              if (next == 'e'.charCodeAt(0) || next == 'E'.charCodeAt(0)) {
                argText = currArg.toExponential(effectivePrecision);
                // Make sure the exponent has at least 2 digits.
                if (/[eE][-+]\d$/.test(argText)) {
                  argText = argText.slice(0, -1) + '0' + argText.slice(-1);
                }
              } else if (next == 'f'.charCodeAt(0) || next == 'F'.charCodeAt(0)) {
                argText = currArg.toFixed(effectivePrecision);
              }
  
              var parts = argText.split('e');
              if (isGeneral && !flagAlternative) {
                // Discard trailing zeros and periods.
                while (parts[0].length > 1 && parts[0].indexOf('.') != -1 &&
                       (parts[0].slice(-1) == '0' || parts[0].slice(-1) == '.')) {
                  parts[0] = parts[0].slice(0, -1);
                }
              } else {
                // Make sure we have a period in alternative mode.
                if (flagAlternative && argText.indexOf('.') == -1) parts[0] += '.';
                // Zero pad until required precision.
                while (precision > effectivePrecision++) parts[0] += '0';
              }
              argText = parts[0] + (parts.length > 1 ? 'e' + parts[1] : '');
  
              // Capitalize 'E' if needed.
              if (next == 'E'.charCodeAt(0)) argText = argText.toUpperCase();
  
              // Add sign.
              if (flagAlwaysSigned && currArg >= 0) {
                argText = '+' + argText;
              }
            }
  
            // Add padding.
            while (argText.length < width) {
              if (flagLeftAlign) {
                argText += ' ';
              } else {
                if (flagZeroPad && (argText[0] == '-' || argText[0] == '+')) {
                  argText = argText[0] + '0' + argText.slice(1);
                } else {
                  argText = (flagZeroPad ? '0' : ' ') + argText;
                }
              }
            }
  
            // Adjust case.
            if (next < 'a'.charCodeAt(0)) argText = argText.toUpperCase();
  
            // Insert the result into the buffer.
            argText.split('').forEach(function(chr) {
              ret.push(chr.charCodeAt(0));
            });
          } else if (next == 's'.charCodeAt(0)) {
            // String.
            var arg = getNextArg('i8*') || nullString;
            var argLength = _strlen(arg);
            if (precisionSet) argLength = Math.min(argLength, precision);
            if (!flagLeftAlign) {
              while (argLength < width--) {
                ret.push(' '.charCodeAt(0));
              }
            }
            for (var i = 0; i < argLength; i++) {
              ret.push(HEAPU8[((arg++)|0)]);
            }
            if (flagLeftAlign) {
              while (argLength < width--) {
                ret.push(' '.charCodeAt(0));
              }
            }
          } else if (next == 'c'.charCodeAt(0)) {
            // Character.
            if (flagLeftAlign) ret.push(getNextArg('i8'));
            while (--width > 0) {
              ret.push(' '.charCodeAt(0));
            }
            if (!flagLeftAlign) ret.push(getNextArg('i8'));
          } else if (next == 'n'.charCodeAt(0)) {
            // Write the length written so far to the next parameter.
            var ptr = getNextArg('i32*');
            HEAP32[((ptr)>>2)]=ret.length
          } else if (next == '%'.charCodeAt(0)) {
            // Literal percent sign.
            ret.push(curr);
          } else {
            // Unknown specifiers remain untouched.
            for (var i = startTextIndex; i < textIndex + 2; i++) {
              ret.push(HEAP8[(i)]);
            }
          }
          textIndex += 2;
          // TODO: Support a/A (hex float) and m (last error) specifiers.
          // TODO: Support %1${specifier} for arg selection.
        } else {
          ret.push(curr);
          textIndex += 1;
        }
      }
      return ret;
    }function _snprintf(s, n, format, varargs) {
      // int snprintf(char *restrict s, size_t n, const char *restrict format, ...);
      // http://pubs.opengroup.org/onlinepubs/000095399/functions/printf.html
      var result = __formatString(format, varargs);
      var limit = (n === undefined) ? result.length
                                    : Math.min(result.length, Math.max(n - 1, 0));
      if (s < 0) {
        s = -s;
        var buf = _malloc(limit+1);
        HEAP32[((s)>>2)]=buf;
        s = buf;
      }
      for (var i = 0; i < limit; i++) {
        HEAP8[(((s)+(i))|0)]=result[i];
      }
      if (limit < n || (n === undefined)) HEAP8[(((s)+(i))|0)]=0;
      return result.length;
    }function _sprintf(s, format, varargs) {
      // int sprintf(char *restrict s, const char *restrict format, ...);
      // http://pubs.opengroup.org/onlinepubs/000095399/functions/printf.html
      return _snprintf(s, undefined, format, varargs);
    }

  function _ldexp(x, exp_) {
      return x * Math.pow(2, exp_);
    }

  function _time(ptr) {
      var ret = Math.floor(Date.now()/1000);
      if (ptr) {
        HEAP32[((ptr)>>2)]=ret
      }
      return ret;
    }

  function _memcmp(p1, p2, num) {
      p1 = p1|0; p2 = p2|0; num = num|0;
      var i = 0, v1 = 0, v2 = 0;
      while ((i|0) < (num|0)) {
        var v1 = HEAPU8[(((p1)+(i))|0)];
        var v2 = HEAPU8[(((p2)+(i))|0)];
        if ((v1|0) != (v2|0)) return ((v1|0) > (v2|0) ? 1 : -1)|0;
        i = (i+1)|0;
      }
      return 0;
    }

  var _strcoll=_strcmp;


  function _memset(ptr, value, num) {
      ptr = ptr|0; value = value|0; num = num|0;
      var stop = 0, value4 = 0, stop4 = 0, unaligned = 0;
      stop = (ptr + num)|0;
      if (num|0 >= 20) {
        // This is unaligned, but quite large, so work hard to get to aligned settings
        unaligned = ptr & 3;
        value4 = value | (value << 8) | (value << 16) | (value << 24);
        stop4 = stop & ~3;
        if (unaligned) {
          unaligned = (ptr + 4 - unaligned)|0;
          while ((ptr|0) < (unaligned|0)) { // no need to check for stop, since we have large num
            HEAP8[(ptr)]=value;
            ptr = (ptr+1)|0;
          }
        }
        while ((ptr|0) < (stop4|0)) {
          HEAP32[((ptr)>>2)]=value4;
          ptr = (ptr+4)|0;
        }
      }
      while ((ptr|0) < (stop|0)) {
        HEAP8[(ptr)]=value;
        ptr = (ptr+1)|0;
      }
    }

  function _malloc(bytes) {
      /* Over-allocate to make sure it is byte-aligned by 8.
       * This will leak memory, but this is only the dummy
       * implementation (replaced by dlmalloc normally) so
       * not an issue.
       */
      var ptr = Runtime.staticAlloc(bytes + 8);
      return (ptr+8) & 0xFFFFFFF8;
    }

  function _free(){}

  var Browser={mainLoop:{scheduler:null,shouldPause:false,paused:false,queue:[],pause:function () {
          Browser.mainLoop.shouldPause = true;
        },resume:function () {
          if (Browser.mainLoop.paused) {
            Browser.mainLoop.paused = false;
            Browser.mainLoop.scheduler();
          }
          Browser.mainLoop.shouldPause = false;
        },updateStatus:function () {
          if (Module['setStatus']) {
            var message = Module['statusMessage'] || 'Please wait...';
            var remaining = Browser.mainLoop.remainingBlockers;
            var expected = Browser.mainLoop.expectedBlockers;
            if (remaining) {
              if (remaining < expected) {
                Module['setStatus'](message + ' (' + (expected - remaining) + '/' + expected + ')');
              } else {
                Module['setStatus'](message);
              }
            } else {
              Module['setStatus']('');
            }
          }
        }},pointerLock:false,moduleContextCreatedCallbacks:[],workers:[],ensureObjects:function () {
        if (Browser.ensured) return;
        Browser.ensured = true;
        try {
          new Blob();
          Browser.hasBlobConstructor = true;
        } catch(e) {
          Browser.hasBlobConstructor = false;
          console.log("warning: no blob constructor, cannot create blobs with mimetypes");
        }
        Browser.BlobBuilder = typeof MozBlobBuilder != "undefined" ? MozBlobBuilder : (typeof WebKitBlobBuilder != "undefined" ? WebKitBlobBuilder : (!Browser.hasBlobConstructor ? console.log("warning: no BlobBuilder") : null));
        Browser.URLObject = typeof window != "undefined" ? (window.URL ? window.URL : window.webkitURL) : console.log("warning: cannot create object URLs");
  
        // Support for plugins that can process preloaded files. You can add more of these to
        // your app by creating and appending to Module.preloadPlugins.
        //
        // Each plugin is asked if it can handle a file based on the file's name. If it can,
        // it is given the file's raw data. When it is done, it calls a callback with the file's
        // (possibly modified) data. For example, a plugin might decompress a file, or it
        // might create some side data structure for use later (like an Image element, etc.).
  
        function getMimetype(name) {
          return {
            'jpg': 'image/jpeg',
            'jpeg': 'image/jpeg',
            'png': 'image/png',
            'bmp': 'image/bmp',
            'ogg': 'audio/ogg',
            'wav': 'audio/wav',
            'mp3': 'audio/mpeg'
          }[name.substr(-3)];
          return ret;
        }
  
        if (!Module["preloadPlugins"]) Module["preloadPlugins"] = [];
  
        var imagePlugin = {};
        imagePlugin['canHandle'] = function(name) {
          return !Module.noImageDecoding && /\.(jpg|jpeg|png|bmp)$/.exec(name);
        };
        imagePlugin['handle'] = function(byteArray, name, onload, onerror) {
          var b = null;
          if (Browser.hasBlobConstructor) {
            try {
              b = new Blob([byteArray], { type: getMimetype(name) });
            } catch(e) {
              Runtime.warnOnce('Blob constructor present but fails: ' + e + '; falling back to blob builder');
            }
          }
          if (!b) {
            var bb = new Browser.BlobBuilder();
            bb.append((new Uint8Array(byteArray)).buffer); // we need to pass a buffer, and must copy the array to get the right data range
            b = bb.getBlob();
          }
          var url = Browser.URLObject.createObjectURL(b);
          var img = new Image();
          img.onload = function() {
            assert(img.complete, 'Image ' + name + ' could not be decoded');
            var canvas = document.createElement('canvas');
            canvas.width = img.width;
            canvas.height = img.height;
            var ctx = canvas.getContext('2d');
            ctx.drawImage(img, 0, 0);
            Module["preloadedImages"][name] = canvas;
            Browser.URLObject.revokeObjectURL(url);
            if (onload) onload(byteArray);
          };
          img.onerror = function(event) {
            console.log('Image ' + url + ' could not be decoded');
            if (onerror) onerror();
          };
          img.src = url;
        };
        Module['preloadPlugins'].push(imagePlugin);
  
        var audioPlugin = {};
        audioPlugin['canHandle'] = function(name) {
          return !Module.noAudioDecoding && name.substr(-4) in { '.ogg': 1, '.wav': 1, '.mp3': 1 };
        };
        audioPlugin['handle'] = function(byteArray, name, onload, onerror) {
          var done = false;
          function finish(audio) {
            if (done) return;
            done = true;
            Module["preloadedAudios"][name] = audio;
            if (onload) onload(byteArray);
          }
          function fail() {
            if (done) return;
            done = true;
            Module["preloadedAudios"][name] = new Audio(); // empty shim
            if (onerror) onerror();
          }
          if (Browser.hasBlobConstructor) {
            try {
              var b = new Blob([byteArray], { type: getMimetype(name) });
            } catch(e) {
              return fail();
            }
            var url = Browser.URLObject.createObjectURL(b); // XXX we never revoke this!
            var audio = new Audio();
            audio.addEventListener('canplaythrough', function() { finish(audio) }, false); // use addEventListener due to chromium bug 124926
            audio.onerror = function(event) {
              if (done) return;
              console.log('warning: browser could not fully decode audio ' + name + ', trying slower base64 approach');
              function encode64(data) {
                var BASE = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
                var PAD = '=';
                var ret = '';
                var leftchar = 0;
                var leftbits = 0;
                for (var i = 0; i < data.length; i++) {
                  leftchar = (leftchar << 8) | data[i];
                  leftbits += 8;
                  while (leftbits >= 6) {
                    var curr = (leftchar >> (leftbits-6)) & 0x3f;
                    leftbits -= 6;
                    ret += BASE[curr];
                  }
                }
                if (leftbits == 2) {
                  ret += BASE[(leftchar&3) << 4];
                  ret += PAD + PAD;
                } else if (leftbits == 4) {
                  ret += BASE[(leftchar&0xf) << 2];
                  ret += PAD;
                }
                return ret;
              }
              audio.src = 'data:audio/x-' + name.substr(-3) + ';base64,' + encode64(byteArray);
              finish(audio); // we don't wait for confirmation this worked - but it's worth trying
            };
            audio.src = url;
            // workaround for chrome bug 124926 - we do not always get oncanplaythrough or onerror
            setTimeout(function() {
              finish(audio); // try to use it even though it is not necessarily ready to play
            }, 10000);
          } else {
            return fail();
          }
        };
        Module['preloadPlugins'].push(audioPlugin);
      },createContext:function (canvas, useWebGL, setInModule) {
        var ctx;
        try {
          if (useWebGL) {
            ctx = canvas.getContext('experimental-webgl', {
              alpha: false,
            });
          } else {
            ctx = canvas.getContext('2d');
          }
          if (!ctx) throw ':(';
        } catch (e) {
          Module.print('Could not create canvas - ' + e);
          return null;
        }
        if (useWebGL) {
          // Set the background of the WebGL canvas to black
          canvas.style.backgroundColor = "black";
  
          // Warn on context loss
          canvas.addEventListener('webglcontextlost', function(event) {
            alert('WebGL context lost. You will need to reload the page.');
          }, false);
        }
        if (setInModule) {
          Module.ctx = ctx;
          Module.useWebGL = useWebGL;
          Browser.moduleContextCreatedCallbacks.forEach(function(callback) { callback() });
        }
        return ctx;
      },destroyContext:function (canvas, useWebGL, setInModule) {},requestFullScreen:function () {
        var canvas = Module['canvas'];
        function fullScreenChange() {
          var isFullScreen = false;
          if ((document['webkitFullScreenElement'] || document['webkitFullscreenElement'] ||
               document['mozFullScreenElement'] || document['mozFullscreenElement'] ||
               document['fullScreenElement'] || document['fullscreenElement']) === canvas) {
            canvas.requestPointerLock = canvas['requestPointerLock'] ||
                                        canvas['mozRequestPointerLock'] ||
                                        canvas['webkitRequestPointerLock'];
            canvas.requestPointerLock();
            isFullScreen = true;
          }
          if (Module['onFullScreen']) Module['onFullScreen'](isFullScreen);
        }
  
        document.addEventListener('fullscreenchange', fullScreenChange, false);
        document.addEventListener('mozfullscreenchange', fullScreenChange, false);
        document.addEventListener('webkitfullscreenchange', fullScreenChange, false);
  
        function pointerLockChange() {
          Browser.pointerLock = document['pointerLockElement'] === canvas ||
                                document['mozPointerLockElement'] === canvas ||
                                document['webkitPointerLockElement'] === canvas;
        }
  
        document.addEventListener('pointerlockchange', pointerLockChange, false);
        document.addEventListener('mozpointerlockchange', pointerLockChange, false);
        document.addEventListener('webkitpointerlockchange', pointerLockChange, false);
  
        canvas.requestFullScreen = canvas['requestFullScreen'] ||
                                   canvas['mozRequestFullScreen'] ||
                                   (canvas['webkitRequestFullScreen'] ? function() { canvas['webkitRequestFullScreen'](Element['ALLOW_KEYBOARD_INPUT']) } : null);
        canvas.requestFullScreen(); 
      },requestAnimationFrame:function (func) {
        if (!window.requestAnimationFrame) {
          window.requestAnimationFrame = window['requestAnimationFrame'] ||
                                         window['mozRequestAnimationFrame'] ||
                                         window['webkitRequestAnimationFrame'] ||
                                         window['msRequestAnimationFrame'] ||
                                         window['oRequestAnimationFrame'] ||
                                         window['setTimeout'];
        }
        window.requestAnimationFrame(func);
      },getMovementX:function (event) {
        return event['movementX'] ||
               event['mozMovementX'] ||
               event['webkitMovementX'] ||
               0;
      },getMovementY:function (event) {
        return event['movementY'] ||
               event['mozMovementY'] ||
               event['webkitMovementY'] ||
               0;
      },xhrLoad:function (url, onload, onerror) {
        var xhr = new XMLHttpRequest();
        xhr.open('GET', url, true);
        xhr.responseType = 'arraybuffer';
        xhr.onload = function() {
          if (xhr.status == 200) {
            onload(xhr.response);
          } else {
            onerror();
          }
        };
        xhr.onerror = onerror;
        xhr.send(null);
      },asyncLoad:function (url, onload, onerror, noRunDep) {
        Browser.xhrLoad(url, function(arrayBuffer) {
          assert(arrayBuffer, 'Loading data file "' + url + '" failed (no arrayBuffer).');
          onload(new Uint8Array(arrayBuffer));
          if (!noRunDep) removeRunDependency('al ' + url);
        }, function(event) {
          if (onerror) {
            onerror();
          } else {
            throw 'Loading data file "' + url + '" failed.';
          }
        });
        if (!noRunDep) addRunDependency('al ' + url);
      },resizeListeners:[],updateResizeListeners:function () {
        var canvas = Module['canvas'];
        Browser.resizeListeners.forEach(function(listener) {
          listener(canvas.width, canvas.height);
        });
      },setCanvasSize:function (width, height, noUpdates) {
        var canvas = Module['canvas'];
        canvas.width = width;
        canvas.height = height;
        if (!noUpdates) Browser.updateResizeListeners();
      }};
Module["requestFullScreen"] = function() { Browser.requestFullScreen() };
  Module["requestAnimationFrame"] = function(func) { Browser.requestAnimationFrame(func) };
  Module["pauseMainLoop"] = function() { Browser.mainLoop.pause() };
  Module["resumeMainLoop"] = function() { Browser.mainLoop.resume() };
  


var FUNCTION_TABLE = [0,0,_lua_newstate,0,_growstack,0,_f_call,0,_dothecall,0,_resume,0,_f_parser,0,_unroll,0,_f_luaopen,0];

function _lua_atpanic($L, $panicf) {
  var label = 0;

  Module.print(INDENT + ' Entering: _lua_atpanic: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';

  var $L_addr;
  var $panicf_addr;
  var $old;
  $L_addr=$L;
  $panicf_addr=$panicf;
  var $0=$L_addr;
  var $l_G=(($0+12)|0);
  var $1=HEAP32[(($l_G)>>2)];
  var $panic=(($1+148)|0);
  var $2=HEAP32[(($panic)>>2)];
  $old=$2;
  var $3=$panicf_addr;
  var $4=$L_addr;
  var $l_G1=(($4+12)|0);
  var $5=HEAP32[(($l_G1)>>2)];
  var $panic2=(($5+148)|0);
  HEAP32[(($panic2)>>2)]=$3;
  var $6=$old;

  Module.print(INDENT + 'Exiting: _lua_atpanic');
  INDENT = INDENT.substr(0, INDENT.length-2);
  return $6;
  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _lua_version($L) {
  var label = 0;

  Module.print(INDENT + ' Entering: _lua_version: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $retval;
      var $L_addr;
      $L_addr=$L;
      var $0=$L_addr;
      var $cmp=(($0)|0)==0;
      if ($cmp) { label = 3; break; } else { label = 4; break; }
    case 3: 
      $retval=5243184;
      label = 5; break;
    case 4: 
      var $1=$L_addr;
      var $l_G=(($1+12)|0);
      var $2=HEAP32[(($l_G)>>2)];
      var $version=(($2+156)|0);
      var $3=HEAP32[(($version)>>2)];
      $retval=$3;
      label = 5; break;
    case 5: 
      var $4=$retval;

      Module.print(INDENT + 'Exiting: _lua_version');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return $4;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _lua_absindex($L, $idx) {
  var label = 0;

  Module.print(INDENT + ' Entering: _lua_absindex: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $L_addr;
      var $idx_addr;
      $L_addr=$L;
      $idx_addr=$idx;
      var $0=$idx_addr;
      var $cmp=(($0)|0) > 0;
      if ($cmp) { label = 4; break; } else { label = 3; break; }
    case 3: 
      var $1=$idx_addr;
      var $cmp1=(($1)|0) <= -1001000;
      if ($cmp1) { label = 4; break; } else { label = 5; break; }
    case 4: 
      var $2=$idx_addr;
      var $cond = $2;label = 6; break;
    case 5: 
      var $3=$L_addr;
      var $top=(($3+8)|0);
      var $4=HEAP32[(($top)>>2)];
      var $5=$L_addr;
      var $ci=(($5+16)|0);
      var $6=HEAP32[(($ci)>>2)];
      var $func=(($6)|0);
      var $7=HEAP32[(($func)>>2)];
      var $sub_ptr_lhs_cast=$4;
      var $sub_ptr_rhs_cast=$7;
      var $sub_ptr_sub=((($sub_ptr_lhs_cast)-($sub_ptr_rhs_cast))|0);
      var $sub_ptr_div=((((($sub_ptr_sub)|0))/(12))&-1);
      var $8=$idx_addr;
      var $add=((($sub_ptr_div)+($8))|0);
      var $cond = $add;label = 6; break;
    case 6: 
      var $cond;

      Module.print(INDENT + 'Exiting: _lua_absindex');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return $cond;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _lua_gettop($L) {
  var label = 0;

  Module.print(INDENT + ' Entering: _lua_gettop: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';

  var $L_addr;
  $L_addr=$L;
  var $0=$L_addr;
  var $top=(($0+8)|0);
  var $1=HEAP32[(($top)>>2)];
  var $2=$L_addr;
  var $ci=(($2+16)|0);
  var $3=HEAP32[(($ci)>>2)];
  var $func=(($3)|0);
  var $4=HEAP32[(($func)>>2)];
  var $add_ptr=(($4+12)|0);
  var $sub_ptr_lhs_cast=$1;
  var $sub_ptr_rhs_cast=$add_ptr;
  var $sub_ptr_sub=((($sub_ptr_lhs_cast)-($sub_ptr_rhs_cast))|0);
  var $sub_ptr_div=((((($sub_ptr_sub)|0))/(12))&-1);

  Module.print(INDENT + 'Exiting: _lua_gettop');
  INDENT = INDENT.substr(0, INDENT.length-2);
  return $sub_ptr_div;
  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _lua_settop($L, $idx) {
  var label = 0;

  Module.print(INDENT + ' Entering: _lua_settop: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $L_addr;
      var $idx_addr;
      var $func;
      $L_addr=$L;
      $idx_addr=$idx;
      var $0=$L_addr;
      var $ci=(($0+16)|0);
      var $1=HEAP32[(($ci)>>2)];
      var $func1=(($1)|0);
      var $2=HEAP32[(($func1)>>2)];
      $func=$2;
      var $3=$idx_addr;
      var $cmp=(($3)|0) >= 0;
      if ($cmp) { label = 3; break; } else { label = 7; break; }
    case 3: 
      label = 4; break;
    case 4: 
      var $4=$L_addr;
      var $top=(($4+8)|0);
      var $5=HEAP32[(($top)>>2)];
      var $6=$func;
      var $add_ptr=(($6+12)|0);
      var $7=$idx_addr;
      var $add_ptr2=(($add_ptr+((($7)*(12))&-1))|0);
      var $cmp3=(($5)>>>0) < (($add_ptr2)>>>0);
      if ($cmp3) { label = 5; break; } else { label = 6; break; }
    case 5: 
      var $8=$L_addr;
      var $top4=(($8+8)|0);
      var $9=HEAP32[(($top4)>>2)];
      var $incdec_ptr=(($9+12)|0);
      HEAP32[(($top4)>>2)]=$incdec_ptr;
      var $tt_=(($9+8)|0);
      HEAP32[(($tt_)>>2)]=0;
      label = 4; break;
    case 6: 
      var $10=$func;
      var $add_ptr5=(($10+12)|0);
      var $11=$idx_addr;
      var $add_ptr6=(($add_ptr5+((($11)*(12))&-1))|0);
      var $12=$L_addr;
      var $top7=(($12+8)|0);
      HEAP32[(($top7)>>2)]=$add_ptr6;
      label = 8; break;
    case 7: 
      var $13=$idx_addr;
      var $add=((($13)+(1))|0);
      var $14=$L_addr;
      var $top8=(($14+8)|0);
      var $15=HEAP32[(($top8)>>2)];
      var $add_ptr9=(($15+((($add)*(12))&-1))|0);
      HEAP32[(($top8)>>2)]=$add_ptr9;
      label = 8; break;
    case 8: 

      Module.print(INDENT + 'Exiting: _lua_settop');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _index2addr($L, $idx) {
  var label = 0;

  Module.print(INDENT + ' Entering: _index2addr: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $retval;
      var $L_addr;
      var $idx_addr;
      var $ci;
      var $o;
      var $func17;
      $L_addr=$L;
      $idx_addr=$idx;
      var $0=$L_addr;
      var $ci1=(($0+16)|0);
      var $1=HEAP32[(($ci1)>>2)];
      $ci=$1;
      var $2=$idx_addr;
      var $cmp=(($2)|0) > 0;
      if ($cmp) { label = 3; break; } else { label = 6; break; }
    case 3: 
      var $3=$ci;
      var $func=(($3)|0);
      var $4=HEAP32[(($func)>>2)];
      var $5=$idx_addr;
      var $add_ptr=(($4+((($5)*(12))&-1))|0);
      $o=$add_ptr;
      var $6=$o;
      var $7=$L_addr;
      var $top=(($7+8)|0);
      var $8=HEAP32[(($top)>>2)];
      var $cmp2=(($6)>>>0) >= (($8)>>>0);
      if ($cmp2) { label = 4; break; } else { label = 5; break; }
    case 4: 
      $retval=5243784;
      label = 16; break;
    case 5: 
      var $9=$o;
      $retval=$9;
      label = 16; break;
    case 6: 
      var $10=$idx_addr;
      var $cmp5=(($10)|0) > -1001000;
      if ($cmp5) { label = 7; break; } else { label = 8; break; }
    case 7: 
      var $11=$L_addr;
      var $top7=(($11+8)|0);
      var $12=HEAP32[(($top7)>>2)];
      var $13=$idx_addr;
      var $add_ptr8=(($12+((($13)*(12))&-1))|0);
      $retval=$add_ptr8;
      label = 16; break;
    case 8: 
      var $14=$idx_addr;
      var $cmp10=(($14)|0)==-1001000;
      if ($cmp10) { label = 9; break; } else { label = 10; break; }
    case 9: 
      var $15=$L_addr;
      var $l_G=(($15+12)|0);
      var $16=HEAP32[(($l_G)>>2)];
      var $l_registry=(($16+36)|0);
      $retval=$l_registry;
      label = 16; break;
    case 10: 
      var $17=$idx_addr;
      var $sub=(((-1001000)-($17))|0);
      $idx_addr=$sub;
      var $18=$ci;
      var $func13=(($18)|0);
      var $19=HEAP32[(($func13)>>2)];
      var $tt_=(($19+8)|0);
      var $20=HEAP32[(($tt_)>>2)];
      var $cmp14=(($20)|0)==22;
      if ($cmp14) { label = 11; break; } else { label = 12; break; }
    case 11: 
      $retval=5243784;
      label = 16; break;
    case 12: 
      var $21=$ci;
      var $func18=(($21)|0);
      var $22=HEAP32[(($func18)>>2)];
      var $value_=(($22)|0);
      var $gc=$value_;
      var $23=HEAP32[(($gc)>>2)];
      var $cl=$23;
      var $c=$cl;
      $func17=$c;
      var $24=$idx_addr;
      var $25=$func17;
      var $nupvalues=(($25+6)|0);
      var $26=HEAP8[($nupvalues)];
      var $conv=(($26)&255);
      var $cmp19=(($24)|0) <= (($conv)|0);
      if ($cmp19) { label = 13; break; } else { label = 14; break; }
    case 13: 
      var $27=$idx_addr;
      var $sub21=((($27)-(1))|0);
      var $28=$func17;
      var $upvalue=(($28+16)|0);
      var $arrayidx=(($upvalue+((($sub21)*(12))&-1))|0);
      var $cond = $arrayidx;label = 15; break;
    case 14: 
      var $cond = 5243784;label = 15; break;
    case 15: 
      var $cond;
      $retval=$cond;
      label = 16; break;
    case 16: 
      var $29=$retval;

      Module.print(INDENT + 'Exiting: _index2addr');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return $29;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_index2addr["X"]=1;

function _lua_typename($L, $t) {
  var label = 0;

  Module.print(INDENT + ' Entering: _lua_typename: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';

  var $L_addr;
  var $t_addr;
  $L_addr=$L;
  $t_addr=$t;
  var $0=$L_addr;
  var $1=$t_addr;
  var $add=((($1)+(1))|0);
  var $arrayidx=((5243464+($add<<2))|0);
  var $2=HEAP32[(($arrayidx)>>2)];

  Module.print(INDENT + 'Exiting: _lua_typename');
  INDENT = INDENT.substr(0, INDENT.length-2);
  return $2;
  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _lua_checkstack($L, $size) {
  var label = 0;
  var __stackBase__  = STACKTOP; STACKTOP = (STACKTOP + 4)|0; _memset(__stackBase__, 0, 4);
  Module.print(INDENT + ' Entering: _lua_checkstack: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $L_addr;
      var $size_addr=__stackBase__;
      var $res;
      var $ci;
      var $inuse;
      $L_addr=$L;
      HEAP32[(($size_addr)>>2)]=$size;
      var $0=$L_addr;
      var $ci1=(($0+16)|0);
      var $1=HEAP32[(($ci1)>>2)];
      $ci=$1;
      var $2=$L_addr;
      var $stack_last=(($2+24)|0);
      var $3=HEAP32[(($stack_last)>>2)];
      var $4=$L_addr;
      var $top=(($4+8)|0);
      var $5=HEAP32[(($top)>>2)];
      var $sub_ptr_lhs_cast=$3;
      var $sub_ptr_rhs_cast=$5;
      var $sub_ptr_sub=((($sub_ptr_lhs_cast)-($sub_ptr_rhs_cast))|0);
      var $sub_ptr_div=((((($sub_ptr_sub)|0))/(12))&-1);
      var $6=HEAP32[(($size_addr)>>2)];
      var $cmp=(($sub_ptr_div)|0) > (($6)|0);
      if ($cmp) { label = 3; break; } else { label = 4; break; }
    case 3: 
      $res=1;
      label = 8; break;
    case 4: 
      var $7=$L_addr;
      var $top2=(($7+8)|0);
      var $8=HEAP32[(($top2)>>2)];
      var $9=$L_addr;
      var $stack=(($9+28)|0);
      var $10=HEAP32[(($stack)>>2)];
      var $sub_ptr_lhs_cast3=$8;
      var $sub_ptr_rhs_cast4=$10;
      var $sub_ptr_sub5=((($sub_ptr_lhs_cast3)-($sub_ptr_rhs_cast4))|0);
      var $sub_ptr_div6=((((($sub_ptr_sub5)|0))/(12))&-1);
      var $add=((($sub_ptr_div6)+(5))|0);
      $inuse=$add;
      var $11=$inuse;
      var $12=HEAP32[(($size_addr)>>2)];
      var $sub=(((1000000)-($12))|0);
      var $cmp7=(($11)|0) > (($sub)|0);
      if ($cmp7) { label = 5; break; } else { label = 6; break; }
    case 5: 
      $res=0;
      label = 7; break;
    case 6: 
      var $13=$L_addr;
      var $14=$size_addr;
      var $call=_luaD_rawrunprotected($13, 4, $14);
      var $cmp10=(($call)|0)==0;
      var $conv=(($cmp10)&1);
      $res=$conv;
      label = 7; break;
    case 7: 
      label = 8; break;
    case 8: 
      var $15=$res;
      var $tobool=(($15)|0)!=0;
      if ($tobool) { label = 9; break; } else { label = 11; break; }
    case 9: 
      var $16=$ci;
      var $top12=(($16+4)|0);
      var $17=HEAP32[(($top12)>>2)];
      var $18=$L_addr;
      var $top13=(($18+8)|0);
      var $19=HEAP32[(($top13)>>2)];
      var $20=HEAP32[(($size_addr)>>2)];
      var $add_ptr=(($19+((($20)*(12))&-1))|0);
      var $cmp14=(($17)>>>0) < (($add_ptr)>>>0);
      if ($cmp14) { label = 10; break; } else { label = 11; break; }
    case 10: 
      var $21=$L_addr;
      var $top17=(($21+8)|0);
      var $22=HEAP32[(($top17)>>2)];
      var $23=HEAP32[(($size_addr)>>2)];
      var $add_ptr18=(($22+((($23)*(12))&-1))|0);
      var $24=$ci;
      var $top19=(($24+4)|0);
      HEAP32[(($top19)>>2)]=$add_ptr18;
      label = 11; break;
    case 11: 
      var $25=$res;
      STACKTOP = __stackBase__;
      Module.print(INDENT + 'Exiting: _lua_checkstack');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return $25;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_lua_checkstack["X"]=1;

function _growstack($L, $ud) {
  var label = 0;

  Module.print(INDENT + ' Entering: _growstack: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';

  var $L_addr;
  var $ud_addr;
  var $size;
  $L_addr=$L;
  $ud_addr=$ud;
  var $0=$ud_addr;
  var $1=$0;
  var $2=HEAP32[(($1)>>2)];
  $size=$2;
  var $3=$L_addr;
  var $4=$size;
  _luaD_growstack($3, $4);

  Module.print(INDENT + 'Exiting: _growstack');
  INDENT = INDENT.substr(0, INDENT.length-2);
  return;
  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _lua_xmove($from, $to, $n) {
  var label = 0;

  Module.print(INDENT + ' Entering: _lua_xmove: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $from_addr;
      var $to_addr;
      var $n_addr;
      var $i;
      var $io2;
      var $io1;
      $from_addr=$from;
      $to_addr=$to;
      $n_addr=$n;
      var $0=$from_addr;
      var $1=$to_addr;
      var $cmp=(($0)|0)==(($1)|0);
      if ($cmp) { label = 3; break; } else { label = 4; break; }
    case 3: 
      label = 8; break;
    case 4: 
      var $2=$n_addr;
      var $3=$from_addr;
      var $top=(($3+8)|0);
      var $4=HEAP32[(($top)>>2)];
      var $idx_neg=(((-$2))|0);
      var $add_ptr=(($4+((($idx_neg)*(12))&-1))|0);
      HEAP32[(($top)>>2)]=$add_ptr;
      $i=0;
      label = 5; break;
    case 5: 
      var $5=$i;
      var $6=$n_addr;
      var $cmp1=(($5)|0) < (($6)|0);
      if ($cmp1) { label = 6; break; } else { label = 8; break; }
    case 6: 
      var $7=$from_addr;
      var $top2=(($7+8)|0);
      var $8=HEAP32[(($top2)>>2)];
      var $9=$i;
      var $add_ptr3=(($8+((($9)*(12))&-1))|0);
      $io2=$add_ptr3;
      var $10=$to_addr;
      var $top4=(($10+8)|0);
      var $11=HEAP32[(($top4)>>2)];
      var $incdec_ptr=(($11+12)|0);
      HEAP32[(($top4)>>2)]=$incdec_ptr;
      $io1=$11;
      var $12=$io1;
      var $value_=(($12)|0);
      var $13=$io2;
      var $value_5=(($13)|0);
      var $14=$value_;
      var $15=$value_5;
      HEAP32[(($14)>>2)]=HEAP32[(($15)>>2)];HEAP32[((($14)+(4))>>2)]=HEAP32[((($15)+(4))>>2)];
      var $16=$io2;
      var $tt_=(($16+8)|0);
      var $17=HEAP32[(($tt_)>>2)];
      var $18=$io1;
      var $tt_6=(($18+8)|0);
      HEAP32[(($tt_6)>>2)]=$17;
      label = 7; break;
    case 7: 
      var $19=$i;
      var $inc=((($19)+(1))|0);
      $i=$inc;
      label = 5; break;
    case 8: 

      Module.print(INDENT + 'Exiting: _lua_xmove');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_lua_xmove["X"]=1;

function _lua_remove($L, $idx) {
  var label = 0;

  Module.print(INDENT + ' Entering: _lua_remove: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $L_addr;
      var $idx_addr;
      var $p;
      var $io2;
      var $io1;
      $L_addr=$L;
      $idx_addr=$idx;
      var $0=$L_addr;
      var $1=$idx_addr;
      var $call=_index2addr($0, $1);
      $p=$call;
      label = 3; break;
    case 3: 
      var $2=$p;
      var $incdec_ptr=(($2+12)|0);
      $p=$incdec_ptr;
      var $3=$L_addr;
      var $top=(($3+8)|0);
      var $4=HEAP32[(($top)>>2)];
      var $cmp=(($incdec_ptr)>>>0) < (($4)>>>0);
      if ($cmp) { label = 4; break; } else { label = 5; break; }
    case 4: 
      var $5=$p;
      $io2=$5;
      var $6=$p;
      var $add_ptr=((($6)-(12))|0);
      $io1=$add_ptr;
      var $7=$io1;
      var $value_=(($7)|0);
      var $8=$io2;
      var $value_1=(($8)|0);
      var $9=$value_;
      var $10=$value_1;
      HEAP32[(($9)>>2)]=HEAP32[(($10)>>2)];HEAP32[((($9)+(4))>>2)]=HEAP32[((($10)+(4))>>2)];
      var $11=$io2;
      var $tt_=(($11+8)|0);
      var $12=HEAP32[(($tt_)>>2)];
      var $13=$io1;
      var $tt_2=(($13+8)|0);
      HEAP32[(($tt_2)>>2)]=$12;
      label = 3; break;
    case 5: 
      var $14=$L_addr;
      var $top3=(($14+8)|0);
      var $15=HEAP32[(($top3)>>2)];
      var $incdec_ptr4=((($15)-(12))|0);
      HEAP32[(($top3)>>2)]=$incdec_ptr4;

      Module.print(INDENT + 'Exiting: _lua_remove');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _lua_insert($L, $idx) {
  var label = 0;

  Module.print(INDENT + ' Entering: _lua_insert: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $L_addr;
      var $idx_addr;
      var $p;
      var $q;
      var $io2;
      var $io1;
      var $io23;
      var $io15;
      $L_addr=$L;
      $idx_addr=$idx;
      var $0=$L_addr;
      var $1=$idx_addr;
      var $call=_index2addr($0, $1);
      $p=$call;
      var $2=$L_addr;
      var $top=(($2+8)|0);
      var $3=HEAP32[(($top)>>2)];
      $q=$3;
      label = 3; break;
    case 3: 
      var $4=$q;
      var $5=$p;
      var $cmp=(($4)>>>0) > (($5)>>>0);
      if ($cmp) { label = 4; break; } else { label = 6; break; }
    case 4: 
      var $6=$q;
      var $add_ptr=((($6)-(12))|0);
      $io2=$add_ptr;
      var $7=$q;
      $io1=$7;
      var $8=$io1;
      var $value_=(($8)|0);
      var $9=$io2;
      var $value_1=(($9)|0);
      var $10=$value_;
      var $11=$value_1;
      HEAP32[(($10)>>2)]=HEAP32[(($11)>>2)];HEAP32[((($10)+(4))>>2)]=HEAP32[((($11)+(4))>>2)];
      var $12=$io2;
      var $tt_=(($12+8)|0);
      var $13=HEAP32[(($tt_)>>2)];
      var $14=$io1;
      var $tt_2=(($14+8)|0);
      HEAP32[(($tt_2)>>2)]=$13;
      label = 5; break;
    case 5: 
      var $15=$q;
      var $incdec_ptr=((($15)-(12))|0);
      $q=$incdec_ptr;
      label = 3; break;
    case 6: 
      var $16=$L_addr;
      var $top4=(($16+8)|0);
      var $17=HEAP32[(($top4)>>2)];
      $io23=$17;
      var $18=$p;
      $io15=$18;
      var $19=$io15;
      var $value_6=(($19)|0);
      var $20=$io23;
      var $value_7=(($20)|0);
      var $21=$value_6;
      var $22=$value_7;
      HEAP32[(($21)>>2)]=HEAP32[(($22)>>2)];HEAP32[((($21)+(4))>>2)]=HEAP32[((($22)+(4))>>2)];
      var $23=$io23;
      var $tt_8=(($23+8)|0);
      var $24=HEAP32[(($tt_8)>>2)];
      var $25=$io15;
      var $tt_9=(($25+8)|0);
      HEAP32[(($tt_9)>>2)]=$24;

      Module.print(INDENT + 'Exiting: _lua_insert');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_lua_insert["X"]=1;

function _lua_replace($L, $idx) {
  var label = 0;

  Module.print(INDENT + ' Entering: _lua_replace: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';

  var $L_addr;
  var $idx_addr;
  $L_addr=$L;
  $idx_addr=$idx;
  var $0=$L_addr;
  var $1=$L_addr;
  var $top=(($1+8)|0);
  var $2=HEAP32[(($top)>>2)];
  var $add_ptr=((($2)-(12))|0);
  var $3=$idx_addr;
  _moveto($0, $add_ptr, $3);
  var $4=$L_addr;
  var $top1=(($4+8)|0);
  var $5=HEAP32[(($top1)>>2)];
  var $incdec_ptr=((($5)-(12))|0);
  HEAP32[(($top1)>>2)]=$incdec_ptr;

  Module.print(INDENT + 'Exiting: _lua_replace');
  INDENT = INDENT.substr(0, INDENT.length-2);
  return;
  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _moveto($L, $fr, $idx) {
  var label = 0;

  Module.print(INDENT + ' Entering: _moveto: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $L_addr;
      var $fr_addr;
      var $idx_addr;
      var $to;
      var $io2;
      var $io1;
      $L_addr=$L;
      $fr_addr=$fr;
      $idx_addr=$idx;
      var $0=$L_addr;
      var $1=$idx_addr;
      var $call=_index2addr($0, $1);
      $to=$call;
      var $2=$fr_addr;
      $io2=$2;
      var $3=$to;
      $io1=$3;
      var $4=$io1;
      var $value_=(($4)|0);
      var $5=$io2;
      var $value_1=(($5)|0);
      var $6=$value_;
      var $7=$value_1;
      HEAP32[(($6)>>2)]=HEAP32[(($7)>>2)];HEAP32[((($6)+(4))>>2)]=HEAP32[((($7)+(4))>>2)];
      var $8=$io2;
      var $tt_=(($8+8)|0);
      var $9=HEAP32[(($tt_)>>2)];
      var $10=$io1;
      var $tt_2=(($10+8)|0);
      HEAP32[(($tt_2)>>2)]=$9;
      var $11=$idx_addr;
      var $cmp=(($11)|0) < -1001000;
      if ($cmp) { label = 3; break; } else { label = 8; break; }
    case 3: 
      var $12=$fr_addr;
      var $tt_3=(($12+8)|0);
      var $13=HEAP32[(($tt_3)>>2)];
      var $and=$13 & 64;
      var $tobool=(($and)|0)!=0;
      if ($tobool) { label = 4; break; } else { label = 7; break; }
    case 4: 
      var $14=$fr_addr;
      var $value_4=(($14)|0);
      var $gc=$value_4;
      var $15=HEAP32[(($gc)>>2)];
      var $gch=$15;
      var $marked=(($gch+5)|0);
      var $16=HEAP8[($marked)];
      var $conv=(($16)&255);
      var $and5=$conv & 3;
      var $tobool6=(($and5)|0)!=0;
      if ($tobool6) { label = 5; break; } else { label = 7; break; }
    case 5: 
      var $17=$L_addr;
      var $ci=(($17+16)|0);
      var $18=HEAP32[(($ci)>>2)];
      var $func=(($18)|0);
      var $19=HEAP32[(($func)>>2)];
      var $value_8=(($19)|0);
      var $gc9=$value_8;
      var $20=HEAP32[(($gc9)>>2)];
      var $cl=$20;
      var $c=$cl;
      var $21=$c;
      var $gch10=$21;
      var $marked11=(($gch10+5)|0);
      var $22=HEAP8[($marked11)];
      var $conv12=(($22)&255);
      var $and13=$conv12 & 4;
      var $tobool14=(($and13)|0)!=0;
      if ($tobool14) { label = 6; break; } else { label = 7; break; }
    case 6: 
      var $23=$L_addr;
      var $24=$L_addr;
      var $ci16=(($24+16)|0);
      var $25=HEAP32[(($ci16)>>2)];
      var $func17=(($25)|0);
      var $26=HEAP32[(($func17)>>2)];
      var $value_18=(($26)|0);
      var $gc19=$value_18;
      var $27=HEAP32[(($gc19)>>2)];
      var $cl20=$27;
      var $c21=$cl20;
      var $28=$c21;
      var $29=$fr_addr;
      var $value_22=(($29)|0);
      var $gc23=$value_22;
      var $30=HEAP32[(($gc23)>>2)];
      _luaC_barrier_($23, $28, $30);
      label = 7; break;
    case 7: 
      label = 8; break;
    case 8: 

      Module.print(INDENT + 'Exiting: _moveto');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_moveto["X"]=1;

function _lua_copy($L, $fromidx, $toidx) {
  var label = 0;

  Module.print(INDENT + ' Entering: _lua_copy: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';

  var $L_addr;
  var $fromidx_addr;
  var $toidx_addr;
  var $fr;
  $L_addr=$L;
  $fromidx_addr=$fromidx;
  $toidx_addr=$toidx;
  var $0=$L_addr;
  var $1=$fromidx_addr;
  var $call=_index2addr($0, $1);
  $fr=$call;
  var $2=$L_addr;
  var $3=$fr;
  var $4=$toidx_addr;
  _moveto($2, $3, $4);

  Module.print(INDENT + 'Exiting: _lua_copy');
  INDENT = INDENT.substr(0, INDENT.length-2);
  return;
  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _lua_pushvalue($L, $idx) {
  var label = 0;

  Module.print(INDENT + ' Entering: _lua_pushvalue: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';

  var $L_addr;
  var $idx_addr;
  var $io2;
  var $io1;
  $L_addr=$L;
  $idx_addr=$idx;
  var $0=$L_addr;
  var $1=$idx_addr;
  var $call=_index2addr($0, $1);
  $io2=$call;
  var $2=$L_addr;
  var $top=(($2+8)|0);
  var $3=HEAP32[(($top)>>2)];
  $io1=$3;
  var $4=$io1;
  var $value_=(($4)|0);
  var $5=$io2;
  var $value_1=(($5)|0);
  var $6=$value_;
  var $7=$value_1;
  HEAP32[(($6)>>2)]=HEAP32[(($7)>>2)];HEAP32[((($6)+(4))>>2)]=HEAP32[((($7)+(4))>>2)];
  var $8=$io2;
  var $tt_=(($8+8)|0);
  var $9=HEAP32[(($tt_)>>2)];
  var $10=$io1;
  var $tt_2=(($10+8)|0);
  HEAP32[(($tt_2)>>2)]=$9;
  var $11=$L_addr;
  var $top3=(($11+8)|0);
  var $12=HEAP32[(($top3)>>2)];
  var $incdec_ptr=(($12+12)|0);
  HEAP32[(($top3)>>2)]=$incdec_ptr;

  Module.print(INDENT + 'Exiting: _lua_pushvalue');
  INDENT = INDENT.substr(0, INDENT.length-2);
  return;
  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _lua_type($L, $idx) {
  var label = 0;

  Module.print(INDENT + ' Entering: _lua_type: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $L_addr;
      var $idx_addr;
      var $o;
      $L_addr=$L;
      $idx_addr=$idx;
      var $0=$L_addr;
      var $1=$idx_addr;
      var $call=_index2addr($0, $1);
      $o=$call;
      var $2=$o;
      var $cmp=(($2)|0)!=5243784;
      if ($cmp) { label = 3; break; } else { label = 4; break; }
    case 3: 
      var $3=$o;
      var $tt_=(($3+8)|0);
      var $4=HEAP32[(($tt_)>>2)];
      var $and=$4 & 15;
      var $cond = $and;label = 5; break;
    case 4: 
      var $cond = -1;label = 5; break;
    case 5: 
      var $cond;

      Module.print(INDENT + 'Exiting: _lua_type');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return $cond;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _lua_iscfunction($L, $idx) {
  var label = 0;

  Module.print(INDENT + ' Entering: _lua_iscfunction: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $L_addr;
      var $idx_addr;
      var $o;
      $L_addr=$L;
      $idx_addr=$idx;
      var $0=$L_addr;
      var $1=$idx_addr;
      var $call=_index2addr($0, $1);
      $o=$call;
      var $2=$o;
      var $tt_=(($2+8)|0);
      var $3=HEAP32[(($tt_)>>2)];
      var $cmp=(($3)|0)==22;
      if ($cmp) { var $6 = 1;label = 4; break; } else { label = 3; break; }
    case 3: 
      var $4=$o;
      var $tt_1=(($4+8)|0);
      var $5=HEAP32[(($tt_1)>>2)];
      var $cmp2=(($5)|0)==102;
      var $6 = $cmp2;label = 4; break;
    case 4: 
      var $6;
      var $lor_ext=(($6)&1);

      Module.print(INDENT + 'Exiting: _lua_iscfunction');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return $lor_ext;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _lua_isnumber($L, $idx) {
  var label = 0;
  var __stackBase__  = STACKTOP; STACKTOP = (STACKTOP + 12)|0; _memset(__stackBase__, 0, 12);
  Module.print(INDENT + ' Entering: _lua_isnumber: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $L_addr;
      var $idx_addr;
      var $n=__stackBase__;
      var $o;
      $L_addr=$L;
      $idx_addr=$idx;
      var $0=$L_addr;
      var $1=$idx_addr;
      var $call=_index2addr($0, $1);
      $o=$call;
      var $2=$o;
      var $tt_=(($2+8)|0);
      var $3=HEAP32[(($tt_)>>2)];
      var $cmp=(($3)|0)==3;
      if ($cmp) { var $5 = 1;label = 4; break; } else { label = 3; break; }
    case 3: 
      var $4=$o;
      var $call1=_luaV_tonumber($4, $n);
      $o=$call1;
      var $cmp2=(($call1)|0)!=0;
      var $5 = $cmp2;label = 4; break;
    case 4: 
      var $5;
      var $lor_ext=(($5)&1);
      STACKTOP = __stackBase__;
      Module.print(INDENT + 'Exiting: _lua_isnumber');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return $lor_ext;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _lua_isstring($L, $idx) {
  var label = 0;

  Module.print(INDENT + ' Entering: _lua_isstring: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $L_addr;
      var $idx_addr;
      var $t;
      $L_addr=$L;
      $idx_addr=$idx;
      var $0=$L_addr;
      var $1=$idx_addr;
      var $call=_lua_type($0, $1);
      $t=$call;
      var $2=$t;
      var $cmp=(($2)|0)==4;
      if ($cmp) { var $4 = 1;label = 4; break; } else { label = 3; break; }
    case 3: 
      var $3=$t;
      var $cmp1=(($3)|0)==3;
      var $4 = $cmp1;label = 4; break;
    case 4: 
      var $4;
      var $lor_ext=(($4)&1);

      Module.print(INDENT + 'Exiting: _lua_isstring');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return $lor_ext;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _lua_isuserdata($L, $idx) {
  var label = 0;

  Module.print(INDENT + ' Entering: _lua_isuserdata: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $L_addr;
      var $idx_addr;
      var $o;
      $L_addr=$L;
      $idx_addr=$idx;
      var $0=$L_addr;
      var $1=$idx_addr;
      var $call=_index2addr($0, $1);
      $o=$call;
      var $2=$o;
      var $tt_=(($2+8)|0);
      var $3=HEAP32[(($tt_)>>2)];
      var $cmp=(($3)|0)==71;
      if ($cmp) { var $6 = 1;label = 4; break; } else { label = 3; break; }
    case 3: 
      var $4=$o;
      var $tt_1=(($4+8)|0);
      var $5=HEAP32[(($tt_1)>>2)];
      var $cmp2=(($5)|0)==2;
      var $6 = $cmp2;label = 4; break;
    case 4: 
      var $6;
      var $lor_ext=(($6)&1);

      Module.print(INDENT + 'Exiting: _lua_isuserdata');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return $lor_ext;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _lua_rawequal($L, $index1, $index2) {
  var label = 0;

  Module.print(INDENT + ' Entering: _lua_rawequal: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $L_addr;
      var $index1_addr;
      var $index2_addr;
      var $o1;
      var $o2;
      $L_addr=$L;
      $index1_addr=$index1;
      $index2_addr=$index2;
      var $0=$L_addr;
      var $1=$index1_addr;
      var $call=_index2addr($0, $1);
      $o1=$call;
      var $2=$L_addr;
      var $3=$index2_addr;
      var $call1=_index2addr($2, $3);
      $o2=$call1;
      var $4=$o1;
      var $cmp=(($4)|0)!=5243784;
      if ($cmp) { label = 3; break; } else { label = 7; break; }
    case 3: 
      var $5=$o2;
      var $cmp2=(($5)|0)!=5243784;
      if ($cmp2) { label = 4; break; } else { label = 7; break; }
    case 4: 
      var $6=$o1;
      var $tt_=(($6+8)|0);
      var $7=HEAP32[(($tt_)>>2)];
      var $8=$o2;
      var $tt_3=(($8+8)|0);
      var $9=HEAP32[(($tt_3)>>2)];
      var $cmp4=(($7)|0)==(($9)|0);
      if ($cmp4) { label = 5; break; } else { var $12 = 0;label = 6; break; }
    case 5: 
      var $10=$o1;
      var $11=$o2;
      var $call5=_luaV_equalobj_(0, $10, $11);
      var $tobool=(($call5)|0)!=0;
      var $12 = $tobool;label = 6; break;
    case 6: 
      var $12;
      var $land_ext=(($12)&1);
      var $cond = $land_ext;label = 8; break;
    case 7: 
      var $cond = 0;label = 8; break;
    case 8: 
      var $cond;

      Module.print(INDENT + 'Exiting: _lua_rawequal');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return $cond;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _lua_pushnil($L) {
  var label = 0;

  Module.print(INDENT + ' Entering: _lua_pushnil: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';

  var $L_addr;
  $L_addr=$L;
  var $0=$L_addr;
  var $top=(($0+8)|0);
  var $1=HEAP32[(($top)>>2)];
  var $tt_=(($1+8)|0);
  HEAP32[(($tt_)>>2)]=0;
  var $2=$L_addr;
  var $top1=(($2+8)|0);
  var $3=HEAP32[(($top1)>>2)];
  var $incdec_ptr=(($3+12)|0);
  HEAP32[(($top1)>>2)]=$incdec_ptr;

  Module.print(INDENT + 'Exiting: _lua_pushnil');
  INDENT = INDENT.substr(0, INDENT.length-2);
  return;
  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _lua_pushnumber($L, $n) {
  var label = 0;

  Module.print(INDENT + ' Entering: _lua_pushnumber: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';

  var $L_addr;
  var $n_addr;
  var $io;
  $L_addr=$L;
  $n_addr=$n;
  var $0=$L_addr;
  var $top=(($0+8)|0);
  var $1=HEAP32[(($top)>>2)];
  $io=$1;
  var $2=$n_addr;
  var $3=$io;
  var $value_=(($3)|0);
  var $n1=$value_;
  (HEAPF64[(tempDoublePtr)>>3]=$2,HEAP32[(($n1)>>2)]=HEAP32[((tempDoublePtr)>>2)],HEAP32[((($n1)+(4))>>2)]=HEAP32[(((tempDoublePtr)+(4))>>2)]);
  var $4=$io;
  var $tt_=(($4+8)|0);
  HEAP32[(($tt_)>>2)]=3;
  var $5=$L_addr;
  var $top2=(($5+8)|0);
  var $6=HEAP32[(($top2)>>2)];
  var $incdec_ptr=(($6+12)|0);
  HEAP32[(($top2)>>2)]=$incdec_ptr;

  Module.print(INDENT + 'Exiting: _lua_pushnumber');
  INDENT = INDENT.substr(0, INDENT.length-2);
  return;
  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _lua_pushinteger($L, $n) {
  var label = 0;

  Module.print(INDENT + ' Entering: _lua_pushinteger: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';

  var $L_addr;
  var $n_addr;
  var $io;
  $L_addr=$L;
  $n_addr=$n;
  var $0=$L_addr;
  var $top=(($0+8)|0);
  var $1=HEAP32[(($top)>>2)];
  $io=$1;
  var $2=$n_addr;
  var $conv=(($2)|0);
  var $3=$io;
  var $value_=(($3)|0);
  var $n1=$value_;
  (HEAPF64[(tempDoublePtr)>>3]=$conv,HEAP32[(($n1)>>2)]=HEAP32[((tempDoublePtr)>>2)],HEAP32[((($n1)+(4))>>2)]=HEAP32[(((tempDoublePtr)+(4))>>2)]);
  var $4=$io;
  var $tt_=(($4+8)|0);
  HEAP32[(($tt_)>>2)]=3;
  var $5=$L_addr;
  var $top2=(($5+8)|0);
  var $6=HEAP32[(($top2)>>2)];
  var $incdec_ptr=(($6+12)|0);
  HEAP32[(($top2)>>2)]=$incdec_ptr;

  Module.print(INDENT + 'Exiting: _lua_pushinteger');
  INDENT = INDENT.substr(0, INDENT.length-2);
  return;
  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _lua_pushunsigned($L, $u) {
  var label = 0;

  Module.print(INDENT + ' Entering: _lua_pushunsigned: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $L_addr;
      var $u_addr;
      var $n;
      var $io;
      $L_addr=$L;
      $u_addr=$u;
      var $0=$u_addr;
      var $cmp=(($0)>>>0) <= 2147483647;
      if ($cmp) { label = 3; break; } else { label = 4; break; }
    case 3: 
      var $1=$u_addr;
      var $conv=(($1)|0);
      var $cond = $conv;label = 5; break;
    case 4: 
      var $2=$u_addr;
      var $conv1=(($2)>>>0);
      var $cond = $conv1;label = 5; break;
    case 5: 
      var $cond;
      $n=$cond;
      var $3=$L_addr;
      var $top=(($3+8)|0);
      var $4=HEAP32[(($top)>>2)];
      $io=$4;
      var $5=$n;
      var $6=$io;
      var $value_=(($6)|0);
      var $n2=$value_;
      (HEAPF64[(tempDoublePtr)>>3]=$5,HEAP32[(($n2)>>2)]=HEAP32[((tempDoublePtr)>>2)],HEAP32[((($n2)+(4))>>2)]=HEAP32[(((tempDoublePtr)+(4))>>2)]);
      var $7=$io;
      var $tt_=(($7+8)|0);
      HEAP32[(($tt_)>>2)]=3;
      var $8=$L_addr;
      var $top3=(($8+8)|0);
      var $9=HEAP32[(($top3)>>2)];
      var $incdec_ptr=(($9+12)|0);
      HEAP32[(($top3)>>2)]=$incdec_ptr;

      Module.print(INDENT + 'Exiting: _lua_pushunsigned');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _lua_arith($L, $op) {
  var label = 0;

  Module.print(INDENT + ' Entering: _lua_arith: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $L_addr;
      var $op_addr;
      var $o1;
      var $o2;
      var $io2;
      var $io1;
      $L_addr=$L;
      $op_addr=$op;
      var $0=$op_addr;
      var $cmp=(($0)|0)!=6;
      if ($cmp) { label = 3; break; } else { label = 4; break; }
    case 3: 
      label = 5; break;
    case 4: 
      var $1=$L_addr;
      var $top=(($1+8)|0);
      var $2=HEAP32[(($top)>>2)];
      var $add_ptr=((($2)-(12))|0);
      $io2=$add_ptr;
      var $3=$L_addr;
      var $top1=(($3+8)|0);
      var $4=HEAP32[(($top1)>>2)];
      $io1=$4;
      var $5=$io1;
      var $value_=(($5)|0);
      var $6=$io2;
      var $value_2=(($6)|0);
      var $7=$value_;
      var $8=$value_2;
      HEAP32[(($7)>>2)]=HEAP32[(($8)>>2)];HEAP32[((($7)+(4))>>2)]=HEAP32[((($8)+(4))>>2)];
      var $9=$io2;
      var $tt_=(($9+8)|0);
      var $10=HEAP32[(($tt_)>>2)];
      var $11=$io1;
      var $tt_3=(($11+8)|0);
      HEAP32[(($tt_3)>>2)]=$10;
      var $12=$L_addr;
      var $top4=(($12+8)|0);
      var $13=HEAP32[(($top4)>>2)];
      var $incdec_ptr=(($13+12)|0);
      HEAP32[(($top4)>>2)]=$incdec_ptr;
      label = 5; break;
    case 5: 
      var $14=$L_addr;
      var $top5=(($14+8)|0);
      var $15=HEAP32[(($top5)>>2)];
      var $add_ptr6=((($15)-(24))|0);
      $o1=$add_ptr6;
      var $16=$L_addr;
      var $top7=(($16+8)|0);
      var $17=HEAP32[(($top7)>>2)];
      var $add_ptr8=((($17)-(12))|0);
      $o2=$add_ptr8;
      var $18=$o1;
      var $tt_9=(($18+8)|0);
      var $19=HEAP32[(($tt_9)>>2)];
      var $cmp10=(($19)|0)==3;
      if ($cmp10) { label = 6; break; } else { label = 8; break; }
    case 6: 
      var $20=$o2;
      var $tt_11=(($20+8)|0);
      var $21=HEAP32[(($tt_11)>>2)];
      var $cmp12=(($21)|0)==3;
      if ($cmp12) { label = 7; break; } else { label = 8; break; }
    case 7: 
      var $22=$op_addr;
      var $23=$o1;
      var $value_14=(($23)|0);
      var $n=$value_14;
      var $24=(HEAP32[((tempDoublePtr)>>2)]=HEAP32[(($n)>>2)],HEAP32[(((tempDoublePtr)+(4))>>2)]=HEAP32[((($n)+(4))>>2)],HEAPF64[(tempDoublePtr)>>3]);
      var $25=$o2;
      var $value_15=(($25)|0);
      var $n16=$value_15;
      var $26=(HEAP32[((tempDoublePtr)>>2)]=HEAP32[(($n16)>>2)],HEAP32[(((tempDoublePtr)+(4))>>2)]=HEAP32[((($n16)+(4))>>2)],HEAPF64[(tempDoublePtr)>>3]);
      var $call=_luaO_arith($22, $24, $26);
      var $27=$o1;
      var $value_17=(($27)|0);
      var $n18=$value_17;
      (HEAPF64[(tempDoublePtr)>>3]=$call,HEAP32[(($n18)>>2)]=HEAP32[((tempDoublePtr)>>2)],HEAP32[((($n18)+(4))>>2)]=HEAP32[(((tempDoublePtr)+(4))>>2)]);
      label = 9; break;
    case 8: 
      var $28=$L_addr;
      var $29=$o1;
      var $30=$o1;
      var $31=$o2;
      var $32=$op_addr;
      var $sub=(($32)|0);
      var $add=((($sub)+(6))|0);
      _luaV_arith($28, $29, $30, $31, $add);
      label = 9; break;
    case 9: 
      var $33=$L_addr;
      var $top21=(($33+8)|0);
      var $34=HEAP32[(($top21)>>2)];
      var $incdec_ptr22=((($34)-(12))|0);
      HEAP32[(($top21)>>2)]=$incdec_ptr22;

      Module.print(INDENT + 'Exiting: _lua_arith');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_lua_arith["X"]=1;

function _lua_compare($L, $index1, $index2, $op) {
  var label = 0;

  Module.print(INDENT + ' Entering: _lua_compare: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $L_addr;
      var $index1_addr;
      var $index2_addr;
      var $op_addr;
      var $o1;
      var $o2;
      var $i;
      $L_addr=$L;
      $index1_addr=$index1;
      $index2_addr=$index2;
      $op_addr=$op;
      $i=0;
      var $0=$L_addr;
      var $1=$index1_addr;
      var $call=_index2addr($0, $1);
      $o1=$call;
      var $2=$L_addr;
      var $3=$index2_addr;
      var $call1=_index2addr($2, $3);
      $o2=$call1;
      var $4=$o1;
      var $cmp=(($4)|0)!=5243784;
      if ($cmp) { label = 3; break; } else { label = 12; break; }
    case 3: 
      var $5=$o2;
      var $cmp2=(($5)|0)!=5243784;
      if ($cmp2) { label = 4; break; } else { label = 12; break; }
    case 4: 
      var $6=$op_addr;
      if ((($6)|0)==0) {
        label = 5; break;
      }
      else if ((($6)|0)==1) {
        label = 8; break;
      }
      else if ((($6)|0)==2) {
        label = 9; break;
      }
      else {
      label = 10; break;
      }
      
    case 5: 
      var $7=$o1;
      var $tt_=(($7+8)|0);
      var $8=HEAP32[(($tt_)>>2)];
      var $9=$o2;
      var $tt_3=(($9+8)|0);
      var $10=HEAP32[(($tt_3)>>2)];
      var $cmp4=(($8)|0)==(($10)|0);
      if ($cmp4) { label = 6; break; } else { var $14 = 0;label = 7; break; }
    case 6: 
      var $11=$L_addr;
      var $12=$o1;
      var $13=$o2;
      var $call5=_luaV_equalobj_($11, $12, $13);
      var $tobool=(($call5)|0)!=0;
      var $14 = $tobool;label = 7; break;
    case 7: 
      var $14;
      var $land_ext=(($14)&1);
      $i=$land_ext;
      label = 11; break;
    case 8: 
      var $15=$L_addr;
      var $16=$o1;
      var $17=$o2;
      var $call7=_luaV_lessthan($15, $16, $17);
      $i=$call7;
      label = 11; break;
    case 9: 
      var $18=$L_addr;
      var $19=$o1;
      var $20=$o2;
      var $call9=_luaV_lessequal($18, $19, $20);
      $i=$call9;
      label = 11; break;
    case 10: 
      label = 11; break;
    case 11: 
      label = 12; break;
    case 12: 
      var $21=$i;

      Module.print(INDENT + 'Exiting: _lua_compare');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return $21;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_lua_compare["X"]=1;

function _lua_tonumberx($L, $idx, $isnum) {
  var label = 0;
  var __stackBase__  = STACKTOP; STACKTOP = (STACKTOP + 12)|0; _memset(__stackBase__, 0, 12);
  Module.print(INDENT + ' Entering: _lua_tonumberx: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $retval;
      var $L_addr;
      var $idx_addr;
      var $isnum_addr;
      var $n=__stackBase__;
      var $o;
      $L_addr=$L;
      $idx_addr=$idx;
      $isnum_addr=$isnum;
      var $0=$L_addr;
      var $1=$idx_addr;
      var $call=_index2addr($0, $1);
      $o=$call;
      var $2=$o;
      var $tt_=(($2+8)|0);
      var $3=HEAP32[(($tt_)>>2)];
      var $cmp=(($3)|0)==3;
      if ($cmp) { label = 4; break; } else { label = 3; break; }
    case 3: 
      var $4=$o;
      var $call1=_luaV_tonumber($4, $n);
      $o=$call1;
      var $cmp2=(($call1)|0)!=0;
      if ($cmp2) { label = 4; break; } else { label = 7; break; }
    case 4: 
      var $5=$isnum_addr;
      var $tobool=(($5)|0)!=0;
      if ($tobool) { label = 5; break; } else { label = 6; break; }
    case 5: 
      var $6=$isnum_addr;
      HEAP32[(($6)>>2)]=1;
      label = 6; break;
    case 6: 
      var $7=$o;
      var $value_=(($7)|0);
      var $n4=$value_;
      var $8=(HEAP32[((tempDoublePtr)>>2)]=HEAP32[(($n4)>>2)],HEAP32[(((tempDoublePtr)+(4))>>2)]=HEAP32[((($n4)+(4))>>2)],HEAPF64[(tempDoublePtr)>>3]);
      $retval=$8;
      label = 10; break;
    case 7: 
      var $9=$isnum_addr;
      var $tobool5=(($9)|0)!=0;
      if ($tobool5) { label = 8; break; } else { label = 9; break; }
    case 8: 
      var $10=$isnum_addr;
      HEAP32[(($10)>>2)]=0;
      label = 9; break;
    case 9: 
      $retval=0;
      label = 10; break;
    case 10: 
      var $11=$retval;
      STACKTOP = __stackBase__;
      Module.print(INDENT + 'Exiting: _lua_tonumberx');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return $11;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _lua_tointegerx($L, $idx, $isnum) {
  var label = 0;
  var __stackBase__  = STACKTOP; STACKTOP = (STACKTOP + 12)|0; _memset(__stackBase__, 0, 12);
  Module.print(INDENT + ' Entering: _lua_tointegerx: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $retval;
      var $L_addr;
      var $idx_addr;
      var $isnum_addr;
      var $n=__stackBase__;
      var $o;
      var $res;
      var $num;
      $L_addr=$L;
      $idx_addr=$idx;
      $isnum_addr=$isnum;
      var $0=$L_addr;
      var $1=$idx_addr;
      var $call=_index2addr($0, $1);
      $o=$call;
      var $2=$o;
      var $tt_=(($2+8)|0);
      var $3=HEAP32[(($tt_)>>2)];
      var $cmp=(($3)|0)==3;
      if ($cmp) { label = 4; break; } else { label = 3; break; }
    case 3: 
      var $4=$o;
      var $call1=_luaV_tonumber($4, $n);
      $o=$call1;
      var $cmp2=(($call1)|0)!=0;
      if ($cmp2) { label = 4; break; } else { label = 7; break; }
    case 4: 
      var $5=$o;
      var $value_=(($5)|0);
      var $n3=$value_;
      var $6=(HEAP32[((tempDoublePtr)>>2)]=HEAP32[(($n3)>>2)],HEAP32[(((tempDoublePtr)+(4))>>2)]=HEAP32[((($n3)+(4))>>2)],HEAPF64[(tempDoublePtr)>>3]);
      $num=$6;
      var $7=$num;
      var $conv=(($7)&-1);
      $res=$conv;
      var $8=$isnum_addr;
      var $tobool=(($8)|0)!=0;
      if ($tobool) { label = 5; break; } else { label = 6; break; }
    case 5: 
      var $9=$isnum_addr;
      HEAP32[(($9)>>2)]=1;
      label = 6; break;
    case 6: 
      var $10=$res;
      $retval=$10;
      label = 10; break;
    case 7: 
      var $11=$isnum_addr;
      var $tobool5=(($11)|0)!=0;
      if ($tobool5) { label = 8; break; } else { label = 9; break; }
    case 8: 
      var $12=$isnum_addr;
      HEAP32[(($12)>>2)]=0;
      label = 9; break;
    case 9: 
      $retval=0;
      label = 10; break;
    case 10: 
      var $13=$retval;
      STACKTOP = __stackBase__;
      Module.print(INDENT + 'Exiting: _lua_tointegerx');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return $13;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_lua_tointegerx["X"]=1;

function _lua_tounsignedx($L, $idx, $isnum) {
  var label = 0;
  var __stackBase__  = STACKTOP; STACKTOP = (STACKTOP + 20)|0; _memset(__stackBase__, 0, 20);
  Module.print(INDENT + ' Entering: _lua_tounsignedx: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $retval;
      var $L_addr;
      var $idx_addr;
      var $isnum_addr;
      var $n=__stackBase__;
      var $o;
      var $res;
      var $num;
      var $u=(__stackBase__)+(12);
      $L_addr=$L;
      $idx_addr=$idx;
      $isnum_addr=$isnum;
      var $0=$L_addr;
      var $1=$idx_addr;
      var $call=_index2addr($0, $1);
      $o=$call;
      var $2=$o;
      var $tt_=(($2+8)|0);
      var $3=HEAP32[(($tt_)>>2)];
      var $cmp=(($3)|0)==3;
      if ($cmp) { label = 4; break; } else { label = 3; break; }
    case 3: 
      var $4=$o;
      var $call1=_luaV_tonumber($4, $n);
      $o=$call1;
      var $cmp2=(($call1)|0)!=0;
      if ($cmp2) { label = 4; break; } else { label = 7; break; }
    case 4: 
      var $5=$o;
      var $value_=(($5)|0);
      var $n3=$value_;
      var $6=(HEAP32[((tempDoublePtr)>>2)]=HEAP32[(($n3)>>2)],HEAP32[(((tempDoublePtr)+(4))>>2)]=HEAP32[((($n3)+(4))>>2)],HEAPF64[(tempDoublePtr)>>3]);
      $num=$6;
      var $7=$num;
      var $add=($7)+(6755399441055744);
      var $l_d=$u;
      (HEAPF64[(tempDoublePtr)>>3]=$add,HEAP32[(($l_d)>>2)]=HEAP32[((tempDoublePtr)>>2)],HEAP32[((($l_d)+(4))>>2)]=HEAP32[(((tempDoublePtr)+(4))>>2)]);
      var $8=HEAP32[((((5243196)|0))>>2)];
      var $cmp4=(($8)|0)==33;
      var $conv=(($cmp4)&1);
      var $l_p=$u;
      var $arrayidx=(($l_p+($conv<<2))|0);
      var $9=HEAP32[(($arrayidx)>>2)];
      $res=$9;
      var $10=$isnum_addr;
      var $tobool=(($10)|0)!=0;
      if ($tobool) { label = 5; break; } else { label = 6; break; }
    case 5: 
      var $11=$isnum_addr;
      HEAP32[(($11)>>2)]=1;
      label = 6; break;
    case 6: 
      var $12=$res;
      $retval=$12;
      label = 10; break;
    case 7: 
      var $13=$isnum_addr;
      var $tobool6=(($13)|0)!=0;
      if ($tobool6) { label = 8; break; } else { label = 9; break; }
    case 8: 
      var $14=$isnum_addr;
      HEAP32[(($14)>>2)]=0;
      label = 9; break;
    case 9: 
      $retval=0;
      label = 10; break;
    case 10: 
      var $15=$retval;
      STACKTOP = __stackBase__;
      Module.print(INDENT + 'Exiting: _lua_tounsignedx');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return $15;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_lua_tounsignedx["X"]=1;

function _lua_toboolean($L, $idx) {
  var label = 0;

  Module.print(INDENT + ' Entering: _lua_toboolean: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $L_addr;
      var $idx_addr;
      var $o;
      $L_addr=$L;
      $idx_addr=$idx;
      var $0=$L_addr;
      var $1=$idx_addr;
      var $call=_index2addr($0, $1);
      $o=$call;
      var $2=$o;
      var $tt_=(($2+8)|0);
      var $3=HEAP32[(($tt_)>>2)];
      var $cmp=(($3)|0)==0;
      if ($cmp) { var $9 = 1;label = 6; break; } else { label = 3; break; }
    case 3: 
      var $4=$o;
      var $tt_1=(($4+8)|0);
      var $5=HEAP32[(($tt_1)>>2)];
      var $cmp2=(($5)|0)==1;
      if ($cmp2) { label = 4; break; } else { var $8 = 0;label = 5; break; }
    case 4: 
      var $6=$o;
      var $value_=(($6)|0);
      var $b=$value_;
      var $7=HEAP32[(($b)>>2)];
      var $cmp3=(($7)|0)==0;
      var $8 = $cmp3;label = 5; break;
    case 5: 
      var $8;
      var $9 = $8;label = 6; break;
    case 6: 
      var $9;
      var $lnot=$9 ^ 1;
      var $lnot_ext=(($lnot)&1);

      Module.print(INDENT + 'Exiting: _lua_toboolean');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return $lnot_ext;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _lua_tolstring($L, $idx, $len) {
  var label = 0;

  Module.print(INDENT + ' Entering: _lua_tolstring: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $retval;
      var $L_addr;
      var $idx_addr;
      var $len_addr;
      var $o;
      $L_addr=$L;
      $idx_addr=$idx;
      $len_addr=$len;
      var $0=$L_addr;
      var $1=$idx_addr;
      var $call=_index2addr($0, $1);
      $o=$call;
      var $2=$o;
      var $tt_=(($2+8)|0);
      var $3=HEAP32[(($tt_)>>2)];
      var $and=$3 & 15;
      var $cmp=(($and)|0)==4;
      if ($cmp) { label = 10; break; } else { label = 3; break; }
    case 3: 
      var $4=$L_addr;
      var $5=$o;
      var $call1=_luaV_tostring($4, $5);
      var $tobool=(($call1)|0)!=0;
      if ($tobool) { label = 7; break; } else { label = 4; break; }
    case 4: 
      var $6=$len_addr;
      var $cmp3=(($6)|0)!=0;
      if ($cmp3) { label = 5; break; } else { label = 6; break; }
    case 5: 
      var $7=$len_addr;
      HEAP32[(($7)>>2)]=0;
      label = 6; break;
    case 6: 
      $retval=0;
      label = 13; break;
    case 7: 
      var $8=$L_addr;
      var $l_G=(($8+12)|0);
      var $9=HEAP32[(($l_G)>>2)];
      var $GCdebt=(($9+12)|0);
      var $10=HEAP32[(($GCdebt)>>2)];
      var $cmp6=(($10)|0) > 0;
      if ($cmp6) { label = 8; break; } else { label = 9; break; }
    case 8: 
      var $11=$L_addr;
      _luaC_step($11);
      label = 9; break;
    case 9: 
      var $12=$L_addr;
      var $13=$idx_addr;
      var $call9=_index2addr($12, $13);
      $o=$call9;
      label = 10; break;
    case 10: 
      var $14=$len_addr;
      var $cmp11=(($14)|0)!=0;
      if ($cmp11) { label = 11; break; } else { label = 12; break; }
    case 11: 
      var $15=$o;
      var $value_=(($15)|0);
      var $gc=$value_;
      var $16=HEAP32[(($gc)>>2)];
      var $ts=$16;
      var $tsv=$ts;
      var $len13=(($tsv+12)|0);
      var $17=HEAP32[(($len13)>>2)];
      var $18=$len_addr;
      HEAP32[(($18)>>2)]=$17;
      label = 12; break;
    case 12: 
      var $19=$o;
      var $value_15=(($19)|0);
      var $gc16=$value_15;
      var $20=HEAP32[(($gc16)>>2)];
      var $ts17=$20;
      var $add_ptr=(($ts17+16)|0);
      var $21=$add_ptr;
      $retval=$21;
      label = 13; break;
    case 13: 
      var $22=$retval;

      Module.print(INDENT + 'Exiting: _lua_tolstring');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return $22;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_lua_tolstring["X"]=1;

function _lua_rawlen($L, $idx) {
  var label = 0;

  Module.print(INDENT + ' Entering: _lua_rawlen: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $retval;
      var $L_addr;
      var $idx_addr;
      var $o;
      $L_addr=$L;
      $idx_addr=$idx;
      var $0=$L_addr;
      var $1=$idx_addr;
      var $call=_index2addr($0, $1);
      $o=$call;
      var $2=$o;
      var $tt_=(($2+8)|0);
      var $3=HEAP32[(($tt_)>>2)];
      var $and=$3 & 15;
      if ((($and)|0)==4) {
        label = 3; break;
      }
      else if ((($and)|0)==7) {
        label = 4; break;
      }
      else if ((($and)|0)==5) {
        label = 5; break;
      }
      else {
      label = 6; break;
      }
      
    case 3: 
      var $4=$o;
      var $value_=(($4)|0);
      var $gc=$value_;
      var $5=HEAP32[(($gc)>>2)];
      var $ts=$5;
      var $tsv=$ts;
      var $len=(($tsv+12)|0);
      var $6=HEAP32[(($len)>>2)];
      $retval=$6;
      label = 7; break;
    case 4: 
      var $7=$o;
      var $value_2=(($7)|0);
      var $gc3=$value_2;
      var $8=HEAP32[(($gc3)>>2)];
      var $u=$8;
      var $uv=$u;
      var $len4=(($uv+16)|0);
      var $9=HEAP32[(($len4)>>2)];
      $retval=$9;
      label = 7; break;
    case 5: 
      var $10=$o;
      var $value_6=(($10)|0);
      var $gc7=$value_6;
      var $11=HEAP32[(($gc7)>>2)];
      var $h=$11;
      var $call8=_luaH_getn($h);
      $retval=$call8;
      label = 7; break;
    case 6: 
      $retval=0;
      label = 7; break;
    case 7: 
      var $12=$retval;

      Module.print(INDENT + 'Exiting: _lua_rawlen');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return $12;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _lua_tocfunction($L, $idx) {
  var label = 0;

  Module.print(INDENT + ' Entering: _lua_tocfunction: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $retval;
      var $L_addr;
      var $idx_addr;
      var $o;
      $L_addr=$L;
      $idx_addr=$idx;
      var $0=$L_addr;
      var $1=$idx_addr;
      var $call=_index2addr($0, $1);
      $o=$call;
      var $2=$o;
      var $tt_=(($2+8)|0);
      var $3=HEAP32[(($tt_)>>2)];
      var $cmp=(($3)|0)==22;
      if ($cmp) { label = 3; break; } else { label = 4; break; }
    case 3: 
      var $4=$o;
      var $value_=(($4)|0);
      var $f=$value_;
      var $5=HEAP32[(($f)>>2)];
      $retval=$5;
      label = 7; break;
    case 4: 
      var $6=$o;
      var $tt_1=(($6+8)|0);
      var $7=HEAP32[(($tt_1)>>2)];
      var $cmp2=(($7)|0)==102;
      if ($cmp2) { label = 5; break; } else { label = 6; break; }
    case 5: 
      var $8=$o;
      var $value_4=(($8)|0);
      var $gc=$value_4;
      var $9=HEAP32[(($gc)>>2)];
      var $cl=$9;
      var $c=$cl;
      var $f5=(($c+12)|0);
      var $10=HEAP32[(($f5)>>2)];
      $retval=$10;
      label = 7; break;
    case 6: 
      $retval=0;
      label = 7; break;
    case 7: 
      var $11=$retval;

      Module.print(INDENT + 'Exiting: _lua_tocfunction');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return $11;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _lua_touserdata($L, $idx) {
  var label = 0;

  Module.print(INDENT + ' Entering: _lua_touserdata: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $retval;
      var $L_addr;
      var $idx_addr;
      var $o;
      $L_addr=$L;
      $idx_addr=$idx;
      var $0=$L_addr;
      var $1=$idx_addr;
      var $call=_index2addr($0, $1);
      $o=$call;
      var $2=$o;
      var $tt_=(($2+8)|0);
      var $3=HEAP32[(($tt_)>>2)];
      var $and=$3 & 15;
      if ((($and)|0)==7) {
        label = 3; break;
      }
      else if ((($and)|0)==2) {
        label = 4; break;
      }
      else {
      label = 5; break;
      }
      
    case 3: 
      var $4=$o;
      var $value_=(($4)|0);
      var $gc=$value_;
      var $5=HEAP32[(($gc)>>2)];
      var $u=$5;
      var $add_ptr=(($u+20)|0);
      var $6=$add_ptr;
      $retval=$6;
      label = 6; break;
    case 4: 
      var $7=$o;
      var $value_2=(($7)|0);
      var $p=$value_2;
      var $8=HEAP32[(($p)>>2)];
      $retval=$8;
      label = 6; break;
    case 5: 
      $retval=0;
      label = 6; break;
    case 6: 
      var $9=$retval;

      Module.print(INDENT + 'Exiting: _lua_touserdata');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return $9;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _lua_tothread($L, $idx) {
  var label = 0;

  Module.print(INDENT + ' Entering: _lua_tothread: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $L_addr;
      var $idx_addr;
      var $o;
      $L_addr=$L;
      $idx_addr=$idx;
      var $0=$L_addr;
      var $1=$idx_addr;
      var $call=_index2addr($0, $1);
      $o=$call;
      var $2=$o;
      var $tt_=(($2+8)|0);
      var $3=HEAP32[(($tt_)>>2)];
      var $cmp=(($3)|0)==72;
      if ($cmp) { label = 4; break; } else { label = 3; break; }
    case 3: 
      var $cond = 0;label = 5; break;
    case 4: 
      var $4=$o;
      var $value_=(($4)|0);
      var $gc=$value_;
      var $5=HEAP32[(($gc)>>2)];
      var $th=$5;
      var $cond = $th;label = 5; break;
    case 5: 
      var $cond;

      Module.print(INDENT + 'Exiting: _lua_tothread');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return $cond;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _lua_topointer($L, $idx) {
  var label = 0;

  Module.print(INDENT + ' Entering: _lua_topointer: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $retval;
      var $L_addr;
      var $idx_addr;
      var $o;
      $L_addr=$L;
      $idx_addr=$idx;
      var $0=$L_addr;
      var $1=$idx_addr;
      var $call=_index2addr($0, $1);
      $o=$call;
      var $2=$o;
      var $tt_=(($2+8)|0);
      var $3=HEAP32[(($tt_)>>2)];
      var $and=$3 & 63;
      if ((($and)|0)==5) {
        label = 3; break;
      }
      else if ((($and)|0)==6) {
        label = 4; break;
      }
      else if ((($and)|0)==38) {
        label = 5; break;
      }
      else if ((($and)|0)==22) {
        label = 6; break;
      }
      else if ((($and)|0)==8) {
        label = 7; break;
      }
      else if ((($and)|0)==7 | (($and)|0)==2) {
        label = 8; break;
      }
      else {
      label = 9; break;
      }
      
    case 3: 
      var $4=$o;
      var $value_=(($4)|0);
      var $gc=$value_;
      var $5=HEAP32[(($gc)>>2)];
      var $h=$5;
      var $6=$h;
      $retval=$6;
      label = 10; break;
    case 4: 
      var $7=$o;
      var $value_2=(($7)|0);
      var $gc3=$value_2;
      var $8=HEAP32[(($gc3)>>2)];
      var $cl=$8;
      var $l=$cl;
      var $9=$l;
      $retval=$9;
      label = 10; break;
    case 5: 
      var $10=$o;
      var $value_5=(($10)|0);
      var $gc6=$value_5;
      var $11=HEAP32[(($gc6)>>2)];
      var $cl7=$11;
      var $c=$cl7;
      var $12=$c;
      $retval=$12;
      label = 10; break;
    case 6: 
      var $13=$o;
      var $value_9=(($13)|0);
      var $f=$value_9;
      var $14=HEAP32[(($f)>>2)];
      var $15=$14;
      var $16=$15;
      $retval=$16;
      label = 10; break;
    case 7: 
      var $17=$o;
      var $value_11=(($17)|0);
      var $gc12=$value_11;
      var $18=HEAP32[(($gc12)>>2)];
      var $th=$18;
      var $19=$th;
      $retval=$19;
      label = 10; break;
    case 8: 
      var $20=$L_addr;
      var $21=$idx_addr;
      var $call14=_lua_touserdata($20, $21);
      $retval=$call14;
      label = 10; break;
    case 9: 
      $retval=0;
      label = 10; break;
    case 10: 
      var $22=$retval;

      Module.print(INDENT + 'Exiting: _lua_topointer');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return $22;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_lua_topointer["X"]=1;

function _lua_pushboolean($L, $b) {
  var label = 0;

  Module.print(INDENT + ' Entering: _lua_pushboolean: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';

  var $L_addr;
  var $b_addr;
  var $io;
  $L_addr=$L;
  $b_addr=$b;
  var $0=$L_addr;
  var $top=(($0+8)|0);
  var $1=HEAP32[(($top)>>2)];
  $io=$1;
  var $2=$b_addr;
  var $cmp=(($2)|0)!=0;
  var $conv=(($cmp)&1);
  var $3=$io;
  var $value_=(($3)|0);
  var $b1=$value_;
  HEAP32[(($b1)>>2)]=$conv;
  var $4=$io;
  var $tt_=(($4+8)|0);
  HEAP32[(($tt_)>>2)]=1;
  var $5=$L_addr;
  var $top2=(($5+8)|0);
  var $6=HEAP32[(($top2)>>2)];
  var $incdec_ptr=(($6+12)|0);
  HEAP32[(($top2)>>2)]=$incdec_ptr;

  Module.print(INDENT + 'Exiting: _lua_pushboolean');
  INDENT = INDENT.substr(0, INDENT.length-2);
  return;
  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _lua_pushlightuserdata($L, $p) {
  var label = 0;

  Module.print(INDENT + ' Entering: _lua_pushlightuserdata: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';

  var $L_addr;
  var $p_addr;
  var $io;
  $L_addr=$L;
  $p_addr=$p;
  var $0=$L_addr;
  var $top=(($0+8)|0);
  var $1=HEAP32[(($top)>>2)];
  $io=$1;
  var $2=$p_addr;
  var $3=$io;
  var $value_=(($3)|0);
  var $p1=$value_;
  HEAP32[(($p1)>>2)]=$2;
  var $4=$io;
  var $tt_=(($4+8)|0);
  HEAP32[(($tt_)>>2)]=2;
  var $5=$L_addr;
  var $top2=(($5+8)|0);
  var $6=HEAP32[(($top2)>>2)];
  var $incdec_ptr=(($6+12)|0);
  HEAP32[(($top2)>>2)]=$incdec_ptr;

  Module.print(INDENT + 'Exiting: _lua_pushlightuserdata');
  INDENT = INDENT.substr(0, INDENT.length-2);
  return;
  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _lua_pushthread($L) {
  var label = 0;

  Module.print(INDENT + ' Entering: _lua_pushthread: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';

  var $L_addr;
  var $io;
  $L_addr=$L;
  var $0=$L_addr;
  var $top=(($0+8)|0);
  var $1=HEAP32[(($top)>>2)];
  $io=$1;
  var $2=$L_addr;
  var $3=$2;
  var $4=$io;
  var $value_=(($4)|0);
  var $gc=$value_;
  HEAP32[(($gc)>>2)]=$3;
  var $5=$io;
  var $tt_=(($5+8)|0);
  HEAP32[(($tt_)>>2)]=72;
  var $6=$L_addr;
  var $top1=(($6+8)|0);
  var $7=HEAP32[(($top1)>>2)];
  var $incdec_ptr=(($7+12)|0);
  HEAP32[(($top1)>>2)]=$incdec_ptr;
  var $8=$L_addr;
  var $l_G=(($8+12)|0);
  var $9=HEAP32[(($l_G)>>2)];
  var $mainthread=(($9+152)|0);
  var $10=HEAP32[(($mainthread)>>2)];
  var $11=$L_addr;
  var $cmp=(($10)|0)==(($11)|0);
  var $conv=(($cmp)&1);

  Module.print(INDENT + 'Exiting: _lua_pushthread');
  INDENT = INDENT.substr(0, INDENT.length-2);
  return $conv;
  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _lua_pushlstring($L, $s, $len) {
  var label = 0;

  Module.print(INDENT + ' Entering: _lua_pushlstring: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $L_addr;
      var $s_addr;
      var $len_addr;
      var $ts;
      var $io;
      var $x_;
      $L_addr=$L;
      $s_addr=$s;
      $len_addr=$len;
      var $0=$L_addr;
      var $l_G=(($0+12)|0);
      var $1=HEAP32[(($l_G)>>2)];
      var $GCdebt=(($1+12)|0);
      var $2=HEAP32[(($GCdebt)>>2)];
      var $cmp=(($2)|0) > 0;
      if ($cmp) { label = 3; break; } else { label = 4; break; }
    case 3: 
      var $3=$L_addr;
      _luaC_step($3);
      label = 4; break;
    case 4: 
      var $4=$L_addr;
      var $5=$s_addr;
      var $6=$len_addr;
      var $call=_luaS_newlstr($4, $5, $6);
      $ts=$call;
      var $7=$L_addr;
      var $top=(($7+8)|0);
      var $8=HEAP32[(($top)>>2)];
      $io=$8;
      var $9=$ts;
      $x_=$9;
      var $10=$x_;
      var $11=$10;
      var $12=$io;
      var $value_=(($12)|0);
      var $gc=$value_;
      HEAP32[(($gc)>>2)]=$11;
      var $13=$x_;
      var $tsv=$13;
      var $tt=(($tsv+4)|0);
      var $14=HEAP8[($tt)];
      var $conv=(($14)&255);
      var $or=$conv | 64;
      var $15=$io;
      var $tt_=(($15+8)|0);
      HEAP32[(($tt_)>>2)]=$or;
      var $16=$L_addr;
      var $top1=(($16+8)|0);
      var $17=HEAP32[(($top1)>>2)];
      var $incdec_ptr=(($17+12)|0);
      HEAP32[(($top1)>>2)]=$incdec_ptr;
      var $18=$ts;
      var $add_ptr=(($18+16)|0);
      var $19=$add_ptr;

      Module.print(INDENT + 'Exiting: _lua_pushlstring');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return $19;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_lua_pushlstring["X"]=1;

function _lua_pushstring($L, $s) {
  var label = 0;

  Module.print(INDENT + ' Entering: _lua_pushstring: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $retval;
      var $L_addr;
      var $s_addr;
      var $ts;
      var $io;
      var $x_;
      $L_addr=$L;
      $s_addr=$s;
      var $0=$s_addr;
      var $cmp=(($0)|0)==0;
      if ($cmp) { label = 3; break; } else { label = 4; break; }
    case 3: 
      var $1=$L_addr;
      _lua_pushnil($1);
      $retval=0;
      label = 7; break;
    case 4: 
      var $2=$L_addr;
      var $l_G=(($2+12)|0);
      var $3=HEAP32[(($l_G)>>2)];
      var $GCdebt=(($3+12)|0);
      var $4=HEAP32[(($GCdebt)>>2)];
      var $cmp1=(($4)|0) > 0;
      if ($cmp1) { label = 5; break; } else { label = 6; break; }
    case 5: 
      var $5=$L_addr;
      _luaC_step($5);
      label = 6; break;
    case 6: 
      var $6=$L_addr;
      var $7=$s_addr;
      var $call=_luaS_new($6, $7);
      $ts=$call;
      var $8=$L_addr;
      var $top=(($8+8)|0);
      var $9=HEAP32[(($top)>>2)];
      $io=$9;
      var $10=$ts;
      $x_=$10;
      var $11=$x_;
      var $12=$11;
      var $13=$io;
      var $value_=(($13)|0);
      var $gc=$value_;
      HEAP32[(($gc)>>2)]=$12;
      var $14=$x_;
      var $tsv=$14;
      var $tt=(($tsv+4)|0);
      var $15=HEAP8[($tt)];
      var $conv=(($15)&255);
      var $or=$conv | 64;
      var $16=$io;
      var $tt_=(($16+8)|0);
      HEAP32[(($tt_)>>2)]=$or;
      var $17=$L_addr;
      var $top3=(($17+8)|0);
      var $18=HEAP32[(($top3)>>2)];
      var $incdec_ptr=(($18+12)|0);
      HEAP32[(($top3)>>2)]=$incdec_ptr;
      var $19=$ts;
      var $add_ptr=(($19+16)|0);
      var $20=$add_ptr;
      $retval=$20;
      label = 7; break;
    case 7: 
      var $21=$retval;

      Module.print(INDENT + 'Exiting: _lua_pushstring');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return $21;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_lua_pushstring["X"]=1;

function _lua_pushvfstring($L, $fmt, $argp) {
  var label = 0;

  Module.print(INDENT + ' Entering: _lua_pushvfstring: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $L_addr;
      var $fmt_addr;
      var $argp_addr;
      var $ret;
      $L_addr=$L;
      $fmt_addr=$fmt;
      $argp_addr=$argp;
      var $0=$L_addr;
      var $l_G=(($0+12)|0);
      var $1=HEAP32[(($l_G)>>2)];
      var $GCdebt=(($1+12)|0);
      var $2=HEAP32[(($GCdebt)>>2)];
      var $cmp=(($2)|0) > 0;
      if ($cmp) { label = 3; break; } else { label = 4; break; }
    case 3: 
      var $3=$L_addr;
      _luaC_step($3);
      label = 4; break;
    case 4: 
      var $4=$L_addr;
      var $5=$fmt_addr;
      var $6=$argp_addr;
      var $call=_luaO_pushvfstring($4, $5, $6);
      $ret=$call;
      var $7=$ret;

      Module.print(INDENT + 'Exiting: _lua_pushvfstring');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return $7;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _lua_pushfstring($L, $fmt, varrp) {
  var label = 0;
  var __stackBase__  = STACKTOP; STACKTOP = (STACKTOP + 4)|0; _memset(__stackBase__, 0, 4);
  Module.print(INDENT + ' Entering: _lua_pushfstring: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $L_addr;
      var $fmt_addr;
      var $ret;
      var $argp=__stackBase__;
      $L_addr=$L;
      $fmt_addr=$fmt;
      var $0=$L_addr;
      var $l_G=(($0+12)|0);
      var $1=HEAP32[(($l_G)>>2)];
      var $GCdebt=(($1+12)|0);
      var $2=HEAP32[(($GCdebt)>>2)];
      var $cmp=(($2)|0) > 0;
      if ($cmp) { label = 3; break; } else { label = 4; break; }
    case 3: 
      var $3=$L_addr;
      _luaC_step($3);
      label = 4; break;
    case 4: 
      var $argp1=$argp;
      HEAP32[(($argp1)>>2)]=varrp;
      var $4=$L_addr;
      var $5=$fmt_addr;
      var $6=HEAP32[(($argp)>>2)];
      var $call=_luaO_pushvfstring($4, $5, $6);
      $ret=$call;
      var $argp2=$argp;

      var $7=$ret;
      STACKTOP = __stackBase__;
      Module.print(INDENT + 'Exiting: _lua_pushfstring');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return $7;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _lua_pushcclosure($L, $fn, $n) {
  var label = 0;

  Module.print(INDENT + ' Entering: _lua_pushcclosure: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $L_addr;
      var $fn_addr;
      var $n_addr;
      var $io;
      var $cl;
      var $io2;
      var $io1;
      var $io12;
      $L_addr=$L;
      $fn_addr=$fn;
      $n_addr=$n;
      var $0=$n_addr;
      var $cmp=(($0)|0)==0;
      if ($cmp) { label = 3; break; } else { label = 4; break; }
    case 3: 
      var $1=$L_addr;
      var $top=(($1+8)|0);
      var $2=HEAP32[(($top)>>2)];
      $io=$2;
      var $3=$fn_addr;
      var $4=$io;
      var $value_=(($4)|0);
      var $f=$value_;
      HEAP32[(($f)>>2)]=$3;
      var $5=$io;
      var $tt_=(($5+8)|0);
      HEAP32[(($tt_)>>2)]=22;
      label = 10; break;
    case 4: 
      var $6=$L_addr;
      var $l_G=(($6+12)|0);
      var $7=HEAP32[(($l_G)>>2)];
      var $GCdebt=(($7+12)|0);
      var $8=HEAP32[(($GCdebt)>>2)];
      var $cmp1=(($8)|0) > 0;
      if ($cmp1) { label = 5; break; } else { label = 6; break; }
    case 5: 
      var $9=$L_addr;
      _luaC_step($9);
      label = 6; break;
    case 6: 
      var $10=$L_addr;
      var $11=$n_addr;
      var $call=_luaF_newCclosure($10, $11);
      $cl=$call;
      var $12=$fn_addr;
      var $13=$cl;
      var $c=$13;
      var $f3=(($c+12)|0);
      HEAP32[(($f3)>>2)]=$12;
      var $14=$n_addr;
      var $15=$L_addr;
      var $top4=(($15+8)|0);
      var $16=HEAP32[(($top4)>>2)];
      var $idx_neg=(((-$14))|0);
      var $add_ptr=(($16+((($idx_neg)*(12))&-1))|0);
      HEAP32[(($top4)>>2)]=$add_ptr;
      label = 7; break;
    case 7: 
      var $17=$n_addr;
      var $dec=((($17)-(1))|0);
      $n_addr=$dec;
      var $tobool=(($17)|0)!=0;
      if ($tobool) { label = 8; break; } else { label = 9; break; }
    case 8: 
      var $18=$L_addr;
      var $top5=(($18+8)|0);
      var $19=HEAP32[(($top5)>>2)];
      var $20=$n_addr;
      var $add_ptr6=(($19+((($20)*(12))&-1))|0);
      $io2=$add_ptr6;
      var $21=$n_addr;
      var $22=$cl;
      var $c7=$22;
      var $upvalue=(($c7+16)|0);
      var $arrayidx=(($upvalue+((($21)*(12))&-1))|0);
      $io1=$arrayidx;
      var $23=$io1;
      var $value_8=(($23)|0);
      var $24=$io2;
      var $value_9=(($24)|0);
      var $25=$value_8;
      var $26=$value_9;
      HEAP32[(($25)>>2)]=HEAP32[(($26)>>2)];HEAP32[((($25)+(4))>>2)]=HEAP32[((($26)+(4))>>2)];
      var $27=$io2;
      var $tt_10=(($27+8)|0);
      var $28=HEAP32[(($tt_10)>>2)];
      var $29=$io1;
      var $tt_11=(($29+8)|0);
      HEAP32[(($tt_11)>>2)]=$28;
      label = 7; break;
    case 9: 
      var $30=$L_addr;
      var $top13=(($30+8)|0);
      var $31=HEAP32[(($top13)>>2)];
      $io12=$31;
      var $32=$cl;
      var $33=$32;
      var $34=$io12;
      var $value_14=(($34)|0);
      var $gc=$value_14;
      HEAP32[(($gc)>>2)]=$33;
      var $35=$io12;
      var $tt_15=(($35+8)|0);
      HEAP32[(($tt_15)>>2)]=102;
      label = 10; break;
    case 10: 
      var $36=$L_addr;
      var $top17=(($36+8)|0);
      var $37=HEAP32[(($top17)>>2)];
      var $incdec_ptr=(($37+12)|0);
      HEAP32[(($top17)>>2)]=$incdec_ptr;

      Module.print(INDENT + 'Exiting: _lua_pushcclosure');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_lua_pushcclosure["X"]=1;

function _lua_getglobal($L, $var) {
  var label = 0;

  Module.print(INDENT + ' Entering: _lua_getglobal: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';

  var $L_addr;
  var $var_addr;
  var $reg;
  var $gt;
  var $io;
  var $x_;
  $L_addr=$L;
  $var_addr=$var;
  var $0=$L_addr;
  var $l_G=(($0+12)|0);
  var $1=HEAP32[(($l_G)>>2)];
  var $l_registry=(($1+36)|0);
  var $value_=(($l_registry)|0);
  var $gc=$value_;
  var $2=HEAP32[(($gc)>>2)];
  var $h=$2;
  $reg=$h;
  var $3=$reg;
  var $call=_luaH_getint($3, 2);
  $gt=$call;
  var $4=$L_addr;
  var $top=(($4+8)|0);
  var $5=HEAP32[(($top)>>2)];
  var $incdec_ptr=(($5+12)|0);
  HEAP32[(($top)>>2)]=$incdec_ptr;
  $io=$5;
  var $6=$L_addr;
  var $7=$var_addr;
  var $call1=_luaS_new($6, $7);
  $x_=$call1;
  var $8=$x_;
  var $9=$8;
  var $10=$io;
  var $value_2=(($10)|0);
  var $gc3=$value_2;
  HEAP32[(($gc3)>>2)]=$9;
  var $11=$x_;
  var $tsv=$11;
  var $tt=(($tsv+4)|0);
  var $12=HEAP8[($tt)];
  var $conv=(($12)&255);
  var $or=$conv | 64;
  var $13=$io;
  var $tt_=(($13+8)|0);
  HEAP32[(($tt_)>>2)]=$or;
  var $14=$L_addr;
  var $15=$gt;
  var $16=$L_addr;
  var $top4=(($16+8)|0);
  var $17=HEAP32[(($top4)>>2)];
  var $add_ptr=((($17)-(12))|0);
  var $18=$L_addr;
  var $top5=(($18+8)|0);
  var $19=HEAP32[(($top5)>>2)];
  var $add_ptr6=((($19)-(12))|0);
  _luaV_gettable($14, $15, $add_ptr, $add_ptr6);

  Module.print(INDENT + 'Exiting: _lua_getglobal');
  INDENT = INDENT.substr(0, INDENT.length-2);
  return;
  INDENT = INDENT.substr(0, INDENT.length-2);
}
_lua_getglobal["X"]=1;

function _lua_gettable($L, $idx) {
  var label = 0;

  Module.print(INDENT + ' Entering: _lua_gettable: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';

  var $L_addr;
  var $idx_addr;
  var $t;
  $L_addr=$L;
  $idx_addr=$idx;
  var $0=$L_addr;
  var $1=$idx_addr;
  var $call=_index2addr($0, $1);
  $t=$call;
  var $2=$L_addr;
  var $3=$t;
  var $4=$L_addr;
  var $top=(($4+8)|0);
  var $5=HEAP32[(($top)>>2)];
  var $add_ptr=((($5)-(12))|0);
  var $6=$L_addr;
  var $top1=(($6+8)|0);
  var $7=HEAP32[(($top1)>>2)];
  var $add_ptr2=((($7)-(12))|0);
  _luaV_gettable($2, $3, $add_ptr, $add_ptr2);

  Module.print(INDENT + 'Exiting: _lua_gettable');
  INDENT = INDENT.substr(0, INDENT.length-2);
  return;
  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _lua_getfield($L, $idx, $k) {
  var label = 0;

  Module.print(INDENT + ' Entering: _lua_getfield: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';

  var $L_addr;
  var $idx_addr;
  var $k_addr;
  var $t;
  var $io;
  var $x_;
  $L_addr=$L;
  $idx_addr=$idx;
  $k_addr=$k;
  var $0=$L_addr;
  var $1=$idx_addr;
  var $call=_index2addr($0, $1);
  $t=$call;
  var $2=$L_addr;
  var $top=(($2+8)|0);
  var $3=HEAP32[(($top)>>2)];
  $io=$3;
  var $4=$L_addr;
  var $5=$k_addr;
  var $call1=_luaS_new($4, $5);
  $x_=$call1;
  var $6=$x_;
  var $7=$6;
  var $8=$io;
  var $value_=(($8)|0);
  var $gc=$value_;
  HEAP32[(($gc)>>2)]=$7;
  var $9=$x_;
  var $tsv=$9;
  var $tt=(($tsv+4)|0);
  var $10=HEAP8[($tt)];
  var $conv=(($10)&255);
  var $or=$conv | 64;
  var $11=$io;
  var $tt_=(($11+8)|0);
  HEAP32[(($tt_)>>2)]=$or;
  var $12=$L_addr;
  var $top2=(($12+8)|0);
  var $13=HEAP32[(($top2)>>2)];
  var $incdec_ptr=(($13+12)|0);
  HEAP32[(($top2)>>2)]=$incdec_ptr;
  var $14=$L_addr;
  var $15=$t;
  var $16=$L_addr;
  var $top3=(($16+8)|0);
  var $17=HEAP32[(($top3)>>2)];
  var $add_ptr=((($17)-(12))|0);
  var $18=$L_addr;
  var $top4=(($18+8)|0);
  var $19=HEAP32[(($top4)>>2)];
  var $add_ptr5=((($19)-(12))|0);
  _luaV_gettable($14, $15, $add_ptr, $add_ptr5);

  Module.print(INDENT + 'Exiting: _lua_getfield');
  INDENT = INDENT.substr(0, INDENT.length-2);
  return;
  INDENT = INDENT.substr(0, INDENT.length-2);
}
_lua_getfield["X"]=1;

function _lua_rawget($L, $idx) {
  var label = 0;

  Module.print(INDENT + ' Entering: _lua_rawget: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';

  var $L_addr;
  var $idx_addr;
  var $t;
  var $io2;
  var $io1;
  $L_addr=$L;
  $idx_addr=$idx;
  var $0=$L_addr;
  var $1=$idx_addr;
  var $call=_index2addr($0, $1);
  $t=$call;
  var $2=$t;
  var $value_=(($2)|0);
  var $gc=$value_;
  var $3=HEAP32[(($gc)>>2)];
  var $h=$3;
  var $4=$L_addr;
  var $top=(($4+8)|0);
  var $5=HEAP32[(($top)>>2)];
  var $add_ptr=((($5)-(12))|0);
  var $call1=_luaH_get($h, $add_ptr);
  $io2=$call1;
  var $6=$L_addr;
  var $top2=(($6+8)|0);
  var $7=HEAP32[(($top2)>>2)];
  var $add_ptr3=((($7)-(12))|0);
  $io1=$add_ptr3;
  var $8=$io1;
  var $value_4=(($8)|0);
  var $9=$io2;
  var $value_5=(($9)|0);
  var $10=$value_4;
  var $11=$value_5;
  HEAP32[(($10)>>2)]=HEAP32[(($11)>>2)];HEAP32[((($10)+(4))>>2)]=HEAP32[((($11)+(4))>>2)];
  var $12=$io2;
  var $tt_=(($12+8)|0);
  var $13=HEAP32[(($tt_)>>2)];
  var $14=$io1;
  var $tt_6=(($14+8)|0);
  HEAP32[(($tt_6)>>2)]=$13;

  Module.print(INDENT + 'Exiting: _lua_rawget');
  INDENT = INDENT.substr(0, INDENT.length-2);
  return;
  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _lua_rawgeti($L, $idx, $n) {
  var label = 0;

  Module.print(INDENT + ' Entering: _lua_rawgeti: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';

  var $L_addr;
  var $idx_addr;
  var $n_addr;
  var $t;
  var $io2;
  var $io1;
  $L_addr=$L;
  $idx_addr=$idx;
  $n_addr=$n;
  var $0=$L_addr;
  var $1=$idx_addr;
  var $call=_index2addr($0, $1);
  $t=$call;
  var $2=$t;
  var $value_=(($2)|0);
  var $gc=$value_;
  var $3=HEAP32[(($gc)>>2)];
  var $h=$3;
  var $4=$n_addr;
  var $call1=_luaH_getint($h, $4);
  $io2=$call1;
  var $5=$L_addr;
  var $top=(($5+8)|0);
  var $6=HEAP32[(($top)>>2)];
  $io1=$6;
  var $7=$io1;
  var $value_2=(($7)|0);
  var $8=$io2;
  var $value_3=(($8)|0);
  var $9=$value_2;
  var $10=$value_3;
  HEAP32[(($9)>>2)]=HEAP32[(($10)>>2)];HEAP32[((($9)+(4))>>2)]=HEAP32[((($10)+(4))>>2)];
  var $11=$io2;
  var $tt_=(($11+8)|0);
  var $12=HEAP32[(($tt_)>>2)];
  var $13=$io1;
  var $tt_4=(($13+8)|0);
  HEAP32[(($tt_4)>>2)]=$12;
  var $14=$L_addr;
  var $top5=(($14+8)|0);
  var $15=HEAP32[(($top5)>>2)];
  var $incdec_ptr=(($15+12)|0);
  HEAP32[(($top5)>>2)]=$incdec_ptr;

  Module.print(INDENT + 'Exiting: _lua_rawgeti');
  INDENT = INDENT.substr(0, INDENT.length-2);
  return;
  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _lua_rawgetp($L, $idx, $p) {
  var label = 0;
  var __stackBase__  = STACKTOP; STACKTOP = (STACKTOP + 12)|0; _memset(__stackBase__, 0, 12);
  Module.print(INDENT + ' Entering: _lua_rawgetp: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';

  var $L_addr;
  var $idx_addr;
  var $p_addr;
  var $t;
  var $k=__stackBase__;
  var $io;
  var $io2;
  var $io1;
  $L_addr=$L;
  $idx_addr=$idx;
  $p_addr=$p;
  var $0=$L_addr;
  var $1=$idx_addr;
  var $call=_index2addr($0, $1);
  $t=$call;
  $io=$k;
  var $2=$p_addr;
  var $3=$io;
  var $value_=(($3)|0);
  var $p1=$value_;
  HEAP32[(($p1)>>2)]=$2;
  var $4=$io;
  var $tt_=(($4+8)|0);
  HEAP32[(($tt_)>>2)]=2;
  var $5=$t;
  var $value_2=(($5)|0);
  var $gc=$value_2;
  var $6=HEAP32[(($gc)>>2)];
  var $h=$6;
  var $call3=_luaH_get($h, $k);
  $io2=$call3;
  var $7=$L_addr;
  var $top=(($7+8)|0);
  var $8=HEAP32[(($top)>>2)];
  $io1=$8;
  var $9=$io1;
  var $value_4=(($9)|0);
  var $10=$io2;
  var $value_5=(($10)|0);
  var $11=$value_4;
  var $12=$value_5;
  HEAP32[(($11)>>2)]=HEAP32[(($12)>>2)];HEAP32[((($11)+(4))>>2)]=HEAP32[((($12)+(4))>>2)];
  var $13=$io2;
  var $tt_6=(($13+8)|0);
  var $14=HEAP32[(($tt_6)>>2)];
  var $15=$io1;
  var $tt_7=(($15+8)|0);
  HEAP32[(($tt_7)>>2)]=$14;
  var $16=$L_addr;
  var $top8=(($16+8)|0);
  var $17=HEAP32[(($top8)>>2)];
  var $incdec_ptr=(($17+12)|0);
  HEAP32[(($top8)>>2)]=$incdec_ptr;
  STACKTOP = __stackBase__;
  Module.print(INDENT + 'Exiting: _lua_rawgetp');
  INDENT = INDENT.substr(0, INDENT.length-2);
  return;
  INDENT = INDENT.substr(0, INDENT.length-2);
}
_lua_rawgetp["X"]=1;

function _lua_createtable($L, $narray, $nrec) {
  var label = 0;

  Module.print(INDENT + ' Entering: _lua_createtable: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $L_addr;
      var $narray_addr;
      var $nrec_addr;
      var $t;
      var $io;
      $L_addr=$L;
      $narray_addr=$narray;
      $nrec_addr=$nrec;
      var $0=$L_addr;
      var $l_G=(($0+12)|0);
      var $1=HEAP32[(($l_G)>>2)];
      var $GCdebt=(($1+12)|0);
      var $2=HEAP32[(($GCdebt)>>2)];
      var $cmp=(($2)|0) > 0;
      if ($cmp) { label = 3; break; } else { label = 4; break; }
    case 3: 
      var $3=$L_addr;
      _luaC_step($3);
      label = 4; break;
    case 4: 
      var $4=$L_addr;
      var $call=_luaH_new($4);
      $t=$call;
      var $5=$L_addr;
      var $top=(($5+8)|0);
      var $6=HEAP32[(($top)>>2)];
      $io=$6;
      var $7=$t;
      var $8=$7;
      var $9=$io;
      var $value_=(($9)|0);
      var $gc=$value_;
      HEAP32[(($gc)>>2)]=$8;
      var $10=$io;
      var $tt_=(($10+8)|0);
      HEAP32[(($tt_)>>2)]=69;
      var $11=$L_addr;
      var $top1=(($11+8)|0);
      var $12=HEAP32[(($top1)>>2)];
      var $incdec_ptr=(($12+12)|0);
      HEAP32[(($top1)>>2)]=$incdec_ptr;
      var $13=$narray_addr;
      var $cmp2=(($13)|0) > 0;
      if ($cmp2) { label = 6; break; } else { label = 5; break; }
    case 5: 
      var $14=$nrec_addr;
      var $cmp3=(($14)|0) > 0;
      if ($cmp3) { label = 6; break; } else { label = 7; break; }
    case 6: 
      var $15=$L_addr;
      var $16=$t;
      var $17=$narray_addr;
      var $18=$nrec_addr;
      _luaH_resize($15, $16, $17, $18);
      label = 7; break;
    case 7: 

      Module.print(INDENT + 'Exiting: _lua_createtable');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_lua_createtable["X"]=1;

function _lua_getmetatable($L, $objindex) {
  var label = 0;

  Module.print(INDENT + ' Entering: _lua_getmetatable: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $L_addr;
      var $objindex_addr;
      var $obj;
      var $mt;
      var $res;
      var $io;
      $L_addr=$L;
      $objindex_addr=$objindex;
      $mt=0;
      var $0=$L_addr;
      var $1=$objindex_addr;
      var $call=_index2addr($0, $1);
      $obj=$call;
      var $2=$obj;
      var $tt_=(($2+8)|0);
      var $3=HEAP32[(($tt_)>>2)];
      var $and=$3 & 15;
      if ((($and)|0)==5) {
        label = 3; break;
      }
      else if ((($and)|0)==7) {
        label = 4; break;
      }
      else {
      label = 5; break;
      }
      
    case 3: 
      var $4=$obj;
      var $value_=(($4)|0);
      var $gc=$value_;
      var $5=HEAP32[(($gc)>>2)];
      var $h=$5;
      var $metatable=(($h+8)|0);
      var $6=HEAP32[(($metatable)>>2)];
      $mt=$6;
      label = 6; break;
    case 4: 
      var $7=$obj;
      var $value_2=(($7)|0);
      var $gc3=$value_2;
      var $8=HEAP32[(($gc3)>>2)];
      var $u=$8;
      var $uv=$u;
      var $metatable4=(($uv+8)|0);
      var $9=HEAP32[(($metatable4)>>2)];
      $mt=$9;
      label = 6; break;
    case 5: 
      var $10=$obj;
      var $tt_5=(($10+8)|0);
      var $11=HEAP32[(($tt_5)>>2)];
      var $and6=$11 & 15;
      var $12=$L_addr;
      var $l_G=(($12+12)|0);
      var $13=HEAP32[(($l_G)>>2)];
      var $mt7=(($13+232)|0);
      var $arrayidx=(($mt7+($and6<<2))|0);
      var $14=HEAP32[(($arrayidx)>>2)];
      $mt=$14;
      label = 6; break;
    case 6: 
      var $15=$mt;
      var $cmp=(($15)|0)==0;
      if ($cmp) { label = 7; break; } else { label = 8; break; }
    case 7: 
      $res=0;
      label = 9; break;
    case 8: 
      var $16=$L_addr;
      var $top=(($16+8)|0);
      var $17=HEAP32[(($top)>>2)];
      $io=$17;
      var $18=$mt;
      var $19=$18;
      var $20=$io;
      var $value_8=(($20)|0);
      var $gc9=$value_8;
      HEAP32[(($gc9)>>2)]=$19;
      var $21=$io;
      var $tt_10=(($21+8)|0);
      HEAP32[(($tt_10)>>2)]=69;
      var $22=$L_addr;
      var $top11=(($22+8)|0);
      var $23=HEAP32[(($top11)>>2)];
      var $incdec_ptr=(($23+12)|0);
      HEAP32[(($top11)>>2)]=$incdec_ptr;
      $res=1;
      label = 9; break;
    case 9: 
      var $24=$res;

      Module.print(INDENT + 'Exiting: _lua_getmetatable');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return $24;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_lua_getmetatable["X"]=1;

function _lua_getuservalue($L, $idx) {
  var label = 0;

  Module.print(INDENT + ' Entering: _lua_getuservalue: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $L_addr;
      var $idx_addr;
      var $o;
      var $io;
      $L_addr=$L;
      $idx_addr=$idx;
      var $0=$L_addr;
      var $1=$idx_addr;
      var $call=_index2addr($0, $1);
      $o=$call;
      var $2=$o;
      var $value_=(($2)|0);
      var $gc=$value_;
      var $3=HEAP32[(($gc)>>2)];
      var $u=$3;
      var $uv=$u;
      var $env=(($uv+12)|0);
      var $4=HEAP32[(($env)>>2)];
      var $tobool=(($4)|0)!=0;
      if ($tobool) { label = 3; break; } else { label = 4; break; }
    case 3: 
      var $5=$L_addr;
      var $top=(($5+8)|0);
      var $6=HEAP32[(($top)>>2)];
      $io=$6;
      var $7=$o;
      var $value_1=(($7)|0);
      var $gc2=$value_1;
      var $8=HEAP32[(($gc2)>>2)];
      var $u3=$8;
      var $uv4=$u3;
      var $env5=(($uv4+12)|0);
      var $9=HEAP32[(($env5)>>2)];
      var $10=$9;
      var $11=$io;
      var $value_6=(($11)|0);
      var $gc7=$value_6;
      HEAP32[(($gc7)>>2)]=$10;
      var $12=$io;
      var $tt_=(($12+8)|0);
      HEAP32[(($tt_)>>2)]=69;
      label = 5; break;
    case 4: 
      var $13=$L_addr;
      var $top8=(($13+8)|0);
      var $14=HEAP32[(($top8)>>2)];
      var $tt_9=(($14+8)|0);
      HEAP32[(($tt_9)>>2)]=0;
      label = 5; break;
    case 5: 
      var $15=$L_addr;
      var $top10=(($15+8)|0);
      var $16=HEAP32[(($top10)>>2)];
      var $incdec_ptr=(($16+12)|0);
      HEAP32[(($top10)>>2)]=$incdec_ptr;

      Module.print(INDENT + 'Exiting: _lua_getuservalue');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_lua_getuservalue["X"]=1;

function _lua_setglobal($L, $var) {
  var label = 0;

  Module.print(INDENT + ' Entering: _lua_setglobal: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';

  var $L_addr;
  var $var_addr;
  var $reg;
  var $gt;
  var $io;
  var $x_;
  $L_addr=$L;
  $var_addr=$var;
  var $0=$L_addr;
  var $l_G=(($0+12)|0);
  var $1=HEAP32[(($l_G)>>2)];
  var $l_registry=(($1+36)|0);
  var $value_=(($l_registry)|0);
  var $gc=$value_;
  var $2=HEAP32[(($gc)>>2)];
  var $h=$2;
  $reg=$h;
  var $3=$reg;
  var $call=_luaH_getint($3, 2);
  $gt=$call;
  var $4=$L_addr;
  var $top=(($4+8)|0);
  var $5=HEAP32[(($top)>>2)];
  var $incdec_ptr=(($5+12)|0);
  HEAP32[(($top)>>2)]=$incdec_ptr;
  $io=$5;
  var $6=$L_addr;
  var $7=$var_addr;
  var $call1=_luaS_new($6, $7);
  $x_=$call1;
  var $8=$x_;
  var $9=$8;
  var $10=$io;
  var $value_2=(($10)|0);
  var $gc3=$value_2;
  HEAP32[(($gc3)>>2)]=$9;
  var $11=$x_;
  var $tsv=$11;
  var $tt=(($tsv+4)|0);
  var $12=HEAP8[($tt)];
  var $conv=(($12)&255);
  var $or=$conv | 64;
  var $13=$io;
  var $tt_=(($13+8)|0);
  HEAP32[(($tt_)>>2)]=$or;
  var $14=$L_addr;
  var $15=$gt;
  var $16=$L_addr;
  var $top4=(($16+8)|0);
  var $17=HEAP32[(($top4)>>2)];
  var $add_ptr=((($17)-(12))|0);
  var $18=$L_addr;
  var $top5=(($18+8)|0);
  var $19=HEAP32[(($top5)>>2)];
  var $add_ptr6=((($19)-(24))|0);
  _luaV_settable($14, $15, $add_ptr, $add_ptr6);
  var $20=$L_addr;
  var $top7=(($20+8)|0);
  var $21=HEAP32[(($top7)>>2)];
  var $add_ptr8=((($21)-(24))|0);
  HEAP32[(($top7)>>2)]=$add_ptr8;

  Module.print(INDENT + 'Exiting: _lua_setglobal');
  INDENT = INDENT.substr(0, INDENT.length-2);
  return;
  INDENT = INDENT.substr(0, INDENT.length-2);
}
_lua_setglobal["X"]=1;

function _lua_getctx($L, $ctx) {
  var label = 0;

  Module.print(INDENT + ' Entering: _lua_getctx: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $retval;
      var $L_addr;
      var $ctx_addr;
      $L_addr=$L;
      $ctx_addr=$ctx;
      var $0=$L_addr;
      var $ci=(($0+16)|0);
      var $1=HEAP32[(($ci)>>2)];
      var $callstatus=(($1+18)|0);
      var $2=HEAP8[($callstatus)];
      var $conv=(($2)&255);
      var $and=$conv & 8;
      var $tobool=(($and)|0)!=0;
      if ($tobool) { label = 3; break; } else { label = 6; break; }
    case 3: 
      var $3=$ctx_addr;
      var $tobool1=(($3)|0)!=0;
      if ($tobool1) { label = 4; break; } else { label = 5; break; }
    case 4: 
      var $4=$L_addr;
      var $ci3=(($4+16)|0);
      var $5=HEAP32[(($ci3)>>2)];
      var $u=(($5+24)|0);
      var $c=$u;
      var $ctx4=(($c)|0);
      var $6=HEAP32[(($ctx4)>>2)];
      var $7=$ctx_addr;
      HEAP32[(($7)>>2)]=$6;
      label = 5; break;
    case 5: 
      var $8=$L_addr;
      var $ci5=(($8+16)|0);
      var $9=HEAP32[(($ci5)>>2)];
      var $u6=(($9+24)|0);
      var $c7=$u6;
      var $status=(($c7+13)|0);
      var $10=HEAP8[($status)];
      var $conv8=(($10)&255);
      $retval=$conv8;
      label = 7; break;
    case 6: 
      $retval=0;
      label = 7; break;
    case 7: 
      var $11=$retval;

      Module.print(INDENT + 'Exiting: _lua_getctx');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return $11;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _lua_settable($L, $idx) {
  var label = 0;

  Module.print(INDENT + ' Entering: _lua_settable: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';

  var $L_addr;
  var $idx_addr;
  var $t;
  $L_addr=$L;
  $idx_addr=$idx;
  var $0=$L_addr;
  var $1=$idx_addr;
  var $call=_index2addr($0, $1);
  $t=$call;
  var $2=$L_addr;
  var $3=$t;
  var $4=$L_addr;
  var $top=(($4+8)|0);
  var $5=HEAP32[(($top)>>2)];
  var $add_ptr=((($5)-(24))|0);
  var $6=$L_addr;
  var $top1=(($6+8)|0);
  var $7=HEAP32[(($top1)>>2)];
  var $add_ptr2=((($7)-(12))|0);
  _luaV_settable($2, $3, $add_ptr, $add_ptr2);
  var $8=$L_addr;
  var $top3=(($8+8)|0);
  var $9=HEAP32[(($top3)>>2)];
  var $add_ptr4=((($9)-(24))|0);
  HEAP32[(($top3)>>2)]=$add_ptr4;

  Module.print(INDENT + 'Exiting: _lua_settable');
  INDENT = INDENT.substr(0, INDENT.length-2);
  return;
  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _lua_setfield($L, $idx, $k) {
  var label = 0;

  Module.print(INDENT + ' Entering: _lua_setfield: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';

  var $L_addr;
  var $idx_addr;
  var $k_addr;
  var $t;
  var $io;
  var $x_;
  $L_addr=$L;
  $idx_addr=$idx;
  $k_addr=$k;
  var $0=$L_addr;
  var $1=$idx_addr;
  var $call=_index2addr($0, $1);
  $t=$call;
  var $2=$L_addr;
  var $top=(($2+8)|0);
  var $3=HEAP32[(($top)>>2)];
  var $incdec_ptr=(($3+12)|0);
  HEAP32[(($top)>>2)]=$incdec_ptr;
  $io=$3;
  var $4=$L_addr;
  var $5=$k_addr;
  var $call1=_luaS_new($4, $5);
  $x_=$call1;
  var $6=$x_;
  var $7=$6;
  var $8=$io;
  var $value_=(($8)|0);
  var $gc=$value_;
  HEAP32[(($gc)>>2)]=$7;
  var $9=$x_;
  var $tsv=$9;
  var $tt=(($tsv+4)|0);
  var $10=HEAP8[($tt)];
  var $conv=(($10)&255);
  var $or=$conv | 64;
  var $11=$io;
  var $tt_=(($11+8)|0);
  HEAP32[(($tt_)>>2)]=$or;
  var $12=$L_addr;
  var $13=$t;
  var $14=$L_addr;
  var $top2=(($14+8)|0);
  var $15=HEAP32[(($top2)>>2)];
  var $add_ptr=((($15)-(12))|0);
  var $16=$L_addr;
  var $top3=(($16+8)|0);
  var $17=HEAP32[(($top3)>>2)];
  var $add_ptr4=((($17)-(24))|0);
  _luaV_settable($12, $13, $add_ptr, $add_ptr4);
  var $18=$L_addr;
  var $top5=(($18+8)|0);
  var $19=HEAP32[(($top5)>>2)];
  var $add_ptr6=((($19)-(24))|0);
  HEAP32[(($top5)>>2)]=$add_ptr6;

  Module.print(INDENT + 'Exiting: _lua_setfield');
  INDENT = INDENT.substr(0, INDENT.length-2);
  return;
  INDENT = INDENT.substr(0, INDENT.length-2);
}
_lua_setfield["X"]=1;

function _lua_rawset($L, $idx) {
  var label = 0;

  Module.print(INDENT + ' Entering: _lua_rawset: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $L_addr;
      var $idx_addr;
      var $t;
      var $io2;
      var $io1;
      $L_addr=$L;
      $idx_addr=$idx;
      var $0=$L_addr;
      var $1=$idx_addr;
      var $call=_index2addr($0, $1);
      $t=$call;
      var $2=$L_addr;
      var $top=(($2+8)|0);
      var $3=HEAP32[(($top)>>2)];
      var $add_ptr=((($3)-(12))|0);
      $io2=$add_ptr;
      var $4=$L_addr;
      var $5=$t;
      var $value_=(($5)|0);
      var $gc=$value_;
      var $6=HEAP32[(($gc)>>2)];
      var $h=$6;
      var $7=$L_addr;
      var $top1=(($7+8)|0);
      var $8=HEAP32[(($top1)>>2)];
      var $add_ptr2=((($8)-(24))|0);
      var $call3=_luaH_set($4, $h, $add_ptr2);
      $io1=$call3;
      var $9=$io1;
      var $value_4=(($9)|0);
      var $10=$io2;
      var $value_5=(($10)|0);
      var $11=$value_4;
      var $12=$value_5;
      HEAP32[(($11)>>2)]=HEAP32[(($12)>>2)];HEAP32[((($11)+(4))>>2)]=HEAP32[((($12)+(4))>>2)];
      var $13=$io2;
      var $tt_=(($13+8)|0);
      var $14=HEAP32[(($tt_)>>2)];
      var $15=$io1;
      var $tt_6=(($15+8)|0);
      HEAP32[(($tt_6)>>2)]=$14;
      var $16=$t;
      var $value_7=(($16)|0);
      var $gc8=$value_7;
      var $17=HEAP32[(($gc8)>>2)];
      var $h9=$17;
      var $flags=(($h9+6)|0);
      HEAP8[($flags)]=0;
      var $18=$L_addr;
      var $top10=(($18+8)|0);
      var $19=HEAP32[(($top10)>>2)];
      var $add_ptr11=((($19)-(12))|0);
      var $tt_12=(($add_ptr11+8)|0);
      var $20=HEAP32[(($tt_12)>>2)];
      var $and=$20 & 64;
      var $tobool=(($and)|0)!=0;
      if ($tobool) { label = 3; break; } else { label = 6; break; }
    case 3: 
      var $21=$L_addr;
      var $top13=(($21+8)|0);
      var $22=HEAP32[(($top13)>>2)];
      var $add_ptr14=((($22)-(12))|0);
      var $value_15=(($add_ptr14)|0);
      var $gc16=$value_15;
      var $23=HEAP32[(($gc16)>>2)];
      var $gch=$23;
      var $marked=(($gch+5)|0);
      var $24=HEAP8[($marked)];
      var $conv=(($24)&255);
      var $and17=$conv & 3;
      var $tobool18=(($and17)|0)!=0;
      if ($tobool18) { label = 4; break; } else { label = 6; break; }
    case 4: 
      var $25=$t;
      var $value_20=(($25)|0);
      var $gc21=$value_20;
      var $26=HEAP32[(($gc21)>>2)];
      var $gch22=$26;
      var $marked23=(($gch22+5)|0);
      var $27=HEAP8[($marked23)];
      var $conv24=(($27)&255);
      var $and25=$conv24 & 4;
      var $tobool26=(($and25)|0)!=0;
      if ($tobool26) { label = 5; break; } else { label = 6; break; }
    case 5: 
      var $28=$L_addr;
      var $29=$t;
      var $value_27=(($29)|0);
      var $gc28=$value_27;
      var $30=HEAP32[(($gc28)>>2)];
      _luaC_barrierback_($28, $30);
      label = 6; break;
    case 6: 
      var $31=$L_addr;
      var $top29=(($31+8)|0);
      var $32=HEAP32[(($top29)>>2)];
      var $add_ptr30=((($32)-(24))|0);
      HEAP32[(($top29)>>2)]=$add_ptr30;

      Module.print(INDENT + 'Exiting: _lua_rawset');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_lua_rawset["X"]=1;

function _lua_rawseti($L, $idx, $n) {
  var label = 0;

  Module.print(INDENT + ' Entering: _lua_rawseti: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $L_addr;
      var $idx_addr;
      var $n_addr;
      var $t;
      $L_addr=$L;
      $idx_addr=$idx;
      $n_addr=$n;
      var $0=$L_addr;
      var $1=$idx_addr;
      var $call=_index2addr($0, $1);
      $t=$call;
      var $2=$L_addr;
      var $3=$t;
      var $value_=(($3)|0);
      var $gc=$value_;
      var $4=HEAP32[(($gc)>>2)];
      var $h=$4;
      var $5=$n_addr;
      var $6=$L_addr;
      var $top=(($6+8)|0);
      var $7=HEAP32[(($top)>>2)];
      var $add_ptr=((($7)-(12))|0);
      _luaH_setint($2, $h, $5, $add_ptr);
      var $8=$L_addr;
      var $top1=(($8+8)|0);
      var $9=HEAP32[(($top1)>>2)];
      var $add_ptr2=((($9)-(12))|0);
      var $tt_=(($add_ptr2+8)|0);
      var $10=HEAP32[(($tt_)>>2)];
      var $and=$10 & 64;
      var $tobool=(($and)|0)!=0;
      if ($tobool) { label = 3; break; } else { label = 6; break; }
    case 3: 
      var $11=$L_addr;
      var $top3=(($11+8)|0);
      var $12=HEAP32[(($top3)>>2)];
      var $add_ptr4=((($12)-(12))|0);
      var $value_5=(($add_ptr4)|0);
      var $gc6=$value_5;
      var $13=HEAP32[(($gc6)>>2)];
      var $gch=$13;
      var $marked=(($gch+5)|0);
      var $14=HEAP8[($marked)];
      var $conv=(($14)&255);
      var $and7=$conv & 3;
      var $tobool8=(($and7)|0)!=0;
      if ($tobool8) { label = 4; break; } else { label = 6; break; }
    case 4: 
      var $15=$t;
      var $value_10=(($15)|0);
      var $gc11=$value_10;
      var $16=HEAP32[(($gc11)>>2)];
      var $gch12=$16;
      var $marked13=(($gch12+5)|0);
      var $17=HEAP8[($marked13)];
      var $conv14=(($17)&255);
      var $and15=$conv14 & 4;
      var $tobool16=(($and15)|0)!=0;
      if ($tobool16) { label = 5; break; } else { label = 6; break; }
    case 5: 
      var $18=$L_addr;
      var $19=$t;
      var $value_17=(($19)|0);
      var $gc18=$value_17;
      var $20=HEAP32[(($gc18)>>2)];
      _luaC_barrierback_($18, $20);
      label = 6; break;
    case 6: 
      var $21=$L_addr;
      var $top19=(($21+8)|0);
      var $22=HEAP32[(($top19)>>2)];
      var $incdec_ptr=((($22)-(12))|0);
      HEAP32[(($top19)>>2)]=$incdec_ptr;

      Module.print(INDENT + 'Exiting: _lua_rawseti');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_lua_rawseti["X"]=1;

function _lua_rawsetp($L, $idx, $p) {
  var label = 0;
  var __stackBase__  = STACKTOP; STACKTOP = (STACKTOP + 12)|0; _memset(__stackBase__, 0, 12);
  Module.print(INDENT + ' Entering: _lua_rawsetp: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $L_addr;
      var $idx_addr;
      var $p_addr;
      var $t;
      var $k=__stackBase__;
      var $io;
      var $io2;
      var $io1;
      $L_addr=$L;
      $idx_addr=$idx;
      $p_addr=$p;
      var $0=$L_addr;
      var $1=$idx_addr;
      var $call=_index2addr($0, $1);
      $t=$call;
      $io=$k;
      var $2=$p_addr;
      var $3=$io;
      var $value_=(($3)|0);
      var $p1=$value_;
      HEAP32[(($p1)>>2)]=$2;
      var $4=$io;
      var $tt_=(($4+8)|0);
      HEAP32[(($tt_)>>2)]=2;
      var $5=$L_addr;
      var $top=(($5+8)|0);
      var $6=HEAP32[(($top)>>2)];
      var $add_ptr=((($6)-(12))|0);
      $io2=$add_ptr;
      var $7=$L_addr;
      var $8=$t;
      var $value_2=(($8)|0);
      var $gc=$value_2;
      var $9=HEAP32[(($gc)>>2)];
      var $h=$9;
      var $call3=_luaH_set($7, $h, $k);
      $io1=$call3;
      var $10=$io1;
      var $value_4=(($10)|0);
      var $11=$io2;
      var $value_5=(($11)|0);
      var $12=$value_4;
      var $13=$value_5;
      HEAP32[(($12)>>2)]=HEAP32[(($13)>>2)];HEAP32[((($12)+(4))>>2)]=HEAP32[((($13)+(4))>>2)];
      var $14=$io2;
      var $tt_6=(($14+8)|0);
      var $15=HEAP32[(($tt_6)>>2)];
      var $16=$io1;
      var $tt_7=(($16+8)|0);
      HEAP32[(($tt_7)>>2)]=$15;
      var $17=$L_addr;
      var $top8=(($17+8)|0);
      var $18=HEAP32[(($top8)>>2)];
      var $add_ptr9=((($18)-(12))|0);
      var $tt_10=(($add_ptr9+8)|0);
      var $19=HEAP32[(($tt_10)>>2)];
      var $and=$19 & 64;
      var $tobool=(($and)|0)!=0;
      if ($tobool) { label = 3; break; } else { label = 6; break; }
    case 3: 
      var $20=$L_addr;
      var $top11=(($20+8)|0);
      var $21=HEAP32[(($top11)>>2)];
      var $add_ptr12=((($21)-(12))|0);
      var $value_13=(($add_ptr12)|0);
      var $gc14=$value_13;
      var $22=HEAP32[(($gc14)>>2)];
      var $gch=$22;
      var $marked=(($gch+5)|0);
      var $23=HEAP8[($marked)];
      var $conv=(($23)&255);
      var $and15=$conv & 3;
      var $tobool16=(($and15)|0)!=0;
      if ($tobool16) { label = 4; break; } else { label = 6; break; }
    case 4: 
      var $24=$t;
      var $value_18=(($24)|0);
      var $gc19=$value_18;
      var $25=HEAP32[(($gc19)>>2)];
      var $gch20=$25;
      var $marked21=(($gch20+5)|0);
      var $26=HEAP8[($marked21)];
      var $conv22=(($26)&255);
      var $and23=$conv22 & 4;
      var $tobool24=(($and23)|0)!=0;
      if ($tobool24) { label = 5; break; } else { label = 6; break; }
    case 5: 
      var $27=$L_addr;
      var $28=$t;
      var $value_25=(($28)|0);
      var $gc26=$value_25;
      var $29=HEAP32[(($gc26)>>2)];
      _luaC_barrierback_($27, $29);
      label = 6; break;
    case 6: 
      var $30=$L_addr;
      var $top27=(($30+8)|0);
      var $31=HEAP32[(($top27)>>2)];
      var $incdec_ptr=((($31)-(12))|0);
      HEAP32[(($top27)>>2)]=$incdec_ptr;
      STACKTOP = __stackBase__;
      Module.print(INDENT + 'Exiting: _lua_rawsetp');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_lua_rawsetp["X"]=1;

function _lua_setmetatable($L, $objindex) {
  var label = 0;

  Module.print(INDENT + ' Entering: _lua_setmetatable: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $L_addr;
      var $objindex_addr;
      var $obj;
      var $mt;
      $L_addr=$L;
      $objindex_addr=$objindex;
      var $0=$L_addr;
      var $1=$objindex_addr;
      var $call=_index2addr($0, $1);
      $obj=$call;
      var $2=$L_addr;
      var $top=(($2+8)|0);
      var $3=HEAP32[(($top)>>2)];
      var $add_ptr=((($3)-(12))|0);
      var $tt_=(($add_ptr+8)|0);
      var $4=HEAP32[(($tt_)>>2)];
      var $cmp=(($4)|0)==0;
      if ($cmp) { label = 3; break; } else { label = 4; break; }
    case 3: 
      $mt=0;
      label = 5; break;
    case 4: 
      var $5=$L_addr;
      var $top1=(($5+8)|0);
      var $6=HEAP32[(($top1)>>2)];
      var $add_ptr2=((($6)-(12))|0);
      var $value_=(($add_ptr2)|0);
      var $gc=$value_;
      var $7=HEAP32[(($gc)>>2)];
      var $h=$7;
      $mt=$h;
      label = 5; break;
    case 5: 
      var $8=$obj;
      var $tt_3=(($8+8)|0);
      var $9=HEAP32[(($tt_3)>>2)];
      var $and=$9 & 15;
      if ((($and)|0)==5) {
        label = 6; break;
      }
      else if ((($and)|0)==7) {
        label = 12; break;
      }
      else {
      label = 18; break;
      }
      
    case 6: 
      var $10=$mt;
      var $11=$obj;
      var $value_4=(($11)|0);
      var $gc5=$value_4;
      var $12=HEAP32[(($gc5)>>2)];
      var $h6=$12;
      var $metatable=(($h6+8)|0);
      HEAP32[(($metatable)>>2)]=$10;
      var $13=$mt;
      var $tobool=(($13)|0)!=0;
      if ($tobool) { label = 7; break; } else { label = 11; break; }
    case 7: 
      var $14=$mt;
      var $15=$14;
      var $gch=$15;
      var $marked=(($gch+5)|0);
      var $16=HEAP8[($marked)];
      var $conv=(($16)&255);
      var $and8=$conv & 3;
      var $tobool9=(($and8)|0)!=0;
      if ($tobool9) { label = 8; break; } else { label = 10; break; }
    case 8: 
      var $17=$obj;
      var $value_10=(($17)|0);
      var $gc11=$value_10;
      var $18=HEAP32[(($gc11)>>2)];
      var $gch12=$18;
      var $marked13=(($gch12+5)|0);
      var $19=HEAP8[($marked13)];
      var $conv14=(($19)&255);
      var $and15=$conv14 & 4;
      var $tobool16=(($and15)|0)!=0;
      if ($tobool16) { label = 9; break; } else { label = 10; break; }
    case 9: 
      var $20=$L_addr;
      var $21=$obj;
      var $value_18=(($21)|0);
      var $gc19=$value_18;
      var $22=HEAP32[(($gc19)>>2)];
      _luaC_barrierback_($20, $22);
      label = 10; break;
    case 10: 
      label = 11; break;
    case 11: 
      var $23=$L_addr;
      var $24=$obj;
      var $value_22=(($24)|0);
      var $gc23=$value_22;
      var $25=HEAP32[(($gc23)>>2)];
      var $26=$mt;
      _luaC_checkfinalizer($23, $25, $26);
      label = 19; break;
    case 12: 
      var $27=$mt;
      var $28=$obj;
      var $value_25=(($28)|0);
      var $gc26=$value_25;
      var $29=HEAP32[(($gc26)>>2)];
      var $u=$29;
      var $uv=$u;
      var $metatable27=(($uv+8)|0);
      HEAP32[(($metatable27)>>2)]=$27;
      var $30=$mt;
      var $tobool28=(($30)|0)!=0;
      if ($tobool28) { label = 13; break; } else { label = 17; break; }
    case 13: 
      var $31=$mt;
      var $32=$31;
      var $gch30=$32;
      var $marked31=(($gch30+5)|0);
      var $33=HEAP8[($marked31)];
      var $conv32=(($33)&255);
      var $and33=$conv32 & 3;
      var $tobool34=(($and33)|0)!=0;
      if ($tobool34) { label = 14; break; } else { label = 16; break; }
    case 14: 
      var $34=$obj;
      var $value_36=(($34)|0);
      var $gc37=$value_36;
      var $35=HEAP32[(($gc37)>>2)];
      var $u38=$35;
      var $36=$u38;
      var $gch39=$36;
      var $marked40=(($gch39+5)|0);
      var $37=HEAP8[($marked40)];
      var $conv41=(($37)&255);
      var $and42=$conv41 & 4;
      var $tobool43=(($and42)|0)!=0;
      if ($tobool43) { label = 15; break; } else { label = 16; break; }
    case 15: 
      var $38=$L_addr;
      var $39=$obj;
      var $value_45=(($39)|0);
      var $gc46=$value_45;
      var $40=HEAP32[(($gc46)>>2)];
      var $u47=$40;
      var $41=$u47;
      var $42=$mt;
      var $43=$42;
      _luaC_barrier_($38, $41, $43);
      label = 16; break;
    case 16: 
      var $44=$L_addr;
      var $45=$obj;
      var $value_49=(($45)|0);
      var $gc50=$value_49;
      var $46=HEAP32[(($gc50)>>2)];
      var $47=$mt;
      _luaC_checkfinalizer($44, $46, $47);
      label = 17; break;
    case 17: 
      label = 19; break;
    case 18: 
      var $48=$mt;
      var $49=$obj;
      var $tt_52=(($49+8)|0);
      var $50=HEAP32[(($tt_52)>>2)];
      var $and53=$50 & 15;
      var $51=$L_addr;
      var $l_G=(($51+12)|0);
      var $52=HEAP32[(($l_G)>>2)];
      var $mt54=(($52+232)|0);
      var $arrayidx=(($mt54+($and53<<2))|0);
      HEAP32[(($arrayidx)>>2)]=$48;
      label = 19; break;
    case 19: 
      var $53=$L_addr;
      var $top55=(($53+8)|0);
      var $54=HEAP32[(($top55)>>2)];
      var $incdec_ptr=((($54)-(12))|0);
      HEAP32[(($top55)>>2)]=$incdec_ptr;

      Module.print(INDENT + 'Exiting: _lua_setmetatable');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return 1;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_lua_setmetatable["X"]=1;

function _lua_setuservalue($L, $idx) {
  var label = 0;

  Module.print(INDENT + ' Entering: _lua_setuservalue: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $L_addr;
      var $idx_addr;
      var $o;
      $L_addr=$L;
      $idx_addr=$idx;
      var $0=$L_addr;
      var $1=$idx_addr;
      var $call=_index2addr($0, $1);
      $o=$call;
      var $2=$L_addr;
      var $top=(($2+8)|0);
      var $3=HEAP32[(($top)>>2)];
      var $add_ptr=((($3)-(12))|0);
      var $tt_=(($add_ptr+8)|0);
      var $4=HEAP32[(($tt_)>>2)];
      var $cmp=(($4)|0)==0;
      if ($cmp) { label = 3; break; } else { label = 4; break; }
    case 3: 
      var $5=$o;
      var $value_=(($5)|0);
      var $gc=$value_;
      var $6=HEAP32[(($gc)>>2)];
      var $u=$6;
      var $uv=$u;
      var $env=(($uv+12)|0);
      HEAP32[(($env)>>2)]=0;
      label = 8; break;
    case 4: 
      var $7=$L_addr;
      var $top1=(($7+8)|0);
      var $8=HEAP32[(($top1)>>2)];
      var $add_ptr2=((($8)-(12))|0);
      var $value_3=(($add_ptr2)|0);
      var $gc4=$value_3;
      var $9=HEAP32[(($gc4)>>2)];
      var $h=$9;
      var $10=$o;
      var $value_5=(($10)|0);
      var $gc6=$value_5;
      var $11=HEAP32[(($gc6)>>2)];
      var $u7=$11;
      var $uv8=$u7;
      var $env9=(($uv8+12)|0);
      HEAP32[(($env9)>>2)]=$h;
      var $12=$L_addr;
      var $top10=(($12+8)|0);
      var $13=HEAP32[(($top10)>>2)];
      var $add_ptr11=((($13)-(12))|0);
      var $value_12=(($add_ptr11)|0);
      var $gc13=$value_12;
      var $14=HEAP32[(($gc13)>>2)];
      var $h14=$14;
      var $15=$h14;
      var $gch=$15;
      var $marked=(($gch+5)|0);
      var $16=HEAP8[($marked)];
      var $conv=(($16)&255);
      var $and=$conv & 3;
      var $tobool=(($and)|0)!=0;
      if ($tobool) { label = 5; break; } else { label = 7; break; }
    case 5: 
      var $17=$o;
      var $value_15=(($17)|0);
      var $gc16=$value_15;
      var $18=HEAP32[(($gc16)>>2)];
      var $gch17=$18;
      var $marked18=(($gch17+5)|0);
      var $19=HEAP8[($marked18)];
      var $conv19=(($19)&255);
      var $and20=$conv19 & 4;
      var $tobool21=(($and20)|0)!=0;
      if ($tobool21) { label = 6; break; } else { label = 7; break; }
    case 6: 
      var $20=$L_addr;
      var $21=$o;
      var $value_23=(($21)|0);
      var $gc24=$value_23;
      var $22=HEAP32[(($gc24)>>2)];
      var $23=$L_addr;
      var $top25=(($23+8)|0);
      var $24=HEAP32[(($top25)>>2)];
      var $add_ptr26=((($24)-(12))|0);
      var $value_27=(($add_ptr26)|0);
      var $gc28=$value_27;
      var $25=HEAP32[(($gc28)>>2)];
      var $h29=$25;
      var $26=$h29;
      _luaC_barrier_($20, $22, $26);
      label = 7; break;
    case 7: 
      label = 8; break;
    case 8: 
      var $27=$L_addr;
      var $top31=(($27+8)|0);
      var $28=HEAP32[(($top31)>>2)];
      var $incdec_ptr=((($28)-(12))|0);
      HEAP32[(($top31)>>2)]=$incdec_ptr;

      Module.print(INDENT + 'Exiting: _lua_setuservalue');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_lua_setuservalue["X"]=1;

function _lua_callk($L, $nargs, $nresults, $ctx, $k) {
  var label = 0;

  Module.print(INDENT + ' Entering: _lua_callk: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $L_addr;
      var $nargs_addr;
      var $nresults_addr;
      var $ctx_addr;
      var $k_addr;
      var $func;
      $L_addr=$L;
      $nargs_addr=$nargs;
      $nresults_addr=$nresults;
      $ctx_addr=$ctx;
      $k_addr=$k;
      var $0=$L_addr;
      var $top=(($0+8)|0);
      var $1=HEAP32[(($top)>>2)];
      var $2=$nargs_addr;
      var $add=((($2)+(1))|0);
      var $idx_neg=(((-$add))|0);
      var $add_ptr=(($1+((($idx_neg)*(12))&-1))|0);
      $func=$add_ptr;
      var $3=$k_addr;
      var $cmp=(($3)|0)!=0;
      if ($cmp) { label = 3; break; } else { label = 5; break; }
    case 3: 
      var $4=$L_addr;
      var $nny=(($4+36)|0);
      var $5=HEAP16[(($nny)>>1)];
      var $conv=(($5)&65535);
      var $cmp1=(($conv)|0)==0;
      if ($cmp1) { label = 4; break; } else { label = 5; break; }
    case 4: 
      var $6=$k_addr;
      var $7=$L_addr;
      var $ci=(($7+16)|0);
      var $8=HEAP32[(($ci)>>2)];
      var $u=(($8+24)|0);
      var $c=$u;
      var $k3=(($c+4)|0);
      HEAP32[(($k3)>>2)]=$6;
      var $9=$ctx_addr;
      var $10=$L_addr;
      var $ci4=(($10+16)|0);
      var $11=HEAP32[(($ci4)>>2)];
      var $u5=(($11+24)|0);
      var $c6=$u5;
      var $ctx7=(($c6)|0);
      HEAP32[(($ctx7)>>2)]=$9;
      var $12=$L_addr;
      var $13=$func;
      var $14=$nresults_addr;
      _luaD_call($12, $13, $14, 1);
      label = 6; break;
    case 5: 
      var $15=$L_addr;
      var $16=$func;
      var $17=$nresults_addr;
      _luaD_call($15, $16, $17, 0);
      label = 6; break;
    case 6: 
      var $18=$nresults_addr;
      var $cmp8=(($18)|0)==-1;
      if ($cmp8) { label = 7; break; } else { label = 9; break; }
    case 7: 
      var $19=$L_addr;
      var $ci11=(($19+16)|0);
      var $20=HEAP32[(($ci11)>>2)];
      var $top12=(($20+4)|0);
      var $21=HEAP32[(($top12)>>2)];
      var $22=$L_addr;
      var $top13=(($22+8)|0);
      var $23=HEAP32[(($top13)>>2)];
      var $cmp14=(($21)>>>0) < (($23)>>>0);
      if ($cmp14) { label = 8; break; } else { label = 9; break; }
    case 8: 
      var $24=$L_addr;
      var $top17=(($24+8)|0);
      var $25=HEAP32[(($top17)>>2)];
      var $26=$L_addr;
      var $ci18=(($26+16)|0);
      var $27=HEAP32[(($ci18)>>2)];
      var $top19=(($27+4)|0);
      HEAP32[(($top19)>>2)]=$25;
      label = 9; break;
    case 9: 

      Module.print(INDENT + 'Exiting: _lua_callk');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_lua_callk["X"]=1;

function _lua_status($L) {
  var label = 0;

  Module.print(INDENT + ' Entering: _lua_status: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';

  var $L_addr;
  $L_addr=$L;
  var $0=$L_addr;
  var $status=(($0+6)|0);
  var $1=HEAP8[($status)];
  var $conv=(($1)&255);

  Module.print(INDENT + 'Exiting: _lua_status');
  INDENT = INDENT.substr(0, INDENT.length-2);
  return $conv;
  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _lua_getallocf($L, $ud) {
  var label = 0;

  Module.print(INDENT + ' Entering: _lua_getallocf: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $L_addr;
      var $ud_addr;
      var $f;
      $L_addr=$L;
      $ud_addr=$ud;
      var $0=$ud_addr;
      var $tobool=(($0)|0)!=0;
      if ($tobool) { label = 3; break; } else { label = 4; break; }
    case 3: 
      var $1=$L_addr;
      var $l_G=(($1+12)|0);
      var $2=HEAP32[(($l_G)>>2)];
      var $ud1=(($2+4)|0);
      var $3=HEAP32[(($ud1)>>2)];
      var $4=$ud_addr;
      HEAP32[(($4)>>2)]=$3;
      label = 4; break;
    case 4: 
      var $5=$L_addr;
      var $l_G2=(($5+12)|0);
      var $6=HEAP32[(($l_G2)>>2)];
      var $frealloc=(($6)|0);
      var $7=HEAP32[(($frealloc)>>2)];
      $f=$7;
      var $8=$f;

      Module.print(INDENT + 'Exiting: _lua_getallocf');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return $8;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _lua_setallocf($L, $f, $ud) {
  var label = 0;

  Module.print(INDENT + ' Entering: _lua_setallocf: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';

  var $L_addr;
  var $f_addr;
  var $ud_addr;
  $L_addr=$L;
  $f_addr=$f;
  $ud_addr=$ud;
  var $0=$ud_addr;
  var $1=$L_addr;
  var $l_G=(($1+12)|0);
  var $2=HEAP32[(($l_G)>>2)];
  var $ud1=(($2+4)|0);
  HEAP32[(($ud1)>>2)]=$0;
  var $3=$f_addr;
  var $4=$L_addr;
  var $l_G2=(($4+12)|0);
  var $5=HEAP32[(($l_G2)>>2)];
  var $frealloc=(($5)|0);
  HEAP32[(($frealloc)>>2)]=$3;

  Module.print(INDENT + 'Exiting: _lua_setallocf');
  INDENT = INDENT.substr(0, INDENT.length-2);
  return;
  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _lua_pcallk($L, $nargs, $nresults, $errfunc, $ctx, $k) {
  var label = 0;
  var __stackBase__  = STACKTOP; STACKTOP = (STACKTOP + 8)|0; _memset(__stackBase__, 0, 8);
  Module.print(INDENT + ' Entering: _lua_pcallk: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $L_addr;
      var $nargs_addr;
      var $nresults_addr;
      var $errfunc_addr;
      var $ctx_addr;
      var $k_addr;
      var $c=__stackBase__;
      var $status;
      var $func;
      var $o;
      var $ci;
      $L_addr=$L;
      $nargs_addr=$nargs;
      $nresults_addr=$nresults;
      $errfunc_addr=$errfunc;
      $ctx_addr=$ctx;
      $k_addr=$k;
      var $0=$errfunc_addr;
      var $cmp=(($0)|0)==0;
      if ($cmp) { label = 3; break; } else { label = 4; break; }
    case 3: 
      $func=0;
      label = 5; break;
    case 4: 
      var $1=$L_addr;
      var $2=$errfunc_addr;
      var $call=_index2addr($1, $2);
      $o=$call;
      var $3=$o;
      var $4=$3;
      var $5=$L_addr;
      var $stack=(($5+28)|0);
      var $6=HEAP32[(($stack)>>2)];
      var $7=$6;
      var $sub_ptr_lhs_cast=$4;
      var $sub_ptr_rhs_cast=$7;
      var $sub_ptr_sub=((($sub_ptr_lhs_cast)-($sub_ptr_rhs_cast))|0);
      $func=$sub_ptr_sub;
      label = 5; break;
    case 5: 
      var $8=$L_addr;
      var $top=(($8+8)|0);
      var $9=HEAP32[(($top)>>2)];
      var $10=$nargs_addr;
      var $add=((($10)+(1))|0);
      var $idx_neg=(((-$add))|0);
      var $add_ptr=(($9+((($idx_neg)*(12))&-1))|0);
      var $func1=(($c)|0);
      HEAP32[(($func1)>>2)]=$add_ptr;
      var $11=$k_addr;
      var $cmp2=(($11)|0)==0;
      if ($cmp2) { label = 7; break; } else { label = 6; break; }
    case 6: 
      var $12=$L_addr;
      var $nny=(($12+36)|0);
      var $13=HEAP16[(($nny)>>1)];
      var $conv=(($13)&65535);
      var $cmp3=(($conv)|0) > 0;
      if ($cmp3) { label = 7; break; } else { label = 8; break; }
    case 7: 
      var $14=$nresults_addr;
      var $nresults6=(($c+4)|0);
      HEAP32[(($nresults6)>>2)]=$14;
      var $15=$L_addr;
      var $16=$c;
      var $func7=(($c)|0);
      var $17=HEAP32[(($func7)>>2)];
      var $18=$17;
      var $19=$L_addr;
      var $stack8=(($19+28)|0);
      var $20=HEAP32[(($stack8)>>2)];
      var $21=$20;
      var $sub_ptr_lhs_cast9=$18;
      var $sub_ptr_rhs_cast10=$21;
      var $sub_ptr_sub11=((($sub_ptr_lhs_cast9)-($sub_ptr_rhs_cast10))|0);
      var $22=$func;
      var $call12=_luaD_pcall($15, 6, $16, $sub_ptr_sub11, $22);
      $status=$call12;
      label = 9; break;
    case 8: 
      var $23=$L_addr;
      var $ci14=(($23+16)|0);
      var $24=HEAP32[(($ci14)>>2)];
      $ci=$24;
      var $25=$k_addr;
      var $26=$ci;
      var $u=(($26+24)|0);
      var $c15=$u;
      var $k16=(($c15+4)|0);
      HEAP32[(($k16)>>2)]=$25;
      var $27=$ctx_addr;
      var $28=$ci;
      var $u17=(($28+24)|0);
      var $c18=$u17;
      var $ctx19=(($c18)|0);
      HEAP32[(($ctx19)>>2)]=$27;
      var $func20=(($c)|0);
      var $29=HEAP32[(($func20)>>2)];
      var $30=$29;
      var $31=$L_addr;
      var $stack21=(($31+28)|0);
      var $32=HEAP32[(($stack21)>>2)];
      var $33=$32;
      var $sub_ptr_lhs_cast22=$30;
      var $sub_ptr_rhs_cast23=$33;
      var $sub_ptr_sub24=((($sub_ptr_lhs_cast22)-($sub_ptr_rhs_cast23))|0);
      var $34=$ci;
      var $extra=(($34+20)|0);
      HEAP32[(($extra)>>2)]=$sub_ptr_sub24;
      var $35=$L_addr;
      var $allowhook=(($35+41)|0);
      var $36=HEAP8[($allowhook)];
      var $37=$ci;
      var $u25=(($37+24)|0);
      var $c26=$u25;
      var $old_allowhook=(($c26+12)|0);
      HEAP8[($old_allowhook)]=$36;
      var $38=$L_addr;
      var $errfunc27=(($38+68)|0);
      var $39=HEAP32[(($errfunc27)>>2)];
      var $40=$ci;
      var $u28=(($40+24)|0);
      var $c29=$u28;
      var $old_errfunc=(($c29+8)|0);
      HEAP32[(($old_errfunc)>>2)]=$39;
      var $41=$func;
      var $42=$L_addr;
      var $errfunc30=(($42+68)|0);
      HEAP32[(($errfunc30)>>2)]=$41;
      var $43=$ci;
      var $callstatus=(($43+18)|0);
      var $44=HEAP8[($callstatus)];
      var $conv31=(($44)&255);
      var $or=$conv31 | 16;
      var $conv32=(($or) & 255);
      HEAP8[($callstatus)]=$conv32;
      var $45=$L_addr;
      var $func33=(($c)|0);
      var $46=HEAP32[(($func33)>>2)];
      var $47=$nresults_addr;
      _luaD_call($45, $46, $47, 1);
      var $48=$ci;
      var $callstatus34=(($48+18)|0);
      var $49=HEAP8[($callstatus34)];
      var $conv35=(($49)&255);
      var $and=$conv35 & -17;
      var $conv36=(($and) & 255);
      HEAP8[($callstatus34)]=$conv36;
      var $50=$ci;
      var $u37=(($50+24)|0);
      var $c38=$u37;
      var $old_errfunc39=(($c38+8)|0);
      var $51=HEAP32[(($old_errfunc39)>>2)];
      var $52=$L_addr;
      var $errfunc40=(($52+68)|0);
      HEAP32[(($errfunc40)>>2)]=$51;
      $status=0;
      label = 9; break;
    case 9: 
      var $53=$nresults_addr;
      var $cmp42=(($53)|0)==-1;
      if ($cmp42) { label = 10; break; } else { label = 12; break; }
    case 10: 
      var $54=$L_addr;
      var $ci44=(($54+16)|0);
      var $55=HEAP32[(($ci44)>>2)];
      var $top45=(($55+4)|0);
      var $56=HEAP32[(($top45)>>2)];
      var $57=$L_addr;
      var $top46=(($57+8)|0);
      var $58=HEAP32[(($top46)>>2)];
      var $cmp47=(($56)>>>0) < (($58)>>>0);
      if ($cmp47) { label = 11; break; } else { label = 12; break; }
    case 11: 
      var $59=$L_addr;
      var $top50=(($59+8)|0);
      var $60=HEAP32[(($top50)>>2)];
      var $61=$L_addr;
      var $ci51=(($61+16)|0);
      var $62=HEAP32[(($ci51)>>2)];
      var $top52=(($62+4)|0);
      HEAP32[(($top52)>>2)]=$60;
      label = 12; break;
    case 12: 
      var $63=$status;
      STACKTOP = __stackBase__;
      Module.print(INDENT + 'Exiting: _lua_pcallk');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return $63;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_lua_pcallk["X"]=1;

function _f_call($L, $ud) {
  var label = 0;

  Module.print(INDENT + ' Entering: _f_call: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';

  var $L_addr;
  var $ud_addr;
  var $c;
  $L_addr=$L;
  $ud_addr=$ud;
  var $0=$ud_addr;
  var $1=$0;
  $c=$1;
  var $2=$L_addr;
  var $3=$c;
  var $func=(($3)|0);
  var $4=HEAP32[(($func)>>2)];
  var $5=$c;
  var $nresults=(($5+4)|0);
  var $6=HEAP32[(($nresults)>>2)];
  _luaD_call($2, $4, $6, 0);

  Module.print(INDENT + 'Exiting: _f_call');
  INDENT = INDENT.substr(0, INDENT.length-2);
  return;
  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _lua_load($L, $reader, $data, $chunkname, $mode) {
  var label = 0;
  var __stackBase__  = STACKTOP; STACKTOP = (STACKTOP + 20)|0; _memset(__stackBase__, 0, 20);
  Module.print(INDENT + ' Entering: _lua_load: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $L_addr;
      var $reader_addr;
      var $data_addr;
      var $chunkname_addr;
      var $mode_addr;
      var $z=__stackBase__;
      var $status;
      var $f;
      var $reg;
      var $gt;
      var $io2;
      var $io1;
      $L_addr=$L;
      $reader_addr=$reader;
      $data_addr=$data;
      $chunkname_addr=$chunkname;
      $mode_addr=$mode;
      var $0=$chunkname_addr;
      var $tobool=(($0)|0)!=0;
      if ($tobool) { label = 4; break; } else { label = 3; break; }
    case 3: 
      $chunkname_addr=((5247220)|0);
      label = 4; break;
    case 4: 
      var $1=$L_addr;
      var $2=$reader_addr;
      var $3=$data_addr;
      _luaZ_init($1, $z, $2, $3);
      var $4=$L_addr;
      var $5=$chunkname_addr;
      var $6=$mode_addr;
      var $call=_luaD_protectedparser($4, $z, $5, $6);
      $status=$call;
      var $7=$status;
      var $cmp=(($7)|0)==0;
      if ($cmp) { label = 5; break; } else { label = 12; break; }
    case 5: 
      var $8=$L_addr;
      var $top=(($8+8)|0);
      var $9=HEAP32[(($top)>>2)];
      var $add_ptr=((($9)-(12))|0);
      var $value_=(($add_ptr)|0);
      var $gc=$value_;
      var $10=HEAP32[(($gc)>>2)];
      var $cl=$10;
      var $l=$cl;
      $f=$l;
      var $11=$f;
      var $nupvalues=(($11+6)|0);
      var $12=HEAP8[($nupvalues)];
      var $conv=(($12)&255);
      var $cmp2=(($conv)|0)==1;
      if ($cmp2) { label = 6; break; } else { label = 11; break; }
    case 6: 
      var $13=$L_addr;
      var $l_G=(($13+12)|0);
      var $14=HEAP32[(($l_G)>>2)];
      var $l_registry=(($14+36)|0);
      var $value_5=(($l_registry)|0);
      var $gc6=$value_5;
      var $15=HEAP32[(($gc6)>>2)];
      var $h=$15;
      $reg=$h;
      var $16=$reg;
      var $call7=_luaH_getint($16, 2);
      $gt=$call7;
      var $17=$gt;
      $io2=$17;
      var $18=$f;
      var $upvals=(($18+16)|0);
      var $arrayidx=(($upvals)|0);
      var $19=HEAP32[(($arrayidx)>>2)];
      var $v=(($19+8)|0);
      var $20=HEAP32[(($v)>>2)];
      $io1=$20;
      var $21=$io1;
      var $value_8=(($21)|0);
      var $22=$io2;
      var $value_9=(($22)|0);
      var $23=$value_8;
      var $24=$value_9;
      HEAP32[(($23)>>2)]=HEAP32[(($24)>>2)];HEAP32[((($23)+(4))>>2)]=HEAP32[((($24)+(4))>>2)];
      var $25=$io2;
      var $tt_=(($25+8)|0);
      var $26=HEAP32[(($tt_)>>2)];
      var $27=$io1;
      var $tt_10=(($27+8)|0);
      HEAP32[(($tt_10)>>2)]=$26;
      var $28=$gt;
      var $tt_11=(($28+8)|0);
      var $29=HEAP32[(($tt_11)>>2)];
      var $and=$29 & 64;
      var $tobool12=(($and)|0)!=0;
      if ($tobool12) { label = 7; break; } else { label = 10; break; }
    case 7: 
      var $30=$gt;
      var $value_13=(($30)|0);
      var $gc14=$value_13;
      var $31=HEAP32[(($gc14)>>2)];
      var $gch=$31;
      var $marked=(($gch+5)|0);
      var $32=HEAP8[($marked)];
      var $conv15=(($32)&255);
      var $and16=$conv15 & 3;
      var $tobool17=(($and16)|0)!=0;
      if ($tobool17) { label = 8; break; } else { label = 10; break; }
    case 8: 
      var $33=$f;
      var $upvals19=(($33+16)|0);
      var $arrayidx20=(($upvals19)|0);
      var $34=HEAP32[(($arrayidx20)>>2)];
      var $35=$34;
      var $gch21=$35;
      var $marked22=(($gch21+5)|0);
      var $36=HEAP8[($marked22)];
      var $conv23=(($36)&255);
      var $and24=$conv23 & 4;
      var $tobool25=(($and24)|0)!=0;
      if ($tobool25) { label = 9; break; } else { label = 10; break; }
    case 9: 
      var $37=$L_addr;
      var $38=$f;
      var $upvals27=(($38+16)|0);
      var $arrayidx28=(($upvals27)|0);
      var $39=HEAP32[(($arrayidx28)>>2)];
      var $40=$39;
      var $41=$gt;
      var $value_29=(($41)|0);
      var $gc30=$value_29;
      var $42=HEAP32[(($gc30)>>2)];
      _luaC_barrier_($37, $40, $42);
      label = 10; break;
    case 10: 
      label = 11; break;
    case 11: 
      label = 12; break;
    case 12: 
      var $43=$status;
      STACKTOP = __stackBase__;
      Module.print(INDENT + 'Exiting: _lua_load');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return $43;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_lua_load["X"]=1;

function _lua_dump($L, $writer, $data) {
  var label = 0;

  Module.print(INDENT + ' Entering: _lua_dump: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $L_addr;
      var $writer_addr;
      var $data_addr;
      var $status;
      var $o;
      $L_addr=$L;
      $writer_addr=$writer;
      $data_addr=$data;
      var $0=$L_addr;
      var $top=(($0+8)|0);
      var $1=HEAP32[(($top)>>2)];
      var $add_ptr=((($1)-(12))|0);
      $o=$add_ptr;
      var $2=$o;
      var $tt_=(($2+8)|0);
      var $3=HEAP32[(($tt_)>>2)];
      var $cmp=(($3)|0)==70;
      if ($cmp) { label = 3; break; } else { label = 4; break; }
    case 3: 
      var $4=$L_addr;
      var $5=$o;
      var $value_=(($5)|0);
      var $gc=$value_;
      var $6=HEAP32[(($gc)>>2)];
      var $cl=$6;
      var $l=$cl;
      var $p=(($l+12)|0);
      var $7=HEAP32[(($p)>>2)];
      var $8=$writer_addr;
      var $9=$data_addr;
      var $call=_luaU_dump($4, $7, $8, $9, 0);
      $status=$call;
      label = 5; break;
    case 4: 
      $status=1;
      label = 5; break;
    case 5: 
      var $10=$status;

      Module.print(INDENT + 'Exiting: _lua_dump');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return $10;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _lua_gc($L, $what, $data) {
  var label = 0;

  Module.print(INDENT + ' Entering: _lua_gc: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $L_addr;
      var $what_addr;
      var $data_addr;
      var $res;
      var $g;
      var $debt;
      $L_addr=$L;
      $what_addr=$what;
      $data_addr=$data;
      $res=0;
      var $0=$L_addr;
      var $l_G=(($0+12)|0);
      var $1=HEAP32[(($l_G)>>2)];
      $g=$1;
      var $2=$what_addr;
      if ((($2)|0)==0) {
        label = 3; break;
      }
      else if ((($2)|0)==1) {
        label = 4; break;
      }
      else if ((($2)|0)==2) {
        label = 5; break;
      }
      else if ((($2)|0)==3) {
        label = 6; break;
      }
      else if ((($2)|0)==4) {
        label = 7; break;
      }
      else if ((($2)|0)==5) {
        label = 8; break;
      }
      else if ((($2)|0)==6) {
        label = 16; break;
      }
      else if ((($2)|0)==8) {
        label = 17; break;
      }
      else if ((($2)|0)==7) {
        label = 18; break;
      }
      else if ((($2)|0)==9) {
        label = 19; break;
      }
      else if ((($2)|0)==10) {
        label = 20; break;
      }
      else if ((($2)|0)==11) {
        label = 21; break;
      }
      else {
      label = 22; break;
      }
      
    case 3: 
      var $3=$g;
      var $gcrunning=(($3+55)|0);
      HEAP8[($gcrunning)]=0;
      label = 23; break;
    case 4: 
      var $4=$g;
      _luaE_setdebt($4, 0);
      var $5=$g;
      var $gcrunning2=(($5+55)|0);
      HEAP8[($gcrunning2)]=1;
      label = 23; break;
    case 5: 
      var $6=$L_addr;
      _luaC_fullgc($6, 0);
      label = 23; break;
    case 6: 
      var $7=$g;
      var $totalbytes=(($7+8)|0);
      var $8=HEAP32[(($totalbytes)>>2)];
      var $9=$g;
      var $GCdebt=(($9+12)|0);
      var $10=HEAP32[(($GCdebt)>>2)];
      var $add=((($8)+($10))|0);
      var $shr=$add >>> 10;
      $res=$shr;
      label = 23; break;
    case 7: 
      var $11=$g;
      var $totalbytes6=(($11+8)|0);
      var $12=HEAP32[(($totalbytes6)>>2)];
      var $13=$g;
      var $GCdebt7=(($13+12)|0);
      var $14=HEAP32[(($GCdebt7)>>2)];
      var $add8=((($12)+($14))|0);
      var $and=$add8 & 1023;
      $res=$and;
      label = 23; break;
    case 8: 
      var $15=$g;
      var $gckind=(($15+54)|0);
      var $16=HEAP8[($gckind)];
      var $conv=(($16)&255);
      var $cmp=(($conv)|0)==2;
      if ($cmp) { label = 9; break; } else { label = 10; break; }
    case 9: 
      var $17=$g;
      var $GCestimate=(($17+20)|0);
      var $18=HEAP32[(($GCestimate)>>2)];
      var $cmp11=(($18)|0)==0;
      var $conv12=(($cmp11)&1);
      $res=$conv12;
      var $19=$L_addr;
      _luaC_forcestep($19);
      label = 15; break;
    case 10: 
      var $20=$data_addr;
      var $mul=($20<<10);
      var $sub=((($mul)-(1600))|0);
      $debt=$sub;
      var $21=$g;
      var $gcrunning13=(($21+55)|0);
      var $22=HEAP8[($gcrunning13)];
      var $tobool=(($22 << 24) >> 24)!=0;
      if ($tobool) { label = 11; break; } else { label = 12; break; }
    case 11: 
      var $23=$g;
      var $GCdebt15=(($23+12)|0);
      var $24=HEAP32[(($GCdebt15)>>2)];
      var $25=$debt;
      var $add16=((($25)+($24))|0);
      $debt=$add16;
      label = 12; break;
    case 12: 
      var $26=$g;
      var $27=$debt;
      _luaE_setdebt($26, $27);
      var $28=$L_addr;
      _luaC_forcestep($28);
      var $29=$g;
      var $gcstate=(($29+53)|0);
      var $30=HEAP8[($gcstate)];
      var $conv17=(($30)&255);
      var $cmp18=(($conv17)|0)==5;
      if ($cmp18) { label = 13; break; } else { label = 14; break; }
    case 13: 
      $res=1;
      label = 14; break;
    case 14: 
      label = 15; break;
    case 15: 
      label = 23; break;
    case 16: 
      var $31=$g;
      var $gcpause=(($31+136)|0);
      var $32=HEAP32[(($gcpause)>>2)];
      $res=$32;
      var $33=$data_addr;
      var $34=$g;
      var $gcpause24=(($34+136)|0);
      HEAP32[(($gcpause24)>>2)]=$33;
      label = 23; break;
    case 17: 
      var $35=$g;
      var $gcmajorinc=(($35+140)|0);
      var $36=HEAP32[(($gcmajorinc)>>2)];
      $res=$36;
      var $37=$data_addr;
      var $38=$g;
      var $gcmajorinc26=(($38+140)|0);
      HEAP32[(($gcmajorinc26)>>2)]=$37;
      label = 23; break;
    case 18: 
      var $39=$g;
      var $gcstepmul=(($39+144)|0);
      var $40=HEAP32[(($gcstepmul)>>2)];
      $res=$40;
      var $41=$data_addr;
      var $42=$g;
      var $gcstepmul28=(($42+144)|0);
      HEAP32[(($gcstepmul28)>>2)]=$41;
      label = 23; break;
    case 19: 
      var $43=$g;
      var $gcrunning30=(($43+55)|0);
      var $44=HEAP8[($gcrunning30)];
      var $conv31=(($44)&255);
      $res=$conv31;
      label = 23; break;
    case 20: 
      var $45=$L_addr;
      _luaC_changemode($45, 2);
      label = 23; break;
    case 21: 
      var $46=$L_addr;
      _luaC_changemode($46, 0);
      label = 23; break;
    case 22: 
      $res=-1;
      label = 23; break;
    case 23: 
      var $47=$res;

      Module.print(INDENT + 'Exiting: _lua_gc');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return $47;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_lua_gc["X"]=1;

function _lua_next($L, $idx) {
  var label = 0;

  Module.print(INDENT + ' Entering: _lua_next: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $L_addr;
      var $idx_addr;
      var $t;
      var $more;
      $L_addr=$L;
      $idx_addr=$idx;
      var $0=$L_addr;
      var $1=$idx_addr;
      var $call=_index2addr($0, $1);
      $t=$call;
      var $2=$L_addr;
      var $3=$t;
      var $value_=(($3)|0);
      var $gc=$value_;
      var $4=HEAP32[(($gc)>>2)];
      var $h=$4;
      var $5=$L_addr;
      var $top=(($5+8)|0);
      var $6=HEAP32[(($top)>>2)];
      var $add_ptr=((($6)-(12))|0);
      var $call1=_luaH_next($2, $h, $add_ptr);
      $more=$call1;
      var $7=$more;
      var $tobool=(($7)|0)!=0;
      if ($tobool) { label = 3; break; } else { label = 4; break; }
    case 3: 
      var $8=$L_addr;
      var $top2=(($8+8)|0);
      var $9=HEAP32[(($top2)>>2)];
      var $incdec_ptr=(($9+12)|0);
      HEAP32[(($top2)>>2)]=$incdec_ptr;
      label = 5; break;
    case 4: 
      var $10=$L_addr;
      var $top3=(($10+8)|0);
      var $11=HEAP32[(($top3)>>2)];
      var $add_ptr4=((($11)-(12))|0);
      HEAP32[(($top3)>>2)]=$add_ptr4;
      label = 5; break;
    case 5: 
      var $12=$more;

      Module.print(INDENT + 'Exiting: _lua_next');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return $12;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _lua_concat($L, $n) {
  var label = 0;

  Module.print(INDENT + ' Entering: _lua_concat: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $L_addr;
      var $n_addr;
      var $io;
      var $x_;
      $L_addr=$L;
      $n_addr=$n;
      var $0=$n_addr;
      var $cmp=(($0)|0) >= 2;
      if ($cmp) { label = 3; break; } else { label = 6; break; }
    case 3: 
      var $1=$L_addr;
      var $l_G=(($1+12)|0);
      var $2=HEAP32[(($l_G)>>2)];
      var $GCdebt=(($2+12)|0);
      var $3=HEAP32[(($GCdebt)>>2)];
      var $cmp1=(($3)|0) > 0;
      if ($cmp1) { label = 4; break; } else { label = 5; break; }
    case 4: 
      var $4=$L_addr;
      _luaC_step($4);
      label = 5; break;
    case 5: 
      var $5=$L_addr;
      var $6=$n_addr;
      _luaV_concat($5, $6);
      label = 9; break;
    case 6: 
      var $7=$n_addr;
      var $cmp3=(($7)|0)==0;
      if ($cmp3) { label = 7; break; } else { label = 8; break; }
    case 7: 
      var $8=$L_addr;
      var $top=(($8+8)|0);
      var $9=HEAP32[(($top)>>2)];
      $io=$9;
      var $10=$L_addr;
      var $call=_luaS_newlstr($10, ((5247216)|0), 0);
      $x_=$call;
      var $11=$x_;
      var $12=$11;
      var $13=$io;
      var $value_=(($13)|0);
      var $gc=$value_;
      HEAP32[(($gc)>>2)]=$12;
      var $14=$x_;
      var $tsv=$14;
      var $tt=(($tsv+4)|0);
      var $15=HEAP8[($tt)];
      var $conv=(($15)&255);
      var $or=$conv | 64;
      var $16=$io;
      var $tt_=(($16+8)|0);
      HEAP32[(($tt_)>>2)]=$or;
      var $17=$L_addr;
      var $top5=(($17+8)|0);
      var $18=HEAP32[(($top5)>>2)];
      var $incdec_ptr=(($18+12)|0);
      HEAP32[(($top5)>>2)]=$incdec_ptr;
      label = 8; break;
    case 8: 
      label = 9; break;
    case 9: 

      Module.print(INDENT + 'Exiting: _lua_concat');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_lua_concat["X"]=1;

function _lua_len($L, $idx) {
  var label = 0;

  Module.print(INDENT + ' Entering: _lua_len: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';

  var $L_addr;
  var $idx_addr;
  var $t;
  $L_addr=$L;
  $idx_addr=$idx;
  var $0=$L_addr;
  var $1=$idx_addr;
  var $call=_index2addr($0, $1);
  $t=$call;
  var $2=$L_addr;
  var $3=$L_addr;
  var $top=(($3+8)|0);
  var $4=HEAP32[(($top)>>2)];
  var $5=$t;
  _luaV_objlen($2, $4, $5);
  var $6=$L_addr;
  var $top1=(($6+8)|0);
  var $7=HEAP32[(($top1)>>2)];
  var $incdec_ptr=(($7+12)|0);
  HEAP32[(($top1)>>2)]=$incdec_ptr;

  Module.print(INDENT + 'Exiting: _lua_len');
  INDENT = INDENT.substr(0, INDENT.length-2);
  return;
  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _lua_newuserdata($L, $size) {
  var label = 0;

  Module.print(INDENT + ' Entering: _lua_newuserdata: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $L_addr;
      var $size_addr;
      var $u;
      var $io;
      $L_addr=$L;
      $size_addr=$size;
      var $0=$L_addr;
      var $l_G=(($0+12)|0);
      var $1=HEAP32[(($l_G)>>2)];
      var $GCdebt=(($1+12)|0);
      var $2=HEAP32[(($GCdebt)>>2)];
      var $cmp=(($2)|0) > 0;
      if ($cmp) { label = 3; break; } else { label = 4; break; }
    case 3: 
      var $3=$L_addr;
      _luaC_step($3);
      label = 4; break;
    case 4: 
      var $4=$L_addr;
      var $5=$size_addr;
      var $call=_luaS_newudata($4, $5, 0);
      $u=$call;
      var $6=$L_addr;
      var $top=(($6+8)|0);
      var $7=HEAP32[(($top)>>2)];
      $io=$7;
      var $8=$u;
      var $9=$8;
      var $10=$io;
      var $value_=(($10)|0);
      var $gc=$value_;
      HEAP32[(($gc)>>2)]=$9;
      var $11=$io;
      var $tt_=(($11+8)|0);
      HEAP32[(($tt_)>>2)]=71;
      var $12=$L_addr;
      var $top1=(($12+8)|0);
      var $13=HEAP32[(($top1)>>2)];
      var $incdec_ptr=(($13+12)|0);
      HEAP32[(($top1)>>2)]=$incdec_ptr;
      var $14=$u;
      var $add_ptr=(($14+20)|0);
      var $15=$add_ptr;

      Module.print(INDENT + 'Exiting: _lua_newuserdata');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return $15;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _lua_getupvalue($L, $funcindex, $n) {
  var label = 0;
  var __stackBase__  = STACKTOP; STACKTOP = (STACKTOP + 4)|0; _memset(__stackBase__, 0, 4);
  Module.print(INDENT + ' Entering: _lua_getupvalue: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $L_addr;
      var $funcindex_addr;
      var $n_addr;
      var $name;
      var $val=__stackBase__;
      var $io2;
      var $io1;
      $L_addr=$L;
      $funcindex_addr=$funcindex;
      $n_addr=$n;
      HEAP32[(($val)>>2)]=0;
      var $0=$L_addr;
      var $1=$funcindex_addr;
      var $call=_index2addr($0, $1);
      var $2=$n_addr;
      var $call1=_aux_upvalue($call, $2, $val, 0);
      $name=$call1;
      var $3=$name;
      var $tobool=(($3)|0)!=0;
      if ($tobool) { label = 3; break; } else { label = 4; break; }
    case 3: 
      var $4=HEAP32[(($val)>>2)];
      $io2=$4;
      var $5=$L_addr;
      var $top=(($5+8)|0);
      var $6=HEAP32[(($top)>>2)];
      $io1=$6;
      var $7=$io1;
      var $value_=(($7)|0);
      var $8=$io2;
      var $value_2=(($8)|0);
      var $9=$value_;
      var $10=$value_2;
      HEAP32[(($9)>>2)]=HEAP32[(($10)>>2)];HEAP32[((($9)+(4))>>2)]=HEAP32[((($10)+(4))>>2)];
      var $11=$io2;
      var $tt_=(($11+8)|0);
      var $12=HEAP32[(($tt_)>>2)];
      var $13=$io1;
      var $tt_3=(($13+8)|0);
      HEAP32[(($tt_3)>>2)]=$12;
      var $14=$L_addr;
      var $top4=(($14+8)|0);
      var $15=HEAP32[(($top4)>>2)];
      var $incdec_ptr=(($15+12)|0);
      HEAP32[(($top4)>>2)]=$incdec_ptr;
      label = 4; break;
    case 4: 
      var $16=$name;
      STACKTOP = __stackBase__;
      Module.print(INDENT + 'Exiting: _lua_getupvalue');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return $16;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _lua_error($L) {
  var label = 0;

  Module.print(INDENT + ' Entering: _lua_error: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $retval;
      var $L_addr;
      $L_addr=$L;
      var $0=$L_addr;
      _luaG_errormsg($0);

    case 3: 
      var $1=$retval;

      Module.print(INDENT + 'Exiting: _lua_error');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return $1;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _aux_upvalue($fi, $n, $val, $owner) {
  var label = 0;

  Module.print(INDENT + ' Entering: _aux_upvalue: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $retval;
      var $fi_addr;
      var $n_addr;
      var $val_addr;
      var $owner_addr;
      var $f;
      var $f6;
      var $name;
      var $p;
      $fi_addr=$fi;
      $n_addr=$n;
      $val_addr=$val;
      $owner_addr=$owner;
      var $0=$fi_addr;
      var $tt_=(($0+8)|0);
      var $1=HEAP32[(($tt_)>>2)];
      var $and=$1 & 63;
      if ((($and)|0)==38) {
        label = 3; break;
      }
      else if ((($and)|0)==6) {
        label = 9; break;
      }
      else {
      label = 18; break;
      }
      
    case 3: 
      var $2=$fi_addr;
      var $value_=(($2)|0);
      var $gc=$value_;
      var $3=HEAP32[(($gc)>>2)];
      var $cl=$3;
      var $c=$cl;
      $f=$c;
      var $4=$n_addr;
      var $cmp=1 <= (($4)|0);
      if ($cmp) { label = 4; break; } else { label = 5; break; }
    case 4: 
      var $5=$n_addr;
      var $6=$f;
      var $nupvalues=(($6+6)|0);
      var $7=HEAP8[($nupvalues)];
      var $conv=(($7)&255);
      var $cmp1=(($5)|0) <= (($conv)|0);
      if ($cmp1) { label = 6; break; } else { label = 5; break; }
    case 5: 
      $retval=0;
      label = 19; break;
    case 6: 
      var $8=$n_addr;
      var $sub=((($8)-(1))|0);
      var $9=$f;
      var $upvalue=(($9+16)|0);
      var $arrayidx=(($upvalue+((($sub)*(12))&-1))|0);
      var $10=$val_addr;
      HEAP32[(($10)>>2)]=$arrayidx;
      var $11=$owner_addr;
      var $tobool=(($11)|0)!=0;
      if ($tobool) { label = 7; break; } else { label = 8; break; }
    case 7: 
      var $12=$f;
      var $13=$12;
      var $14=$owner_addr;
      HEAP32[(($14)>>2)]=$13;
      label = 8; break;
    case 8: 
      $retval=((5247216)|0);
      label = 19; break;
    case 9: 
      var $15=$fi_addr;
      var $value_7=(($15)|0);
      var $gc8=$value_7;
      var $16=HEAP32[(($gc8)>>2)];
      var $cl9=$16;
      var $l=$cl9;
      $f6=$l;
      var $17=$f6;
      var $p10=(($17+12)|0);
      var $18=HEAP32[(($p10)>>2)];
      $p=$18;
      var $19=$n_addr;
      var $cmp11=1 <= (($19)|0);
      if ($cmp11) { label = 10; break; } else { label = 11; break; }
    case 10: 
      var $20=$n_addr;
      var $21=$p;
      var $sizeupvalues=(($21+40)|0);
      var $22=HEAP32[(($sizeupvalues)>>2)];
      var $cmp14=(($20)|0) <= (($22)|0);
      if ($cmp14) { label = 12; break; } else { label = 11; break; }
    case 11: 
      $retval=0;
      label = 19; break;
    case 12: 
      var $23=$n_addr;
      var $sub18=((($23)-(1))|0);
      var $24=$f6;
      var $upvals=(($24+16)|0);
      var $arrayidx19=(($upvals+($sub18<<2))|0);
      var $25=HEAP32[(($arrayidx19)>>2)];
      var $v=(($25+8)|0);
      var $26=HEAP32[(($v)>>2)];
      var $27=$val_addr;
      HEAP32[(($27)>>2)]=$26;
      var $28=$owner_addr;
      var $tobool20=(($28)|0)!=0;
      if ($tobool20) { label = 13; break; } else { label = 14; break; }
    case 13: 
      var $29=$n_addr;
      var $sub22=((($29)-(1))|0);
      var $30=$f6;
      var $upvals23=(($30+16)|0);
      var $arrayidx24=(($upvals23+($sub22<<2))|0);
      var $31=HEAP32[(($arrayidx24)>>2)];
      var $32=$31;
      var $33=$owner_addr;
      HEAP32[(($33)>>2)]=$32;
      label = 14; break;
    case 14: 
      var $34=$n_addr;
      var $sub26=((($34)-(1))|0);
      var $35=$p;
      var $upvalues=(($35+28)|0);
      var $36=HEAP32[(($upvalues)>>2)];
      var $arrayidx27=(($36+($sub26<<3))|0);
      var $name28=(($arrayidx27)|0);
      var $37=HEAP32[(($name28)>>2)];
      $name=$37;
      var $38=$name;
      var $cmp29=(($38)|0)==0;
      if ($cmp29) { label = 15; break; } else { label = 16; break; }
    case 15: 
      var $cond = ((5247216)|0);label = 17; break;
    case 16: 
      var $39=$name;
      var $add_ptr=(($39+16)|0);
      var $40=$add_ptr;
      var $cond = $40;label = 17; break;
    case 17: 
      var $cond;
      $retval=$cond;
      label = 19; break;
    case 18: 
      $retval=0;
      label = 19; break;
    case 19: 
      var $41=$retval;

      Module.print(INDENT + 'Exiting: _aux_upvalue');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return $41;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_aux_upvalue["X"]=1;

function _luaK_getlabel($fs) {
  var label = 0;

  Module.print(INDENT + ' Entering: _luaK_getlabel: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';

  var $fs_addr;
  $fs_addr=$fs;
  var $0=$fs_addr;
  var $pc=(($0+20)|0);
  var $1=HEAP32[(($pc)>>2)];
  var $2=$fs_addr;
  var $lasttarget=(($2+24)|0);
  HEAP32[(($lasttarget)>>2)]=$1;
  var $3=$fs_addr;
  var $pc1=(($3+20)|0);
  var $4=HEAP32[(($pc1)>>2)];

  Module.print(INDENT + 'Exiting: _luaK_getlabel');
  INDENT = INDENT.substr(0, INDENT.length-2);
  return $4;
  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _getjump($fs, $pc) {
  var label = 0;

  Module.print(INDENT + ' Entering: _getjump: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $retval;
      var $fs_addr;
      var $pc_addr;
      var $offset;
      $fs_addr=$fs;
      $pc_addr=$pc;
      var $0=$pc_addr;
      var $1=$fs_addr;
      var $f=(($1)|0);
      var $2=HEAP32[(($f)>>2)];
      var $code=(($2+12)|0);
      var $3=HEAP32[(($code)>>2)];
      var $arrayidx=(($3+($0<<2))|0);
      var $4=HEAP32[(($arrayidx)>>2)];
      var $shr=$4 >>> 14;
      var $and=$shr & 262143;
      var $sub=((($and)-(131071))|0);
      $offset=$sub;
      var $5=$offset;
      var $cmp=(($5)|0)==-1;
      if ($cmp) { label = 3; break; } else { label = 4; break; }
    case 3: 
      $retval=-1;
      label = 5; break;
    case 4: 
      var $6=$pc_addr;
      var $add=((($6)+(1))|0);
      var $7=$offset;
      var $add1=((($add)+($7))|0);
      $retval=$add1;
      label = 5; break;
    case 5: 
      var $8=$retval;

      Module.print(INDENT + 'Exiting: _getjump');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return $8;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _lua_setupvalue($L, $funcindex, $n) {
  var label = 0;
  var __stackBase__  = STACKTOP; STACKTOP = (STACKTOP + 8)|0; _memset(__stackBase__, 0, 8);
  Module.print(INDENT + ' Entering: _lua_setupvalue: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $L_addr;
      var $funcindex_addr;
      var $n_addr;
      var $name;
      var $val=__stackBase__;
      var $owner=(__stackBase__)+(4);
      var $fi;
      var $io2;
      var $io1;
      $L_addr=$L;
      $funcindex_addr=$funcindex;
      $n_addr=$n;
      HEAP32[(($val)>>2)]=0;
      HEAP32[(($owner)>>2)]=0;
      var $0=$L_addr;
      var $1=$funcindex_addr;
      var $call=_index2addr($0, $1);
      $fi=$call;
      var $2=$fi;
      var $3=$n_addr;
      var $call1=_aux_upvalue($2, $3, $val, $owner);
      $name=$call1;
      var $4=$name;
      var $tobool=(($4)|0)!=0;
      if ($tobool) { label = 3; break; } else { label = 8; break; }
    case 3: 
      var $5=$L_addr;
      var $top=(($5+8)|0);
      var $6=HEAP32[(($top)>>2)];
      var $incdec_ptr=((($6)-(12))|0);
      HEAP32[(($top)>>2)]=$incdec_ptr;
      var $7=$L_addr;
      var $top2=(($7+8)|0);
      var $8=HEAP32[(($top2)>>2)];
      $io2=$8;
      var $9=HEAP32[(($val)>>2)];
      $io1=$9;
      var $10=$io1;
      var $value_=(($10)|0);
      var $11=$io2;
      var $value_3=(($11)|0);
      var $12=$value_;
      var $13=$value_3;
      HEAP32[(($12)>>2)]=HEAP32[(($13)>>2)];HEAP32[((($12)+(4))>>2)]=HEAP32[((($13)+(4))>>2)];
      var $14=$io2;
      var $tt_=(($14+8)|0);
      var $15=HEAP32[(($tt_)>>2)];
      var $16=$io1;
      var $tt_4=(($16+8)|0);
      HEAP32[(($tt_4)>>2)]=$15;
      var $17=$L_addr;
      var $top5=(($17+8)|0);
      var $18=HEAP32[(($top5)>>2)];
      var $tt_6=(($18+8)|0);
      var $19=HEAP32[(($tt_6)>>2)];
      var $and=$19 & 64;
      var $tobool7=(($and)|0)!=0;
      if ($tobool7) { label = 4; break; } else { label = 7; break; }
    case 4: 
      var $20=$L_addr;
      var $top8=(($20+8)|0);
      var $21=HEAP32[(($top8)>>2)];
      var $value_9=(($21)|0);
      var $gc=$value_9;
      var $22=HEAP32[(($gc)>>2)];
      var $gch=$22;
      var $marked=(($gch+5)|0);
      var $23=HEAP8[($marked)];
      var $conv=(($23)&255);
      var $and10=$conv & 3;
      var $tobool11=(($and10)|0)!=0;
      if ($tobool11) { label = 5; break; } else { label = 7; break; }
    case 5: 
      var $24=HEAP32[(($owner)>>2)];
      var $gch13=$24;
      var $marked14=(($gch13+5)|0);
      var $25=HEAP8[($marked14)];
      var $conv15=(($25)&255);
      var $and16=$conv15 & 4;
      var $tobool17=(($and16)|0)!=0;
      if ($tobool17) { label = 6; break; } else { label = 7; break; }
    case 6: 
      var $26=$L_addr;
      var $27=HEAP32[(($owner)>>2)];
      var $28=$L_addr;
      var $top19=(($28+8)|0);
      var $29=HEAP32[(($top19)>>2)];
      var $value_20=(($29)|0);
      var $gc21=$value_20;
      var $30=HEAP32[(($gc21)>>2)];
      _luaC_barrier_($26, $27, $30);
      label = 7; break;
    case 7: 
      label = 8; break;
    case 8: 
      var $31=$name;
      STACKTOP = __stackBase__;
      Module.print(INDENT + 'Exiting: _lua_setupvalue');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return $31;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_lua_setupvalue["X"]=1;

function _lua_upvalueid($L, $fidx, $n) {
  var label = 0;

  Module.print(INDENT + ' Entering: _lua_upvalueid: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $retval;
      var $L_addr;
      var $fidx_addr;
      var $n_addr;
      var $fi;
      var $f;
      $L_addr=$L;
      $fidx_addr=$fidx;
      $n_addr=$n;
      var $0=$L_addr;
      var $1=$fidx_addr;
      var $call=_index2addr($0, $1);
      $fi=$call;
      var $2=$fi;
      var $tt_=(($2+8)|0);
      var $3=HEAP32[(($tt_)>>2)];
      var $and=$3 & 63;
      if ((($and)|0)==6) {
        label = 3; break;
      }
      else if ((($and)|0)==38) {
        label = 4; break;
      }
      else {
      label = 5; break;
      }
      
    case 3: 
      var $4=$L_addr;
      var $5=$fidx_addr;
      var $6=$n_addr;
      var $call1=_getupvalref($4, $5, $6, 0);
      var $7=HEAP32[(($call1)>>2)];
      var $8=$7;
      $retval=$8;
      label = 6; break;
    case 4: 
      var $9=$fi;
      var $value_=(($9)|0);
      var $gc=$value_;
      var $10=HEAP32[(($gc)>>2)];
      var $cl=$10;
      var $c=$cl;
      $f=$c;
      var $11=$n_addr;
      var $sub=((($11)-(1))|0);
      var $12=$f;
      var $upvalue=(($12+16)|0);
      var $arrayidx=(($upvalue+((($sub)*(12))&-1))|0);
      var $13=$arrayidx;
      $retval=$13;
      label = 6; break;
    case 5: 
      $retval=0;
      label = 6; break;
    case 6: 
      var $14=$retval;

      Module.print(INDENT + 'Exiting: _lua_upvalueid');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return $14;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _getupvalref($L, $fidx, $n, $pf) {
  var label = 0;

  Module.print(INDENT + ' Entering: _getupvalref: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $L_addr;
      var $fidx_addr;
      var $n_addr;
      var $pf_addr;
      var $f;
      var $fi;
      $L_addr=$L;
      $fidx_addr=$fidx;
      $n_addr=$n;
      $pf_addr=$pf;
      var $0=$L_addr;
      var $1=$fidx_addr;
      var $call=_index2addr($0, $1);
      $fi=$call;
      var $2=$fi;
      var $value_=(($2)|0);
      var $gc=$value_;
      var $3=HEAP32[(($gc)>>2)];
      var $cl=$3;
      var $l=$cl;
      $f=$l;
      var $4=$pf_addr;
      var $tobool=(($4)|0)!=0;
      if ($tobool) { label = 3; break; } else { label = 4; break; }
    case 3: 
      var $5=$f;
      var $6=$pf_addr;
      HEAP32[(($6)>>2)]=$5;
      label = 4; break;
    case 4: 
      var $7=$n_addr;
      var $sub=((($7)-(1))|0);
      var $8=$f;
      var $upvals=(($8+16)|0);
      var $arrayidx=(($upvals+($sub<<2))|0);

      Module.print(INDENT + 'Exiting: _getupvalref');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return $arrayidx;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _lua_upvaluejoin($L, $fidx1, $n1, $fidx2, $n2) {
  var label = 0;
  var __stackBase__  = STACKTOP; STACKTOP = (STACKTOP + 4)|0; _memset(__stackBase__, 0, 4);
  Module.print(INDENT + ' Entering: _lua_upvaluejoin: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $L_addr;
      var $fidx1_addr;
      var $n1_addr;
      var $fidx2_addr;
      var $n2_addr;
      var $f1=__stackBase__;
      var $up1;
      var $up2;
      $L_addr=$L;
      $fidx1_addr=$fidx1;
      $n1_addr=$n1;
      $fidx2_addr=$fidx2;
      $n2_addr=$n2;
      var $0=$L_addr;
      var $1=$fidx1_addr;
      var $2=$n1_addr;
      var $call=_getupvalref($0, $1, $2, $f1);
      $up1=$call;
      var $3=$L_addr;
      var $4=$fidx2_addr;
      var $5=$n2_addr;
      var $call1=_getupvalref($3, $4, $5, 0);
      $up2=$call1;
      var $6=$up2;
      var $7=HEAP32[(($6)>>2)];
      var $8=$up1;
      HEAP32[(($8)>>2)]=$7;
      var $9=$up2;
      var $10=HEAP32[(($9)>>2)];
      var $11=$10;
      var $gch=$11;
      var $marked=(($gch+5)|0);
      var $12=HEAP8[($marked)];
      var $conv=(($12)&255);
      var $and=$conv & 3;
      var $tobool=(($and)|0)!=0;
      if ($tobool) { label = 3; break; } else { label = 5; break; }
    case 3: 
      var $13=HEAP32[(($f1)>>2)];
      var $14=$13;
      var $gch2=$14;
      var $marked3=(($gch2+5)|0);
      var $15=HEAP8[($marked3)];
      var $conv4=(($15)&255);
      var $and5=$conv4 & 4;
      var $tobool6=(($and5)|0)!=0;
      if ($tobool6) { label = 4; break; } else { label = 5; break; }
    case 4: 
      var $16=$L_addr;
      var $17=HEAP32[(($f1)>>2)];
      var $18=$17;
      var $19=$up2;
      var $20=HEAP32[(($19)>>2)];
      var $21=$20;
      _luaC_barrier_($16, $18, $21);
      label = 5; break;
    case 5: 
      STACKTOP = __stackBase__;
      Module.print(INDENT + 'Exiting: _lua_upvaluejoin');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_lua_upvaluejoin["X"]=1;

function _luaK_nil($fs, $from, $n) {
  var label = 0;

  Module.print(INDENT + ' Entering: _luaK_nil: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $fs_addr;
      var $from_addr;
      var $n_addr;
      var $previous;
      var $l;
      var $pfrom;
      var $pl;
      $fs_addr=$fs;
      $from_addr=$from;
      $n_addr=$n;
      var $0=$from_addr;
      var $1=$n_addr;
      var $add=((($0)+($1))|0);
      var $sub=((($add)-(1))|0);
      $l=$sub;
      var $2=$fs_addr;
      var $pc=(($2+20)|0);
      var $3=HEAP32[(($pc)>>2)];
      var $4=$fs_addr;
      var $lasttarget=(($4+24)|0);
      var $5=HEAP32[(($lasttarget)>>2)];
      var $cmp=(($3)|0) > (($5)|0);
      if ($cmp) { label = 3; break; } else { label = 15; break; }
    case 3: 
      var $6=$fs_addr;
      var $pc1=(($6+20)|0);
      var $7=HEAP32[(($pc1)>>2)];
      var $sub2=((($7)-(1))|0);
      var $8=$fs_addr;
      var $f=(($8)|0);
      var $9=HEAP32[(($f)>>2)];
      var $code=(($9+12)|0);
      var $10=HEAP32[(($code)>>2)];
      var $arrayidx=(($10+($sub2<<2))|0);
      $previous=$arrayidx;
      var $11=$previous;
      var $12=HEAP32[(($11)>>2)];
      var $shr=$12 >>> 0;
      var $and=$shr & 63;
      var $cmp3=(($and)|0)==4;
      if ($cmp3) { label = 4; break; } else { label = 14; break; }
    case 4: 
      var $13=$previous;
      var $14=HEAP32[(($13)>>2)];
      var $shr5=$14 >>> 6;
      var $and6=$shr5 & 255;
      $pfrom=$and6;
      var $15=$pfrom;
      var $16=$previous;
      var $17=HEAP32[(($16)>>2)];
      var $shr7=$17 >>> 23;
      var $and8=$shr7 & 511;
      var $add9=((($15)+($and8))|0);
      $pl=$add9;
      var $18=$pfrom;
      var $19=$from_addr;
      var $cmp10=(($18)|0) <= (($19)|0);
      if ($cmp10) { label = 5; break; } else { label = 6; break; }
    case 5: 
      var $20=$from_addr;
      var $21=$pl;
      var $add11=((($21)+(1))|0);
      var $cmp12=(($20)|0) <= (($add11)|0);
      if ($cmp12) { label = 8; break; } else { label = 6; break; }
    case 6: 
      var $22=$from_addr;
      var $23=$pfrom;
      var $cmp13=(($22)|0) <= (($23)|0);
      if ($cmp13) { label = 7; break; } else { label = 13; break; }
    case 7: 
      var $24=$pfrom;
      var $25=$l;
      var $add15=((($25)+(1))|0);
      var $cmp16=(($24)|0) <= (($add15)|0);
      if ($cmp16) { label = 8; break; } else { label = 13; break; }
    case 8: 
      var $26=$pfrom;
      var $27=$from_addr;
      var $cmp18=(($26)|0) < (($27)|0);
      if ($cmp18) { label = 9; break; } else { label = 10; break; }
    case 9: 
      var $28=$pfrom;
      $from_addr=$28;
      label = 10; break;
    case 10: 
      var $29=$pl;
      var $30=$l;
      var $cmp20=(($29)|0) > (($30)|0);
      if ($cmp20) { label = 11; break; } else { label = 12; break; }
    case 11: 
      var $31=$pl;
      $l=$31;
      label = 12; break;
    case 12: 
      var $32=$previous;
      var $33=HEAP32[(($32)>>2)];
      var $and23=$33 & -16321;
      var $34=$from_addr;
      var $shl=$34 << 6;
      var $and24=$shl & 16320;
      var $or=$and23 | $and24;
      var $35=$previous;
      HEAP32[(($35)>>2)]=$or;
      var $36=$previous;
      var $37=HEAP32[(($36)>>2)];
      var $and25=$37 & 8388607;
      var $38=$l;
      var $39=$from_addr;
      var $sub26=((($38)-($39))|0);
      var $shl27=$sub26 << 23;
      var $and28=$shl27 & -8388608;
      var $or29=$and25 | $and28;
      var $40=$previous;
      HEAP32[(($40)>>2)]=$or29;
      label = 16; break;
    case 13: 
      label = 14; break;
    case 14: 
      label = 15; break;
    case 15: 
      var $41=$fs_addr;
      var $42=$from_addr;
      var $43=$n_addr;
      var $sub33=((($43)-(1))|0);
      var $call=_luaK_codeABC($41, 4, $42, $sub33, 0);
      label = 16; break;
    case 16: 

      Module.print(INDENT + 'Exiting: _luaK_nil');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_luaK_nil["X"]=1;

function _luaK_codeABC($fs, $o, $a, $b, $c) {
  var label = 0;

  Module.print(INDENT + ' Entering: _luaK_codeABC: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';

  var $fs_addr;
  var $o_addr;
  var $a_addr;
  var $b_addr;
  var $c_addr;
  $fs_addr=$fs;
  $o_addr=$o;
  $a_addr=$a;
  $b_addr=$b;
  $c_addr=$c;
  var $0=$fs_addr;
  var $1=$o_addr;
  var $shl=$1 << 0;
  var $2=$a_addr;
  var $shl1=$2 << 6;
  var $or=$shl | $shl1;
  var $3=$b_addr;
  var $shl2=$3 << 23;
  var $or3=$or | $shl2;
  var $4=$c_addr;
  var $shl4=$4 << 14;
  var $or5=$or3 | $shl4;
  var $call=_luaK_code($0, $or5);

  Module.print(INDENT + 'Exiting: _luaK_codeABC');
  INDENT = INDENT.substr(0, INDENT.length-2);
  return $call;
  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _luaK_jump($fs) {
  var label = 0;
  var __stackBase__  = STACKTOP; STACKTOP = (STACKTOP + 4)|0; _memset(__stackBase__, 0, 4);
  Module.print(INDENT + ' Entering: _luaK_jump: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';

  var $fs_addr;
  var $jpc;
  var $j=__stackBase__;
  $fs_addr=$fs;
  var $0=$fs_addr;
  var $jpc1=(($0+28)|0);
  var $1=HEAP32[(($jpc1)>>2)];
  $jpc=$1;
  var $2=$fs_addr;
  var $jpc2=(($2+28)|0);
  HEAP32[(($jpc2)>>2)]=-1;
  var $3=$fs_addr;
  var $call=_luaK_codeABx($3, 23, 0, 131070);
  HEAP32[(($j)>>2)]=$call;
  var $4=$fs_addr;
  var $5=$jpc;
  _luaK_concat($4, $j, $5);
  var $6=HEAP32[(($j)>>2)];
  STACKTOP = __stackBase__;
  Module.print(INDENT + 'Exiting: _luaK_jump');
  INDENT = INDENT.substr(0, INDENT.length-2);
  return $6;
  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _luaK_codeABx($fs, $o, $a, $bc) {
  var label = 0;

  Module.print(INDENT + ' Entering: _luaK_codeABx: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';

  var $fs_addr;
  var $o_addr;
  var $a_addr;
  var $bc_addr;
  $fs_addr=$fs;
  $o_addr=$o;
  $a_addr=$a;
  $bc_addr=$bc;
  var $0=$fs_addr;
  var $1=$o_addr;
  var $shl=$1 << 0;
  var $2=$a_addr;
  var $shl1=$2 << 6;
  var $or=$shl | $shl1;
  var $3=$bc_addr;
  var $shl2=$3 << 14;
  var $or3=$or | $shl2;
  var $call=_luaK_code($0, $or3);

  Module.print(INDENT + 'Exiting: _luaK_codeABx');
  INDENT = INDENT.substr(0, INDENT.length-2);
  return $call;
  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _luaK_concat($fs, $l1, $l2) {
  var label = 0;

  Module.print(INDENT + ' Entering: _luaK_concat: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $fs_addr;
      var $l1_addr;
      var $l2_addr;
      var $list;
      var $next;
      $fs_addr=$fs;
      $l1_addr=$l1;
      $l2_addr=$l2;
      var $0=$l2_addr;
      var $cmp=(($0)|0)==-1;
      if ($cmp) { label = 3; break; } else { label = 4; break; }
    case 3: 
      label = 11; break;
    case 4: 
      var $1=$l1_addr;
      var $2=HEAP32[(($1)>>2)];
      var $cmp1=(($2)|0)==-1;
      if ($cmp1) { label = 5; break; } else { label = 6; break; }
    case 5: 
      var $3=$l2_addr;
      var $4=$l1_addr;
      HEAP32[(($4)>>2)]=$3;
      label = 10; break;
    case 6: 
      var $5=$l1_addr;
      var $6=HEAP32[(($5)>>2)];
      $list=$6;
      label = 7; break;
    case 7: 
      var $7=$fs_addr;
      var $8=$list;
      var $call=_getjump($7, $8);
      $next=$call;
      var $cmp4=(($call)|0)!=-1;
      if ($cmp4) { label = 8; break; } else { label = 9; break; }
    case 8: 
      var $9=$next;
      $list=$9;
      label = 7; break;
    case 9: 
      var $10=$fs_addr;
      var $11=$list;
      var $12=$l2_addr;
      _fixjump($10, $11, $12);
      label = 10; break;
    case 10: 
      label = 11; break;
    case 11: 

      Module.print(INDENT + 'Exiting: _luaK_concat');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _luaK_ret($fs, $first, $nret) {
  var label = 0;

  Module.print(INDENT + ' Entering: _luaK_ret: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';

  var $fs_addr;
  var $first_addr;
  var $nret_addr;
  $fs_addr=$fs;
  $first_addr=$first;
  $nret_addr=$nret;
  var $0=$fs_addr;
  var $1=$first_addr;
  var $2=$nret_addr;
  var $add=((($2)+(1))|0);
  var $call=_luaK_codeABC($0, 31, $1, $add, 0);

  Module.print(INDENT + 'Exiting: _luaK_ret');
  INDENT = INDENT.substr(0, INDENT.length-2);
  return;
  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _luaK_patchlist($fs, $list, $target) {
  var label = 0;

  Module.print(INDENT + ' Entering: _luaK_patchlist: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $fs_addr;
      var $list_addr;
      var $target_addr;
      $fs_addr=$fs;
      $list_addr=$list;
      $target_addr=$target;
      var $0=$target_addr;
      var $1=$fs_addr;
      var $pc=(($1+20)|0);
      var $2=HEAP32[(($pc)>>2)];
      var $cmp=(($0)|0)==(($2)|0);
      if ($cmp) { label = 3; break; } else { label = 4; break; }
    case 3: 
      var $3=$fs_addr;
      var $4=$list_addr;
      _luaK_patchtohere($3, $4);
      label = 5; break;
    case 4: 
      var $5=$fs_addr;
      var $6=$list_addr;
      var $7=$target_addr;
      var $8=$target_addr;
      _patchlistaux($5, $6, $7, 255, $8);
      label = 5; break;
    case 5: 

      Module.print(INDENT + 'Exiting: _luaK_patchlist');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _luaK_patchtohere($fs, $list) {
  var label = 0;

  Module.print(INDENT + ' Entering: _luaK_patchtohere: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';

  var $fs_addr;
  var $list_addr;
  $fs_addr=$fs;
  $list_addr=$list;
  var $0=$fs_addr;
  var $call=_luaK_getlabel($0);
  var $1=$fs_addr;
  var $2=$fs_addr;
  var $jpc=(($2+28)|0);
  var $3=$list_addr;
  _luaK_concat($1, $jpc, $3);

  Module.print(INDENT + 'Exiting: _luaK_patchtohere');
  INDENT = INDENT.substr(0, INDENT.length-2);
  return;
  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _patchlistaux($fs, $list, $vtarget, $reg, $dtarget) {
  var label = 0;

  Module.print(INDENT + ' Entering: _patchlistaux: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $fs_addr;
      var $list_addr;
      var $vtarget_addr;
      var $reg_addr;
      var $dtarget_addr;
      var $next;
      $fs_addr=$fs;
      $list_addr=$list;
      $vtarget_addr=$vtarget;
      $reg_addr=$reg;
      $dtarget_addr=$dtarget;
      label = 3; break;
    case 3: 
      var $0=$list_addr;
      var $cmp=(($0)|0)!=-1;
      if ($cmp) { label = 4; break; } else { label = 8; break; }
    case 4: 
      var $1=$fs_addr;
      var $2=$list_addr;
      var $call=_getjump($1, $2);
      $next=$call;
      var $3=$fs_addr;
      var $4=$list_addr;
      var $5=$reg_addr;
      var $call1=_patchtestreg($3, $4, $5);
      var $tobool=(($call1)|0)!=0;
      if ($tobool) { label = 5; break; } else { label = 6; break; }
    case 5: 
      var $6=$fs_addr;
      var $7=$list_addr;
      var $8=$vtarget_addr;
      _fixjump($6, $7, $8);
      label = 7; break;
    case 6: 
      var $9=$fs_addr;
      var $10=$list_addr;
      var $11=$dtarget_addr;
      _fixjump($9, $10, $11);
      label = 7; break;
    case 7: 
      var $12=$next;
      $list_addr=$12;
      label = 3; break;
    case 8: 

      Module.print(INDENT + 'Exiting: _patchlistaux');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _luaK_patchclose($fs, $list, $level) {
  var label = 0;

  Module.print(INDENT + ' Entering: _luaK_patchclose: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $fs_addr;
      var $list_addr;
      var $level_addr;
      var $next;
      $fs_addr=$fs;
      $list_addr=$list;
      $level_addr=$level;
      var $0=$level_addr;
      var $inc=((($0)+(1))|0);
      $level_addr=$inc;
      label = 3; break;
    case 3: 
      var $1=$list_addr;
      var $cmp=(($1)|0)!=-1;
      if ($cmp) { label = 4; break; } else { label = 5; break; }
    case 4: 
      var $2=$fs_addr;
      var $3=$list_addr;
      var $call=_getjump($2, $3);
      $next=$call;
      var $4=$list_addr;
      var $5=$fs_addr;
      var $f=(($5)|0);
      var $6=HEAP32[(($f)>>2)];
      var $code=(($6+12)|0);
      var $7=HEAP32[(($code)>>2)];
      var $arrayidx=(($7+($4<<2))|0);
      var $8=HEAP32[(($arrayidx)>>2)];
      var $and=$8 & -16321;
      var $9=$level_addr;
      var $shl=$9 << 6;
      var $and1=$shl & 16320;
      var $or=$and | $and1;
      var $10=$list_addr;
      var $11=$fs_addr;
      var $f2=(($11)|0);
      var $12=HEAP32[(($f2)>>2)];
      var $code3=(($12+12)|0);
      var $13=HEAP32[(($code3)>>2)];
      var $arrayidx4=(($13+($10<<2))|0);
      HEAP32[(($arrayidx4)>>2)]=$or;
      var $14=$next;
      $list_addr=$14;
      label = 3; break;
    case 5: 

      Module.print(INDENT + 'Exiting: _luaK_patchclose');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _fixjump($fs, $pc, $dest) {
  var label = 0;

  Module.print(INDENT + ' Entering: _fixjump: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $fs_addr;
      var $pc_addr;
      var $dest_addr;
      var $jmp;
      var $offset;
      $fs_addr=$fs;
      $pc_addr=$pc;
      $dest_addr=$dest;
      var $0=$pc_addr;
      var $1=$fs_addr;
      var $f=(($1)|0);
      var $2=HEAP32[(($f)>>2)];
      var $code=(($2+12)|0);
      var $3=HEAP32[(($code)>>2)];
      var $arrayidx=(($3+($0<<2))|0);
      $jmp=$arrayidx;
      var $4=$dest_addr;
      var $5=$pc_addr;
      var $add=((($5)+(1))|0);
      var $sub=((($4)-($add))|0);
      $offset=$sub;
      var $6=$offset;
      var $call=Math.abs($6);
      var $cmp=(($call)|0) > 131071;
      if ($cmp) { label = 3; break; } else { label = 4; break; }
    case 3: 
      var $7=$fs_addr;
      var $ls=(($7+12)|0);
      var $8=HEAP32[(($ls)>>2)];
      _luaX_syntaxerror($8, ((5245064)|0));

    case 4: 
      var $9=$jmp;
      var $10=HEAP32[(($9)>>2)];
      var $and=$10 & 16383;
      var $11=$offset;
      var $add1=((($11)+(131071))|0);
      var $shl=$add1 << 14;
      var $and2=$shl & -16384;
      var $or=$and | $and2;
      var $12=$jmp;
      HEAP32[(($12)>>2)]=$or;

      Module.print(INDENT + 'Exiting: _fixjump');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _luaK_setoneret($fs, $e) {
  var label = 0;

  Module.print(INDENT + ' Entering: _luaK_setoneret: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $fs_addr;
      var $e_addr;
      $fs_addr=$fs;
      $e_addr=$e;
      var $0=$e_addr;
      var $k=(($0)|0);
      var $1=HEAP32[(($k)>>2)];
      var $cmp=(($1)|0)==12;
      if ($cmp) { label = 3; break; } else { label = 4; break; }
    case 3: 
      var $2=$e_addr;
      var $k1=(($2)|0);
      HEAP32[(($k1)>>2)]=6;
      var $3=$e_addr;
      var $u=(($3+4)|0);
      var $info=$u;
      var $4=HEAP32[(($info)>>2)];
      var $5=$fs_addr;
      var $f=(($5)|0);
      var $6=HEAP32[(($f)>>2)];
      var $code=(($6+12)|0);
      var $7=HEAP32[(($code)>>2)];
      var $arrayidx=(($7+($4<<2))|0);
      var $8=HEAP32[(($arrayidx)>>2)];
      var $shr=$8 >>> 6;
      var $and=$shr & 255;
      var $9=$e_addr;
      var $u2=(($9+4)|0);
      var $info3=$u2;
      HEAP32[(($info3)>>2)]=$and;
      label = 7; break;
    case 4: 
      var $10=$e_addr;
      var $k4=(($10)|0);
      var $11=HEAP32[(($k4)>>2)];
      var $cmp5=(($11)|0)==13;
      if ($cmp5) { label = 5; break; } else { label = 6; break; }
    case 5: 
      var $12=$e_addr;
      var $u7=(($12+4)|0);
      var $info8=$u7;
      var $13=HEAP32[(($info8)>>2)];
      var $14=$fs_addr;
      var $f9=(($14)|0);
      var $15=HEAP32[(($f9)>>2)];
      var $code10=(($15+12)|0);
      var $16=HEAP32[(($code10)>>2)];
      var $arrayidx11=(($16+($13<<2))|0);
      var $17=HEAP32[(($arrayidx11)>>2)];
      var $and12=$17 & 8388607;
      var $or=$and12 | 16777216;
      var $18=$e_addr;
      var $u13=(($18+4)|0);
      var $info14=$u13;
      var $19=HEAP32[(($info14)>>2)];
      var $20=$fs_addr;
      var $f15=(($20)|0);
      var $21=HEAP32[(($f15)>>2)];
      var $code16=(($21+12)|0);
      var $22=HEAP32[(($code16)>>2)];
      var $arrayidx17=(($22+($19<<2))|0);
      HEAP32[(($arrayidx17)>>2)]=$or;
      var $23=$e_addr;
      var $k18=(($23)|0);
      HEAP32[(($k18)>>2)]=11;
      label = 6; break;
    case 6: 
      label = 7; break;
    case 7: 

      Module.print(INDENT + 'Exiting: _luaK_setoneret');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_luaK_setoneret["X"]=1;

function _freereg($fs, $reg) {
  var label = 0;

  Module.print(INDENT + ' Entering: _freereg: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $fs_addr;
      var $reg_addr;
      $fs_addr=$fs;
      $reg_addr=$reg;
      var $0=$reg_addr;
      var $and=$0 & 256;
      var $tobool=(($and)|0)!=0;
      if ($tobool) { label = 5; break; } else { label = 3; break; }
    case 3: 
      var $1=$reg_addr;
      var $2=$fs_addr;
      var $nactvar=(($2+46)|0);
      var $3=HEAP8[($nactvar)];
      var $conv=(($3)&255);
      var $cmp=(($1)|0) >= (($conv)|0);
      if ($cmp) { label = 4; break; } else { label = 5; break; }
    case 4: 
      var $4=$fs_addr;
      var $freereg=(($4+48)|0);
      var $5=HEAP8[($freereg)];
      var $dec=((($5)-(1))&255);
      HEAP8[($freereg)]=$dec;
      label = 5; break;
    case 5: 

      Module.print(INDENT + 'Exiting: _freereg');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _luaK_code($fs, $i) {
  var label = 0;

  Module.print(INDENT + ' Entering: _luaK_code: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $fs_addr;
      var $i_addr;
      var $f;
      $fs_addr=$fs;
      $i_addr=$i;
      var $0=$fs_addr;
      var $f1=(($0)|0);
      var $1=HEAP32[(($f1)>>2)];
      $f=$1;
      var $2=$fs_addr;
      _dischargejpc($2);
      var $3=$fs_addr;
      var $pc=(($3+20)|0);
      var $4=HEAP32[(($pc)>>2)];
      var $add=((($4)+(1))|0);
      var $5=$f;
      var $sizecode=(($5+48)|0);
      var $6=HEAP32[(($sizecode)>>2)];
      var $cmp=(($add)|0) > (($6)|0);
      if ($cmp) { label = 3; break; } else { label = 4; break; }
    case 3: 
      var $7=$fs_addr;
      var $ls=(($7+12)|0);
      var $8=HEAP32[(($ls)>>2)];
      var $L=(($8+40)|0);
      var $9=HEAP32[(($L)>>2)];
      var $10=$f;
      var $code=(($10+12)|0);
      var $11=HEAP32[(($code)>>2)];
      var $12=$11;
      var $13=$f;
      var $sizecode2=(($13+48)|0);
      var $call=_luaM_growaux_($9, $12, $sizecode2, 4, 2147483645, ((5245412)|0));
      var $14=$call;
      var $15=$f;
      var $code3=(($15+12)|0);
      HEAP32[(($code3)>>2)]=$14;
      label = 4; break;
    case 4: 
      var $16=$i_addr;
      var $17=$fs_addr;
      var $pc4=(($17+20)|0);
      var $18=HEAP32[(($pc4)>>2)];
      var $19=$f;
      var $code5=(($19+12)|0);
      var $20=HEAP32[(($code5)>>2)];
      var $arrayidx=(($20+($18<<2))|0);
      HEAP32[(($arrayidx)>>2)]=$16;
      var $21=$fs_addr;
      var $pc6=(($21+20)|0);
      var $22=HEAP32[(($pc6)>>2)];
      var $add7=((($22)+(1))|0);
      var $23=$f;
      var $sizelineinfo=(($23+52)|0);
      var $24=HEAP32[(($sizelineinfo)>>2)];
      var $cmp8=(($add7)|0) > (($24)|0);
      if ($cmp8) { label = 5; break; } else { label = 6; break; }
    case 5: 
      var $25=$fs_addr;
      var $ls10=(($25+12)|0);
      var $26=HEAP32[(($ls10)>>2)];
      var $L11=(($26+40)|0);
      var $27=HEAP32[(($L11)>>2)];
      var $28=$f;
      var $lineinfo=(($28+20)|0);
      var $29=HEAP32[(($lineinfo)>>2)];
      var $30=$29;
      var $31=$f;
      var $sizelineinfo12=(($31+52)|0);
      var $call13=_luaM_growaux_($27, $30, $sizelineinfo12, 4, 2147483645, ((5245412)|0));
      var $32=$call13;
      var $33=$f;
      var $lineinfo14=(($33+20)|0);
      HEAP32[(($lineinfo14)>>2)]=$32;
      label = 6; break;
    case 6: 
      var $34=$fs_addr;
      var $ls16=(($34+12)|0);
      var $35=HEAP32[(($ls16)>>2)];
      var $lastline=(($35+8)|0);
      var $36=HEAP32[(($lastline)>>2)];
      var $37=$fs_addr;
      var $pc17=(($37+20)|0);
      var $38=HEAP32[(($pc17)>>2)];
      var $39=$f;
      var $lineinfo18=(($39+20)|0);
      var $40=HEAP32[(($lineinfo18)>>2)];
      var $arrayidx19=(($40+($38<<2))|0);
      HEAP32[(($arrayidx19)>>2)]=$36;
      var $41=$fs_addr;
      var $pc20=(($41+20)|0);
      var $42=HEAP32[(($pc20)>>2)];
      var $inc=((($42)+(1))|0);
      HEAP32[(($pc20)>>2)]=$inc;

      Module.print(INDENT + 'Exiting: _luaK_code');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return $42;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_luaK_code["X"]=1;

function _luaK_codek($fs, $reg, $k) {
  var label = 0;

  Module.print(INDENT + ' Entering: _luaK_codek: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $retval;
      var $fs_addr;
      var $reg_addr;
      var $k_addr;
      var $p;
      $fs_addr=$fs;
      $reg_addr=$reg;
      $k_addr=$k;
      var $0=$k_addr;
      var $cmp=(($0)|0) <= 262143;
      if ($cmp) { label = 3; break; } else { label = 4; break; }
    case 3: 
      var $1=$fs_addr;
      var $2=$reg_addr;
      var $3=$k_addr;
      var $call=_luaK_codeABx($1, 1, $2, $3);
      $retval=$call;
      label = 5; break;
    case 4: 
      var $4=$fs_addr;
      var $5=$reg_addr;
      var $call1=_luaK_codeABx($4, 2, $5, 0);
      $p=$call1;
      var $6=$fs_addr;
      var $7=$k_addr;
      var $call2=_codeextraarg($6, $7);
      var $8=$p;
      $retval=$8;
      label = 5; break;
    case 5: 
      var $9=$retval;

      Module.print(INDENT + 'Exiting: _luaK_codek');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return $9;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _codeextraarg($fs, $a) {
  var label = 0;

  Module.print(INDENT + ' Entering: _codeextraarg: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';

  var $fs_addr;
  var $a_addr;
  $fs_addr=$fs;
  $a_addr=$a;
  var $0=$fs_addr;
  var $1=$a_addr;
  var $shl=$1 << 6;
  var $or=39 | $shl;
  var $call=_luaK_code($0, $or);

  Module.print(INDENT + 'Exiting: _codeextraarg');
  INDENT = INDENT.substr(0, INDENT.length-2);
  return $call;
  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _luaK_reserveregs($fs, $n) {
  var label = 0;

  Module.print(INDENT + ' Entering: _luaK_reserveregs: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';

  var $fs_addr;
  var $n_addr;
  $fs_addr=$fs;
  $n_addr=$n;
  var $0=$fs_addr;
  var $1=$n_addr;
  _luaK_checkstack($0, $1);
  var $2=$n_addr;
  var $3=$fs_addr;
  var $freereg=(($3+48)|0);
  var $4=HEAP8[($freereg)];
  var $conv=(($4)&255);
  var $add=((($conv)+($2))|0);
  var $conv1=(($add) & 255);
  HEAP8[($freereg)]=$conv1;

  Module.print(INDENT + 'Exiting: _luaK_reserveregs');
  INDENT = INDENT.substr(0, INDENT.length-2);
  return;
  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _luaK_stringK($fs, $s) {
  var label = 0;
  var __stackBase__  = STACKTOP; STACKTOP = (STACKTOP + 12)|0; _memset(__stackBase__, 0, 12);
  Module.print(INDENT + ' Entering: _luaK_stringK: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';

  var $fs_addr;
  var $s_addr;
  var $o=__stackBase__;
  var $io;
  var $x_;
  $fs_addr=$fs;
  $s_addr=$s;
  $io=$o;
  var $0=$s_addr;
  $x_=$0;
  var $1=$x_;
  var $2=$1;
  var $3=$io;
  var $value_=(($3)|0);
  var $gc=$value_;
  HEAP32[(($gc)>>2)]=$2;
  var $4=$x_;
  var $tsv=$4;
  var $tt=(($tsv+4)|0);
  var $5=HEAP8[($tt)];
  var $conv=(($5)&255);
  var $or=$conv | 64;
  var $6=$io;
  var $tt_=(($6+8)|0);
  HEAP32[(($tt_)>>2)]=$or;
  var $7=$fs_addr;
  var $call=_addk($7, $o, $o);
  STACKTOP = __stackBase__;
  Module.print(INDENT + 'Exiting: _luaK_stringK');
  INDENT = INDENT.substr(0, INDENT.length-2);
  return $call;
  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _addk($fs, $key, $v) {
  var label = 0;
  var __stackBase__  = STACKTOP; STACKTOP = (STACKTOP + 8)|0; _memset(__stackBase__, 0, 8);
  Module.print(INDENT + ' Entering: _addk: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $retval;
      var $fs_addr;
      var $key_addr;
      var $v_addr;
      var $L;
      var $idx;
      var $f;
      var $k;
      var $oldsize;
      var $n;
      var $u=__stackBase__;
      var $io;
      var $io2;
      var $io1;
      $fs_addr=$fs;
      $key_addr=$key;
      $v_addr=$v;
      var $0=$fs_addr;
      var $ls=(($0+12)|0);
      var $1=HEAP32[(($ls)>>2)];
      var $L1=(($1+40)|0);
      var $2=HEAP32[(($L1)>>2)];
      $L=$2;
      var $3=$L;
      var $4=$fs_addr;
      var $h=(($4+4)|0);
      var $5=HEAP32[(($h)>>2)];
      var $6=$key_addr;
      var $call=_luaH_set($3, $5, $6);
      $idx=$call;
      var $7=$fs_addr;
      var $f2=(($7)|0);
      var $8=HEAP32[(($f2)>>2)];
      $f=$8;
      var $9=$idx;
      var $tt_=(($9+8)|0);
      var $10=HEAP32[(($tt_)>>2)];
      var $cmp=(($10)|0)==3;
      if ($cmp) { label = 3; break; } else { label = 7; break; }
    case 3: 
      var $11=$idx;
      var $value_=(($11)|0);
      var $n3=$value_;
      var $12=(HEAP32[((tempDoublePtr)>>2)]=HEAP32[(($n3)>>2)],HEAP32[(((tempDoublePtr)+(4))>>2)]=HEAP32[((($n3)+(4))>>2)],HEAPF64[(tempDoublePtr)>>3]);
      $n=$12;
      var $13=$n;
      var $add=($13)+(6755399441055744);
      var $l_d=$u;
      (HEAPF64[(tempDoublePtr)>>3]=$add,HEAP32[(($l_d)>>2)]=HEAP32[((tempDoublePtr)>>2)],HEAP32[((($l_d)+(4))>>2)]=HEAP32[(((tempDoublePtr)+(4))>>2)]);
      var $14=HEAP32[((((5244100)|0))>>2)];
      var $cmp4=(($14)|0)==33;
      var $conv=(($cmp4)&1);
      var $l_p=$u;
      var $arrayidx=(($l_p+($conv<<2))|0);
      var $15=HEAP32[(($arrayidx)>>2)];
      $k=$15;
      var $16=$k;
      var $17=$f;
      var $k5=(($17+8)|0);
      var $18=HEAP32[(($k5)>>2)];
      var $arrayidx6=(($18+((($16)*(12))&-1))|0);
      var $tt_7=(($arrayidx6+8)|0);
      var $19=HEAP32[(($tt_7)>>2)];
      var $20=$v_addr;
      var $tt_8=(($20+8)|0);
      var $21=HEAP32[(($tt_8)>>2)];
      var $cmp9=(($19)|0)==(($21)|0);
      if ($cmp9) { label = 4; break; } else { label = 6; break; }
    case 4: 
      var $22=$k;
      var $23=$f;
      var $k11=(($23+8)|0);
      var $24=HEAP32[(($k11)>>2)];
      var $arrayidx12=(($24+((($22)*(12))&-1))|0);
      var $25=$v_addr;
      var $call13=_luaV_equalobj_(0, $arrayidx12, $25);
      var $tobool=(($call13)|0)!=0;
      if ($tobool) { label = 5; break; } else { label = 6; break; }
    case 5: 
      var $26=$k;
      $retval=$26;
      label = 17; break;
    case 6: 
      label = 7; break;
    case 7: 
      var $27=$f;
      var $sizek=(($27+44)|0);
      var $28=HEAP32[(($sizek)>>2)];
      $oldsize=$28;
      var $29=$fs_addr;
      var $nk=(($29+32)|0);
      var $30=HEAP32[(($nk)>>2)];
      $k=$30;
      var $31=$idx;
      $io=$31;
      var $32=$k;
      var $conv16=(($32)|0);
      var $33=$io;
      var $value_17=(($33)|0);
      var $n18=$value_17;
      (HEAPF64[(tempDoublePtr)>>3]=$conv16,HEAP32[(($n18)>>2)]=HEAP32[((tempDoublePtr)>>2)],HEAP32[((($n18)+(4))>>2)]=HEAP32[(((tempDoublePtr)+(4))>>2)]);
      var $34=$io;
      var $tt_19=(($34+8)|0);
      HEAP32[(($tt_19)>>2)]=3;
      var $35=$k;
      var $add20=((($35)+(1))|0);
      var $36=$f;
      var $sizek21=(($36+44)|0);
      var $37=HEAP32[(($sizek21)>>2)];
      var $cmp22=(($add20)|0) > (($37)|0);
      if ($cmp22) { label = 8; break; } else { label = 9; break; }
    case 8: 
      var $38=$L;
      var $39=$f;
      var $k25=(($39+8)|0);
      var $40=HEAP32[(($k25)>>2)];
      var $41=$40;
      var $42=$f;
      var $sizek26=(($42+44)|0);
      var $call27=_luaM_growaux_($38, $41, $sizek26, 12, 67108863, ((5245684)|0));
      var $43=$call27;
      var $44=$f;
      var $k28=(($44+8)|0);
      HEAP32[(($k28)>>2)]=$43;
      label = 9; break;
    case 9: 
      label = 10; break;
    case 10: 
      var $45=$oldsize;
      var $46=$f;
      var $sizek30=(($46+44)|0);
      var $47=HEAP32[(($sizek30)>>2)];
      var $cmp31=(($45)|0) < (($47)|0);
      if ($cmp31) { label = 11; break; } else { label = 12; break; }
    case 11: 
      var $48=$oldsize;
      var $inc=((($48)+(1))|0);
      $oldsize=$inc;
      var $49=$f;
      var $k33=(($49+8)|0);
      var $50=HEAP32[(($k33)>>2)];
      var $arrayidx34=(($50+((($48)*(12))&-1))|0);
      var $tt_35=(($arrayidx34+8)|0);
      HEAP32[(($tt_35)>>2)]=0;
      label = 10; break;
    case 12: 
      var $51=$v_addr;
      $io2=$51;
      var $52=$k;
      var $53=$f;
      var $k36=(($53+8)|0);
      var $54=HEAP32[(($k36)>>2)];
      var $arrayidx37=(($54+((($52)*(12))&-1))|0);
      $io1=$arrayidx37;
      var $55=$io1;
      var $value_38=(($55)|0);
      var $56=$io2;
      var $value_39=(($56)|0);
      var $57=$value_38;
      var $58=$value_39;
      HEAP32[(($57)>>2)]=HEAP32[(($58)>>2)];HEAP32[((($57)+(4))>>2)]=HEAP32[((($58)+(4))>>2)];
      var $59=$io2;
      var $tt_40=(($59+8)|0);
      var $60=HEAP32[(($tt_40)>>2)];
      var $61=$io1;
      var $tt_41=(($61+8)|0);
      HEAP32[(($tt_41)>>2)]=$60;
      var $62=$fs_addr;
      var $nk42=(($62+32)|0);
      var $63=HEAP32[(($nk42)>>2)];
      var $inc43=((($63)+(1))|0);
      HEAP32[(($nk42)>>2)]=$inc43;
      var $64=$v_addr;
      var $tt_44=(($64+8)|0);
      var $65=HEAP32[(($tt_44)>>2)];
      var $and=$65 & 64;
      var $tobool45=(($and)|0)!=0;
      if ($tobool45) { label = 13; break; } else { label = 16; break; }
    case 13: 
      var $66=$v_addr;
      var $value_47=(($66)|0);
      var $gc=$value_47;
      var $67=HEAP32[(($gc)>>2)];
      var $gch=$67;
      var $marked=(($gch+5)|0);
      var $68=HEAP8[($marked)];
      var $conv48=(($68)&255);
      var $and49=$conv48 & 3;
      var $tobool50=(($and49)|0)!=0;
      if ($tobool50) { label = 14; break; } else { label = 16; break; }
    case 14: 
      var $69=$f;
      var $70=$69;
      var $gch52=$70;
      var $marked53=(($gch52+5)|0);
      var $71=HEAP8[($marked53)];
      var $conv54=(($71)&255);
      var $and55=$conv54 & 4;
      var $tobool56=(($and55)|0)!=0;
      if ($tobool56) { label = 15; break; } else { label = 16; break; }
    case 15: 
      var $72=$L;
      var $73=$f;
      var $74=$73;
      var $75=$v_addr;
      var $value_58=(($75)|0);
      var $gc59=$value_58;
      var $76=HEAP32[(($gc59)>>2)];
      _luaC_barrier_($72, $74, $76);
      label = 16; break;
    case 16: 
      var $77=$k;
      $retval=$77;
      label = 17; break;
    case 17: 
      var $78=$retval;
      STACKTOP = __stackBase__;
      Module.print(INDENT + 'Exiting: _addk');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return $78;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_addk["X"]=1;

function _luaK_numberK($fs, $r) {
  var label = 0;
  var __stackBase__  = STACKTOP; STACKTOP = (STACKTOP + 20)|0; _memset(__stackBase__, 0, 20);
  Module.print(INDENT + ' Entering: _luaK_numberK: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $fs_addr;
      var $r_addr=__stackBase__;
      var $n;
      var $L;
      var $o=(__stackBase__)+(8);
      var $io;
      var $io4;
      var $x_;
      $fs_addr=$fs;
      (HEAPF64[(tempDoublePtr)>>3]=$r,HEAP32[(($r_addr)>>2)]=HEAP32[((tempDoublePtr)>>2)],HEAP32[((($r_addr)+(4))>>2)]=HEAP32[(((tempDoublePtr)+(4))>>2)]);
      var $0=$fs_addr;
      var $ls=(($0+12)|0);
      var $1=HEAP32[(($ls)>>2)];
      var $L1=(($1+40)|0);
      var $2=HEAP32[(($L1)>>2)];
      $L=$2;
      $io=$o;
      var $3=(HEAP32[((tempDoublePtr)>>2)]=HEAP32[(($r_addr)>>2)],HEAP32[(((tempDoublePtr)+(4))>>2)]=HEAP32[((($r_addr)+(4))>>2)],HEAPF64[(tempDoublePtr)>>3]);
      var $4=$io;
      var $value_=(($4)|0);
      var $n2=$value_;
      (HEAPF64[(tempDoublePtr)>>3]=$3,HEAP32[(($n2)>>2)]=HEAP32[((tempDoublePtr)>>2)],HEAP32[((($n2)+(4))>>2)]=HEAP32[(((tempDoublePtr)+(4))>>2)]);
      var $5=$io;
      var $tt_=(($5+8)|0);
      HEAP32[(($tt_)>>2)]=3;
      var $6=(HEAP32[((tempDoublePtr)>>2)]=HEAP32[(($r_addr)>>2)],HEAP32[(((tempDoublePtr)+(4))>>2)]=HEAP32[((($r_addr)+(4))>>2)],HEAPF64[(tempDoublePtr)>>3]);
      var $cmp=$6 == 0;
      if ($cmp) { label = 4; break; } else { label = 3; break; }
    case 3: 
      var $7=(HEAP32[((tempDoublePtr)>>2)]=HEAP32[(($r_addr)>>2)],HEAP32[(((tempDoublePtr)+(4))>>2)]=HEAP32[((($r_addr)+(4))>>2)],HEAPF64[(tempDoublePtr)>>3]);
      var $8=(HEAP32[((tempDoublePtr)>>2)]=HEAP32[(($r_addr)>>2)],HEAP32[(((tempDoublePtr)+(4))>>2)]=HEAP32[((($r_addr)+(4))>>2)],HEAPF64[(tempDoublePtr)>>3]);
      var $cmp3=$7 == $8;
      if ($cmp3) { label = 8; break; } else { label = 4; break; }
    case 4: 
      var $9=$L;
      var $top=(($9+8)|0);
      var $10=HEAP32[(($top)>>2)];
      $io4=$10;
      var $11=$L;
      var $12=$r_addr;
      var $call=_luaS_newlstr($11, $12, 8);
      $x_=$call;
      var $13=$x_;
      var $14=$13;
      var $15=$io4;
      var $value_5=(($15)|0);
      var $gc=$value_5;
      HEAP32[(($gc)>>2)]=$14;
      var $16=$x_;
      var $tsv=$16;
      var $tt=(($tsv+4)|0);
      var $17=HEAP8[($tt)];
      var $conv=(($17)&255);
      var $or=$conv | 64;
      var $18=$io4;
      var $tt_6=(($18+8)|0);
      HEAP32[(($tt_6)>>2)]=$or;
      var $19=$L;
      var $top7=(($19+8)|0);
      var $20=HEAP32[(($top7)>>2)];
      var $incdec_ptr=(($20+12)|0);
      HEAP32[(($top7)>>2)]=$incdec_ptr;
      var $21=$L;
      var $stack_last=(($21+24)|0);
      var $22=HEAP32[(($stack_last)>>2)];
      var $23=$L;
      var $top8=(($23+8)|0);
      var $24=HEAP32[(($top8)>>2)];
      var $sub_ptr_lhs_cast=$22;
      var $sub_ptr_rhs_cast=$24;
      var $sub_ptr_sub=((($sub_ptr_lhs_cast)-($sub_ptr_rhs_cast))|0);
      var $sub_ptr_div=((((($sub_ptr_sub)|0))/(12))&-1);
      var $cmp9=(($sub_ptr_div)|0) <= 0;
      if ($cmp9) { label = 5; break; } else { label = 6; break; }
    case 5: 
      var $25=$L;
      _luaD_growstack($25, 0);
      label = 7; break;
    case 6: 
      label = 7; break;
    case 7: 
      var $26=$fs_addr;
      var $27=$L;
      var $top12=(($27+8)|0);
      var $28=HEAP32[(($top12)>>2)];
      var $add_ptr=((($28)-(12))|0);
      var $call13=_addk($26, $add_ptr, $o);
      $n=$call13;
      var $29=$L;
      var $top14=(($29+8)|0);
      var $30=HEAP32[(($top14)>>2)];
      var $incdec_ptr15=((($30)-(12))|0);
      HEAP32[(($top14)>>2)]=$incdec_ptr15;
      label = 9; break;
    case 8: 
      var $31=$fs_addr;
      var $call17=_addk($31, $o, $o);
      $n=$call17;
      label = 9; break;
    case 9: 
      var $32=$n;
      STACKTOP = __stackBase__;
      Module.print(INDENT + 'Exiting: _luaK_numberK');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return $32;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_luaK_numberK["X"]=1;

function _luaK_setreturns($fs, $e, $nresults) {
  var label = 0;

  Module.print(INDENT + ' Entering: _luaK_setreturns: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $fs_addr;
      var $e_addr;
      var $nresults_addr;
      $fs_addr=$fs;
      $e_addr=$e;
      $nresults_addr=$nresults;
      var $0=$e_addr;
      var $k=(($0)|0);
      var $1=HEAP32[(($k)>>2)];
      var $cmp=(($1)|0)==12;
      if ($cmp) { label = 3; break; } else { label = 4; break; }
    case 3: 
      var $2=$e_addr;
      var $u=(($2+4)|0);
      var $info=$u;
      var $3=HEAP32[(($info)>>2)];
      var $4=$fs_addr;
      var $f=(($4)|0);
      var $5=HEAP32[(($f)>>2)];
      var $code=(($5+12)|0);
      var $6=HEAP32[(($code)>>2)];
      var $arrayidx=(($6+($3<<2))|0);
      var $7=HEAP32[(($arrayidx)>>2)];
      var $and=$7 & -8372225;
      var $8=$nresults_addr;
      var $add=((($8)+(1))|0);
      var $shl=$add << 14;
      var $and1=$shl & 8372224;
      var $or=$and | $and1;
      var $9=$e_addr;
      var $u2=(($9+4)|0);
      var $info3=$u2;
      var $10=HEAP32[(($info3)>>2)];
      var $11=$fs_addr;
      var $f4=(($11)|0);
      var $12=HEAP32[(($f4)>>2)];
      var $code5=(($12+12)|0);
      var $13=HEAP32[(($code5)>>2)];
      var $arrayidx6=(($13+($10<<2))|0);
      HEAP32[(($arrayidx6)>>2)]=$or;
      label = 7; break;
    case 4: 
      var $14=$e_addr;
      var $k7=(($14)|0);
      var $15=HEAP32[(($k7)>>2)];
      var $cmp8=(($15)|0)==13;
      if ($cmp8) { label = 5; break; } else { label = 6; break; }
    case 5: 
      var $16=$e_addr;
      var $u10=(($16+4)|0);
      var $info11=$u10;
      var $17=HEAP32[(($info11)>>2)];
      var $18=$fs_addr;
      var $f12=(($18)|0);
      var $19=HEAP32[(($f12)>>2)];
      var $code13=(($19+12)|0);
      var $20=HEAP32[(($code13)>>2)];
      var $arrayidx14=(($20+($17<<2))|0);
      var $21=HEAP32[(($arrayidx14)>>2)];
      var $and15=$21 & 8388607;
      var $22=$nresults_addr;
      var $add16=((($22)+(1))|0);
      var $shl17=$add16 << 23;
      var $and18=$shl17 & -8388608;
      var $or19=$and15 | $and18;
      var $23=$e_addr;
      var $u20=(($23+4)|0);
      var $info21=$u20;
      var $24=HEAP32[(($info21)>>2)];
      var $25=$fs_addr;
      var $f22=(($25)|0);
      var $26=HEAP32[(($f22)>>2)];
      var $code23=(($26+12)|0);
      var $27=HEAP32[(($code23)>>2)];
      var $arrayidx24=(($27+($24<<2))|0);
      HEAP32[(($arrayidx24)>>2)]=$or19;
      var $28=$e_addr;
      var $u25=(($28+4)|0);
      var $info26=$u25;
      var $29=HEAP32[(($info26)>>2)];
      var $30=$fs_addr;
      var $f27=(($30)|0);
      var $31=HEAP32[(($f27)>>2)];
      var $code28=(($31+12)|0);
      var $32=HEAP32[(($code28)>>2)];
      var $arrayidx29=(($32+($29<<2))|0);
      var $33=HEAP32[(($arrayidx29)>>2)];
      var $and30=$33 & -16321;
      var $34=$fs_addr;
      var $freereg=(($34+48)|0);
      var $35=HEAP8[($freereg)];
      var $conv=(($35)&255);
      var $shl31=$conv << 6;
      var $and32=$shl31 & 16320;
      var $or33=$and30 | $and32;
      var $36=$e_addr;
      var $u34=(($36+4)|0);
      var $info35=$u34;
      var $37=HEAP32[(($info35)>>2)];
      var $38=$fs_addr;
      var $f36=(($38)|0);
      var $39=HEAP32[(($f36)>>2)];
      var $code37=(($39+12)|0);
      var $40=HEAP32[(($code37)>>2)];
      var $arrayidx38=(($40+($37<<2))|0);
      HEAP32[(($arrayidx38)>>2)]=$or33;
      var $41=$fs_addr;
      _luaK_reserveregs($41, 1);
      label = 6; break;
    case 6: 
      label = 7; break;
    case 7: 

      Module.print(INDENT + 'Exiting: _luaK_setreturns');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_luaK_setreturns["X"]=1;

function _luaK_dischargevars($fs, $e) {
  var label = 0;

  Module.print(INDENT + ' Entering: _luaK_dischargevars: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $fs_addr;
      var $e_addr;
      var $op;
      $fs_addr=$fs;
      $e_addr=$e;
      var $0=$e_addr;
      var $k=(($0)|0);
      var $1=HEAP32[(($k)>>2)];
      if ((($1)|0)==7) {
        label = 3; break;
      }
      else if ((($1)|0)==8) {
        label = 4; break;
      }
      else if ((($1)|0)==9) {
        label = 5; break;
      }
      else if ((($1)|0)==13 | (($1)|0)==12) {
        label = 8; break;
      }
      else {
      label = 9; break;
      }
      
    case 3: 
      var $2=$e_addr;
      var $k1=(($2)|0);
      HEAP32[(($k1)>>2)]=6;
      label = 10; break;
    case 4: 
      var $3=$fs_addr;
      var $4=$e_addr;
      var $u=(($4+4)|0);
      var $info=$u;
      var $5=HEAP32[(($info)>>2)];
      var $call=_luaK_codeABC($3, 5, 0, $5, 0);
      var $6=$e_addr;
      var $u3=(($6+4)|0);
      var $info4=$u3;
      HEAP32[(($info4)>>2)]=$call;
      var $7=$e_addr;
      var $k5=(($7)|0);
      HEAP32[(($k5)>>2)]=11;
      label = 10; break;
    case 5: 
      $op=6;
      var $8=$fs_addr;
      var $9=$e_addr;
      var $u7=(($9+4)|0);
      var $ind=$u7;
      var $idx=(($ind)|0);
      var $10=HEAP16[(($idx)>>1)];
      var $conv=(($10 << 16) >> 16);
      _freereg($8, $conv);
      var $11=$e_addr;
      var $u8=(($11+4)|0);
      var $ind9=$u8;
      var $vt=(($ind9+3)|0);
      var $12=HEAP8[($vt)];
      var $conv10=(($12)&255);
      var $cmp=(($conv10)|0)==7;
      if ($cmp) { label = 6; break; } else { label = 7; break; }
    case 6: 
      var $13=$fs_addr;
      var $14=$e_addr;
      var $u12=(($14+4)|0);
      var $ind13=$u12;
      var $t=(($ind13+2)|0);
      var $15=HEAP8[($t)];
      var $conv14=(($15)&255);
      _freereg($13, $conv14);
      $op=7;
      label = 7; break;
    case 7: 
      var $16=$fs_addr;
      var $17=$op;
      var $18=$e_addr;
      var $u15=(($18+4)|0);
      var $ind16=$u15;
      var $t17=(($ind16+2)|0);
      var $19=HEAP8[($t17)];
      var $conv18=(($19)&255);
      var $20=$e_addr;
      var $u19=(($20+4)|0);
      var $ind20=$u19;
      var $idx21=(($ind20)|0);
      var $21=HEAP16[(($idx21)>>1)];
      var $conv22=(($21 << 16) >> 16);
      var $call23=_luaK_codeABC($16, $17, 0, $conv18, $conv22);
      var $22=$e_addr;
      var $u24=(($22+4)|0);
      var $info25=$u24;
      HEAP32[(($info25)>>2)]=$call23;
      var $23=$e_addr;
      var $k26=(($23)|0);
      HEAP32[(($k26)>>2)]=11;
      label = 10; break;
    case 8: 
      var $24=$fs_addr;
      var $25=$e_addr;
      _luaK_setoneret($24, $25);
      label = 10; break;
    case 9: 
      label = 10; break;
    case 10: 

      Module.print(INDENT + 'Exiting: _luaK_dischargevars');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_luaK_dischargevars["X"]=1;

function _luaK_exp2nextreg($fs, $e) {
  var label = 0;

  Module.print(INDENT + ' Entering: _luaK_exp2nextreg: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';

  var $fs_addr;
  var $e_addr;
  $fs_addr=$fs;
  $e_addr=$e;
  var $0=$fs_addr;
  var $1=$e_addr;
  _luaK_dischargevars($0, $1);
  var $2=$fs_addr;
  var $3=$e_addr;
  _freeexp($2, $3);
  var $4=$fs_addr;
  _luaK_reserveregs($4, 1);
  var $5=$fs_addr;
  var $6=$e_addr;
  var $7=$fs_addr;
  var $freereg=(($7+48)|0);
  var $8=HEAP8[($freereg)];
  var $conv=(($8)&255);
  var $sub=((($conv)-(1))|0);
  _exp2reg($5, $6, $sub);

  Module.print(INDENT + 'Exiting: _luaK_exp2nextreg');
  INDENT = INDENT.substr(0, INDENT.length-2);
  return;
  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _freeexp($fs, $e) {
  var label = 0;

  Module.print(INDENT + ' Entering: _freeexp: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $fs_addr;
      var $e_addr;
      $fs_addr=$fs;
      $e_addr=$e;
      var $0=$e_addr;
      var $k=(($0)|0);
      var $1=HEAP32[(($k)>>2)];
      var $cmp=(($1)|0)==6;
      if ($cmp) { label = 3; break; } else { label = 4; break; }
    case 3: 
      var $2=$fs_addr;
      var $3=$e_addr;
      var $u=(($3+4)|0);
      var $info=$u;
      var $4=HEAP32[(($info)>>2)];
      _freereg($2, $4);
      label = 4; break;
    case 4: 

      Module.print(INDENT + 'Exiting: _freeexp');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _luaK_checkstack($fs, $n) {
  var label = 0;

  Module.print(INDENT + ' Entering: _luaK_checkstack: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $fs_addr;
      var $n_addr;
      var $newstack;
      $fs_addr=$fs;
      $n_addr=$n;
      var $0=$fs_addr;
      var $freereg=(($0+48)|0);
      var $1=HEAP8[($freereg)];
      var $conv=(($1)&255);
      var $2=$n_addr;
      var $add=((($conv)+($2))|0);
      $newstack=$add;
      var $3=$newstack;
      var $4=$fs_addr;
      var $f=(($4)|0);
      var $5=HEAP32[(($f)>>2)];
      var $maxstacksize=(($5+78)|0);
      var $6=HEAP8[($maxstacksize)];
      var $conv1=(($6)&255);
      var $cmp=(($3)|0) > (($conv1)|0);
      if ($cmp) { label = 3; break; } else { label = 6; break; }
    case 3: 
      var $7=$newstack;
      var $cmp3=(($7)|0) >= 250;
      if ($cmp3) { label = 4; break; } else { label = 5; break; }
    case 4: 
      var $8=$fs_addr;
      var $ls=(($8+12)|0);
      var $9=HEAP32[(($ls)>>2)];
      _luaX_syntaxerror($9, ((5246088)|0));

    case 5: 
      var $10=$newstack;
      var $conv6=(($10) & 255);
      var $11=$fs_addr;
      var $f7=(($11)|0);
      var $12=HEAP32[(($f7)>>2)];
      var $maxstacksize8=(($12+78)|0);
      HEAP8[($maxstacksize8)]=$conv6;
      label = 6; break;
    case 6: 

      Module.print(INDENT + 'Exiting: _luaK_checkstack');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _isnumeral($e) {
  var label = 0;

  Module.print(INDENT + ' Entering: _isnumeral: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $e_addr;
      $e_addr=$e;
      var $0=$e_addr;
      var $k=(($0)|0);
      var $1=HEAP32[(($k)>>2)];
      var $cmp=(($1)|0)==5;
      if ($cmp) { label = 3; break; } else { var $6 = 0;label = 5; break; }
    case 3: 
      var $2=$e_addr;
      var $t=(($2+12)|0);
      var $3=HEAP32[(($t)>>2)];
      var $cmp1=(($3)|0)==-1;
      if ($cmp1) { label = 4; break; } else { var $6 = 0;label = 5; break; }
    case 4: 
      var $4=$e_addr;
      var $f=(($4+16)|0);
      var $5=HEAP32[(($f)>>2)];
      var $cmp2=(($5)|0)==-1;
      var $6 = $cmp2;label = 5; break;
    case 5: 
      var $6;
      var $land_ext=(($6)&1);

      Module.print(INDENT + 'Exiting: _isnumeral');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return $land_ext;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _exp2reg($fs, $e, $reg) {
  var label = 0;

  Module.print(INDENT + ' Entering: _exp2reg: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $fs_addr;
      var $e_addr;
      var $reg_addr;
      var $final;
      var $p_f;
      var $p_t;
      var $fj;
      $fs_addr=$fs;
      $e_addr=$e;
      $reg_addr=$reg;
      var $0=$fs_addr;
      var $1=$e_addr;
      var $2=$reg_addr;
      _discharge2reg($0, $1, $2);
      var $3=$e_addr;
      var $k=(($3)|0);
      var $4=HEAP32[(($k)>>2)];
      var $cmp=(($4)|0)==10;
      if ($cmp) { label = 3; break; } else { label = 4; break; }
    case 3: 
      var $5=$fs_addr;
      var $6=$e_addr;
      var $t=(($6+12)|0);
      var $7=$e_addr;
      var $u=(($7+4)|0);
      var $info=$u;
      var $8=HEAP32[(($info)>>2)];
      _luaK_concat($5, $t, $8);
      label = 4; break;
    case 4: 
      var $9=$e_addr;
      var $t1=(($9+12)|0);
      var $10=HEAP32[(($t1)>>2)];
      var $11=$e_addr;
      var $f=(($11+16)|0);
      var $12=HEAP32[(($f)>>2)];
      var $cmp2=(($10)|0)!=(($12)|0);
      if ($cmp2) { label = 5; break; } else { label = 12; break; }
    case 5: 
      $p_f=-1;
      $p_t=-1;
      var $13=$fs_addr;
      var $14=$e_addr;
      var $t4=(($14+12)|0);
      var $15=HEAP32[(($t4)>>2)];
      var $call=_need_value($13, $15);
      var $tobool=(($call)|0)!=0;
      if ($tobool) { label = 7; break; } else { label = 6; break; }
    case 6: 
      var $16=$fs_addr;
      var $17=$e_addr;
      var $f5=(($17+16)|0);
      var $18=HEAP32[(($f5)>>2)];
      var $call6=_need_value($16, $18);
      var $tobool7=(($call6)|0)!=0;
      if ($tobool7) { label = 7; break; } else { label = 11; break; }
    case 7: 
      var $19=$e_addr;
      var $k9=(($19)|0);
      var $20=HEAP32[(($k9)>>2)];
      var $cmp10=(($20)|0)==10;
      if ($cmp10) { label = 8; break; } else { label = 9; break; }
    case 8: 
      var $cond = -1;label = 10; break;
    case 9: 
      var $21=$fs_addr;
      var $call11=_luaK_jump($21);
      var $cond = $call11;label = 10; break;
    case 10: 
      var $cond;
      $fj=$cond;
      var $22=$fs_addr;
      var $23=$reg_addr;
      var $call12=_code_label($22, $23, 0, 1);
      $p_f=$call12;
      var $24=$fs_addr;
      var $25=$reg_addr;
      var $call13=_code_label($24, $25, 1, 0);
      $p_t=$call13;
      var $26=$fs_addr;
      var $27=$fj;
      _luaK_patchtohere($26, $27);
      label = 11; break;
    case 11: 
      var $28=$fs_addr;
      var $call15=_luaK_getlabel($28);
      $final=$call15;
      var $29=$fs_addr;
      var $30=$e_addr;
      var $f16=(($30+16)|0);
      var $31=HEAP32[(($f16)>>2)];
      var $32=$final;
      var $33=$reg_addr;
      var $34=$p_f;
      _patchlistaux($29, $31, $32, $33, $34);
      var $35=$fs_addr;
      var $36=$e_addr;
      var $t17=(($36+12)|0);
      var $37=HEAP32[(($t17)>>2)];
      var $38=$final;
      var $39=$reg_addr;
      var $40=$p_t;
      _patchlistaux($35, $37, $38, $39, $40);
      label = 12; break;
    case 12: 
      var $41=$e_addr;
      var $t19=(($41+12)|0);
      HEAP32[(($t19)>>2)]=-1;
      var $42=$e_addr;
      var $f20=(($42+16)|0);
      HEAP32[(($f20)>>2)]=-1;
      var $43=$reg_addr;
      var $44=$e_addr;
      var $u21=(($44+4)|0);
      var $info22=$u21;
      HEAP32[(($info22)>>2)]=$43;
      var $45=$e_addr;
      var $k23=(($45)|0);
      HEAP32[(($k23)>>2)]=6;

      Module.print(INDENT + 'Exiting: _exp2reg');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_exp2reg["X"]=1;

function _luaK_exp2anyreg($fs, $e) {
  var label = 0;

  Module.print(INDENT + ' Entering: _luaK_exp2anyreg: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $retval;
      var $fs_addr;
      var $e_addr;
      $fs_addr=$fs;
      $e_addr=$e;
      var $0=$fs_addr;
      var $1=$e_addr;
      _luaK_dischargevars($0, $1);
      var $2=$e_addr;
      var $k=(($2)|0);
      var $3=HEAP32[(($k)>>2)];
      var $cmp=(($3)|0)==6;
      if ($cmp) { label = 3; break; } else { label = 8; break; }
    case 3: 
      var $4=$e_addr;
      var $t=(($4+12)|0);
      var $5=HEAP32[(($t)>>2)];
      var $6=$e_addr;
      var $f=(($6+16)|0);
      var $7=HEAP32[(($f)>>2)];
      var $cmp1=(($5)|0)!=(($7)|0);
      if ($cmp1) { label = 5; break; } else { label = 4; break; }
    case 4: 
      var $8=$e_addr;
      var $u=(($8+4)|0);
      var $info=$u;
      var $9=HEAP32[(($info)>>2)];
      $retval=$9;
      label = 9; break;
    case 5: 
      var $10=$e_addr;
      var $u3=(($10+4)|0);
      var $info4=$u3;
      var $11=HEAP32[(($info4)>>2)];
      var $12=$fs_addr;
      var $nactvar=(($12+46)|0);
      var $13=HEAP8[($nactvar)];
      var $conv=(($13)&255);
      var $cmp5=(($11)|0) >= (($conv)|0);
      if ($cmp5) { label = 6; break; } else { label = 7; break; }
    case 6: 
      var $14=$fs_addr;
      var $15=$e_addr;
      var $16=$e_addr;
      var $u8=(($16+4)|0);
      var $info9=$u8;
      var $17=HEAP32[(($info9)>>2)];
      _exp2reg($14, $15, $17);
      var $18=$e_addr;
      var $u10=(($18+4)|0);
      var $info11=$u10;
      var $19=HEAP32[(($info11)>>2)];
      $retval=$19;
      label = 9; break;
    case 7: 
      label = 8; break;
    case 8: 
      var $20=$fs_addr;
      var $21=$e_addr;
      _luaK_exp2nextreg($20, $21);
      var $22=$e_addr;
      var $u14=(($22+4)|0);
      var $info15=$u14;
      var $23=HEAP32[(($info15)>>2)];
      $retval=$23;
      label = 9; break;
    case 9: 
      var $24=$retval;

      Module.print(INDENT + 'Exiting: _luaK_exp2anyreg');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return $24;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_luaK_exp2anyreg["X"]=1;

function _luaK_exp2anyregup($fs, $e) {
  var label = 0;

  Module.print(INDENT + ' Entering: _luaK_exp2anyregup: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $fs_addr;
      var $e_addr;
      $fs_addr=$fs;
      $e_addr=$e;
      var $0=$e_addr;
      var $k=(($0)|0);
      var $1=HEAP32[(($k)>>2)];
      var $cmp=(($1)|0)!=8;
      if ($cmp) { label = 4; break; } else { label = 3; break; }
    case 3: 
      var $2=$e_addr;
      var $t=(($2+12)|0);
      var $3=HEAP32[(($t)>>2)];
      var $4=$e_addr;
      var $f=(($4+16)|0);
      var $5=HEAP32[(($f)>>2)];
      var $cmp1=(($3)|0)!=(($5)|0);
      if ($cmp1) { label = 4; break; } else { label = 5; break; }
    case 4: 
      var $6=$fs_addr;
      var $7=$e_addr;
      var $call=_luaK_exp2anyreg($6, $7);
      label = 5; break;
    case 5: 

      Module.print(INDENT + 'Exiting: _luaK_exp2anyregup');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _luaK_exp2val($fs, $e) {
  var label = 0;

  Module.print(INDENT + ' Entering: _luaK_exp2val: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $fs_addr;
      var $e_addr;
      $fs_addr=$fs;
      $e_addr=$e;
      var $0=$e_addr;
      var $t=(($0+12)|0);
      var $1=HEAP32[(($t)>>2)];
      var $2=$e_addr;
      var $f=(($2+16)|0);
      var $3=HEAP32[(($f)>>2)];
      var $cmp=(($1)|0)!=(($3)|0);
      if ($cmp) { label = 3; break; } else { label = 4; break; }
    case 3: 
      var $4=$fs_addr;
      var $5=$e_addr;
      var $call=_luaK_exp2anyreg($4, $5);
      label = 5; break;
    case 4: 
      var $6=$fs_addr;
      var $7=$e_addr;
      _luaK_dischargevars($6, $7);
      label = 5; break;
    case 5: 

      Module.print(INDENT + 'Exiting: _luaK_exp2val');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _luaK_exp2RK($fs, $e) {
  var label = 0;

  Module.print(INDENT + ' Entering: _luaK_exp2RK: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $retval;
      var $fs_addr;
      var $e_addr;
      $fs_addr=$fs;
      $e_addr=$e;
      var $0=$fs_addr;
      var $1=$e_addr;
      _luaK_exp2val($0, $1);
      var $2=$e_addr;
      var $k=(($2)|0);
      var $3=HEAP32[(($k)>>2)];
      if ((($3)|0)==2 | (($3)|0)==3 | (($3)|0)==1) {
        label = 3; break;
      }
      else if ((($3)|0)==5) {
        label = 9; break;
      }
      else if ((($3)|0)==4) {
        label = 10; break;
      }
      else {
      label = 13; break;
      }
      
    case 3: 
      var $4=$fs_addr;
      var $nk=(($4+32)|0);
      var $5=HEAP32[(($nk)>>2)];
      var $cmp=(($5)|0) <= 255;
      if ($cmp) { label = 4; break; } else { label = 8; break; }
    case 4: 
      var $6=$e_addr;
      var $k1=(($6)|0);
      var $7=HEAP32[(($k1)>>2)];
      var $cmp2=(($7)|0)==1;
      if ($cmp2) { label = 5; break; } else { label = 6; break; }
    case 5: 
      var $8=$fs_addr;
      var $call=_nilK($8);
      var $cond = $call;label = 7; break;
    case 6: 
      var $9=$fs_addr;
      var $10=$e_addr;
      var $k3=(($10)|0);
      var $11=HEAP32[(($k3)>>2)];
      var $cmp4=(($11)|0)==2;
      var $conv=(($cmp4)&1);
      var $call5=_boolK($9, $conv);
      var $cond = $call5;label = 7; break;
    case 7: 
      var $cond;
      var $12=$e_addr;
      var $u=(($12+4)|0);
      var $info=$u;
      HEAP32[(($info)>>2)]=$cond;
      var $13=$e_addr;
      var $k6=(($13)|0);
      HEAP32[(($k6)>>2)]=4;
      var $14=$e_addr;
      var $u7=(($14+4)|0);
      var $info8=$u7;
      var $15=HEAP32[(($info8)>>2)];
      var $or=$15 | 256;
      $retval=$or;
      label = 15; break;
    case 8: 
      label = 14; break;
    case 9: 
      var $16=$fs_addr;
      var $17=$e_addr;
      var $u10=(($17+4)|0);
      var $nval=$u10;
      var $18=(HEAP32[((tempDoublePtr)>>2)]=HEAP32[(($nval)>>2)],HEAP32[(((tempDoublePtr)+(4))>>2)]=HEAP32[((($nval)+(4))>>2)],HEAPF64[(tempDoublePtr)>>3]);
      var $call11=_luaK_numberK($16, $18);
      var $19=$e_addr;
      var $u12=(($19+4)|0);
      var $info13=$u12;
      HEAP32[(($info13)>>2)]=$call11;
      var $20=$e_addr;
      var $k14=(($20)|0);
      HEAP32[(($k14)>>2)]=4;
      label = 10; break;
    case 10: 
      var $21=$e_addr;
      var $u16=(($21+4)|0);
      var $info17=$u16;
      var $22=HEAP32[(($info17)>>2)];
      var $cmp18=(($22)|0) <= 255;
      if ($cmp18) { label = 11; break; } else { label = 12; break; }
    case 11: 
      var $23=$e_addr;
      var $u21=(($23+4)|0);
      var $info22=$u21;
      var $24=HEAP32[(($info22)>>2)];
      var $or23=$24 | 256;
      $retval=$or23;
      label = 15; break;
    case 12: 
      label = 14; break;
    case 13: 
      label = 14; break;
    case 14: 
      var $25=$fs_addr;
      var $26=$e_addr;
      var $call25=_luaK_exp2anyreg($25, $26);
      $retval=$call25;
      label = 15; break;
    case 15: 
      var $27=$retval;

      Module.print(INDENT + 'Exiting: _luaK_exp2RK');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return $27;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_luaK_exp2RK["X"]=1;

function _nilK($fs) {
  var label = 0;
  var __stackBase__  = STACKTOP; STACKTOP = (STACKTOP + 24)|0; _memset(__stackBase__, 0, 24);
  Module.print(INDENT + ' Entering: _nilK: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';

  var $fs_addr;
  var $k=__stackBase__;
  var $v=(__stackBase__)+(12);
  var $io;
  $fs_addr=$fs;
  var $tt_=(($v+8)|0);
  HEAP32[(($tt_)>>2)]=0;
  $io=$k;
  var $0=$fs_addr;
  var $h=(($0+4)|0);
  var $1=HEAP32[(($h)>>2)];
  var $2=$1;
  var $3=$io;
  var $value_=(($3)|0);
  var $gc=$value_;
  HEAP32[(($gc)>>2)]=$2;
  var $4=$io;
  var $tt_1=(($4+8)|0);
  HEAP32[(($tt_1)>>2)]=69;
  var $5=$fs_addr;
  var $call=_addk($5, $k, $v);
  STACKTOP = __stackBase__;
  Module.print(INDENT + 'Exiting: _nilK');
  INDENT = INDENT.substr(0, INDENT.length-2);
  return $call;
  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _boolK($fs, $b) {
  var label = 0;
  var __stackBase__  = STACKTOP; STACKTOP = (STACKTOP + 12)|0; _memset(__stackBase__, 0, 12);
  Module.print(INDENT + ' Entering: _boolK: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';

  var $fs_addr;
  var $b_addr;
  var $o=__stackBase__;
  var $io;
  $fs_addr=$fs;
  $b_addr=$b;
  $io=$o;
  var $0=$b_addr;
  var $1=$io;
  var $value_=(($1)|0);
  var $b1=$value_;
  HEAP32[(($b1)>>2)]=$0;
  var $2=$io;
  var $tt_=(($2+8)|0);
  HEAP32[(($tt_)>>2)]=1;
  var $3=$fs_addr;
  var $call=_addk($3, $o, $o);
  STACKTOP = __stackBase__;
  Module.print(INDENT + 'Exiting: _boolK');
  INDENT = INDENT.substr(0, INDENT.length-2);
  return $call;
  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _luaK_storevar($fs, $var, $ex) {
  var label = 0;

  Module.print(INDENT + ' Entering: _luaK_storevar: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $fs_addr;
      var $var_addr;
      var $ex_addr;
      var $e;
      var $op;
      var $e8;
      $fs_addr=$fs;
      $var_addr=$var;
      $ex_addr=$ex;
      var $0=$var_addr;
      var $k=(($0)|0);
      var $1=HEAP32[(($k)>>2)];
      if ((($1)|0)==7) {
        label = 3; break;
      }
      else if ((($1)|0)==8) {
        label = 4; break;
      }
      else if ((($1)|0)==9) {
        label = 5; break;
      }
      else {
      label = 6; break;
      }
      
    case 3: 
      var $2=$fs_addr;
      var $3=$ex_addr;
      _freeexp($2, $3);
      var $4=$fs_addr;
      var $5=$ex_addr;
      var $6=$var_addr;
      var $u=(($6+4)|0);
      var $info=$u;
      var $7=HEAP32[(($info)>>2)];
      _exp2reg($4, $5, $7);
      label = 8; break;
    case 4: 
      var $8=$fs_addr;
      var $9=$ex_addr;
      var $call=_luaK_exp2anyreg($8, $9);
      $e=$call;
      var $10=$fs_addr;
      var $11=$e;
      var $12=$var_addr;
      var $u2=(($12+4)|0);
      var $info3=$u2;
      var $13=HEAP32[(($info3)>>2)];
      var $call4=_luaK_codeABC($10, 9, $11, $13, 0);
      label = 7; break;
    case 5: 
      var $14=$var_addr;
      var $u6=(($14+4)|0);
      var $ind=$u6;
      var $vt=(($ind+3)|0);
      var $15=HEAP8[($vt)];
      var $conv=(($15)&255);
      var $cmp=(($conv)|0)==7;
      var $cond=$cmp ? 10 : 8;
      $op=$cond;
      var $16=$fs_addr;
      var $17=$ex_addr;
      var $call9=_luaK_exp2RK($16, $17);
      $e8=$call9;
      var $18=$fs_addr;
      var $19=$op;
      var $20=$var_addr;
      var $u10=(($20+4)|0);
      var $ind11=$u10;
      var $t=(($ind11+2)|0);
      var $21=HEAP8[($t)];
      var $conv12=(($21)&255);
      var $22=$var_addr;
      var $u13=(($22+4)|0);
      var $ind14=$u13;
      var $idx=(($ind14)|0);
      var $23=HEAP16[(($idx)>>1)];
      var $conv15=(($23 << 16) >> 16);
      var $24=$e8;
      var $call16=_luaK_codeABC($18, $19, $conv12, $conv15, $24);
      label = 7; break;
    case 6: 
      label = 7; break;
    case 7: 
      var $25=$fs_addr;
      var $26=$ex_addr;
      _freeexp($25, $26);
      label = 8; break;
    case 8: 

      Module.print(INDENT + 'Exiting: _luaK_storevar');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_luaK_storevar["X"]=1;

function _luaK_self($fs, $e, $key) {
  var label = 0;

  Module.print(INDENT + ' Entering: _luaK_self: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';

  var $fs_addr;
  var $e_addr;
  var $key_addr;
  var $ereg;
  $fs_addr=$fs;
  $e_addr=$e;
  $key_addr=$key;
  var $0=$fs_addr;
  var $1=$e_addr;
  var $call=_luaK_exp2anyreg($0, $1);
  var $2=$e_addr;
  var $u=(($2+4)|0);
  var $info=$u;
  var $3=HEAP32[(($info)>>2)];
  $ereg=$3;
  var $4=$fs_addr;
  var $5=$e_addr;
  _freeexp($4, $5);
  var $6=$fs_addr;
  var $freereg=(($6+48)|0);
  var $7=HEAP8[($freereg)];
  var $conv=(($7)&255);
  var $8=$e_addr;
  var $u1=(($8+4)|0);
  var $info2=$u1;
  HEAP32[(($info2)>>2)]=$conv;
  var $9=$e_addr;
  var $k=(($9)|0);
  HEAP32[(($k)>>2)]=6;
  var $10=$fs_addr;
  _luaK_reserveregs($10, 2);
  var $11=$fs_addr;
  var $12=$e_addr;
  var $u3=(($12+4)|0);
  var $info4=$u3;
  var $13=HEAP32[(($info4)>>2)];
  var $14=$ereg;
  var $15=$fs_addr;
  var $16=$key_addr;
  var $call5=_luaK_exp2RK($15, $16);
  var $call6=_luaK_codeABC($11, 12, $13, $14, $call5);
  var $17=$fs_addr;
  var $18=$key_addr;
  _freeexp($17, $18);

  Module.print(INDENT + 'Exiting: _luaK_self');
  INDENT = INDENT.substr(0, INDENT.length-2);
  return;
  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _luaK_goiftrue($fs, $e) {
  var label = 0;

  Module.print(INDENT + ' Entering: _luaK_goiftrue: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $fs_addr;
      var $e_addr;
      var $pc;
      $fs_addr=$fs;
      $e_addr=$e;
      var $0=$fs_addr;
      var $1=$e_addr;
      _luaK_dischargevars($0, $1);
      var $2=$e_addr;
      var $k=(($2)|0);
      var $3=HEAP32[(($k)>>2)];
      if ((($3)|0)==10) {
        label = 3; break;
      }
      else if ((($3)|0)==4 | (($3)|0)==5 | (($3)|0)==2) {
        label = 4; break;
      }
      else {
      label = 5; break;
      }
      
    case 3: 
      var $4=$fs_addr;
      var $5=$e_addr;
      _invertjump($4, $5);
      var $6=$e_addr;
      var $u=(($6+4)|0);
      var $info=$u;
      var $7=HEAP32[(($info)>>2)];
      $pc=$7;
      label = 6; break;
    case 4: 
      $pc=-1;
      label = 6; break;
    case 5: 
      var $8=$fs_addr;
      var $9=$e_addr;
      var $call=_jumponcond($8, $9, 0);
      $pc=$call;
      label = 6; break;
    case 6: 
      var $10=$fs_addr;
      var $11=$e_addr;
      var $f=(($11+16)|0);
      var $12=$pc;
      _luaK_concat($10, $f, $12);
      var $13=$fs_addr;
      var $14=$e_addr;
      var $t=(($14+12)|0);
      var $15=HEAP32[(($t)>>2)];
      _luaK_patchtohere($13, $15);
      var $16=$e_addr;
      var $t2=(($16+12)|0);
      HEAP32[(($t2)>>2)]=-1;

      Module.print(INDENT + 'Exiting: _luaK_goiftrue');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _invertjump($fs, $e) {
  var label = 0;

  Module.print(INDENT + ' Entering: _invertjump: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';

  var $fs_addr;
  var $e_addr;
  var $pc;
  $fs_addr=$fs;
  $e_addr=$e;
  var $0=$fs_addr;
  var $1=$e_addr;
  var $u=(($1+4)|0);
  var $info=$u;
  var $2=HEAP32[(($info)>>2)];
  var $call=_getjumpcontrol($0, $2);
  $pc=$call;
  var $3=$pc;
  var $4=HEAP32[(($3)>>2)];
  var $and=$4 & -16321;
  var $5=$pc;
  var $6=HEAP32[(($5)>>2)];
  var $shr=$6 >>> 6;
  var $and1=$shr & 255;
  var $tobool=(($and1)|0)!=0;
  var $lnot=$tobool ^ 1;
  var $lnot_ext=(($lnot)&1);
  var $shl=$lnot_ext << 6;
  var $and2=$shl & 16320;
  var $or=$and | $and2;
  var $7=$pc;
  HEAP32[(($7)>>2)]=$or;

  Module.print(INDENT + 'Exiting: _invertjump');
  INDENT = INDENT.substr(0, INDENT.length-2);
  return;
  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _jumponcond($fs, $e, $cond) {
  var label = 0;

  Module.print(INDENT + ' Entering: _jumponcond: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $retval;
      var $fs_addr;
      var $e_addr;
      var $cond_addr;
      var $ie;
      $fs_addr=$fs;
      $e_addr=$e;
      $cond_addr=$cond;
      var $0=$e_addr;
      var $k=(($0)|0);
      var $1=HEAP32[(($k)>>2)];
      var $cmp=(($1)|0)==11;
      if ($cmp) { label = 3; break; } else { label = 6; break; }
    case 3: 
      var $2=$e_addr;
      var $u=(($2+4)|0);
      var $info=$u;
      var $3=HEAP32[(($info)>>2)];
      var $4=$fs_addr;
      var $f=(($4)|0);
      var $5=HEAP32[(($f)>>2)];
      var $code=(($5+12)|0);
      var $6=HEAP32[(($code)>>2)];
      var $arrayidx=(($6+($3<<2))|0);
      var $7=HEAP32[(($arrayidx)>>2)];
      $ie=$7;
      var $8=$ie;
      var $shr=$8 >>> 0;
      var $and=$shr & 63;
      var $cmp1=(($and)|0)==20;
      if ($cmp1) { label = 4; break; } else { label = 5; break; }
    case 4: 
      var $9=$fs_addr;
      var $pc=(($9+20)|0);
      var $10=HEAP32[(($pc)>>2)];
      var $dec=((($10)-(1))|0);
      HEAP32[(($pc)>>2)]=$dec;
      var $11=$fs_addr;
      var $12=$ie;
      var $shr3=$12 >>> 23;
      var $and4=$shr3 & 511;
      var $13=$cond_addr;
      var $tobool=(($13)|0)!=0;
      var $lnot=$tobool ^ 1;
      var $lnot_ext=(($lnot)&1);
      var $call=_condjump($11, 27, $and4, 0, $lnot_ext);
      $retval=$call;
      label = 7; break;
    case 5: 
      label = 6; break;
    case 6: 
      var $14=$fs_addr;
      var $15=$e_addr;
      _discharge2anyreg($14, $15);
      var $16=$fs_addr;
      var $17=$e_addr;
      _freeexp($16, $17);
      var $18=$fs_addr;
      var $19=$e_addr;
      var $u6=(($19+4)|0);
      var $info7=$u6;
      var $20=HEAP32[(($info7)>>2)];
      var $21=$cond_addr;
      var $call8=_condjump($18, 28, 255, $20, $21);
      $retval=$call8;
      label = 7; break;
    case 7: 
      var $22=$retval;

      Module.print(INDENT + 'Exiting: _jumponcond');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return $22;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_jumponcond["X"]=1;

function _luaK_goiffalse($fs, $e) {
  var label = 0;

  Module.print(INDENT + ' Entering: _luaK_goiffalse: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $fs_addr;
      var $e_addr;
      var $pc;
      $fs_addr=$fs;
      $e_addr=$e;
      var $0=$fs_addr;
      var $1=$e_addr;
      _luaK_dischargevars($0, $1);
      var $2=$e_addr;
      var $k=(($2)|0);
      var $3=HEAP32[(($k)>>2)];
      if ((($3)|0)==10) {
        label = 3; break;
      }
      else if ((($3)|0)==1 | (($3)|0)==3) {
        label = 4; break;
      }
      else {
      label = 5; break;
      }
      
    case 3: 
      var $4=$e_addr;
      var $u=(($4+4)|0);
      var $info=$u;
      var $5=HEAP32[(($info)>>2)];
      $pc=$5;
      label = 6; break;
    case 4: 
      $pc=-1;
      label = 6; break;
    case 5: 
      var $6=$fs_addr;
      var $7=$e_addr;
      var $call=_jumponcond($6, $7, 1);
      $pc=$call;
      label = 6; break;
    case 6: 
      var $8=$fs_addr;
      var $9=$e_addr;
      var $t=(($9+12)|0);
      var $10=$pc;
      _luaK_concat($8, $t, $10);
      var $11=$fs_addr;
      var $12=$e_addr;
      var $f=(($12+16)|0);
      var $13=HEAP32[(($f)>>2)];
      _luaK_patchtohere($11, $13);
      var $14=$e_addr;
      var $f2=(($14+16)|0);
      HEAP32[(($f2)>>2)]=-1;

      Module.print(INDENT + 'Exiting: _luaK_goiffalse');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _luaK_indexed($fs, $t, $k) {
  var label = 0;

  Module.print(INDENT + ' Entering: _luaK_indexed: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';

  var $fs_addr;
  var $t_addr;
  var $k_addr;
  $fs_addr=$fs;
  $t_addr=$t;
  $k_addr=$k;
  var $0=$t_addr;
  var $u=(($0+4)|0);
  var $info=$u;
  var $1=HEAP32[(($info)>>2)];
  var $conv=(($1) & 255);
  var $2=$t_addr;
  var $u1=(($2+4)|0);
  var $ind=$u1;
  var $t2=(($ind+2)|0);
  HEAP8[($t2)]=$conv;
  var $3=$fs_addr;
  var $4=$k_addr;
  var $call=_luaK_exp2RK($3, $4);
  var $conv3=(($call) & 65535);
  var $5=$t_addr;
  var $u4=(($5+4)|0);
  var $ind5=$u4;
  var $idx=(($ind5)|0);
  HEAP16[(($idx)>>1)]=$conv3;
  var $6=$t_addr;
  var $k6=(($6)|0);
  var $7=HEAP32[(($k6)>>2)];
  var $cmp=(($7)|0)==8;
  var $cond=$cmp ? 8 : 7;
  var $conv8=(($cond) & 255);
  var $8=$t_addr;
  var $u9=(($8+4)|0);
  var $ind10=$u9;
  var $vt=(($ind10+3)|0);
  HEAP8[($vt)]=$conv8;
  var $9=$t_addr;
  var $k11=(($9)|0);
  HEAP32[(($k11)>>2)]=9;

  Module.print(INDENT + 'Exiting: _luaK_indexed');
  INDENT = INDENT.substr(0, INDENT.length-2);
  return;
  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _luaK_prefix($fs, $op, $e, $line) {
  var label = 0;
  var __stackBase__  = STACKTOP; STACKTOP = (STACKTOP + 20)|0; _memset(__stackBase__, 0, 20);
  Module.print(INDENT + ' Entering: _luaK_prefix: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $fs_addr;
      var $op_addr;
      var $e_addr;
      var $line_addr;
      var $e2=__stackBase__;
      $fs_addr=$fs;
      $op_addr=$op;
      $e_addr=$e;
      $line_addr=$line;
      var $f=(($e2+16)|0);
      HEAP32[(($f)>>2)]=-1;
      var $t=(($e2+12)|0);
      HEAP32[(($t)>>2)]=-1;
      var $k=(($e2)|0);
      HEAP32[(($k)>>2)]=5;
      var $u=(($e2+4)|0);
      var $nval=$u;
      (HEAPF64[(tempDoublePtr)>>3]=0,HEAP32[(($nval)>>2)]=HEAP32[((tempDoublePtr)>>2)],HEAP32[((($nval)+(4))>>2)]=HEAP32[(((tempDoublePtr)+(4))>>2)]);
      var $0=$op_addr;
      if ((($0)|0)==0) {
        label = 3; break;
      }
      else if ((($0)|0)==1) {
        label = 7; break;
      }
      else if ((($0)|0)==2) {
        label = 8; break;
      }
      else {
      label = 9; break;
      }
      
    case 3: 
      var $1=$e_addr;
      var $call=_isnumeral($1);
      var $tobool=(($call)|0)!=0;
      if ($tobool) { label = 4; break; } else { label = 5; break; }
    case 4: 
      var $2=$e_addr;
      var $u1=(($2+4)|0);
      var $nval2=$u1;
      var $3=(HEAP32[((tempDoublePtr)>>2)]=HEAP32[(($nval2)>>2)],HEAP32[(((tempDoublePtr)+(4))>>2)]=HEAP32[((($nval2)+(4))>>2)],HEAPF64[(tempDoublePtr)>>3]);
      var $sub=(-$3);
      var $4=$e_addr;
      var $u3=(($4+4)|0);
      var $nval4=$u3;
      (HEAPF64[(tempDoublePtr)>>3]=$sub,HEAP32[(($nval4)>>2)]=HEAP32[((tempDoublePtr)>>2)],HEAP32[((($nval4)+(4))>>2)]=HEAP32[(((tempDoublePtr)+(4))>>2)]);
      label = 6; break;
    case 5: 
      var $5=$fs_addr;
      var $6=$e_addr;
      var $call5=_luaK_exp2anyreg($5, $6);
      var $7=$fs_addr;
      var $8=$e_addr;
      var $9=$line_addr;
      _codearith($7, 19, $8, $e2, $9);
      label = 6; break;
    case 6: 
      label = 10; break;
    case 7: 
      var $10=$fs_addr;
      var $11=$e_addr;
      _codenot($10, $11);
      label = 10; break;
    case 8: 
      var $12=$fs_addr;
      var $13=$e_addr;
      var $call8=_luaK_exp2anyreg($12, $13);
      var $14=$fs_addr;
      var $15=$e_addr;
      var $16=$line_addr;
      _codearith($14, 21, $15, $e2, $16);
      label = 10; break;
    case 9: 
      label = 10; break;
    case 10: 
      STACKTOP = __stackBase__;
      Module.print(INDENT + 'Exiting: _luaK_prefix');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_luaK_prefix["X"]=1;

function _luaK_fixline($fs, $line) {
  var label = 0;

  Module.print(INDENT + ' Entering: _luaK_fixline: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';

  var $fs_addr;
  var $line_addr;
  $fs_addr=$fs;
  $line_addr=$line;
  var $0=$line_addr;
  var $1=$fs_addr;
  var $pc=(($1+20)|0);
  var $2=HEAP32[(($pc)>>2)];
  var $sub=((($2)-(1))|0);
  var $3=$fs_addr;
  var $f=(($3)|0);
  var $4=HEAP32[(($f)>>2)];
  var $lineinfo=(($4+20)|0);
  var $5=HEAP32[(($lineinfo)>>2)];
  var $arrayidx=(($5+($sub<<2))|0);
  HEAP32[(($arrayidx)>>2)]=$0;

  Module.print(INDENT + 'Exiting: _luaK_fixline');
  INDENT = INDENT.substr(0, INDENT.length-2);
  return;
  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _getjumpcontrol($fs, $pc) {
  var label = 0;

  Module.print(INDENT + ' Entering: _getjumpcontrol: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $retval;
      var $fs_addr;
      var $pc_addr;
      var $pi;
      $fs_addr=$fs;
      $pc_addr=$pc;
      var $0=$pc_addr;
      var $1=$fs_addr;
      var $f=(($1)|0);
      var $2=HEAP32[(($f)>>2)];
      var $code=(($2+12)|0);
      var $3=HEAP32[(($code)>>2)];
      var $arrayidx=(($3+($0<<2))|0);
      $pi=$arrayidx;
      var $4=$pc_addr;
      var $cmp=(($4)|0) >= 1;
      if ($cmp) { label = 3; break; } else { label = 5; break; }
    case 3: 
      var $5=$pi;
      var $add_ptr=((($5)-(4))|0);
      var $6=HEAP32[(($add_ptr)>>2)];
      var $shr=$6 >>> 0;
      var $and=$shr & 63;
      var $arrayidx1=((5243744+$and)|0);
      var $7=HEAP8[($arrayidx1)];
      var $conv=(($7)&255);
      var $and2=$conv & 128;
      var $tobool=(($and2)|0)!=0;
      if ($tobool) { label = 4; break; } else { label = 5; break; }
    case 4: 
      var $8=$pi;
      var $add_ptr3=((($8)-(4))|0);
      $retval=$add_ptr3;
      label = 6; break;
    case 5: 
      var $9=$pi;
      $retval=$9;
      label = 6; break;
    case 6: 
      var $10=$retval;

      Module.print(INDENT + 'Exiting: _getjumpcontrol');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return $10;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _codearith($fs, $op, $e1, $e2, $line) {
  var label = 0;

  Module.print(INDENT + ' Entering: _codearith: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $fs_addr;
      var $op_addr;
      var $e1_addr;
      var $e2_addr;
      var $line_addr;
      var $o2;
      var $o1;
      $fs_addr=$fs;
      $op_addr=$op;
      $e1_addr=$e1;
      $e2_addr=$e2;
      $line_addr=$line;
      var $0=$op_addr;
      var $1=$e1_addr;
      var $2=$e2_addr;
      var $call=_constfolding($0, $1, $2);
      var $tobool=(($call)|0)!=0;
      if ($tobool) { label = 3; break; } else { label = 4; break; }
    case 3: 
      label = 12; break;
    case 4: 
      var $3=$op_addr;
      var $cmp=(($3)|0)!=19;
      if ($cmp) { label = 5; break; } else { label = 7; break; }
    case 5: 
      var $4=$op_addr;
      var $cmp1=(($4)|0)!=21;
      if ($cmp1) { label = 6; break; } else { label = 7; break; }
    case 6: 
      var $5=$fs_addr;
      var $6=$e2_addr;
      var $call2=_luaK_exp2RK($5, $6);
      var $cond = $call2;label = 8; break;
    case 7: 
      var $cond = 0;label = 8; break;
    case 8: 
      var $cond;
      $o2=$cond;
      var $7=$fs_addr;
      var $8=$e1_addr;
      var $call3=_luaK_exp2RK($7, $8);
      $o1=$call3;
      var $9=$o1;
      var $10=$o2;
      var $cmp4=(($9)|0) > (($10)|0);
      if ($cmp4) { label = 9; break; } else { label = 10; break; }
    case 9: 
      var $11=$fs_addr;
      var $12=$e1_addr;
      _freeexp($11, $12);
      var $13=$fs_addr;
      var $14=$e2_addr;
      _freeexp($13, $14);
      label = 11; break;
    case 10: 
      var $15=$fs_addr;
      var $16=$e2_addr;
      _freeexp($15, $16);
      var $17=$fs_addr;
      var $18=$e1_addr;
      _freeexp($17, $18);
      label = 11; break;
    case 11: 
      var $19=$fs_addr;
      var $20=$op_addr;
      var $21=$o1;
      var $22=$o2;
      var $call7=_luaK_codeABC($19, $20, 0, $21, $22);
      var $23=$e1_addr;
      var $u=(($23+4)|0);
      var $info=$u;
      HEAP32[(($info)>>2)]=$call7;
      var $24=$e1_addr;
      var $k=(($24)|0);
      HEAP32[(($k)>>2)]=11;
      var $25=$fs_addr;
      var $26=$line_addr;
      _luaK_fixline($25, $26);
      label = 12; break;
    case 12: 

      Module.print(INDENT + 'Exiting: _codearith');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_codearith["X"]=1;

function _codenot($fs, $e) {
  var label = 0;

  Module.print(INDENT + ' Entering: _codenot: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $fs_addr;
      var $e_addr;
      var $temp;
      $fs_addr=$fs;
      $e_addr=$e;
      var $0=$fs_addr;
      var $1=$e_addr;
      _luaK_dischargevars($0, $1);
      var $2=$e_addr;
      var $k=(($2)|0);
      var $3=HEAP32[(($k)>>2)];
      if ((($3)|0)==1 | (($3)|0)==3) {
        label = 3; break;
      }
      else if ((($3)|0)==4 | (($3)|0)==5 | (($3)|0)==2) {
        label = 4; break;
      }
      else if ((($3)|0)==10) {
        label = 5; break;
      }
      else if ((($3)|0)==11 | (($3)|0)==6) {
        label = 6; break;
      }
      else {
      label = 7; break;
      }
      
    case 3: 
      var $4=$e_addr;
      var $k1=(($4)|0);
      HEAP32[(($k1)>>2)]=2;
      label = 8; break;
    case 4: 
      var $5=$e_addr;
      var $k3=(($5)|0);
      HEAP32[(($k3)>>2)]=3;
      label = 8; break;
    case 5: 
      var $6=$fs_addr;
      var $7=$e_addr;
      _invertjump($6, $7);
      label = 8; break;
    case 6: 
      var $8=$fs_addr;
      var $9=$e_addr;
      _discharge2anyreg($8, $9);
      var $10=$fs_addr;
      var $11=$e_addr;
      _freeexp($10, $11);
      var $12=$fs_addr;
      var $13=$e_addr;
      var $u=(($13+4)|0);
      var $info=$u;
      var $14=HEAP32[(($info)>>2)];
      var $call=_luaK_codeABC($12, 20, 0, $14, 0);
      var $15=$e_addr;
      var $u6=(($15+4)|0);
      var $info7=$u6;
      HEAP32[(($info7)>>2)]=$call;
      var $16=$e_addr;
      var $k8=(($16)|0);
      HEAP32[(($k8)>>2)]=11;
      label = 8; break;
    case 7: 
      label = 8; break;
    case 8: 
      var $17=$e_addr;
      var $f=(($17+16)|0);
      var $18=HEAP32[(($f)>>2)];
      $temp=$18;
      var $19=$e_addr;
      var $t=(($19+12)|0);
      var $20=HEAP32[(($t)>>2)];
      var $21=$e_addr;
      var $f9=(($21+16)|0);
      HEAP32[(($f9)>>2)]=$20;
      var $22=$temp;
      var $23=$e_addr;
      var $t10=(($23+12)|0);
      HEAP32[(($t10)>>2)]=$22;
      var $24=$fs_addr;
      var $25=$e_addr;
      var $f11=(($25+16)|0);
      var $26=HEAP32[(($f11)>>2)];
      _removevalues($24, $26);
      var $27=$fs_addr;
      var $28=$e_addr;
      var $t12=(($28+12)|0);
      var $29=HEAP32[(($t12)>>2)];
      _removevalues($27, $29);

      Module.print(INDENT + 'Exiting: _codenot');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_codenot["X"]=1;

function _luaK_infix($fs, $op, $v) {
  var label = 0;

  Module.print(INDENT + ' Entering: _luaK_infix: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $fs_addr;
      var $op_addr;
      var $v_addr;
      $fs_addr=$fs;
      $op_addr=$op;
      $v_addr=$v;
      var $0=$op_addr;
      if ((($0)|0)==13) {
        label = 3; break;
      }
      else if ((($0)|0)==14) {
        label = 4; break;
      }
      else if ((($0)|0)==6) {
        label = 5; break;
      }
      else if ((($0)|0)==0 | (($0)|0)==1 | (($0)|0)==2 | (($0)|0)==3 | (($0)|0)==4 | (($0)|0)==5) {
        label = 6; break;
      }
      else {
      label = 9; break;
      }
      
    case 3: 
      var $1=$fs_addr;
      var $2=$v_addr;
      _luaK_goiftrue($1, $2);
      label = 10; break;
    case 4: 
      var $3=$fs_addr;
      var $4=$v_addr;
      _luaK_goiffalse($3, $4);
      label = 10; break;
    case 5: 
      var $5=$fs_addr;
      var $6=$v_addr;
      _luaK_exp2nextreg($5, $6);
      label = 10; break;
    case 6: 
      var $7=$v_addr;
      var $call=_isnumeral($7);
      var $tobool=(($call)|0)!=0;
      if ($tobool) { label = 8; break; } else { label = 7; break; }
    case 7: 
      var $8=$fs_addr;
      var $9=$v_addr;
      var $call4=_luaK_exp2RK($8, $9);
      label = 8; break;
    case 8: 
      label = 10; break;
    case 9: 
      var $10=$fs_addr;
      var $11=$v_addr;
      var $call5=_luaK_exp2RK($10, $11);
      label = 10; break;
    case 10: 

      Module.print(INDENT + 'Exiting: _luaK_infix');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _luaK_posfix($fs, $op, $e1, $e2, $line) {
  var label = 0;

  Module.print(INDENT + ' Entering: _luaK_posfix: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $fs_addr;
      var $op_addr;
      var $e1_addr;
      var $e2_addr;
      var $line_addr;
      $fs_addr=$fs;
      $op_addr=$op;
      $e1_addr=$e1;
      $e2_addr=$e2;
      $line_addr=$line;
      var $0=$op_addr;
      if ((($0)|0)==13) {
        label = 3; break;
      }
      else if ((($0)|0)==14) {
        label = 4; break;
      }
      else if ((($0)|0)==6) {
        label = 5; break;
      }
      else if ((($0)|0)==0 | (($0)|0)==1 | (($0)|0)==2 | (($0)|0)==3 | (($0)|0)==4 | (($0)|0)==5) {
        label = 10; break;
      }
      else if ((($0)|0)==7 | (($0)|0)==8 | (($0)|0)==9) {
        label = 11; break;
      }
      else if ((($0)|0)==10 | (($0)|0)==11 | (($0)|0)==12) {
        label = 12; break;
      }
      else {
      label = 13; break;
      }
      
    case 3: 
      var $1=$fs_addr;
      var $2=$e2_addr;
      _luaK_dischargevars($1, $2);
      var $3=$fs_addr;
      var $4=$e2_addr;
      var $f=(($4+16)|0);
      var $5=$e1_addr;
      var $f1=(($5+16)|0);
      var $6=HEAP32[(($f1)>>2)];
      _luaK_concat($3, $f, $6);
      var $7=$e1_addr;
      var $8=$e2_addr;
      var $9=$7;
      var $10=$8;
      HEAP32[(($9)>>2)]=HEAP32[(($10)>>2)];HEAP32[((($9)+(4))>>2)]=HEAP32[((($10)+(4))>>2)];HEAP32[((($9)+(8))>>2)]=HEAP32[((($10)+(8))>>2)];HEAP32[((($9)+(12))>>2)]=HEAP32[((($10)+(12))>>2)];HEAP32[((($9)+(16))>>2)]=HEAP32[((($10)+(16))>>2)];
      label = 14; break;
    case 4: 
      var $11=$fs_addr;
      var $12=$e2_addr;
      _luaK_dischargevars($11, $12);
      var $13=$fs_addr;
      var $14=$e2_addr;
      var $t=(($14+12)|0);
      var $15=$e1_addr;
      var $t3=(($15+12)|0);
      var $16=HEAP32[(($t3)>>2)];
      _luaK_concat($13, $t, $16);
      var $17=$e1_addr;
      var $18=$e2_addr;
      var $19=$17;
      var $20=$18;
      HEAP32[(($19)>>2)]=HEAP32[(($20)>>2)];HEAP32[((($19)+(4))>>2)]=HEAP32[((($20)+(4))>>2)];HEAP32[((($19)+(8))>>2)]=HEAP32[((($20)+(8))>>2)];HEAP32[((($19)+(12))>>2)]=HEAP32[((($20)+(12))>>2)];HEAP32[((($19)+(16))>>2)]=HEAP32[((($20)+(16))>>2)];
      label = 14; break;
    case 5: 
      var $21=$fs_addr;
      var $22=$e2_addr;
      _luaK_exp2val($21, $22);
      var $23=$e2_addr;
      var $k=(($23)|0);
      var $24=HEAP32[(($k)>>2)];
      var $cmp=(($24)|0)==11;
      if ($cmp) { label = 6; break; } else { label = 8; break; }
    case 6: 
      var $25=$e2_addr;
      var $u=(($25+4)|0);
      var $info=$u;
      var $26=HEAP32[(($info)>>2)];
      var $27=$fs_addr;
      var $f5=(($27)|0);
      var $28=HEAP32[(($f5)>>2)];
      var $code=(($28+12)|0);
      var $29=HEAP32[(($code)>>2)];
      var $arrayidx=(($29+($26<<2))|0);
      var $30=HEAP32[(($arrayidx)>>2)];
      var $shr=$30 >>> 0;
      var $and=$shr & 63;
      var $cmp6=(($and)|0)==22;
      if ($cmp6) { label = 7; break; } else { label = 8; break; }
    case 7: 
      var $31=$fs_addr;
      var $32=$e1_addr;
      _freeexp($31, $32);
      var $33=$e2_addr;
      var $u7=(($33+4)|0);
      var $info8=$u7;
      var $34=HEAP32[(($info8)>>2)];
      var $35=$fs_addr;
      var $f9=(($35)|0);
      var $36=HEAP32[(($f9)>>2)];
      var $code10=(($36+12)|0);
      var $37=HEAP32[(($code10)>>2)];
      var $arrayidx11=(($37+($34<<2))|0);
      var $38=HEAP32[(($arrayidx11)>>2)];
      var $and12=$38 & 8388607;
      var $39=$e1_addr;
      var $u13=(($39+4)|0);
      var $info14=$u13;
      var $40=HEAP32[(($info14)>>2)];
      var $shl=$40 << 23;
      var $and15=$shl & -8388608;
      var $or=$and12 | $and15;
      var $41=$e2_addr;
      var $u16=(($41+4)|0);
      var $info17=$u16;
      var $42=HEAP32[(($info17)>>2)];
      var $43=$fs_addr;
      var $f18=(($43)|0);
      var $44=HEAP32[(($f18)>>2)];
      var $code19=(($44+12)|0);
      var $45=HEAP32[(($code19)>>2)];
      var $arrayidx20=(($45+($42<<2))|0);
      HEAP32[(($arrayidx20)>>2)]=$or;
      var $46=$e1_addr;
      var $k21=(($46)|0);
      HEAP32[(($k21)>>2)]=11;
      var $47=$e2_addr;
      var $u22=(($47+4)|0);
      var $info23=$u22;
      var $48=HEAP32[(($info23)>>2)];
      var $49=$e1_addr;
      var $u24=(($49+4)|0);
      var $info25=$u24;
      HEAP32[(($info25)>>2)]=$48;
      label = 9; break;
    case 8: 
      var $50=$fs_addr;
      var $51=$e2_addr;
      _luaK_exp2nextreg($50, $51);
      var $52=$fs_addr;
      var $53=$e1_addr;
      var $54=$e2_addr;
      var $55=$line_addr;
      _codearith($52, 22, $53, $54, $55);
      label = 9; break;
    case 9: 
      label = 14; break;
    case 10: 
      var $56=$fs_addr;
      var $57=$op_addr;
      var $sub=(($57)|0);
      var $add=((($sub)+(13))|0);
      var $58=$e1_addr;
      var $59=$e2_addr;
      var $60=$line_addr;
      _codearith($56, $add, $58, $59, $60);
      label = 14; break;
    case 11: 
      var $61=$fs_addr;
      var $62=$op_addr;
      var $sub28=((($62)-(7))|0);
      var $add29=((($sub28)+(24))|0);
      var $63=$e1_addr;
      var $64=$e2_addr;
      _codecomp($61, $add29, 1, $63, $64);
      label = 14; break;
    case 12: 
      var $65=$fs_addr;
      var $66=$op_addr;
      var $sub31=((($66)-(10))|0);
      var $add32=((($sub31)+(24))|0);
      var $67=$e1_addr;
      var $68=$e2_addr;
      _codecomp($65, $add32, 0, $67, $68);
      label = 14; break;
    case 13: 
      label = 14; break;
    case 14: 

      Module.print(INDENT + 'Exiting: _luaK_posfix');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_luaK_posfix["X"]=1;

function _codecomp($fs, $op, $cond, $e1, $e2) {
  var label = 0;

  Module.print(INDENT + ' Entering: _codecomp: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $fs_addr;
      var $op_addr;
      var $cond_addr;
      var $e1_addr;
      var $e2_addr;
      var $o1;
      var $o2;
      var $temp;
      $fs_addr=$fs;
      $op_addr=$op;
      $cond_addr=$cond;
      $e1_addr=$e1;
      $e2_addr=$e2;
      var $0=$fs_addr;
      var $1=$e1_addr;
      var $call=_luaK_exp2RK($0, $1);
      $o1=$call;
      var $2=$fs_addr;
      var $3=$e2_addr;
      var $call1=_luaK_exp2RK($2, $3);
      $o2=$call1;
      var $4=$fs_addr;
      var $5=$e2_addr;
      _freeexp($4, $5);
      var $6=$fs_addr;
      var $7=$e1_addr;
      _freeexp($6, $7);
      var $8=$cond_addr;
      var $cmp=(($8)|0)==0;
      if ($cmp) { label = 3; break; } else { label = 5; break; }
    case 3: 
      var $9=$op_addr;
      var $cmp2=(($9)|0)!=24;
      if ($cmp2) { label = 4; break; } else { label = 5; break; }
    case 4: 
      var $10=$o1;
      $temp=$10;
      var $11=$o2;
      $o1=$11;
      var $12=$temp;
      $o2=$12;
      $cond_addr=1;
      label = 5; break;
    case 5: 
      var $13=$fs_addr;
      var $14=$op_addr;
      var $15=$cond_addr;
      var $16=$o1;
      var $17=$o2;
      var $call3=_condjump($13, $14, $15, $16, $17);
      var $18=$e1_addr;
      var $u=(($18+4)|0);
      var $info=$u;
      HEAP32[(($info)>>2)]=$call3;
      var $19=$e1_addr;
      var $k=(($19)|0);
      HEAP32[(($k)>>2)]=10;

      Module.print(INDENT + 'Exiting: _codecomp');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_codecomp["X"]=1;

function _condjump($fs, $op, $A, $B, $C) {
  var label = 0;

  Module.print(INDENT + ' Entering: _condjump: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';

  var $fs_addr;
  var $op_addr;
  var $A_addr;
  var $B_addr;
  var $C_addr;
  $fs_addr=$fs;
  $op_addr=$op;
  $A_addr=$A;
  $B_addr=$B;
  $C_addr=$C;
  var $0=$fs_addr;
  var $1=$op_addr;
  var $2=$A_addr;
  var $3=$B_addr;
  var $4=$C_addr;
  var $call=_luaK_codeABC($0, $1, $2, $3, $4);
  var $5=$fs_addr;
  var $call1=_luaK_jump($5);

  Module.print(INDENT + 'Exiting: _condjump');
  INDENT = INDENT.substr(0, INDENT.length-2);
  return $call1;
  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _discharge2anyreg($fs, $e) {
  var label = 0;

  Module.print(INDENT + ' Entering: _discharge2anyreg: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $fs_addr;
      var $e_addr;
      $fs_addr=$fs;
      $e_addr=$e;
      var $0=$e_addr;
      var $k=(($0)|0);
      var $1=HEAP32[(($k)>>2)];
      var $cmp=(($1)|0)!=6;
      if ($cmp) { label = 3; break; } else { label = 4; break; }
    case 3: 
      var $2=$fs_addr;
      _luaK_reserveregs($2, 1);
      var $3=$fs_addr;
      var $4=$e_addr;
      var $5=$fs_addr;
      var $freereg=(($5+48)|0);
      var $6=HEAP8[($freereg)];
      var $conv=(($6)&255);
      var $sub=((($conv)-(1))|0);
      _discharge2reg($3, $4, $sub);
      label = 4; break;
    case 4: 

      Module.print(INDENT + 'Exiting: _discharge2anyreg');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _removevalues($fs, $list) {
  var label = 0;

  Module.print(INDENT + ' Entering: _removevalues: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $fs_addr;
      var $list_addr;
      $fs_addr=$fs;
      $list_addr=$list;
      label = 3; break;
    case 3: 
      var $0=$list_addr;
      var $cmp=(($0)|0)!=-1;
      if ($cmp) { label = 4; break; } else { label = 6; break; }
    case 4: 
      var $1=$fs_addr;
      var $2=$list_addr;
      var $call=_patchtestreg($1, $2, 255);
      label = 5; break;
    case 5: 
      var $3=$fs_addr;
      var $4=$list_addr;
      var $call1=_getjump($3, $4);
      $list_addr=$call1;
      label = 3; break;
    case 6: 

      Module.print(INDENT + 'Exiting: _removevalues');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _patchtestreg($fs, $node, $reg) {
  var label = 0;

  Module.print(INDENT + ' Entering: _patchtestreg: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $retval;
      var $fs_addr;
      var $node_addr;
      var $reg_addr;
      var $i;
      $fs_addr=$fs;
      $node_addr=$node;
      $reg_addr=$reg;
      var $0=$fs_addr;
      var $1=$node_addr;
      var $call=_getjumpcontrol($0, $1);
      $i=$call;
      var $2=$i;
      var $3=HEAP32[(($2)>>2)];
      var $shr=$3 >>> 0;
      var $and=$shr & 63;
      var $cmp=(($and)|0)!=28;
      if ($cmp) { label = 3; break; } else { label = 4; break; }
    case 3: 
      $retval=0;
      label = 9; break;
    case 4: 
      var $4=$reg_addr;
      var $cmp1=(($4)|0)!=255;
      if ($cmp1) { label = 5; break; } else { label = 7; break; }
    case 5: 
      var $5=$reg_addr;
      var $6=$i;
      var $7=HEAP32[(($6)>>2)];
      var $shr2=$7 >>> 23;
      var $and3=$shr2 & 511;
      var $cmp4=(($5)|0)!=(($and3)|0);
      if ($cmp4) { label = 6; break; } else { label = 7; break; }
    case 6: 
      var $8=$i;
      var $9=HEAP32[(($8)>>2)];
      var $and6=$9 & -16321;
      var $10=$reg_addr;
      var $shl=$10 << 6;
      var $and7=$shl & 16320;
      var $or=$and6 | $and7;
      var $11=$i;
      HEAP32[(($11)>>2)]=$or;
      label = 8; break;
    case 7: 
      var $12=$i;
      var $13=HEAP32[(($12)>>2)];
      var $shr8=$13 >>> 23;
      var $and9=$shr8 & 511;
      var $shl10=$and9 << 6;
      var $or11=27 | $shl10;
      var $14=$i;
      var $15=HEAP32[(($14)>>2)];
      var $shr12=$15 >>> 14;
      var $and13=$shr12 & 511;
      var $shl14=$and13 << 14;
      var $or15=$or11 | $shl14;
      var $16=$i;
      HEAP32[(($16)>>2)]=$or15;
      label = 8; break;
    case 8: 
      $retval=1;
      label = 9; break;
    case 9: 
      var $17=$retval;

      Module.print(INDENT + 'Exiting: _patchtestreg');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return $17;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_patchtestreg["X"]=1;

function _discharge2reg($fs, $e, $reg) {
  var label = 0;

  Module.print(INDENT + ' Entering: _discharge2reg: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $fs_addr;
      var $e_addr;
      var $reg_addr;
      var $pc;
      $fs_addr=$fs;
      $e_addr=$e;
      $reg_addr=$reg;
      var $0=$fs_addr;
      var $1=$e_addr;
      _luaK_dischargevars($0, $1);
      var $2=$e_addr;
      var $k=(($2)|0);
      var $3=HEAP32[(($k)>>2)];
      if ((($3)|0)==1) {
        label = 3; break;
      }
      else if ((($3)|0)==3 | (($3)|0)==2) {
        label = 4; break;
      }
      else if ((($3)|0)==4) {
        label = 5; break;
      }
      else if ((($3)|0)==5) {
        label = 6; break;
      }
      else if ((($3)|0)==11) {
        label = 7; break;
      }
      else if ((($3)|0)==6) {
        label = 8; break;
      }
      else {
      label = 11; break;
      }
      
    case 3: 
      var $4=$fs_addr;
      var $5=$reg_addr;
      _luaK_nil($4, $5, 1);
      label = 12; break;
    case 4: 
      var $6=$fs_addr;
      var $7=$reg_addr;
      var $8=$e_addr;
      var $k2=(($8)|0);
      var $9=HEAP32[(($k2)>>2)];
      var $cmp=(($9)|0)==2;
      var $conv=(($cmp)&1);
      var $call=_luaK_codeABC($6, 3, $7, $conv, 0);
      label = 12; break;
    case 5: 
      var $10=$fs_addr;
      var $11=$reg_addr;
      var $12=$e_addr;
      var $u=(($12+4)|0);
      var $info=$u;
      var $13=HEAP32[(($info)>>2)];
      var $call4=_luaK_codek($10, $11, $13);
      label = 12; break;
    case 6: 
      var $14=$fs_addr;
      var $15=$reg_addr;
      var $16=$fs_addr;
      var $17=$e_addr;
      var $u6=(($17+4)|0);
      var $nval=$u6;
      var $18=(HEAP32[((tempDoublePtr)>>2)]=HEAP32[(($nval)>>2)],HEAP32[(((tempDoublePtr)+(4))>>2)]=HEAP32[((($nval)+(4))>>2)],HEAPF64[(tempDoublePtr)>>3]);
      var $call7=_luaK_numberK($16, $18);
      var $call8=_luaK_codek($14, $15, $call7);
      label = 12; break;
    case 7: 
      var $19=$e_addr;
      var $u10=(($19+4)|0);
      var $info11=$u10;
      var $20=HEAP32[(($info11)>>2)];
      var $21=$fs_addr;
      var $f=(($21)|0);
      var $22=HEAP32[(($f)>>2)];
      var $code=(($22+12)|0);
      var $23=HEAP32[(($code)>>2)];
      var $arrayidx=(($23+($20<<2))|0);
      $pc=$arrayidx;
      var $24=$pc;
      var $25=HEAP32[(($24)>>2)];
      var $and=$25 & -16321;
      var $26=$reg_addr;
      var $shl=$26 << 6;
      var $and12=$shl & 16320;
      var $or=$and | $and12;
      var $27=$pc;
      HEAP32[(($27)>>2)]=$or;
      label = 12; break;
    case 8: 
      var $28=$reg_addr;
      var $29=$e_addr;
      var $u14=(($29+4)|0);
      var $info15=$u14;
      var $30=HEAP32[(($info15)>>2)];
      var $cmp16=(($28)|0)!=(($30)|0);
      if ($cmp16) { label = 9; break; } else { label = 10; break; }
    case 9: 
      var $31=$fs_addr;
      var $32=$reg_addr;
      var $33=$e_addr;
      var $u18=(($33+4)|0);
      var $info19=$u18;
      var $34=HEAP32[(($info19)>>2)];
      var $call20=_luaK_codeABC($31, 0, $32, $34, 0);
      label = 10; break;
    case 10: 
      label = 12; break;
    case 11: 
      label = 13; break;
    case 12: 
      var $35=$reg_addr;
      var $36=$e_addr;
      var $u21=(($36+4)|0);
      var $info22=$u21;
      HEAP32[(($info22)>>2)]=$35;
      var $37=$e_addr;
      var $k23=(($37)|0);
      HEAP32[(($k23)>>2)]=6;
      label = 13; break;
    case 13: 

      Module.print(INDENT + 'Exiting: _discharge2reg');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_discharge2reg["X"]=1;

function _luaK_setlist($fs, $base, $nelems, $tostore) {
  var label = 0;

  Module.print(INDENT + ' Entering: _luaK_setlist: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $fs_addr;
      var $base_addr;
      var $nelems_addr;
      var $tostore_addr;
      var $c;
      var $b;
      $fs_addr=$fs;
      $base_addr=$base;
      $nelems_addr=$nelems;
      $tostore_addr=$tostore;
      var $0=$nelems_addr;
      var $sub=((($0)-(1))|0);
      var $div=((((($sub)|0))/(50))&-1);
      var $add=((($div)+(1))|0);
      $c=$add;
      var $1=$tostore_addr;
      var $cmp=(($1)|0)==-1;
      if ($cmp) { label = 3; break; } else { label = 4; break; }
    case 3: 
      var $cond = 0;label = 5; break;
    case 4: 
      var $2=$tostore_addr;
      var $cond = $2;label = 5; break;
    case 5: 
      var $cond;
      $b=$cond;
      var $3=$c;
      var $cmp1=(($3)|0) <= 511;
      if ($cmp1) { label = 6; break; } else { label = 7; break; }
    case 6: 
      var $4=$fs_addr;
      var $5=$base_addr;
      var $6=$b;
      var $7=$c;
      var $call=_luaK_codeABC($4, 36, $5, $6, $7);
      label = 11; break;
    case 7: 
      var $8=$c;
      var $cmp2=(($8)|0) <= 67108863;
      if ($cmp2) { label = 8; break; } else { label = 9; break; }
    case 8: 
      var $9=$fs_addr;
      var $10=$base_addr;
      var $11=$b;
      var $call4=_luaK_codeABC($9, 36, $10, $11, 0);
      var $12=$fs_addr;
      var $13=$c;
      var $call5=_codeextraarg($12, $13);
      label = 10; break;
    case 9: 
      var $14=$fs_addr;
      var $ls=(($14+12)|0);
      var $15=HEAP32[(($ls)>>2)];
      _luaX_syntaxerror($15, ((5246736)|0));

    case 10: 
      label = 11; break;
    case 11: 
      var $16=$base_addr;
      var $add8=((($16)+(1))|0);
      var $conv=(($add8) & 255);
      var $17=$fs_addr;
      var $freereg=(($17+48)|0);
      HEAP8[($freereg)]=$conv;

      Module.print(INDENT + 'Exiting: _luaK_setlist');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_luaK_setlist["X"]=1;

function _lua_sethook($L, $func, $mask, $count) {
  var label = 0;

  Module.print(INDENT + ' Entering: _lua_sethook: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $L_addr;
      var $func_addr;
      var $mask_addr;
      var $count_addr;
      $L_addr=$L;
      $func_addr=$func;
      $mask_addr=$mask;
      $count_addr=$count;
      var $0=$func_addr;
      var $cmp=(($0)|0)==0;
      if ($cmp) { label = 4; break; } else { label = 3; break; }
    case 3: 
      var $1=$mask_addr;
      var $cmp1=(($1)|0)==0;
      if ($cmp1) { label = 4; break; } else { label = 5; break; }
    case 4: 
      $mask_addr=0;
      $func_addr=0;
      label = 5; break;
    case 5: 
      var $2=$L_addr;
      var $ci=(($2+16)|0);
      var $3=HEAP32[(($ci)>>2)];
      var $callstatus=(($3+18)|0);
      var $4=HEAP8[($callstatus)];
      var $conv=(($4)&255);
      var $and=$conv & 1;
      var $tobool=(($and)|0)!=0;
      if ($tobool) { label = 6; break; } else { label = 7; break; }
    case 6: 
      var $5=$L_addr;
      var $ci3=(($5+16)|0);
      var $6=HEAP32[(($ci3)>>2)];
      var $u=(($6+24)|0);
      var $l=$u;
      var $savedpc=(($l+4)|0);
      var $7=HEAP32[(($savedpc)>>2)];
      var $8=$L_addr;
      var $oldpc=(($8+20)|0);
      HEAP32[(($oldpc)>>2)]=$7;
      label = 7; break;
    case 7: 
      var $9=$func_addr;
      var $10=$L_addr;
      var $hook=(($10+52)|0);
      HEAP32[(($hook)>>2)]=$9;
      var $11=$count_addr;
      var $12=$L_addr;
      var $basehookcount=(($12+44)|0);
      HEAP32[(($basehookcount)>>2)]=$11;
      var $13=$L_addr;
      var $basehookcount5=(($13+44)|0);
      var $14=HEAP32[(($basehookcount5)>>2)];
      var $15=$L_addr;
      var $hookcount=(($15+48)|0);
      HEAP32[(($hookcount)>>2)]=$14;
      var $16=$mask_addr;
      var $conv6=(($16) & 255);
      var $17=$L_addr;
      var $hookmask=(($17+40)|0);
      HEAP8[($hookmask)]=$conv6;

      Module.print(INDENT + 'Exiting: _lua_sethook');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return 1;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_lua_sethook["X"]=1;

function _lua_gethook($L) {
  var label = 0;

  Module.print(INDENT + ' Entering: _lua_gethook: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';

  var $L_addr;
  $L_addr=$L;
  var $0=$L_addr;
  var $hook=(($0+52)|0);
  var $1=HEAP32[(($hook)>>2)];

  Module.print(INDENT + 'Exiting: _lua_gethook');
  INDENT = INDENT.substr(0, INDENT.length-2);
  return $1;
  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _lua_gethookmask($L) {
  var label = 0;

  Module.print(INDENT + ' Entering: _lua_gethookmask: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';

  var $L_addr;
  $L_addr=$L;
  var $0=$L_addr;
  var $hookmask=(($0+40)|0);
  var $1=HEAP8[($hookmask)];
  var $conv=(($1)&255);

  Module.print(INDENT + 'Exiting: _lua_gethookmask');
  INDENT = INDENT.substr(0, INDENT.length-2);
  return $conv;
  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _lua_gethookcount($L) {
  var label = 0;

  Module.print(INDENT + ' Entering: _lua_gethookcount: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';

  var $L_addr;
  $L_addr=$L;
  var $0=$L_addr;
  var $basehookcount=(($0+44)|0);
  var $1=HEAP32[(($basehookcount)>>2)];

  Module.print(INDENT + 'Exiting: _lua_gethookcount');
  INDENT = INDENT.substr(0, INDENT.length-2);
  return $1;
  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _lua_getstack($L, $level, $ar) {
  var label = 0;

  Module.print(INDENT + ' Entering: _lua_getstack: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $retval;
      var $L_addr;
      var $level_addr;
      var $ar_addr;
      var $status;
      var $ci;
      $L_addr=$L;
      $level_addr=$level;
      $ar_addr=$ar;
      var $0=$level_addr;
      var $cmp=(($0)|0) < 0;
      if ($cmp) { label = 3; break; } else { label = 4; break; }
    case 3: 
      $retval=0;
      label = 15; break;
    case 4: 
      var $1=$L_addr;
      var $ci1=(($1+16)|0);
      var $2=HEAP32[(($ci1)>>2)];
      $ci=$2;
      label = 5; break;
    case 5: 
      var $3=$level_addr;
      var $cmp2=(($3)|0) > 0;
      if ($cmp2) { label = 6; break; } else { var $6 = 0;label = 7; break; }
    case 6: 
      var $4=$ci;
      var $5=$L_addr;
      var $base_ci=(($5+72)|0);
      var $cmp3=(($4)|0)!=(($base_ci)|0);
      var $6 = $cmp3;label = 7; break;
    case 7: 
      var $6;
      if ($6) { label = 8; break; } else { label = 10; break; }
    case 8: 
      var $7=$level_addr;
      var $dec=((($7)-(1))|0);
      $level_addr=$dec;
      label = 9; break;
    case 9: 
      var $8=$ci;
      var $previous=(($8+8)|0);
      var $9=HEAP32[(($previous)>>2)];
      $ci=$9;
      label = 5; break;
    case 10: 
      var $10=$level_addr;
      var $cmp4=(($10)|0)==0;
      if ($cmp4) { label = 11; break; } else { label = 13; break; }
    case 11: 
      var $11=$ci;
      var $12=$L_addr;
      var $base_ci5=(($12+72)|0);
      var $cmp6=(($11)|0)!=(($base_ci5)|0);
      if ($cmp6) { label = 12; break; } else { label = 13; break; }
    case 12: 
      $status=1;
      var $13=$ci;
      var $14=$ar_addr;
      var $i_ci=(($14+96)|0);
      HEAP32[(($i_ci)>>2)]=$13;
      label = 14; break;
    case 13: 
      $status=0;
      label = 14; break;
    case 14: 
      var $15=$status;
      $retval=$15;
      label = 15; break;
    case 15: 
      var $16=$retval;

      Module.print(INDENT + 'Exiting: _lua_getstack');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return $16;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_lua_getstack["X"]=1;

function _constfolding($op, $e1, $e2) {
  var label = 0;

  Module.print(INDENT + ' Entering: _constfolding: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $retval;
      var $op_addr;
      var $e1_addr;
      var $e2_addr;
      var $r;
      $op_addr=$op;
      $e1_addr=$e1;
      $e2_addr=$e2;
      var $0=$e1_addr;
      var $call=_isnumeral($0);
      var $tobool=(($call)|0)!=0;
      if ($tobool) { label = 3; break; } else { label = 4; break; }
    case 3: 
      var $1=$e2_addr;
      var $call1=_isnumeral($1);
      var $tobool2=(($call1)|0)!=0;
      if ($tobool2) { label = 5; break; } else { label = 4; break; }
    case 4: 
      $retval=0;
      label = 10; break;
    case 5: 
      var $2=$op_addr;
      var $cmp=(($2)|0)==16;
      if ($cmp) { label = 7; break; } else { label = 6; break; }
    case 6: 
      var $3=$op_addr;
      var $cmp4=(($3)|0)==17;
      if ($cmp4) { label = 7; break; } else { label = 9; break; }
    case 7: 
      var $4=$e2_addr;
      var $u=(($4+4)|0);
      var $nval=$u;
      var $5=(HEAP32[((tempDoublePtr)>>2)]=HEAP32[(($nval)>>2)],HEAP32[(((tempDoublePtr)+(4))>>2)]=HEAP32[((($nval)+(4))>>2)],HEAPF64[(tempDoublePtr)>>3]);
      var $cmp5=$5 == 0;
      if ($cmp5) { label = 8; break; } else { label = 9; break; }
    case 8: 
      $retval=0;
      label = 10; break;
    case 9: 
      var $6=$op_addr;
      var $sub=((($6)-(13))|0);
      var $add=(($sub)|0);
      var $7=$e1_addr;
      var $u8=(($7+4)|0);
      var $nval9=$u8;
      var $8=(HEAP32[((tempDoublePtr)>>2)]=HEAP32[(($nval9)>>2)],HEAP32[(((tempDoublePtr)+(4))>>2)]=HEAP32[((($nval9)+(4))>>2)],HEAPF64[(tempDoublePtr)>>3]);
      var $9=$e2_addr;
      var $u10=(($9+4)|0);
      var $nval11=$u10;
      var $10=(HEAP32[((tempDoublePtr)>>2)]=HEAP32[(($nval11)>>2)],HEAP32[(((tempDoublePtr)+(4))>>2)]=HEAP32[((($nval11)+(4))>>2)],HEAPF64[(tempDoublePtr)>>3]);
      var $call12=_luaO_arith($add, $8, $10);
      $r=$call12;
      var $11=$r;
      var $12=$e1_addr;
      var $u13=(($12+4)|0);
      var $nval14=$u13;
      (HEAPF64[(tempDoublePtr)>>3]=$11,HEAP32[(($nval14)>>2)]=HEAP32[((tempDoublePtr)>>2)],HEAP32[((($nval14)+(4))>>2)]=HEAP32[(((tempDoublePtr)+(4))>>2)]);
      $retval=1;
      label = 10; break;
    case 10: 
      var $13=$retval;

      Module.print(INDENT + 'Exiting: _constfolding');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return $13;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_constfolding["X"]=1;

function _need_value($fs, $list) {
  var label = 0;

  Module.print(INDENT + ' Entering: _need_value: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $retval;
      var $fs_addr;
      var $list_addr;
      var $i;
      $fs_addr=$fs;
      $list_addr=$list;
      label = 3; break;
    case 3: 
      var $0=$list_addr;
      var $cmp=(($0)|0)!=-1;
      if ($cmp) { label = 4; break; } else { label = 8; break; }
    case 4: 
      var $1=$fs_addr;
      var $2=$list_addr;
      var $call=_getjumpcontrol($1, $2);
      var $3=HEAP32[(($call)>>2)];
      $i=$3;
      var $4=$i;
      var $shr=$4 >>> 0;
      var $and=$shr & 63;
      var $cmp1=(($and)|0)!=28;
      if ($cmp1) { label = 5; break; } else { label = 6; break; }
    case 5: 
      $retval=1;
      label = 9; break;
    case 6: 
      label = 7; break;
    case 7: 
      var $5=$fs_addr;
      var $6=$list_addr;
      var $call2=_getjump($5, $6);
      $list_addr=$call2;
      label = 3; break;
    case 8: 
      $retval=0;
      label = 9; break;
    case 9: 
      var $7=$retval;

      Module.print(INDENT + 'Exiting: _need_value');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return $7;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _code_label($fs, $A, $b, $jump) {
  var label = 0;

  Module.print(INDENT + ' Entering: _code_label: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';

  var $fs_addr;
  var $A_addr;
  var $b_addr;
  var $jump_addr;
  $fs_addr=$fs;
  $A_addr=$A;
  $b_addr=$b;
  $jump_addr=$jump;
  var $0=$fs_addr;
  var $call=_luaK_getlabel($0);
  var $1=$fs_addr;
  var $2=$A_addr;
  var $3=$b_addr;
  var $4=$jump_addr;
  var $call1=_luaK_codeABC($1, 3, $2, $3, $4);

  Module.print(INDENT + 'Exiting: _code_label');
  INDENT = INDENT.substr(0, INDENT.length-2);
  return $call1;
  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _dischargejpc($fs) {
  var label = 0;

  Module.print(INDENT + ' Entering: _dischargejpc: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';

  var $fs_addr;
  $fs_addr=$fs;
  var $0=$fs_addr;
  var $1=$fs_addr;
  var $jpc=(($1+28)|0);
  var $2=HEAP32[(($jpc)>>2)];
  var $3=$fs_addr;
  var $pc=(($3+20)|0);
  var $4=HEAP32[(($pc)>>2)];
  var $5=$fs_addr;
  var $pc1=(($5+20)|0);
  var $6=HEAP32[(($pc1)>>2)];
  _patchlistaux($0, $2, $4, 255, $6);
  var $7=$fs_addr;
  var $jpc2=(($7+28)|0);
  HEAP32[(($jpc2)>>2)]=-1;

  Module.print(INDENT + 'Exiting: _dischargejpc');
  INDENT = INDENT.substr(0, INDENT.length-2);
  return;
  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _lua_getlocal($L, $ar, $n) {
  var label = 0;
  var __stackBase__  = STACKTOP; STACKTOP = (STACKTOP + 4)|0; _memset(__stackBase__, 0, 4);
  Module.print(INDENT + ' Entering: _lua_getlocal: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $L_addr;
      var $ar_addr;
      var $n_addr;
      var $name;
      var $pos=__stackBase__;
      var $io2;
      var $io1;
      $L_addr=$L;
      $ar_addr=$ar;
      $n_addr=$n;
      var $0=$ar_addr;
      var $cmp=(($0)|0)==0;
      if ($cmp) { label = 3; break; } else { label = 7; break; }
    case 3: 
      var $1=$L_addr;
      var $top=(($1+8)|0);
      var $2=HEAP32[(($top)>>2)];
      var $add_ptr=((($2)-(12))|0);
      var $tt_=(($add_ptr+8)|0);
      var $3=HEAP32[(($tt_)>>2)];
      var $cmp1=(($3)|0)==70;
      if ($cmp1) { label = 5; break; } else { label = 4; break; }
    case 4: 
      $name=0;
      label = 6; break;
    case 5: 
      var $4=$L_addr;
      var $top3=(($4+8)|0);
      var $5=HEAP32[(($top3)>>2)];
      var $add_ptr4=((($5)-(12))|0);
      var $value_=(($add_ptr4)|0);
      var $gc=$value_;
      var $6=HEAP32[(($gc)>>2)];
      var $cl=$6;
      var $l=$cl;
      var $p=(($l+12)|0);
      var $7=HEAP32[(($p)>>2)];
      var $8=$n_addr;
      var $call=_luaF_getlocalname($7, $8, 0);
      $name=$call;
      label = 6; break;
    case 6: 
      label = 10; break;
    case 7: 
      HEAP32[(($pos)>>2)]=0;
      var $9=$L_addr;
      var $10=$ar_addr;
      var $i_ci=(($10+96)|0);
      var $11=HEAP32[(($i_ci)>>2)];
      var $12=$n_addr;
      var $call6=_findlocal($9, $11, $12, $pos);
      $name=$call6;
      var $13=$name;
      var $tobool=(($13)|0)!=0;
      if ($tobool) { label = 8; break; } else { label = 9; break; }
    case 8: 
      var $14=HEAP32[(($pos)>>2)];
      $io2=$14;
      var $15=$L_addr;
      var $top8=(($15+8)|0);
      var $16=HEAP32[(($top8)>>2)];
      $io1=$16;
      var $17=$io1;
      var $value_9=(($17)|0);
      var $18=$io2;
      var $value_10=(($18)|0);
      var $19=$value_9;
      var $20=$value_10;
      HEAP32[(($19)>>2)]=HEAP32[(($20)>>2)];HEAP32[((($19)+(4))>>2)]=HEAP32[((($20)+(4))>>2)];
      var $21=$io2;
      var $tt_11=(($21+8)|0);
      var $22=HEAP32[(($tt_11)>>2)];
      var $23=$io1;
      var $tt_12=(($23+8)|0);
      HEAP32[(($tt_12)>>2)]=$22;
      var $24=$L_addr;
      var $top13=(($24+8)|0);
      var $25=HEAP32[(($top13)>>2)];
      var $incdec_ptr=(($25+12)|0);
      HEAP32[(($top13)>>2)]=$incdec_ptr;
      label = 9; break;
    case 9: 
      label = 10; break;
    case 10: 
      var $26=$name;
      STACKTOP = __stackBase__;
      Module.print(INDENT + 'Exiting: _lua_getlocal');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return $26;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_lua_getlocal["X"]=1;

function _findlocal($L, $ci, $n, $pos) {
  var label = 0;

  Module.print(INDENT + ' Entering: _findlocal: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $retval;
      var $L_addr;
      var $ci_addr;
      var $n_addr;
      var $pos_addr;
      var $name;
      var $base;
      var $limit;
      $L_addr=$L;
      $ci_addr=$ci;
      $n_addr=$n;
      $pos_addr=$pos;
      $name=0;
      var $0=$ci_addr;
      var $callstatus=(($0+18)|0);
      var $1=HEAP8[($callstatus)];
      var $conv=(($1)&255);
      var $and=$conv & 1;
      var $tobool=(($and)|0)!=0;
      if ($tobool) { label = 3; break; } else { label = 7; break; }
    case 3: 
      var $2=$n_addr;
      var $cmp=(($2)|0) < 0;
      if ($cmp) { label = 4; break; } else { label = 5; break; }
    case 4: 
      var $3=$ci_addr;
      var $4=$n_addr;
      var $sub=(((-$4))|0);
      var $5=$pos_addr;
      var $call=_findvararg($3, $sub, $5);
      $retval=$call;
      label = 18; break;
    case 5: 
      var $6=$ci_addr;
      var $u=(($6+24)|0);
      var $l=$u;
      var $base3=(($l)|0);
      var $7=HEAP32[(($base3)>>2)];
      $base=$7;
      var $8=$ci_addr;
      var $func=(($8)|0);
      var $9=HEAP32[(($func)>>2)];
      var $value_=(($9)|0);
      var $gc=$value_;
      var $10=HEAP32[(($gc)>>2)];
      var $cl=$10;
      var $l4=$cl;
      var $p=(($l4+12)|0);
      var $11=HEAP32[(($p)>>2)];
      var $12=$n_addr;
      var $13=$ci_addr;
      var $call5=_currentpc($13);
      var $call6=_luaF_getlocalname($11, $12, $call5);
      $name=$call6;
      label = 6; break;
    case 6: 
      label = 8; break;
    case 7: 
      var $14=$ci_addr;
      var $func8=(($14)|0);
      var $15=HEAP32[(($func8)>>2)];
      var $add_ptr=(($15+12)|0);
      $base=$add_ptr;
      label = 8; break;
    case 8: 
      var $16=$name;
      var $cmp10=(($16)|0)==0;
      if ($cmp10) { label = 9; break; } else { label = 17; break; }
    case 9: 
      var $17=$ci_addr;
      var $18=$L_addr;
      var $ci13=(($18+16)|0);
      var $19=HEAP32[(($ci13)>>2)];
      var $cmp14=(($17)|0)==(($19)|0);
      if ($cmp14) { label = 10; break; } else { label = 11; break; }
    case 10: 
      var $20=$L_addr;
      var $top=(($20+8)|0);
      var $21=HEAP32[(($top)>>2)];
      var $cond = $21;label = 12; break;
    case 11: 
      var $22=$ci_addr;
      var $next=(($22+12)|0);
      var $23=HEAP32[(($next)>>2)];
      var $func16=(($23)|0);
      var $24=HEAP32[(($func16)>>2)];
      var $cond = $24;label = 12; break;
    case 12: 
      var $cond;
      $limit=$cond;
      var $25=$limit;
      var $26=$base;
      var $sub_ptr_lhs_cast=$25;
      var $sub_ptr_rhs_cast=$26;
      var $sub_ptr_sub=((($sub_ptr_lhs_cast)-($sub_ptr_rhs_cast))|0);
      var $sub_ptr_div=((((($sub_ptr_sub)|0))/(12))&-1);
      var $27=$n_addr;
      var $cmp17=(($sub_ptr_div)|0) >= (($27)|0);
      if ($cmp17) { label = 13; break; } else { label = 15; break; }
    case 13: 
      var $28=$n_addr;
      var $cmp19=(($28)|0) > 0;
      if ($cmp19) { label = 14; break; } else { label = 15; break; }
    case 14: 
      $name=((5245768)|0);
      label = 16; break;
    case 15: 
      $retval=0;
      label = 18; break;
    case 16: 
      label = 17; break;
    case 17: 
      var $29=$base;
      var $30=$n_addr;
      var $sub25=((($30)-(1))|0);
      var $add_ptr26=(($29+((($sub25)*(12))&-1))|0);
      var $31=$pos_addr;
      HEAP32[(($31)>>2)]=$add_ptr26;
      var $32=$name;
      $retval=$32;
      label = 18; break;
    case 18: 
      var $33=$retval;

      Module.print(INDENT + 'Exiting: _findlocal');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return $33;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_findlocal["X"]=1;

function _lua_setlocal($L, $ar, $n) {
  var label = 0;
  var __stackBase__  = STACKTOP; STACKTOP = (STACKTOP + 4)|0; _memset(__stackBase__, 0, 4);
  Module.print(INDENT + ' Entering: _lua_setlocal: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $L_addr;
      var $ar_addr;
      var $n_addr;
      var $pos=__stackBase__;
      var $name;
      var $io2;
      var $io1;
      $L_addr=$L;
      $ar_addr=$ar;
      $n_addr=$n;
      HEAP32[(($pos)>>2)]=0;
      var $0=$L_addr;
      var $1=$ar_addr;
      var $i_ci=(($1+96)|0);
      var $2=HEAP32[(($i_ci)>>2)];
      var $3=$n_addr;
      var $call=_findlocal($0, $2, $3, $pos);
      $name=$call;
      var $4=$name;
      var $tobool=(($4)|0)!=0;
      if ($tobool) { label = 3; break; } else { label = 4; break; }
    case 3: 
      var $5=$L_addr;
      var $top=(($5+8)|0);
      var $6=HEAP32[(($top)>>2)];
      var $add_ptr=((($6)-(12))|0);
      $io2=$add_ptr;
      var $7=HEAP32[(($pos)>>2)];
      $io1=$7;
      var $8=$io1;
      var $value_=(($8)|0);
      var $9=$io2;
      var $value_1=(($9)|0);
      var $10=$value_;
      var $11=$value_1;
      HEAP32[(($10)>>2)]=HEAP32[(($11)>>2)];HEAP32[((($10)+(4))>>2)]=HEAP32[((($11)+(4))>>2)];
      var $12=$io2;
      var $tt_=(($12+8)|0);
      var $13=HEAP32[(($tt_)>>2)];
      var $14=$io1;
      var $tt_2=(($14+8)|0);
      HEAP32[(($tt_2)>>2)]=$13;
      label = 4; break;
    case 4: 
      var $15=$L_addr;
      var $top3=(($15+8)|0);
      var $16=HEAP32[(($top3)>>2)];
      var $incdec_ptr=((($16)-(12))|0);
      HEAP32[(($top3)>>2)]=$incdec_ptr;
      var $17=$name;
      STACKTOP = __stackBase__;
      Module.print(INDENT + 'Exiting: _lua_setlocal');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return $17;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _lua_getinfo($L, $what, $ar) {
  var label = 0;

  Module.print(INDENT + ' Entering: _lua_getinfo: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $L_addr;
      var $what_addr;
      var $ar_addr;
      var $status;
      var $cl;
      var $ci;
      var $func;
      var $io2;
      var $io1;
      $L_addr=$L;
      $what_addr=$what;
      $ar_addr=$ar;
      var $0=$what_addr;
      var $1=HEAP8[($0)];
      var $conv=(($1 << 24) >> 24);
      var $cmp=(($conv)|0)==62;
      if ($cmp) { label = 3; break; } else { label = 4; break; }
    case 3: 
      $ci=0;
      var $2=$L_addr;
      var $top=(($2+8)|0);
      var $3=HEAP32[(($top)>>2)];
      var $add_ptr=((($3)-(12))|0);
      $func=$add_ptr;
      var $4=$what_addr;
      var $incdec_ptr=(($4+1)|0);
      $what_addr=$incdec_ptr;
      var $5=$L_addr;
      var $top2=(($5+8)|0);
      var $6=HEAP32[(($top2)>>2)];
      var $incdec_ptr3=((($6)-(12))|0);
      HEAP32[(($top2)>>2)]=$incdec_ptr3;
      label = 5; break;
    case 4: 
      var $7=$ar_addr;
      var $i_ci=(($7+96)|0);
      var $8=HEAP32[(($i_ci)>>2)];
      $ci=$8;
      var $9=$ci;
      var $func4=(($9)|0);
      var $10=HEAP32[(($func4)>>2)];
      $func=$10;
      label = 5; break;
    case 5: 
      var $11=$func;
      var $tt_=(($11+8)|0);
      var $12=HEAP32[(($tt_)>>2)];
      var $and=$12 & 31;
      var $cmp5=(($and)|0)==6;
      if ($cmp5) { label = 6; break; } else { label = 7; break; }
    case 6: 
      var $13=$func;
      var $value_=(($13)|0);
      var $gc=$value_;
      var $14=HEAP32[(($gc)>>2)];
      var $cl7=$14;
      var $cond = $cl7;label = 8; break;
    case 7: 
      var $cond = 0;label = 8; break;
    case 8: 
      var $cond;
      $cl=$cond;
      var $15=$L_addr;
      var $16=$what_addr;
      var $17=$ar_addr;
      var $18=$cl;
      var $19=$ci;
      var $call=_auxgetinfo($15, $16, $17, $18, $19);
      $status=$call;
      var $20=$what_addr;
      var $call8=_strchr($20, 102);
      var $tobool=(($call8)|0)!=0;
      if ($tobool) { label = 9; break; } else { label = 13; break; }
    case 9: 
      var $21=$func;
      $io2=$21;
      var $22=$L_addr;
      var $top10=(($22+8)|0);
      var $23=HEAP32[(($top10)>>2)];
      $io1=$23;
      var $24=$io1;
      var $value_11=(($24)|0);
      var $25=$io2;
      var $value_12=(($25)|0);
      var $26=$value_11;
      var $27=$value_12;
      HEAP32[(($26)>>2)]=HEAP32[(($27)>>2)];HEAP32[((($26)+(4))>>2)]=HEAP32[((($27)+(4))>>2)];
      var $28=$io2;
      var $tt_13=(($28+8)|0);
      var $29=HEAP32[(($tt_13)>>2)];
      var $30=$io1;
      var $tt_14=(($30+8)|0);
      HEAP32[(($tt_14)>>2)]=$29;
      var $31=$L_addr;
      var $top15=(($31+8)|0);
      var $32=HEAP32[(($top15)>>2)];
      var $incdec_ptr16=(($32+12)|0);
      HEAP32[(($top15)>>2)]=$incdec_ptr16;
      var $33=$L_addr;
      var $stack_last=(($33+24)|0);
      var $34=HEAP32[(($stack_last)>>2)];
      var $35=$L_addr;
      var $top17=(($35+8)|0);
      var $36=HEAP32[(($top17)>>2)];
      var $sub_ptr_lhs_cast=$34;
      var $sub_ptr_rhs_cast=$36;
      var $sub_ptr_sub=((($sub_ptr_lhs_cast)-($sub_ptr_rhs_cast))|0);
      var $sub_ptr_div=((((($sub_ptr_sub)|0))/(12))&-1);
      var $cmp18=(($sub_ptr_div)|0) <= 0;
      if ($cmp18) { label = 10; break; } else { label = 11; break; }
    case 10: 
      var $37=$L_addr;
      _luaD_growstack($37, 0);
      label = 12; break;
    case 11: 
      label = 12; break;
    case 12: 
      label = 13; break;
    case 13: 
      var $38=$what_addr;
      var $call24=_strchr($38, 76);
      var $tobool25=(($call24)|0)!=0;
      if ($tobool25) { label = 14; break; } else { label = 15; break; }
    case 14: 
      var $39=$L_addr;
      var $40=$cl;
      _collectvalidlines($39, $40);
      label = 15; break;
    case 15: 
      var $41=$status;

      Module.print(INDENT + 'Exiting: _lua_getinfo');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return $41;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_lua_getinfo["X"]=1;

function _isinstack($ci, $o) {
  var label = 0;

  Module.print(INDENT + ' Entering: _isinstack: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $retval;
      var $ci_addr;
      var $o_addr;
      var $p;
      $ci_addr=$ci;
      $o_addr=$o;
      var $0=$ci_addr;
      var $u=(($0+24)|0);
      var $l=$u;
      var $base=(($l)|0);
      var $1=HEAP32[(($base)>>2)];
      $p=$1;
      label = 3; break;
    case 3: 
      var $2=$p;
      var $3=$ci_addr;
      var $top=(($3+4)|0);
      var $4=HEAP32[(($top)>>2)];
      var $cmp=(($2)>>>0) < (($4)>>>0);
      if ($cmp) { label = 4; break; } else { label = 8; break; }
    case 4: 
      var $5=$o_addr;
      var $6=$p;
      var $cmp1=(($5)|0)==(($6)|0);
      if ($cmp1) { label = 5; break; } else { label = 6; break; }
    case 5: 
      $retval=1;
      label = 9; break;
    case 6: 
      label = 7; break;
    case 7: 
      var $7=$p;
      var $incdec_ptr=(($7+12)|0);
      $p=$incdec_ptr;
      label = 3; break;
    case 8: 
      $retval=0;
      label = 9; break;
    case 9: 
      var $8=$retval;

      Module.print(INDENT + 'Exiting: _isinstack');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return $8;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _currentpc($ci) {
  var label = 0;

  Module.print(INDENT + ' Entering: _currentpc: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';

  var $ci_addr;
  $ci_addr=$ci;
  var $0=$ci_addr;
  var $u=(($0+24)|0);
  var $l=$u;
  var $savedpc=(($l+4)|0);
  var $1=HEAP32[(($savedpc)>>2)];
  var $2=$ci_addr;
  var $func=(($2)|0);
  var $3=HEAP32[(($func)>>2)];
  var $value_=(($3)|0);
  var $gc=$value_;
  var $4=HEAP32[(($gc)>>2)];
  var $cl=$4;
  var $l1=$cl;
  var $p=(($l1+12)|0);
  var $5=HEAP32[(($p)>>2)];
  var $code=(($5+12)|0);
  var $6=HEAP32[(($code)>>2)];
  var $sub_ptr_lhs_cast=$1;
  var $sub_ptr_rhs_cast=$6;
  var $sub_ptr_sub=((($sub_ptr_lhs_cast)-($sub_ptr_rhs_cast))|0);
  var $sub_ptr_div=((((($sub_ptr_sub)|0))/(4))&-1);
  var $sub=((($sub_ptr_div)-(1))|0);

  Module.print(INDENT + 'Exiting: _currentpc');
  INDENT = INDENT.substr(0, INDENT.length-2);
  return $sub;
  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _auxgetinfo($L, $what, $ar, $f, $ci) {
  var label = 0;

  Module.print(INDENT + ' Entering: _auxgetinfo: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $L_addr;
      var $what_addr;
      var $ar_addr;
      var $f_addr;
      var $ci_addr;
      var $status;
      $L_addr=$L;
      $what_addr=$what;
      $ar_addr=$ar;
      $f_addr=$f;
      $ci_addr=$ci;
      $status=1;
      label = 3; break;
    case 3: 
      var $0=$what_addr;
      var $1=HEAP8[($0)];
      var $tobool=(($1 << 24) >> 24)!=0;
      if ($tobool) { label = 4; break; } else { label = 35; break; }
    case 4: 
      var $2=$what_addr;
      var $3=HEAP8[($2)];
      var $conv=(($3 << 24) >> 24);
      if ((($conv)|0)==83) {
        label = 5; break;
      }
      else if ((($conv)|0)==108) {
        label = 6; break;
      }
      else if ((($conv)|0)==117) {
        label = 11; break;
      }
      else if ((($conv)|0)==116) {
        label = 19; break;
      }
      else if ((($conv)|0)==110) {
        label = 23; break;
      }
      else if ((($conv)|0)==76 | (($conv)|0)==102) {
        label = 31; break;
      }
      else {
      label = 32; break;
      }
      
    case 5: 
      var $4=$ar_addr;
      var $5=$f_addr;
      _funcinfo($4, $5);
      label = 33; break;
    case 6: 
      var $6=$ci_addr;
      var $tobool2=(($6)|0)!=0;
      if ($tobool2) { label = 7; break; } else { label = 9; break; }
    case 7: 
      var $7=$ci_addr;
      var $callstatus=(($7+18)|0);
      var $8=HEAP8[($callstatus)];
      var $conv3=(($8)&255);
      var $and=$conv3 & 1;
      var $tobool4=(($and)|0)!=0;
      if ($tobool4) { label = 8; break; } else { label = 9; break; }
    case 8: 
      var $9=$ci_addr;
      var $call=_currentline($9);
      var $cond = $call;label = 10; break;
    case 9: 
      var $cond = -1;label = 10; break;
    case 10: 
      var $cond;
      var $10=$ar_addr;
      var $currentline=(($10+20)|0);
      HEAP32[(($currentline)>>2)]=$cond;
      label = 33; break;
    case 11: 
      var $11=$f_addr;
      var $cmp=(($11)|0)==0;
      if ($cmp) { label = 12; break; } else { label = 13; break; }
    case 12: 
      var $cond11 = 0;label = 14; break;
    case 13: 
      var $12=$f_addr;
      var $c=$12;
      var $nupvalues=(($c+6)|0);
      var $13=HEAP8[($nupvalues)];
      var $conv9=(($13)&255);
      var $cond11 = $conv9;label = 14; break;
    case 14: 
      var $cond11;
      var $conv12=(($cond11) & 255);
      var $14=$ar_addr;
      var $nups=(($14+32)|0);
      HEAP8[($nups)]=$conv12;
      var $15=$f_addr;
      var $cmp13=(($15)|0)==0;
      if ($cmp13) { label = 16; break; } else { label = 15; break; }
    case 15: 
      var $16=$f_addr;
      var $c15=$16;
      var $tt=(($c15+4)|0);
      var $17=HEAP8[($tt)];
      var $conv16=(($17)&255);
      var $cmp17=(($conv16)|0)==38;
      if ($cmp17) { label = 16; break; } else { label = 17; break; }
    case 16: 
      var $18=$ar_addr;
      var $isvararg=(($18+34)|0);
      HEAP8[($isvararg)]=1;
      var $19=$ar_addr;
      var $nparams=(($19+33)|0);
      HEAP8[($nparams)]=0;
      label = 18; break;
    case 17: 
      var $20=$f_addr;
      var $l=$20;
      var $p=(($l+12)|0);
      var $21=HEAP32[(($p)>>2)];
      var $is_vararg=(($21+77)|0);
      var $22=HEAP8[($is_vararg)];
      var $23=$ar_addr;
      var $isvararg19=(($23+34)|0);
      HEAP8[($isvararg19)]=$22;
      var $24=$f_addr;
      var $l20=$24;
      var $p21=(($l20+12)|0);
      var $25=HEAP32[(($p21)>>2)];
      var $numparams=(($25+76)|0);
      var $26=HEAP8[($numparams)];
      var $27=$ar_addr;
      var $nparams22=(($27+33)|0);
      HEAP8[($nparams22)]=$26;
      label = 18; break;
    case 18: 
      label = 33; break;
    case 19: 
      var $28=$ci_addr;
      var $tobool24=(($28)|0)!=0;
      if ($tobool24) { label = 20; break; } else { label = 21; break; }
    case 20: 
      var $29=$ci_addr;
      var $callstatus26=(($29+18)|0);
      var $30=HEAP8[($callstatus26)];
      var $conv27=(($30)&255);
      var $and28=$conv27 & 64;
      var $cond31 = $and28;label = 22; break;
    case 21: 
      var $cond31 = 0;label = 22; break;
    case 22: 
      var $cond31;
      var $conv32=(($cond31) & 255);
      var $31=$ar_addr;
      var $istailcall=(($31+35)|0);
      HEAP8[($istailcall)]=$conv32;
      label = 33; break;
    case 23: 
      var $32=$ci_addr;
      var $tobool34=(($32)|0)!=0;
      if ($tobool34) { label = 24; break; } else { label = 27; break; }
    case 24: 
      var $33=$ci_addr;
      var $callstatus36=(($33+18)|0);
      var $34=HEAP8[($callstatus36)];
      var $conv37=(($34)&255);
      var $and38=$conv37 & 64;
      var $tobool39=(($and38)|0)!=0;
      if ($tobool39) { label = 27; break; } else { label = 25; break; }
    case 25: 
      var $35=$ci_addr;
      var $previous=(($35+8)|0);
      var $36=HEAP32[(($previous)>>2)];
      var $callstatus41=(($36+18)|0);
      var $37=HEAP8[($callstatus41)];
      var $conv42=(($37)&255);
      var $and43=$conv42 & 1;
      var $tobool44=(($and43)|0)!=0;
      if ($tobool44) { label = 26; break; } else { label = 27; break; }
    case 26: 
      var $38=$L_addr;
      var $39=$ci_addr;
      var $previous46=(($39+8)|0);
      var $40=HEAP32[(($previous46)>>2)];
      var $41=$ar_addr;
      var $name=(($41+4)|0);
      var $call47=_getfuncname($38, $40, $name);
      var $42=$ar_addr;
      var $namewhat=(($42+8)|0);
      HEAP32[(($namewhat)>>2)]=$call47;
      label = 28; break;
    case 27: 
      var $43=$ar_addr;
      var $namewhat49=(($43+8)|0);
      HEAP32[(($namewhat49)>>2)]=0;
      label = 28; break;
    case 28: 
      var $44=$ar_addr;
      var $namewhat51=(($44+8)|0);
      var $45=HEAP32[(($namewhat51)>>2)];
      var $cmp52=(($45)|0)==0;
      if ($cmp52) { label = 29; break; } else { label = 30; break; }
    case 29: 
      var $46=$ar_addr;
      var $namewhat55=(($46+8)|0);
      HEAP32[(($namewhat55)>>2)]=((5246588)|0);
      var $47=$ar_addr;
      var $name56=(($47+4)|0);
      HEAP32[(($name56)>>2)]=0;
      label = 30; break;
    case 30: 
      label = 33; break;
    case 31: 
      label = 33; break;
    case 32: 
      $status=0;
      label = 33; break;
    case 33: 
      label = 34; break;
    case 34: 
      var $48=$what_addr;
      var $incdec_ptr=(($48+1)|0);
      $what_addr=$incdec_ptr;
      label = 3; break;
    case 35: 
      var $49=$status;

      Module.print(INDENT + 'Exiting: _auxgetinfo');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return $49;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_auxgetinfo["X"]=1;

function _collectvalidlines($L, $f) {
  var label = 0;
  var __stackBase__  = STACKTOP; STACKTOP = (STACKTOP + 12)|0; _memset(__stackBase__, 0, 12);
  Module.print(INDENT + ' Entering: _collectvalidlines: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $L_addr;
      var $f_addr;
      var $i;
      var $v=__stackBase__;
      var $lineinfo;
      var $t;
      var $io;
      var $io25;
      $L_addr=$L;
      $f_addr=$f;
      var $0=$f_addr;
      var $cmp=(($0)|0)==0;
      if ($cmp) { label = 4; break; } else { label = 3; break; }
    case 3: 
      var $1=$f_addr;
      var $c=$1;
      var $tt=(($c+4)|0);
      var $2=HEAP8[($tt)];
      var $conv=(($2)&255);
      var $cmp1=(($conv)|0)==38;
      if ($cmp1) { label = 4; break; } else { label = 8; break; }
    case 4: 
      var $3=$L_addr;
      var $top=(($3+8)|0);
      var $4=HEAP32[(($top)>>2)];
      var $tt_=(($4+8)|0);
      HEAP32[(($tt_)>>2)]=0;
      var $5=$L_addr;
      var $top3=(($5+8)|0);
      var $6=HEAP32[(($top3)>>2)];
      var $incdec_ptr=(($6+12)|0);
      HEAP32[(($top3)>>2)]=$incdec_ptr;
      var $7=$L_addr;
      var $stack_last=(($7+24)|0);
      var $8=HEAP32[(($stack_last)>>2)];
      var $9=$L_addr;
      var $top4=(($9+8)|0);
      var $10=HEAP32[(($top4)>>2)];
      var $sub_ptr_lhs_cast=$8;
      var $sub_ptr_rhs_cast=$10;
      var $sub_ptr_sub=((($sub_ptr_lhs_cast)-($sub_ptr_rhs_cast))|0);
      var $sub_ptr_div=((((($sub_ptr_sub)|0))/(12))&-1);
      var $cmp5=(($sub_ptr_div)|0) <= 0;
      if ($cmp5) { label = 5; break; } else { label = 6; break; }
    case 5: 
      var $11=$L_addr;
      _luaD_growstack($11, 0);
      label = 7; break;
    case 6: 
      label = 7; break;
    case 7: 
      label = 16; break;
    case 8: 
      var $12=$f_addr;
      var $l=$12;
      var $p=(($l+12)|0);
      var $13=HEAP32[(($p)>>2)];
      var $lineinfo9=(($13+20)|0);
      var $14=HEAP32[(($lineinfo9)>>2)];
      $lineinfo=$14;
      var $15=$L_addr;
      var $call=_luaH_new($15);
      $t=$call;
      var $16=$L_addr;
      var $top10=(($16+8)|0);
      var $17=HEAP32[(($top10)>>2)];
      $io=$17;
      var $18=$t;
      var $19=$18;
      var $20=$io;
      var $value_=(($20)|0);
      var $gc=$value_;
      HEAP32[(($gc)>>2)]=$19;
      var $21=$io;
      var $tt_11=(($21+8)|0);
      HEAP32[(($tt_11)>>2)]=69;
      var $22=$L_addr;
      var $top12=(($22+8)|0);
      var $23=HEAP32[(($top12)>>2)];
      var $incdec_ptr13=(($23+12)|0);
      HEAP32[(($top12)>>2)]=$incdec_ptr13;
      var $24=$L_addr;
      var $stack_last14=(($24+24)|0);
      var $25=HEAP32[(($stack_last14)>>2)];
      var $26=$L_addr;
      var $top15=(($26+8)|0);
      var $27=HEAP32[(($top15)>>2)];
      var $sub_ptr_lhs_cast16=$25;
      var $sub_ptr_rhs_cast17=$27;
      var $sub_ptr_sub18=((($sub_ptr_lhs_cast16)-($sub_ptr_rhs_cast17))|0);
      var $sub_ptr_div19=((((($sub_ptr_sub18)|0))/(12))&-1);
      var $cmp20=(($sub_ptr_div19)|0) <= 0;
      if ($cmp20) { label = 9; break; } else { label = 10; break; }
    case 9: 
      var $28=$L_addr;
      _luaD_growstack($28, 0);
      label = 11; break;
    case 10: 
      label = 11; break;
    case 11: 
      $io25=$v;
      var $29=$io25;
      var $value_26=(($29)|0);
      var $b=$value_26;
      HEAP32[(($b)>>2)]=1;
      var $30=$io25;
      var $tt_27=(($30+8)|0);
      HEAP32[(($tt_27)>>2)]=1;
      $i=0;
      label = 12; break;
    case 12: 
      var $31=$i;
      var $32=$f_addr;
      var $l28=$32;
      var $p29=(($l28+12)|0);
      var $33=HEAP32[(($p29)>>2)];
      var $sizelineinfo=(($33+52)|0);
      var $34=HEAP32[(($sizelineinfo)>>2)];
      var $cmp30=(($31)|0) < (($34)|0);
      if ($cmp30) { label = 13; break; } else { label = 15; break; }
    case 13: 
      var $35=$L_addr;
      var $36=$t;
      var $37=$i;
      var $38=$lineinfo;
      var $arrayidx=(($38+($37<<2))|0);
      var $39=HEAP32[(($arrayidx)>>2)];
      _luaH_setint($35, $36, $39, $v);
      label = 14; break;
    case 14: 
      var $40=$i;
      var $inc=((($40)+(1))|0);
      $i=$inc;
      label = 12; break;
    case 15: 
      label = 16; break;
    case 16: 
      STACKTOP = __stackBase__;
      Module.print(INDENT + 'Exiting: _collectvalidlines');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_collectvalidlines["X"]=1;

function _getupvalname($ci, $o, $name) {
  var label = 0;

  Module.print(INDENT + ' Entering: _getupvalname: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $retval;
      var $ci_addr;
      var $o_addr;
      var $name_addr;
      var $c;
      var $i;
      $ci_addr=$ci;
      $o_addr=$o;
      $name_addr=$name;
      var $0=$ci_addr;
      var $func=(($0)|0);
      var $1=HEAP32[(($func)>>2)];
      var $value_=(($1)|0);
      var $gc=$value_;
      var $2=HEAP32[(($gc)>>2)];
      var $cl=$2;
      var $l=$cl;
      $c=$l;
      $i=0;
      label = 3; break;
    case 3: 
      var $3=$i;
      var $4=$c;
      var $nupvalues=(($4+6)|0);
      var $5=HEAP8[($nupvalues)];
      var $conv=(($5)&255);
      var $cmp=(($3)|0) < (($conv)|0);
      if ($cmp) { label = 4; break; } else { label = 8; break; }
    case 4: 
      var $6=$i;
      var $7=$c;
      var $upvals=(($7+16)|0);
      var $arrayidx=(($upvals+($6<<2))|0);
      var $8=HEAP32[(($arrayidx)>>2)];
      var $v=(($8+8)|0);
      var $9=HEAP32[(($v)>>2)];
      var $10=$o_addr;
      var $cmp2=(($9)|0)==(($10)|0);
      if ($cmp2) { label = 5; break; } else { label = 6; break; }
    case 5: 
      var $11=$c;
      var $p=(($11+12)|0);
      var $12=HEAP32[(($p)>>2)];
      var $13=$i;
      var $call=_upvalname($12, $13);
      var $14=$name_addr;
      HEAP32[(($14)>>2)]=$call;
      $retval=((5247084)|0);
      label = 9; break;
    case 6: 
      label = 7; break;
    case 7: 
      var $15=$i;
      var $inc=((($15)+(1))|0);
      $i=$inc;
      label = 3; break;
    case 8: 
      $retval=0;
      label = 9; break;
    case 9: 
      var $16=$retval;

      Module.print(INDENT + 'Exiting: _getupvalname');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return $16;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_getupvalname["X"]=1;

function _getobjname($p, $lastpc, $reg, $name) {
  var label = 0;

  Module.print(INDENT + ' Entering: _getobjname: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $retval;
      var $p_addr;
      var $lastpc_addr;
      var $reg_addr;
      var $name_addr;
      var $pc;
      var $i;
      var $op;
      var $b;
      var $k;
      var $t;
      var $vn;
      var $b29;
      var $k51;
      $p_addr=$p;
      $lastpc_addr=$lastpc;
      $reg_addr=$reg;
      $name_addr=$name;
      var $0=$p_addr;
      var $1=$reg_addr;
      var $add=((($1)+(1))|0);
      var $2=$lastpc_addr;
      var $call=_luaF_getlocalname($0, $add, $2);
      var $3=$name_addr;
      HEAP32[(($3)>>2)]=$call;
      var $4=$name_addr;
      var $5=HEAP32[(($4)>>2)];
      var $tobool=(($5)|0)!=0;
      if ($tobool) { label = 3; break; } else { label = 4; break; }
    case 3: 
      $retval=((5244488)|0);
      label = 26; break;
    case 4: 
      var $6=$p_addr;
      var $7=$lastpc_addr;
      var $8=$reg_addr;
      var $call1=_findsetreg($6, $7, $8);
      $pc=$call1;
      var $9=$pc;
      var $cmp=(($9)|0)!=-1;
      if ($cmp) { label = 5; break; } else { label = 25; break; }
    case 5: 
      var $10=$pc;
      var $11=$p_addr;
      var $code=(($11+12)|0);
      var $12=HEAP32[(($code)>>2)];
      var $arrayidx=(($12+($10<<2))|0);
      var $13=HEAP32[(($arrayidx)>>2)];
      $i=$13;
      var $14=$i;
      var $shr=$14 >>> 0;
      var $and=$shr & 63;
      $op=$and;
      var $15=$op;
      if ((($15)|0)==0) {
        label = 6; break;
      }
      else if ((($15)|0)==6 | (($15)|0)==7) {
        label = 9; break;
      }
      else if ((($15)|0)==5) {
        label = 15; break;
      }
      else if ((($15)|0)==1 | (($15)|0)==2) {
        label = 16; break;
      }
      else if ((($15)|0)==12) {
        label = 22; break;
      }
      else {
      label = 23; break;
      }
      
    case 6: 
      var $16=$i;
      var $shr3=$16 >>> 23;
      var $and4=$shr3 & 511;
      $b=$and4;
      var $17=$b;
      var $18=$i;
      var $shr5=$18 >>> 6;
      var $and6=$shr5 & 255;
      var $cmp7=(($17)|0) < (($and6)|0);
      if ($cmp7) { label = 7; break; } else { label = 8; break; }
    case 7: 
      var $19=$p_addr;
      var $20=$pc;
      var $21=$b;
      var $22=$name_addr;
      var $call9=_getobjname($19, $20, $21, $22);
      $retval=$call9;
      label = 26; break;
    case 8: 
      label = 24; break;
    case 9: 
      var $23=$i;
      var $shr12=$23 >>> 14;
      var $and13=$shr12 & 511;
      $k=$and13;
      var $24=$i;
      var $shr14=$24 >>> 23;
      var $and15=$shr14 & 511;
      $t=$and15;
      var $25=$op;
      var $cmp16=(($25)|0)==7;
      if ($cmp16) { label = 10; break; } else { label = 11; break; }
    case 10: 
      var $26=$p_addr;
      var $27=$t;
      var $add17=((($27)+(1))|0);
      var $28=$pc;
      var $call18=_luaF_getlocalname($26, $add17, $28);
      var $cond = $call18;label = 12; break;
    case 11: 
      var $29=$p_addr;
      var $30=$t;
      var $call19=_upvalname($29, $30);
      var $cond = $call19;label = 12; break;
    case 12: 
      var $cond;
      $vn=$cond;
      var $31=$p_addr;
      var $32=$pc;
      var $33=$k;
      var $34=$name_addr;
      _kname($31, $32, $33, $34);
      var $35=$vn;
      var $tobool20=(($35)|0)!=0;
      if ($tobool20) { label = 13; break; } else { var $37 = 0;label = 14; break; }
    case 13: 
      var $36=$vn;
      var $call21=_strcmp($36, ((5244336)|0));
      var $cmp22=(($call21)|0)==0;
      var $37 = $cmp22;label = 14; break;
    case 14: 
      var $37;
      var $cond23=$37 ? (((5244196)|0)) : (((5247208)|0));
      $retval=$cond23;
      label = 26; break;
    case 15: 
      var $38=$p_addr;
      var $39=$i;
      var $shr25=$39 >>> 23;
      var $and26=$shr25 & 511;
      var $call27=_upvalname($38, $and26);
      var $40=$name_addr;
      HEAP32[(($40)>>2)]=$call27;
      $retval=((5247084)|0);
      label = 26; break;
    case 16: 
      var $41=$op;
      var $cmp30=(($41)|0)==1;
      if ($cmp30) { label = 17; break; } else { label = 18; break; }
    case 17: 
      var $42=$i;
      var $shr32=$42 >>> 14;
      var $and33=$shr32 & 262143;
      var $cond41 = $and33;label = 19; break;
    case 18: 
      var $43=$pc;
      var $add35=((($43)+(1))|0);
      var $44=$p_addr;
      var $code36=(($44+12)|0);
      var $45=HEAP32[(($code36)>>2)];
      var $arrayidx37=(($45+($add35<<2))|0);
      var $46=HEAP32[(($arrayidx37)>>2)];
      var $shr38=$46 >>> 6;
      var $and39=$shr38 & 67108863;
      var $cond41 = $and39;label = 19; break;
    case 19: 
      var $cond41;
      $b29=$cond41;
      var $47=$b29;
      var $48=$p_addr;
      var $k42=(($48+8)|0);
      var $49=HEAP32[(($k42)>>2)];
      var $arrayidx43=(($49+((($47)*(12))&-1))|0);
      var $tt_=(($arrayidx43+8)|0);
      var $50=HEAP32[(($tt_)>>2)];
      var $and44=$50 & 15;
      var $cmp45=(($and44)|0)==4;
      if ($cmp45) { label = 20; break; } else { label = 21; break; }
    case 20: 
      var $51=$b29;
      var $52=$p_addr;
      var $k47=(($52+8)|0);
      var $53=HEAP32[(($k47)>>2)];
      var $arrayidx48=(($53+((($51)*(12))&-1))|0);
      var $value_=(($arrayidx48)|0);
      var $gc=$value_;
      var $54=HEAP32[(($gc)>>2)];
      var $ts=$54;
      var $add_ptr=(($ts+16)|0);
      var $55=$add_ptr;
      var $56=$name_addr;
      HEAP32[(($56)>>2)]=$55;
      $retval=((5246872)|0);
      label = 26; break;
    case 21: 
      label = 24; break;
    case 22: 
      var $57=$i;
      var $shr52=$57 >>> 14;
      var $and53=$shr52 & 511;
      $k51=$and53;
      var $58=$p_addr;
      var $59=$pc;
      var $60=$k51;
      var $61=$name_addr;
      _kname($58, $59, $60, $61);
      $retval=((5246720)|0);
      label = 26; break;
    case 23: 
      label = 24; break;
    case 24: 
      label = 25; break;
    case 25: 
      $retval=0;
      label = 26; break;
    case 26: 
      var $62=$retval;

      Module.print(INDENT + 'Exiting: _getobjname');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return $62;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_getobjname["X"]=1;

function _luaG_typeerror($L, $o, $op) {
  var label = 0;
  var __stackBase__  = STACKTOP; STACKTOP = (STACKTOP + 4)|0; _memset(__stackBase__, 0, 4);
  Module.print(INDENT + ' Entering: _luaG_typeerror: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $L_addr;
      var $o_addr;
      var $op_addr;
      var $ci;
      var $name=__stackBase__;
      var $t;
      var $kind;
      $L_addr=$L;
      $o_addr=$o;
      $op_addr=$op;
      var $0=$L_addr;
      var $ci1=(($0+16)|0);
      var $1=HEAP32[(($ci1)>>2)];
      $ci=$1;
      HEAP32[(($name)>>2)]=0;
      var $2=$o_addr;
      var $tt_=(($2+8)|0);
      var $3=HEAP32[(($tt_)>>2)];
      var $and=$3 & 15;
      var $add=((($and)+(1))|0);
      var $arrayidx=((5243464+($add<<2))|0);
      var $4=HEAP32[(($arrayidx)>>2)];
      $t=$4;
      $kind=0;
      var $5=$ci;
      var $callstatus=(($5+18)|0);
      var $6=HEAP8[($callstatus)];
      var $conv=(($6)&255);
      var $and2=$conv & 1;
      var $tobool=(($and2)|0)!=0;
      if ($tobool) { label = 3; break; } else { label = 7; break; }
    case 3: 
      var $7=$ci;
      var $8=$o_addr;
      var $call=_getupvalname($7, $8, $name);
      $kind=$call;
      var $9=$kind;
      var $tobool3=(($9)|0)!=0;
      if ($tobool3) { label = 6; break; } else { label = 4; break; }
    case 4: 
      var $10=$ci;
      var $11=$o_addr;
      var $call4=_isinstack($10, $11);
      var $tobool5=(($call4)|0)!=0;
      if ($tobool5) { label = 5; break; } else { label = 6; break; }
    case 5: 
      var $12=$ci;
      var $func=(($12)|0);
      var $13=HEAP32[(($func)>>2)];
      var $value_=(($13)|0);
      var $gc=$value_;
      var $14=HEAP32[(($gc)>>2)];
      var $cl=$14;
      var $l=$cl;
      var $p=(($l+12)|0);
      var $15=HEAP32[(($p)>>2)];
      var $16=$ci;
      var $call7=_currentpc($16);
      var $17=$o_addr;
      var $18=$ci;
      var $u=(($18+24)|0);
      var $l8=$u;
      var $base=(($l8)|0);
      var $19=HEAP32[(($base)>>2)];
      var $sub_ptr_lhs_cast=$17;
      var $sub_ptr_rhs_cast=$19;
      var $sub_ptr_sub=((($sub_ptr_lhs_cast)-($sub_ptr_rhs_cast))|0);
      var $sub_ptr_div=((((($sub_ptr_sub)|0))/(12))&-1);
      var $call9=_getobjname($15, $call7, $sub_ptr_div, $name);
      $kind=$call9;
      label = 6; break;
    case 6: 
      label = 7; break;
    case 7: 
      var $20=$kind;
      var $tobool11=(($20)|0)!=0;
      if ($tobool11) { label = 8; break; } else { label = 9; break; }
    case 8: 
      var $21=$L_addr;
      var $22=$op_addr;
      var $23=$kind;
      var $24=HEAP32[(($name)>>2)];
      var $25=$t;
      _luaG_runerror($21, ((5244832)|0), (tempInt=STACKTOP,_memset(STACKTOP, 0, 16),STACKTOP = (STACKTOP + 16)|0,HEAP32[((tempInt)>>2)]=$22,HEAP32[(((tempInt)+(4))>>2)]=$23,HEAP32[(((tempInt)+(8))>>2)]=$24,HEAP32[(((tempInt)+(12))>>2)]=$25,tempInt));

    case 9: 
      var $26=$L_addr;
      var $27=$op_addr;
      var $28=$t;
      _luaG_runerror($26, ((5246500)|0), (tempInt=STACKTOP,_memset(STACKTOP, 0, 8),STACKTOP = (STACKTOP + 8)|0,HEAP32[((tempInt)>>2)]=$27,HEAP32[(((tempInt)+(4))>>2)]=$28,tempInt));

    case 10: 
      STACKTOP = __stackBase__;
      Module.print(INDENT + 'Exiting: _luaG_typeerror');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_luaG_typeerror["X"]=1;

function _luaG_runerror($L, $fmt, varrp) {
  var label = 0;
  var __stackBase__  = STACKTOP; STACKTOP = (STACKTOP + 4)|0; _memset(__stackBase__, 0, 4);
  Module.print(INDENT + ' Entering: _luaG_runerror: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $L_addr;
      var $fmt_addr;
      var $argp=__stackBase__;
      $L_addr=$L;
      $fmt_addr=$fmt;
      var $argp1=$argp;
      HEAP32[(($argp1)>>2)]=varrp;
      var $0=$L_addr;
      var $1=$L_addr;
      var $2=$fmt_addr;
      var $3=HEAP32[(($argp)>>2)];
      var $call=_luaO_pushvfstring($1, $2, $3);
      _addinfo($0, $call);
      var $argp2=$argp;

      var $4=$L_addr;
      _luaG_errormsg($4);

    case 3: 
      STACKTOP = __stackBase__;
      Module.print(INDENT + 'Exiting: _luaG_runerror');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _luaG_concaterror($L, $p1, $p2) {
  var label = 0;

  Module.print(INDENT + ' Entering: _luaG_concaterror: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $L_addr;
      var $p1_addr;
      var $p2_addr;
      $L_addr=$L;
      $p1_addr=$p1;
      $p2_addr=$p2;
      var $0=$p1_addr;
      var $tt_=(($0+8)|0);
      var $1=HEAP32[(($tt_)>>2)];
      var $and=$1 & 15;
      var $cmp=(($and)|0)==4;
      if ($cmp) { label = 4; break; } else { label = 3; break; }
    case 3: 
      var $2=$p1_addr;
      var $tt_1=(($2+8)|0);
      var $3=HEAP32[(($tt_1)>>2)];
      var $cmp2=(($3)|0)==3;
      if ($cmp2) { label = 4; break; } else { label = 5; break; }
    case 4: 
      var $4=$p2_addr;
      $p1_addr=$4;
      label = 5; break;
    case 5: 
      var $5=$L_addr;
      var $6=$p1_addr;
      _luaG_typeerror($5, $6, ((5245536)|0));

    case 6: 

      Module.print(INDENT + 'Exiting: _luaG_concaterror');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _luaG_aritherror($L, $p1, $p2) {
  var label = 0;
  var __stackBase__  = STACKTOP; STACKTOP = (STACKTOP + 12)|0; _memset(__stackBase__, 0, 12);
  Module.print(INDENT + ' Entering: _luaG_aritherror: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $L_addr;
      var $p1_addr;
      var $p2_addr;
      var $temp=__stackBase__;
      $L_addr=$L;
      $p1_addr=$p1;
      $p2_addr=$p2;
      var $0=$p1_addr;
      var $call=_luaV_tonumber($0, $temp);
      var $cmp=(($call)|0)==0;
      if ($cmp) { label = 3; break; } else { label = 4; break; }
    case 3: 
      var $1=$p1_addr;
      $p2_addr=$1;
      label = 4; break;
    case 4: 
      var $2=$L_addr;
      var $3=$p2_addr;
      _luaG_typeerror($2, $3, ((5245136)|0));

    case 5: 
      STACKTOP = __stackBase__;
      Module.print(INDENT + 'Exiting: _luaG_aritherror');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _findsetreg($p, $lastpc, $reg) {
  var label = 0;

  Module.print(INDENT + ' Entering: _findsetreg: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $p_addr;
      var $lastpc_addr;
      var $reg_addr;
      var $pc;
      var $setreg;
      var $i;
      var $op;
      var $a;
      var $b;
      var $b17;
      var $dest;
      $p_addr=$p;
      $lastpc_addr=$lastpc;
      $reg_addr=$reg;
      $setreg=-1;
      $pc=0;
      label = 3; break;
    case 3: 
      var $0=$pc;
      var $1=$lastpc_addr;
      var $cmp=(($0)|0) < (($1)|0);
      if ($cmp) { label = 4; break; } else { label = 28; break; }
    case 4: 
      var $2=$pc;
      var $3=$p_addr;
      var $code=(($3+12)|0);
      var $4=HEAP32[(($code)>>2)];
      var $arrayidx=(($4+($2<<2))|0);
      var $5=HEAP32[(($arrayidx)>>2)];
      $i=$5;
      var $6=$i;
      var $shr=$6 >>> 0;
      var $and=$shr & 63;
      $op=$and;
      var $7=$i;
      var $shr1=$7 >>> 6;
      var $and2=$shr1 & 255;
      $a=$and2;
      var $8=$op;
      if ((($8)|0)==4) {
        label = 5; break;
      }
      else if ((($8)|0)==34) {
        label = 9; break;
      }
      else if ((($8)|0)==29 | (($8)|0)==30) {
        label = 12; break;
      }
      else if ((($8)|0)==23) {
        label = 15; break;
      }
      else if ((($8)|0)==27) {
        label = 19; break;
      }
      else {
      label = 22; break;
      }
      
    case 5: 
      var $9=$i;
      var $shr3=$9 >>> 23;
      var $and4=$shr3 & 511;
      $b=$and4;
      var $10=$a;
      var $11=$reg_addr;
      var $cmp5=(($10)|0) <= (($11)|0);
      if ($cmp5) { label = 6; break; } else { label = 8; break; }
    case 6: 
      var $12=$reg_addr;
      var $13=$a;
      var $14=$b;
      var $add=((($13)+($14))|0);
      var $cmp6=(($12)|0) <= (($add)|0);
      if ($cmp6) { label = 7; break; } else { label = 8; break; }
    case 7: 
      var $15=$pc;
      $setreg=$15;
      label = 8; break;
    case 8: 
      label = 26; break;
    case 9: 
      var $16=$reg_addr;
      var $17=$a;
      var $add8=((($17)+(2))|0);
      var $cmp9=(($16)|0) >= (($add8)|0);
      if ($cmp9) { label = 10; break; } else { label = 11; break; }
    case 10: 
      var $18=$pc;
      $setreg=$18;
      label = 11; break;
    case 11: 
      label = 26; break;
    case 12: 
      var $19=$reg_addr;
      var $20=$a;
      var $cmp13=(($19)|0) >= (($20)|0);
      if ($cmp13) { label = 13; break; } else { label = 14; break; }
    case 13: 
      var $21=$pc;
      $setreg=$21;
      label = 14; break;
    case 14: 
      label = 26; break;
    case 15: 
      var $22=$i;
      var $shr18=$22 >>> 14;
      var $and19=$shr18 & 262143;
      var $sub=((($and19)-(131071))|0);
      $b17=$sub;
      var $23=$pc;
      var $add20=((($23)+(1))|0);
      var $24=$b17;
      var $add21=((($add20)+($24))|0);
      $dest=$add21;
      var $25=$pc;
      var $26=$dest;
      var $cmp22=(($25)|0) < (($26)|0);
      if ($cmp22) { label = 16; break; } else { label = 18; break; }
    case 16: 
      var $27=$dest;
      var $28=$lastpc_addr;
      var $cmp24=(($27)|0) <= (($28)|0);
      if ($cmp24) { label = 17; break; } else { label = 18; break; }
    case 17: 
      var $29=$b17;
      var $30=$pc;
      var $add26=((($30)+($29))|0);
      $pc=$add26;
      label = 18; break;
    case 18: 
      label = 26; break;
    case 19: 
      var $31=$reg_addr;
      var $32=$a;
      var $cmp29=(($31)|0)==(($32)|0);
      if ($cmp29) { label = 20; break; } else { label = 21; break; }
    case 20: 
      var $33=$pc;
      $setreg=$33;
      label = 21; break;
    case 21: 
      label = 26; break;
    case 22: 
      var $34=$op;
      var $arrayidx32=((5243744+$34)|0);
      var $35=HEAP8[($arrayidx32)];
      var $conv=(($35)&255);
      var $and33=$conv & 64;
      var $tobool=(($and33)|0)!=0;
      if ($tobool) { label = 23; break; } else { label = 25; break; }
    case 23: 
      var $36=$reg_addr;
      var $37=$a;
      var $cmp35=(($36)|0)==(($37)|0);
      if ($cmp35) { label = 24; break; } else { label = 25; break; }
    case 24: 
      var $38=$pc;
      $setreg=$38;
      label = 25; break;
    case 25: 
      label = 26; break;
    case 26: 
      label = 27; break;
    case 27: 
      var $39=$pc;
      var $inc=((($39)+(1))|0);
      $pc=$inc;
      label = 3; break;
    case 28: 
      var $40=$setreg;

      Module.print(INDENT + 'Exiting: _findsetreg');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return $40;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_findsetreg["X"]=1;

function _upvalname($p, $uv) {
  var label = 0;

  Module.print(INDENT + ' Entering: _upvalname: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $retval;
      var $p_addr;
      var $uv_addr;
      var $s;
      $p_addr=$p;
      $uv_addr=$uv;
      var $0=$uv_addr;
      var $1=$p_addr;
      var $upvalues=(($1+28)|0);
      var $2=HEAP32[(($upvalues)>>2)];
      var $arrayidx=(($2+($0<<3))|0);
      var $name=(($arrayidx)|0);
      var $3=HEAP32[(($name)>>2)];
      $s=$3;
      var $4=$s;
      var $cmp=(($4)|0)==0;
      if ($cmp) { label = 3; break; } else { label = 4; break; }
    case 3: 
      $retval=((5246656)|0);
      label = 5; break;
    case 4: 
      var $5=$s;
      var $add_ptr=(($5+16)|0);
      var $6=$add_ptr;
      $retval=$6;
      label = 5; break;
    case 5: 
      var $7=$retval;

      Module.print(INDENT + 'Exiting: _upvalname');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return $7;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _findvararg($ci, $n, $pos) {
  var label = 0;

  Module.print(INDENT + ' Entering: _findvararg: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $retval;
      var $ci_addr;
      var $n_addr;
      var $pos_addr;
      var $nparams;
      $ci_addr=$ci;
      $n_addr=$n;
      $pos_addr=$pos;
      var $0=$ci_addr;
      var $func=(($0)|0);
      var $1=HEAP32[(($func)>>2)];
      var $value_=(($1)|0);
      var $gc=$value_;
      var $2=HEAP32[(($gc)>>2)];
      var $cl=$2;
      var $l=$cl;
      var $p=(($l+12)|0);
      var $3=HEAP32[(($p)>>2)];
      var $numparams=(($3+76)|0);
      var $4=HEAP8[($numparams)];
      var $conv=(($4)&255);
      $nparams=$conv;
      var $5=$n_addr;
      var $6=$ci_addr;
      var $u=(($6+24)|0);
      var $l1=$u;
      var $base=(($l1)|0);
      var $7=HEAP32[(($base)>>2)];
      var $8=$ci_addr;
      var $func2=(($8)|0);
      var $9=HEAP32[(($func2)>>2)];
      var $sub_ptr_lhs_cast=$7;
      var $sub_ptr_rhs_cast=$9;
      var $sub_ptr_sub=((($sub_ptr_lhs_cast)-($sub_ptr_rhs_cast))|0);
      var $sub_ptr_div=((((($sub_ptr_sub)|0))/(12))&-1);
      var $10=$nparams;
      var $sub=((($sub_ptr_div)-($10))|0);
      var $cmp=(($5)|0) >= (($sub)|0);
      if ($cmp) { label = 3; break; } else { label = 4; break; }
    case 3: 
      $retval=0;
      label = 5; break;
    case 4: 
      var $11=$ci_addr;
      var $func4=(($11)|0);
      var $12=HEAP32[(($func4)>>2)];
      var $13=$nparams;
      var $add_ptr=(($12+((($13)*(12))&-1))|0);
      var $14=$n_addr;
      var $add_ptr5=(($add_ptr+((($14)*(12))&-1))|0);
      var $15=$pos_addr;
      HEAP32[(($15)>>2)]=$add_ptr5;
      $retval=((5245664)|0);
      label = 5; break;
    case 5: 
      var $16=$retval;

      Module.print(INDENT + 'Exiting: _findvararg');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return $16;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_findvararg["X"]=1;

function _addinfo($L, $msg) {
  var label = 0;
  var __stackBase__  = STACKTOP; STACKTOP = (STACKTOP + 60)|0; _memset(__stackBase__, 0, 60);
  Module.print(INDENT + ' Entering: _addinfo: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $L_addr;
      var $msg_addr;
      var $ci;
      var $buff=__stackBase__;
      var $line;
      var $src;
      $L_addr=$L;
      $msg_addr=$msg;
      var $0=$L_addr;
      var $ci1=(($0+16)|0);
      var $1=HEAP32[(($ci1)>>2)];
      $ci=$1;
      var $2=$ci;
      var $callstatus=(($2+18)|0);
      var $3=HEAP8[($callstatus)];
      var $conv=(($3)&255);
      var $and=$conv & 1;
      var $tobool=(($and)|0)!=0;
      if ($tobool) { label = 3; break; } else { label = 7; break; }
    case 3: 
      var $4=$ci;
      var $call=_currentline($4);
      $line=$call;
      var $5=$ci;
      var $func=(($5)|0);
      var $6=HEAP32[(($func)>>2)];
      var $value_=(($6)|0);
      var $gc=$value_;
      var $7=HEAP32[(($gc)>>2)];
      var $cl=$7;
      var $l=$cl;
      var $p=(($l+12)|0);
      var $8=HEAP32[(($p)>>2)];
      var $source=(($8+36)|0);
      var $9=HEAP32[(($source)>>2)];
      $src=$9;
      var $10=$src;
      var $tobool2=(($10)|0)!=0;
      if ($tobool2) { label = 4; break; } else { label = 5; break; }
    case 4: 
      var $arraydecay=(($buff)|0);
      var $11=$src;
      var $add_ptr=(($11+16)|0);
      var $12=$add_ptr;
      _luaO_chunkid($arraydecay, $12, 60);
      label = 6; break;
    case 5: 
      var $arrayidx=(($buff)|0);
      HEAP8[($arrayidx)]=63;
      var $arrayidx4=(($buff+1)|0);
      HEAP8[($arrayidx4)]=0;
      label = 6; break;
    case 6: 
      var $13=$L_addr;
      var $arraydecay5=(($buff)|0);
      var $14=$line;
      var $15=$msg_addr;
      var $call6=_luaO_pushfstring($13, ((5244620)|0), (tempInt=STACKTOP,_memset(STACKTOP, 0, 12),STACKTOP = (STACKTOP + 12)|0,HEAP32[((tempInt)>>2)]=$arraydecay5,HEAP32[(((tempInt)+(4))>>2)]=$14,HEAP32[(((tempInt)+(8))>>2)]=$15,tempInt));
      label = 7; break;
    case 7: 
      STACKTOP = __stackBase__;
      Module.print(INDENT + 'Exiting: _addinfo');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_addinfo["X"]=1;

function _currentline($ci) {
  var label = 0;

  Module.print(INDENT + ' Entering: _currentline: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $ci_addr;
      $ci_addr=$ci;
      var $0=$ci_addr;
      var $func=(($0)|0);
      var $1=HEAP32[(($func)>>2)];
      var $value_=(($1)|0);
      var $gc=$value_;
      var $2=HEAP32[(($gc)>>2)];
      var $cl=$2;
      var $l=$cl;
      var $p=(($l+12)|0);
      var $3=HEAP32[(($p)>>2)];
      var $lineinfo=(($3+20)|0);
      var $4=HEAP32[(($lineinfo)>>2)];
      var $tobool=(($4)|0)!=0;
      if ($tobool) { label = 3; break; } else { label = 4; break; }
    case 3: 
      var $5=$ci_addr;
      var $call=_currentpc($5);
      var $6=$ci_addr;
      var $func1=(($6)|0);
      var $7=HEAP32[(($func1)>>2)];
      var $value_2=(($7)|0);
      var $gc3=$value_2;
      var $8=HEAP32[(($gc3)>>2)];
      var $cl4=$8;
      var $l5=$cl4;
      var $p6=(($l5+12)|0);
      var $9=HEAP32[(($p6)>>2)];
      var $lineinfo7=(($9+20)|0);
      var $10=HEAP32[(($lineinfo7)>>2)];
      var $arrayidx=(($10+($call<<2))|0);
      var $11=HEAP32[(($arrayidx)>>2)];
      var $cond = $11;label = 5; break;
    case 4: 
      var $cond = 0;label = 5; break;
    case 5: 
      var $cond;

      Module.print(INDENT + 'Exiting: _currentline');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return $cond;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _kname($p, $pc, $c, $name) {
  var label = 0;

  Module.print(INDENT + ' Entering: _kname: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $p_addr;
      var $pc_addr;
      var $c_addr;
      var $name_addr;
      var $kvalue;
      var $what;
      $p_addr=$p;
      $pc_addr=$pc;
      $c_addr=$c;
      $name_addr=$name;
      var $0=$c_addr;
      var $and=$0 & 256;
      var $tobool=(($and)|0)!=0;
      if ($tobool) { label = 3; break; } else { label = 6; break; }
    case 3: 
      var $1=$c_addr;
      var $and1=$1 & -257;
      var $2=$p_addr;
      var $k=(($2+8)|0);
      var $3=HEAP32[(($k)>>2)];
      var $arrayidx=(($3+((($and1)*(12))&-1))|0);
      $kvalue=$arrayidx;
      var $4=$kvalue;
      var $tt_=(($4+8)|0);
      var $5=HEAP32[(($tt_)>>2)];
      var $and2=$5 & 15;
      var $cmp=(($and2)|0)==4;
      if ($cmp) { label = 4; break; } else { label = 5; break; }
    case 4: 
      var $6=$kvalue;
      var $value_=(($6)|0);
      var $gc=$value_;
      var $7=HEAP32[(($gc)>>2)];
      var $ts=$7;
      var $add_ptr=(($ts+16)|0);
      var $8=$add_ptr;
      var $9=$name_addr;
      HEAP32[(($9)>>2)]=$8;
      label = 11; break;
    case 5: 
      label = 10; break;
    case 6: 
      var $10=$p_addr;
      var $11=$pc_addr;
      var $12=$c_addr;
      var $13=$name_addr;
      var $call=_getobjname($10, $11, $12, $13);
      $what=$call;
      var $14=$what;
      var $tobool4=(($14)|0)!=0;
      if ($tobool4) { label = 7; break; } else { label = 9; break; }
    case 7: 
      var $15=$what;
      var $16=HEAP8[($15)];
      var $conv=(($16 << 24) >> 24);
      var $cmp5=(($conv)|0)==99;
      if ($cmp5) { label = 8; break; } else { label = 9; break; }
    case 8: 
      label = 11; break;
    case 9: 
      label = 10; break;
    case 10: 
      var $17=$name_addr;
      HEAP32[(($17)>>2)]=((5246656)|0);
      label = 11; break;
    case 11: 

      Module.print(INDENT + 'Exiting: _kname');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_kname["X"]=1;

function _funcinfo($ar, $cl) {
  var label = 0;

  Module.print(INDENT + ' Entering: _funcinfo: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $ar_addr;
      var $cl_addr;
      var $p;
      $ar_addr=$ar;
      $cl_addr=$cl;
      var $0=$cl_addr;
      var $cmp=(($0)|0)==0;
      if ($cmp) { label = 4; break; } else { label = 3; break; }
    case 3: 
      var $1=$cl_addr;
      var $c=$1;
      var $tt=(($c+4)|0);
      var $2=HEAP8[($tt)];
      var $conv=(($2)&255);
      var $cmp1=(($conv)|0)==38;
      if ($cmp1) { label = 4; break; } else { label = 5; break; }
    case 4: 
      var $3=$ar_addr;
      var $source=(($3+16)|0);
      HEAP32[(($source)>>2)]=((5246300)|0);
      var $4=$ar_addr;
      var $linedefined=(($4+24)|0);
      HEAP32[(($linedefined)>>2)]=-1;
      var $5=$ar_addr;
      var $lastlinedefined=(($5+28)|0);
      HEAP32[(($lastlinedefined)>>2)]=-1;
      var $6=$ar_addr;
      var $what=(($6+12)|0);
      HEAP32[(($what)>>2)]=((5246188)|0);
      label = 9; break;
    case 5: 
      var $7=$cl_addr;
      var $l=$7;
      var $p3=(($l+12)|0);
      var $8=HEAP32[(($p3)>>2)];
      $p=$8;
      var $9=$p;
      var $source4=(($9+36)|0);
      var $10=HEAP32[(($source4)>>2)];
      var $tobool=(($10)|0)!=0;
      if ($tobool) { label = 6; break; } else { label = 7; break; }
    case 6: 
      var $11=$p;
      var $source5=(($11+36)|0);
      var $12=HEAP32[(($source5)>>2)];
      var $add_ptr=(($12+16)|0);
      var $13=$add_ptr;
      var $cond = $13;label = 8; break;
    case 7: 
      var $cond = ((5246084)|0);label = 8; break;
    case 8: 
      var $cond;
      var $14=$ar_addr;
      var $source6=(($14+16)|0);
      HEAP32[(($source6)>>2)]=$cond;
      var $15=$p;
      var $linedefined7=(($15+64)|0);
      var $16=HEAP32[(($linedefined7)>>2)];
      var $17=$ar_addr;
      var $linedefined8=(($17+24)|0);
      HEAP32[(($linedefined8)>>2)]=$16;
      var $18=$p;
      var $lastlinedefined9=(($18+68)|0);
      var $19=HEAP32[(($lastlinedefined9)>>2)];
      var $20=$ar_addr;
      var $lastlinedefined10=(($20+28)|0);
      HEAP32[(($lastlinedefined10)>>2)]=$19;
      var $21=$ar_addr;
      var $linedefined11=(($21+24)|0);
      var $22=HEAP32[(($linedefined11)>>2)];
      var $cmp12=(($22)|0)==0;
      var $cond14=$cmp12 ? (((5246028)|0)) : (((5245900)|0));
      var $23=$ar_addr;
      var $what15=(($23+12)|0);
      HEAP32[(($what15)>>2)]=$cond14;
      label = 9; break;
    case 9: 
      var $24=$ar_addr;
      var $short_src=(($24+36)|0);
      var $arraydecay=(($short_src)|0);
      var $25=$ar_addr;
      var $source16=(($25+16)|0);
      var $26=HEAP32[(($source16)>>2)];
      _luaO_chunkid($arraydecay, $26, 60);

      Module.print(INDENT + 'Exiting: _funcinfo');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_funcinfo["X"]=1;

function _getfuncname($L, $ci, $name) {
  var label = 0;

  Module.print(INDENT + ' Entering: _getfuncname: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $retval;
      var $L_addr;
      var $ci_addr;
      var $name_addr;
      var $tm;
      var $p;
      var $pc;
      var $i;
      $L_addr=$L;
      $ci_addr=$ci;
      $name_addr=$name;
      var $0=$ci_addr;
      var $func=(($0)|0);
      var $1=HEAP32[(($func)>>2)];
      var $value_=(($1)|0);
      var $gc=$value_;
      var $2=HEAP32[(($gc)>>2)];
      var $cl=$2;
      var $l=$cl;
      var $p1=(($l+12)|0);
      var $3=HEAP32[(($p1)>>2)];
      $p=$3;
      var $4=$ci_addr;
      var $call=_currentpc($4);
      $pc=$call;
      var $5=$pc;
      var $6=$p;
      var $code=(($6+12)|0);
      var $7=HEAP32[(($code)>>2)];
      var $arrayidx=(($7+($5<<2))|0);
      var $8=HEAP32[(($arrayidx)>>2)];
      $i=$8;
      var $9=$i;
      var $shr=$9 >>> 0;
      var $and=$shr & 63;
      if ((($and)|0)==29 | (($and)|0)==30) {
        label = 3; break;
      }
      else if ((($and)|0)==34) {
        label = 4; break;
      }
      else if ((($and)|0)==12 | (($and)|0)==6 | (($and)|0)==7) {
        label = 5; break;
      }
      else if ((($and)|0)==8 | (($and)|0)==10) {
        label = 6; break;
      }
      else if ((($and)|0)==24) {
        label = 7; break;
      }
      else if ((($and)|0)==13) {
        label = 8; break;
      }
      else if ((($and)|0)==14) {
        label = 9; break;
      }
      else if ((($and)|0)==15) {
        label = 10; break;
      }
      else if ((($and)|0)==16) {
        label = 11; break;
      }
      else if ((($and)|0)==17) {
        label = 12; break;
      }
      else if ((($and)|0)==18) {
        label = 13; break;
      }
      else if ((($and)|0)==19) {
        label = 14; break;
      }
      else if ((($and)|0)==21) {
        label = 15; break;
      }
      else if ((($and)|0)==25) {
        label = 16; break;
      }
      else if ((($and)|0)==26) {
        label = 17; break;
      }
      else if ((($and)|0)==22) {
        label = 18; break;
      }
      else {
      label = 19; break;
      }
      
    case 3: 
      var $10=$p;
      var $11=$pc;
      var $12=$i;
      var $shr2=$12 >>> 6;
      var $and3=$shr2 & 255;
      var $13=$name_addr;
      var $call4=_getobjname($10, $11, $and3, $13);
      $retval=$call4;
      label = 21; break;
    case 4: 
      var $14=$name_addr;
      HEAP32[(($14)>>2)]=((5246452)|0);
      $retval=((5246452)|0);
      label = 21; break;
    case 5: 
      $tm=0;
      label = 20; break;
    case 6: 
      $tm=1;
      label = 20; break;
    case 7: 
      $tm=5;
      label = 20; break;
    case 8: 
      $tm=6;
      label = 20; break;
    case 9: 
      $tm=7;
      label = 20; break;
    case 10: 
      $tm=8;
      label = 20; break;
    case 11: 
      $tm=9;
      label = 20; break;
    case 12: 
      $tm=10;
      label = 20; break;
    case 13: 
      $tm=11;
      label = 20; break;
    case 14: 
      $tm=12;
      label = 20; break;
    case 15: 
      $tm=4;
      label = 20; break;
    case 16: 
      $tm=13;
      label = 20; break;
    case 17: 
      $tm=14;
      label = 20; break;
    case 18: 
      $tm=15;
      label = 20; break;
    case 19: 
      $retval=0;
      label = 21; break;
    case 20: 
      var $15=$tm;
      var $16=$L_addr;
      var $l_G=(($16+12)|0);
      var $17=HEAP32[(($l_G)>>2)];
      var $tmname=(($17+164)|0);
      var $arrayidx20=(($tmname+($15<<2))|0);
      var $18=HEAP32[(($arrayidx20)>>2)];
      var $add_ptr=(($18+16)|0);
      var $19=$add_ptr;
      var $20=$name_addr;
      HEAP32[(($20)>>2)]=$19;
      $retval=((5246372)|0);
      label = 21; break;
    case 21: 
      var $21=$retval;

      Module.print(INDENT + 'Exiting: _getfuncname');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return $21;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_getfuncname["X"]=1;

function _luaG_ordererror($L, $p1, $p2) {
  var label = 0;
  var __stackBase__  = STACKTOP; _memset(__stackBase__, 0, 0);
  Module.print(INDENT + ' Entering: _luaG_ordererror: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $L_addr;
      var $p1_addr;
      var $p2_addr;
      var $t1;
      var $t2;
      $L_addr=$L;
      $p1_addr=$p1;
      $p2_addr=$p2;
      var $0=$p1_addr;
      var $tt_=(($0+8)|0);
      var $1=HEAP32[(($tt_)>>2)];
      var $and=$1 & 15;
      var $add=((($and)+(1))|0);
      var $arrayidx=((5243464+($add<<2))|0);
      var $2=HEAP32[(($arrayidx)>>2)];
      $t1=$2;
      var $3=$p2_addr;
      var $tt_1=(($3+8)|0);
      var $4=HEAP32[(($tt_1)>>2)];
      var $and2=$4 & 15;
      var $add3=((($and2)+(1))|0);
      var $arrayidx4=((5243464+($add3<<2))|0);
      var $5=HEAP32[(($arrayidx4)>>2)];
      $t2=$5;
      var $6=$t1;
      var $7=$t2;
      var $cmp=(($6)|0)==(($7)|0);
      if ($cmp) { label = 3; break; } else { label = 4; break; }
    case 3: 
      var $8=$L_addr;
      var $9=$t1;
      _luaG_runerror($8, ((5244872)|0), (tempInt=STACKTOP,_memset(STACKTOP, 0, 4),STACKTOP = (STACKTOP + 4)|0,HEAP32[((tempInt)>>2)]=$9,tempInt));

    case 4: 
      var $10=$L_addr;
      var $11=$t1;
      var $12=$t2;
      _luaG_runerror($10, ((5244780)|0), (tempInt=STACKTOP,_memset(STACKTOP, 0, 8),STACKTOP = (STACKTOP + 8)|0,HEAP32[((tempInt)>>2)]=$11,HEAP32[(((tempInt)+(4))>>2)]=$12,tempInt));

    case 5: 
      STACKTOP = __stackBase__;
      Module.print(INDENT + 'Exiting: _luaG_ordererror');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _luaG_errormsg($L) {
  var label = 0;

  Module.print(INDENT + ' Entering: _luaG_errormsg: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $L_addr;
      var $errfunc1;
      var $io2;
      var $io1;
      var $io210;
      var $io111;
      $L_addr=$L;
      var $0=$L_addr;
      var $errfunc=(($0+68)|0);
      var $1=HEAP32[(($errfunc)>>2)];
      var $cmp=(($1)|0)!=0;
      if ($cmp) { label = 3; break; } else { label = 9; break; }
    case 3: 
      var $2=$L_addr;
      var $stack=(($2+28)|0);
      var $3=HEAP32[(($stack)>>2)];
      var $4=$3;
      var $5=$L_addr;
      var $errfunc2=(($5+68)|0);
      var $6=HEAP32[(($errfunc2)>>2)];
      var $add_ptr=(($4+$6)|0);
      var $7=$add_ptr;
      $errfunc1=$7;
      var $8=$errfunc1;
      var $tt_=(($8+8)|0);
      var $9=HEAP32[(($tt_)>>2)];
      var $and=$9 & 15;
      var $cmp3=(($and)|0)==6;
      if ($cmp3) { label = 5; break; } else { label = 4; break; }
    case 4: 
      var $10=$L_addr;
      _luaD_throw($10, 6);

    case 5: 
      var $11=$L_addr;
      var $top=(($11+8)|0);
      var $12=HEAP32[(($top)>>2)];
      var $add_ptr5=((($12)-(12))|0);
      $io2=$add_ptr5;
      var $13=$L_addr;
      var $top6=(($13+8)|0);
      var $14=HEAP32[(($top6)>>2)];
      $io1=$14;
      var $15=$io1;
      var $value_=(($15)|0);
      var $16=$io2;
      var $value_7=(($16)|0);
      var $17=$value_;
      var $18=$value_7;
      HEAP32[(($17)>>2)]=HEAP32[(($18)>>2)];HEAP32[((($17)+(4))>>2)]=HEAP32[((($18)+(4))>>2)];
      var $19=$io2;
      var $tt_8=(($19+8)|0);
      var $20=HEAP32[(($tt_8)>>2)];
      var $21=$io1;
      var $tt_9=(($21+8)|0);
      HEAP32[(($tt_9)>>2)]=$20;
      var $22=$errfunc1;
      $io210=$22;
      var $23=$L_addr;
      var $top12=(($23+8)|0);
      var $24=HEAP32[(($top12)>>2)];
      var $add_ptr13=((($24)-(12))|0);
      $io111=$add_ptr13;
      var $25=$io111;
      var $value_14=(($25)|0);
      var $26=$io210;
      var $value_15=(($26)|0);
      var $27=$value_14;
      var $28=$value_15;
      HEAP32[(($27)>>2)]=HEAP32[(($28)>>2)];HEAP32[((($27)+(4))>>2)]=HEAP32[((($28)+(4))>>2)];
      var $29=$io210;
      var $tt_16=(($29+8)|0);
      var $30=HEAP32[(($tt_16)>>2)];
      var $31=$io111;
      var $tt_17=(($31+8)|0);
      HEAP32[(($tt_17)>>2)]=$30;
      var $32=$L_addr;
      var $top18=(($32+8)|0);
      var $33=HEAP32[(($top18)>>2)];
      var $incdec_ptr=(($33+12)|0);
      HEAP32[(($top18)>>2)]=$incdec_ptr;
      var $34=$L_addr;
      var $stack_last=(($34+24)|0);
      var $35=HEAP32[(($stack_last)>>2)];
      var $36=$L_addr;
      var $top19=(($36+8)|0);
      var $37=HEAP32[(($top19)>>2)];
      var $sub_ptr_lhs_cast=$35;
      var $sub_ptr_rhs_cast=$37;
      var $sub_ptr_sub=((($sub_ptr_lhs_cast)-($sub_ptr_rhs_cast))|0);
      var $sub_ptr_div=((((($sub_ptr_sub)|0))/(12))&-1);
      var $cmp20=(($sub_ptr_div)|0) <= 0;
      if ($cmp20) { label = 6; break; } else { label = 7; break; }
    case 6: 
      var $38=$L_addr;
      _luaD_growstack($38, 0);
      label = 8; break;
    case 7: 
      label = 8; break;
    case 8: 
      var $39=$L_addr;
      var $40=$L_addr;
      var $top23=(($40+8)|0);
      var $41=HEAP32[(($top23)>>2)];
      var $add_ptr24=((($41)-(24))|0);
      _luaD_call($39, $add_ptr24, 1, 0);
      label = 9; break;
    case 9: 
      var $42=$L_addr;
      _luaD_throw($42, 2);

    case 10: 

      Module.print(INDENT + 'Exiting: _luaG_errormsg');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_luaG_errormsg["X"]=1;

function _correctstack($L, $oldstack) {
  var label = 0;

  Module.print(INDENT + ' Entering: _correctstack: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $L_addr;
      var $oldstack_addr;
      var $ci;
      var $up;
      $L_addr=$L;
      $oldstack_addr=$oldstack;
      var $0=$L_addr;
      var $top=(($0+8)|0);
      var $1=HEAP32[(($top)>>2)];
      var $2=$oldstack_addr;
      var $sub_ptr_lhs_cast=$1;
      var $sub_ptr_rhs_cast=$2;
      var $sub_ptr_sub=((($sub_ptr_lhs_cast)-($sub_ptr_rhs_cast))|0);
      var $sub_ptr_div=((((($sub_ptr_sub)|0))/(12))&-1);
      var $3=$L_addr;
      var $stack=(($3+28)|0);
      var $4=HEAP32[(($stack)>>2)];
      var $add_ptr=(($4+((($sub_ptr_div)*(12))&-1))|0);
      var $5=$L_addr;
      var $top1=(($5+8)|0);
      HEAP32[(($top1)>>2)]=$add_ptr;
      var $6=$L_addr;
      var $openupval=(($6+56)|0);
      var $7=HEAP32[(($openupval)>>2)];
      $up=$7;
      label = 3; break;
    case 3: 
      var $8=$up;
      var $cmp=(($8)|0)!=0;
      if ($cmp) { label = 4; break; } else { label = 6; break; }
    case 4: 
      var $9=$up;
      var $uv=$9;
      var $v=(($uv+8)|0);
      var $10=HEAP32[(($v)>>2)];
      var $11=$oldstack_addr;
      var $sub_ptr_lhs_cast2=$10;
      var $sub_ptr_rhs_cast3=$11;
      var $sub_ptr_sub4=((($sub_ptr_lhs_cast2)-($sub_ptr_rhs_cast3))|0);
      var $sub_ptr_div5=((((($sub_ptr_sub4)|0))/(12))&-1);
      var $12=$L_addr;
      var $stack6=(($12+28)|0);
      var $13=HEAP32[(($stack6)>>2)];
      var $add_ptr7=(($13+((($sub_ptr_div5)*(12))&-1))|0);
      var $14=$up;
      var $uv8=$14;
      var $v9=(($uv8+8)|0);
      HEAP32[(($v9)>>2)]=$add_ptr7;
      label = 5; break;
    case 5: 
      var $15=$up;
      var $gch=$15;
      var $next=(($gch)|0);
      var $16=HEAP32[(($next)>>2)];
      $up=$16;
      label = 3; break;
    case 6: 
      var $17=$L_addr;
      var $ci10=(($17+16)|0);
      var $18=HEAP32[(($ci10)>>2)];
      $ci=$18;
      label = 7; break;
    case 7: 
      var $19=$ci;
      var $cmp12=(($19)|0)!=0;
      if ($cmp12) { label = 8; break; } else { label = 12; break; }
    case 8: 
      var $20=$ci;
      var $top14=(($20+4)|0);
      var $21=HEAP32[(($top14)>>2)];
      var $22=$oldstack_addr;
      var $sub_ptr_lhs_cast15=$21;
      var $sub_ptr_rhs_cast16=$22;
      var $sub_ptr_sub17=((($sub_ptr_lhs_cast15)-($sub_ptr_rhs_cast16))|0);
      var $sub_ptr_div18=((((($sub_ptr_sub17)|0))/(12))&-1);
      var $23=$L_addr;
      var $stack19=(($23+28)|0);
      var $24=HEAP32[(($stack19)>>2)];
      var $add_ptr20=(($24+((($sub_ptr_div18)*(12))&-1))|0);
      var $25=$ci;
      var $top21=(($25+4)|0);
      HEAP32[(($top21)>>2)]=$add_ptr20;
      var $26=$ci;
      var $func=(($26)|0);
      var $27=HEAP32[(($func)>>2)];
      var $28=$oldstack_addr;
      var $sub_ptr_lhs_cast22=$27;
      var $sub_ptr_rhs_cast23=$28;
      var $sub_ptr_sub24=((($sub_ptr_lhs_cast22)-($sub_ptr_rhs_cast23))|0);
      var $sub_ptr_div25=((((($sub_ptr_sub24)|0))/(12))&-1);
      var $29=$L_addr;
      var $stack26=(($29+28)|0);
      var $30=HEAP32[(($stack26)>>2)];
      var $add_ptr27=(($30+((($sub_ptr_div25)*(12))&-1))|0);
      var $31=$ci;
      var $func28=(($31)|0);
      HEAP32[(($func28)>>2)]=$add_ptr27;
      var $32=$ci;
      var $callstatus=(($32+18)|0);
      var $33=HEAP8[($callstatus)];
      var $conv=(($33)&255);
      var $and=$conv & 1;
      var $tobool=(($and)|0)!=0;
      if ($tobool) { label = 9; break; } else { label = 10; break; }
    case 9: 
      var $34=$ci;
      var $u=(($34+24)|0);
      var $l=$u;
      var $base=(($l)|0);
      var $35=HEAP32[(($base)>>2)];
      var $36=$oldstack_addr;
      var $sub_ptr_lhs_cast29=$35;
      var $sub_ptr_rhs_cast30=$36;
      var $sub_ptr_sub31=((($sub_ptr_lhs_cast29)-($sub_ptr_rhs_cast30))|0);
      var $sub_ptr_div32=((((($sub_ptr_sub31)|0))/(12))&-1);
      var $37=$L_addr;
      var $stack33=(($37+28)|0);
      var $38=HEAP32[(($stack33)>>2)];
      var $add_ptr34=(($38+((($sub_ptr_div32)*(12))&-1))|0);
      var $39=$ci;
      var $u35=(($39+24)|0);
      var $l36=$u35;
      var $base37=(($l36)|0);
      HEAP32[(($base37)>>2)]=$add_ptr34;
      label = 10; break;
    case 10: 
      label = 11; break;
    case 11: 
      var $40=$ci;
      var $previous=(($40+8)|0);
      var $41=HEAP32[(($previous)>>2)];
      $ci=$41;
      label = 7; break;
    case 12: 

      Module.print(INDENT + 'Exiting: _correctstack');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_correctstack["X"]=1;

function _stackinuse($L) {
  var label = 0;

  Module.print(INDENT + ' Entering: _stackinuse: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $L_addr;
      var $ci;
      var $lim;
      $L_addr=$L;
      var $0=$L_addr;
      var $top=(($0+8)|0);
      var $1=HEAP32[(($top)>>2)];
      $lim=$1;
      var $2=$L_addr;
      var $ci1=(($2+16)|0);
      var $3=HEAP32[(($ci1)>>2)];
      $ci=$3;
      label = 3; break;
    case 3: 
      var $4=$ci;
      var $cmp=(($4)|0)!=0;
      if ($cmp) { label = 4; break; } else { label = 8; break; }
    case 4: 
      var $5=$lim;
      var $6=$ci;
      var $top2=(($6+4)|0);
      var $7=HEAP32[(($top2)>>2)];
      var $cmp3=(($5)>>>0) < (($7)>>>0);
      if ($cmp3) { label = 5; break; } else { label = 6; break; }
    case 5: 
      var $8=$ci;
      var $top4=(($8+4)|0);
      var $9=HEAP32[(($top4)>>2)];
      $lim=$9;
      label = 6; break;
    case 6: 
      label = 7; break;
    case 7: 
      var $10=$ci;
      var $previous=(($10+8)|0);
      var $11=HEAP32[(($previous)>>2)];
      $ci=$11;
      label = 3; break;
    case 8: 
      var $12=$lim;
      var $13=$L_addr;
      var $stack=(($13+28)|0);
      var $14=HEAP32[(($stack)>>2)];
      var $sub_ptr_lhs_cast=$12;
      var $sub_ptr_rhs_cast=$14;
      var $sub_ptr_sub=((($sub_ptr_lhs_cast)-($sub_ptr_rhs_cast))|0);
      var $sub_ptr_div=((((($sub_ptr_sub)|0))/(12))&-1);
      var $add=((($sub_ptr_div)+(1))|0);

      Module.print(INDENT + 'Exiting: _stackinuse');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return $add;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _luaD_rawrunprotected($L, $f, $ud) {
  var label = 0;
  var __stackBase__  = STACKTOP; STACKTOP = (STACKTOP + 48)|0; _memset(__stackBase__, 0, 48);
  Module.print(INDENT + ' Entering: _luaD_rawrunprotected: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  var mySetjmpIds = {};
  var setjmpTable = {"2": function(value) { label = 5; $call = value },dummy: 0};
  while(1) try { switch(label) {
    case 2: 
      var $L_addr;
      var $f_addr;
      var $ud_addr;
      var $oldnCcalls;
      var $lj=__stackBase__;
      $L_addr=$L;
      $f_addr=$f;
      $ud_addr=$ud;
      var $0=$L_addr;
      var $nCcalls=(($0+38)|0);
      var $1=HEAP16[(($nCcalls)>>1)];
      $oldnCcalls=$1;
      var $status=(($lj+44)|0);
      HEAP32[(($status)>>2)]=0;
      var $2=$L_addr;
      var $errorJmp=(($2+64)|0);
      var $3=HEAP32[(($errorJmp)>>2)];
      var $previous=(($lj)|0);
      HEAP32[(($previous)>>2)]=$3;
      var $4=$L_addr;
      var $errorJmp1=(($4+64)|0);
      HEAP32[(($errorJmp1)>>2)]=$lj;
      var $b=(($lj+4)|0);
      var $arraydecay=(($b)|0);
      var $call=(tempInt = setjmpId++, mySetjmpIds[tempInt] = 1, setjmpLabels[tempInt] = label,HEAP32[(($arraydecay)>>2)]=tempInt, 0);
      label = 5; break;
    case 5: 
      var $cmp=(($call)|0)==0;
      if ($cmp) { label = 3; break; } else { label = 4; break; }
    case 3: 
      var $5=$f_addr;
      var $6=$L_addr;
      var $7=$ud_addr;
      FUNCTION_TABLE[$5]($6, $7);
      label = 4; break;
    case 4: 
      var $previous2=(($lj)|0);
      var $8=HEAP32[(($previous2)>>2)];
      var $9=$L_addr;
      var $errorJmp3=(($9+64)|0);
      HEAP32[(($errorJmp3)>>2)]=$8;
      var $10=$oldnCcalls;
      var $11=$L_addr;
      var $nCcalls4=(($11+38)|0);
      HEAP16[(($nCcalls4)>>1)]=$10;
      var $status5=(($lj+44)|0);
      var $12=HEAP32[(($status5)>>2)];
      STACKTOP = __stackBase__;
      Module.print(INDENT + 'Exiting: _luaD_rawrunprotected');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return $12;
  }
 } catch(e) { if (!e.longjmp || !(e.id in mySetjmpIds)) throw(e); setjmpTable[setjmpLabels[e.id]](e.value) }
  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _luaD_shrinkstack($L) {
  var label = 0;

  Module.print(INDENT + ' Entering: _luaD_shrinkstack: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $L_addr;
      var $inuse;
      var $goodsize;
      $L_addr=$L;
      var $0=$L_addr;
      var $call=_stackinuse($0);
      $inuse=$call;
      var $1=$inuse;
      var $2=$inuse;
      var $div=((((($2)|0))/(8))&-1);
      var $add=((($1)+($div))|0);
      var $add1=((($add)+(10))|0);
      $goodsize=$add1;
      var $3=$goodsize;
      var $cmp=(($3)|0) > 1000000;
      if ($cmp) { label = 3; break; } else { label = 4; break; }
    case 3: 
      $goodsize=1000000;
      label = 4; break;
    case 4: 
      var $4=$inuse;
      var $cmp2=(($4)|0) > 1000000;
      if ($cmp2) { label = 6; break; } else { label = 5; break; }
    case 5: 
      var $5=$goodsize;
      var $6=$L_addr;
      var $stacksize=(($6+32)|0);
      var $7=HEAP32[(($stacksize)>>2)];
      var $cmp3=(($5)|0) >= (($7)|0);
      if ($cmp3) { label = 6; break; } else { label = 7; break; }
    case 6: 
      label = 8; break;
    case 7: 
      var $8=$L_addr;
      var $9=$goodsize;
      _luaD_reallocstack($8, $9);
      label = 8; break;
    case 8: 

      Module.print(INDENT + 'Exiting: _luaD_shrinkstack');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _luaD_hook($L, $event, $line) {
  var label = 0;
  var __stackBase__  = STACKTOP; STACKTOP = (STACKTOP + 100)|0; _memset(__stackBase__, 0, 100);
  Module.print(INDENT + ' Entering: _luaD_hook: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $L_addr;
      var $event_addr;
      var $line_addr;
      var $hook;
      var $ci;
      var $top;
      var $ci_top;
      var $ar=__stackBase__;
      $L_addr=$L;
      $event_addr=$event;
      $line_addr=$line;
      var $0=$L_addr;
      var $hook1=(($0+52)|0);
      var $1=HEAP32[(($hook1)>>2)];
      $hook=$1;
      var $2=$hook;
      var $tobool=(($2)|0)!=0;
      if ($tobool) { label = 3; break; } else { label = 8; break; }
    case 3: 
      var $3=$L_addr;
      var $allowhook=(($3+41)|0);
      var $4=HEAP8[($allowhook)];
      var $conv=(($4)&255);
      var $tobool2=(($conv)|0)!=0;
      if ($tobool2) { label = 4; break; } else { label = 8; break; }
    case 4: 
      var $5=$L_addr;
      var $ci3=(($5+16)|0);
      var $6=HEAP32[(($ci3)>>2)];
      $ci=$6;
      var $7=$L_addr;
      var $top4=(($7+8)|0);
      var $8=HEAP32[(($top4)>>2)];
      var $9=$8;
      var $10=$L_addr;
      var $stack=(($10+28)|0);
      var $11=HEAP32[(($stack)>>2)];
      var $12=$11;
      var $sub_ptr_lhs_cast=$9;
      var $sub_ptr_rhs_cast=$12;
      var $sub_ptr_sub=((($sub_ptr_lhs_cast)-($sub_ptr_rhs_cast))|0);
      $top=$sub_ptr_sub;
      var $13=$ci;
      var $top5=(($13+4)|0);
      var $14=HEAP32[(($top5)>>2)];
      var $15=$14;
      var $16=$L_addr;
      var $stack6=(($16+28)|0);
      var $17=HEAP32[(($stack6)>>2)];
      var $18=$17;
      var $sub_ptr_lhs_cast7=$15;
      var $sub_ptr_rhs_cast8=$18;
      var $sub_ptr_sub9=((($sub_ptr_lhs_cast7)-($sub_ptr_rhs_cast8))|0);
      $ci_top=$sub_ptr_sub9;
      var $19=$event_addr;
      var $event10=(($ar)|0);
      HEAP32[(($event10)>>2)]=$19;
      var $20=$line_addr;
      var $currentline=(($ar+20)|0);
      HEAP32[(($currentline)>>2)]=$20;
      var $21=$ci;
      var $i_ci=(($ar+96)|0);
      HEAP32[(($i_ci)>>2)]=$21;
      var $22=$L_addr;
      var $stack_last=(($22+24)|0);
      var $23=HEAP32[(($stack_last)>>2)];
      var $24=$L_addr;
      var $top11=(($24+8)|0);
      var $25=HEAP32[(($top11)>>2)];
      var $sub_ptr_lhs_cast12=$23;
      var $sub_ptr_rhs_cast13=$25;
      var $sub_ptr_sub14=((($sub_ptr_lhs_cast12)-($sub_ptr_rhs_cast13))|0);
      var $sub_ptr_div=((((($sub_ptr_sub14)|0))/(12))&-1);
      var $cmp=(($sub_ptr_div)|0) <= 20;
      if ($cmp) { label = 5; break; } else { label = 6; break; }
    case 5: 
      var $26=$L_addr;
      _luaD_growstack($26, 20);
      label = 7; break;
    case 6: 
      label = 7; break;
    case 7: 
      var $27=$L_addr;
      var $top17=(($27+8)|0);
      var $28=HEAP32[(($top17)>>2)];
      var $add_ptr=(($28+240)|0);
      var $29=$ci;
      var $top18=(($29+4)|0);
      HEAP32[(($top18)>>2)]=$add_ptr;
      var $30=$L_addr;
      var $allowhook19=(($30+41)|0);
      HEAP8[($allowhook19)]=0;
      var $31=$ci;
      var $callstatus=(($31+18)|0);
      var $32=HEAP8[($callstatus)];
      var $conv20=(($32)&255);
      var $or=$conv20 | 2;
      var $conv21=(($or) & 255);
      HEAP8[($callstatus)]=$conv21;
      var $33=$hook;
      var $34=$L_addr;
      FUNCTION_TABLE[$33]($34, $ar);
      var $35=$L_addr;
      var $allowhook22=(($35+41)|0);
      HEAP8[($allowhook22)]=1;
      var $36=$L_addr;
      var $stack23=(($36+28)|0);
      var $37=HEAP32[(($stack23)>>2)];
      var $38=$37;
      var $39=$ci_top;
      var $add_ptr24=(($38+$39)|0);
      var $40=$add_ptr24;
      var $41=$ci;
      var $top25=(($41+4)|0);
      HEAP32[(($top25)>>2)]=$40;
      var $42=$L_addr;
      var $stack26=(($42+28)|0);
      var $43=HEAP32[(($stack26)>>2)];
      var $44=$43;
      var $45=$top;
      var $add_ptr27=(($44+$45)|0);
      var $46=$add_ptr27;
      var $47=$L_addr;
      var $top28=(($47+8)|0);
      HEAP32[(($top28)>>2)]=$46;
      var $48=$ci;
      var $callstatus29=(($48+18)|0);
      var $49=HEAP8[($callstatus29)];
      var $conv30=(($49)&255);
      var $and=$conv30 & -3;
      var $conv31=(($and) & 255);
      HEAP8[($callstatus29)]=$conv31;
      label = 8; break;
    case 8: 
      STACKTOP = __stackBase__;
      Module.print(INDENT + 'Exiting: _luaD_hook');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_luaD_hook["X"]=1;

function _luaD_throw($L, $errcode) {
  var label = 0;

  Module.print(INDENT + ' Entering: _luaD_throw: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $L_addr;
      var $errcode_addr;
      var $io2;
      var $io1;
      $L_addr=$L;
      $errcode_addr=$errcode;
      var $0=$L_addr;
      var $errorJmp=(($0+64)|0);
      var $1=HEAP32[(($errorJmp)>>2)];
      var $tobool=(($1)|0)!=0;
      if ($tobool) { label = 3; break; } else { label = 4; break; }
    case 3: 
      var $2=$errcode_addr;
      var $3=$L_addr;
      var $errorJmp1=(($3+64)|0);
      var $4=HEAP32[(($errorJmp1)>>2)];
      var $status=(($4+44)|0);
      HEAP32[(($status)>>2)]=$2;
      var $5=$L_addr;
      var $errorJmp2=(($5+64)|0);
      var $6=HEAP32[(($errorJmp2)>>2)];
      var $b=(($6+4)|0);
      var $arraydecay=(($b)|0);
      _longjmp($arraydecay, 1);

    case 4: 
      var $7=$errcode_addr;
      var $conv=(($7) & 255);
      var $8=$L_addr;
      var $status3=(($8+6)|0);
      HEAP8[($status3)]=$conv;
      var $9=$L_addr;
      var $l_G=(($9+12)|0);
      var $10=HEAP32[(($l_G)>>2)];
      var $mainthread=(($10+152)|0);
      var $11=HEAP32[(($mainthread)>>2)];
      var $errorJmp4=(($11+64)|0);
      var $12=HEAP32[(($errorJmp4)>>2)];
      var $tobool5=(($12)|0)!=0;
      if ($tobool5) { label = 5; break; } else { label = 6; break; }
    case 5: 
      var $13=$L_addr;
      var $top=(($13+8)|0);
      var $14=HEAP32[(($top)>>2)];
      var $add_ptr=((($14)-(12))|0);
      $io2=$add_ptr;
      var $15=$L_addr;
      var $l_G7=(($15+12)|0);
      var $16=HEAP32[(($l_G7)>>2)];
      var $mainthread8=(($16+152)|0);
      var $17=HEAP32[(($mainthread8)>>2)];
      var $top9=(($17+8)|0);
      var $18=HEAP32[(($top9)>>2)];
      var $incdec_ptr=(($18+12)|0);
      HEAP32[(($top9)>>2)]=$incdec_ptr;
      $io1=$18;
      var $19=$io1;
      var $value_=(($19)|0);
      var $20=$io2;
      var $value_10=(($20)|0);
      var $21=$value_;
      var $22=$value_10;
      HEAP32[(($21)>>2)]=HEAP32[(($22)>>2)];HEAP32[((($21)+(4))>>2)]=HEAP32[((($22)+(4))>>2)];
      var $23=$io2;
      var $tt_=(($23+8)|0);
      var $24=HEAP32[(($tt_)>>2)];
      var $25=$io1;
      var $tt_11=(($25+8)|0);
      HEAP32[(($tt_11)>>2)]=$24;
      var $26=$L_addr;
      var $l_G12=(($26+12)|0);
      var $27=HEAP32[(($l_G12)>>2)];
      var $mainthread13=(($27+152)|0);
      var $28=HEAP32[(($mainthread13)>>2)];
      var $29=$errcode_addr;
      _luaD_throw($28, $29);

    case 6: 
      var $30=$L_addr;
      var $l_G15=(($30+12)|0);
      var $31=HEAP32[(($l_G15)>>2)];
      var $panic=(($31+148)|0);
      var $32=HEAP32[(($panic)>>2)];
      var $tobool16=(($32)|0)!=0;
      if ($tobool16) { label = 7; break; } else { label = 8; break; }
    case 7: 
      var $33=$L_addr;
      var $l_G18=(($33+12)|0);
      var $34=HEAP32[(($l_G18)>>2)];
      var $panic19=(($34+148)|0);
      var $35=HEAP32[(($panic19)>>2)];
      var $36=$L_addr;
      var $call=FUNCTION_TABLE[$35]($36);
      label = 8; break;
    case 8: 
      _abort();

    case 9: 

      Module.print(INDENT + 'Exiting: _luaD_throw');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_luaD_throw["X"]=1;

function _luaD_reallocstack($L, $newsize) {
  var label = 0;

  Module.print(INDENT + ' Entering: _luaD_reallocstack: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $L_addr;
      var $newsize_addr;
      var $oldstack;
      var $lim;
      $L_addr=$L;
      $newsize_addr=$newsize;
      var $0=$L_addr;
      var $stack=(($0+28)|0);
      var $1=HEAP32[(($stack)>>2)];
      $oldstack=$1;
      var $2=$L_addr;
      var $stacksize=(($2+32)|0);
      var $3=HEAP32[(($stacksize)>>2)];
      $lim=$3;
      var $4=$newsize_addr;
      var $add=((($4)+(1))|0);
      var $cmp=(($add)>>>0) > 357913941;
      if ($cmp) { label = 3; break; } else { label = 4; break; }
    case 3: 
      var $5=$L_addr;
      _luaM_toobig($5);

      label = 5; break;
    case 4: 
      var $7=$L_addr;
      var $8=$L_addr;
      var $stack1=(($8+28)|0);
      var $9=HEAP32[(($stack1)>>2)];
      var $10=$9;
      var $11=$L_addr;
      var $stacksize2=(($11+32)|0);
      var $12=HEAP32[(($stacksize2)>>2)];
      var $mul=((($12)*(12))&-1);
      var $13=$newsize_addr;
      var $mul3=((($13)*(12))&-1);
      var $call=_luaM_realloc_($7, $10, $mul, $mul3);
      var $cond = $call;label = 5; break;
    case 5: 
      var $cond;
      var $14=$cond;
      var $15=$L_addr;
      var $stack4=(($15+28)|0);
      HEAP32[(($stack4)>>2)]=$14;
      label = 6; break;
    case 6: 
      var $16=$lim;
      var $17=$newsize_addr;
      var $cmp5=(($16)|0) < (($17)|0);
      if ($cmp5) { label = 7; break; } else { label = 9; break; }
    case 7: 
      var $18=$L_addr;
      var $stack6=(($18+28)|0);
      var $19=HEAP32[(($stack6)>>2)];
      var $20=$lim;
      var $add_ptr=(($19+((($20)*(12))&-1))|0);
      var $tt_=(($add_ptr+8)|0);
      HEAP32[(($tt_)>>2)]=0;
      label = 8; break;
    case 8: 
      var $21=$lim;
      var $inc=((($21)+(1))|0);
      $lim=$inc;
      label = 6; break;
    case 9: 
      var $22=$newsize_addr;
      var $23=$L_addr;
      var $stacksize7=(($23+32)|0);
      HEAP32[(($stacksize7)>>2)]=$22;
      var $24=$L_addr;
      var $stack8=(($24+28)|0);
      var $25=HEAP32[(($stack8)>>2)];
      var $26=$newsize_addr;
      var $add_ptr9=(($25+((($26)*(12))&-1))|0);
      var $add_ptr10=((($add_ptr9)-(60))|0);
      var $27=$L_addr;
      var $stack_last=(($27+24)|0);
      HEAP32[(($stack_last)>>2)]=$add_ptr10;
      var $28=$L_addr;
      var $29=$oldstack;
      _correctstack($28, $29);

      Module.print(INDENT + 'Exiting: _luaD_reallocstack');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_luaD_reallocstack["X"]=1;

function _luaD_growstack($L, $n) {
  var label = 0;
  var __stackBase__  = STACKTOP; _memset(__stackBase__, 0, 0);
  Module.print(INDENT + ' Entering: _luaD_growstack: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $L_addr;
      var $n_addr;
      var $size;
      var $needed;
      var $newsize;
      $L_addr=$L;
      $n_addr=$n;
      var $0=$L_addr;
      var $stacksize=(($0+32)|0);
      var $1=HEAP32[(($stacksize)>>2)];
      $size=$1;
      var $2=$size;
      var $cmp=(($2)|0) > 1000000;
      if ($cmp) { label = 3; break; } else { label = 4; break; }
    case 3: 
      var $3=$L_addr;
      _luaD_throw($3, 6);

    case 4: 
      var $4=$L_addr;
      var $top=(($4+8)|0);
      var $5=HEAP32[(($top)>>2)];
      var $6=$L_addr;
      var $stack=(($6+28)|0);
      var $7=HEAP32[(($stack)>>2)];
      var $sub_ptr_lhs_cast=$5;
      var $sub_ptr_rhs_cast=$7;
      var $sub_ptr_sub=((($sub_ptr_lhs_cast)-($sub_ptr_rhs_cast))|0);
      var $sub_ptr_div=((((($sub_ptr_sub)|0))/(12))&-1);
      var $8=$n_addr;
      var $add=((($sub_ptr_div)+($8))|0);
      var $add1=((($add)+(5))|0);
      $needed=$add1;
      var $9=$size;
      var $mul=($9<<1);
      $newsize=$mul;
      var $10=$newsize;
      var $cmp2=(($10)|0) > 1000000;
      if ($cmp2) { label = 5; break; } else { label = 6; break; }
    case 5: 
      $newsize=1000000;
      label = 6; break;
    case 6: 
      var $11=$newsize;
      var $12=$needed;
      var $cmp4=(($11)|0) < (($12)|0);
      if ($cmp4) { label = 7; break; } else { label = 8; break; }
    case 7: 
      var $13=$needed;
      $newsize=$13;
      label = 8; break;
    case 8: 
      var $14=$newsize;
      var $cmp7=(($14)|0) > 1000000;
      if ($cmp7) { label = 9; break; } else { label = 10; break; }
    case 9: 
      var $15=$L_addr;
      _luaD_reallocstack($15, 1000200);
      var $16=$L_addr;
      _luaG_runerror($16, ((5245624)|0), (tempInt=STACKTOP,_memset(STACKTOP, 0, 1),STACKTOP = (STACKTOP + 1)|0,STACKTOP = ((((STACKTOP)+3)>>2)<<2),HEAP32[((tempInt)>>2)]=0,tempInt));

    case 10: 
      var $17=$L_addr;
      var $18=$newsize;
      _luaD_reallocstack($17, $18);
      label = 11; break;
    case 11: 
      label = 12; break;
    case 12: 
      STACKTOP = __stackBase__;
      Module.print(INDENT + 'Exiting: _luaD_growstack');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_luaD_growstack["X"]=1;

function _luaD_precall($L, $func, $nresults) {
  var label = 0;

  Module.print(INDENT + ' Entering: _luaD_precall: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $retval;
      var $L_addr;
      var $func_addr;
      var $nresults_addr;
      var $f;
      var $ci;
      var $n;
      var $funcr;
      var $base;
      var $p;
      $L_addr=$L;
      $func_addr=$func;
      $nresults_addr=$nresults;
      var $0=$func_addr;
      var $1=$0;
      var $2=$L_addr;
      var $stack=(($2+28)|0);
      var $3=HEAP32[(($stack)>>2)];
      var $4=$3;
      var $sub_ptr_lhs_cast=$1;
      var $sub_ptr_rhs_cast=$4;
      var $sub_ptr_sub=((($sub_ptr_lhs_cast)-($sub_ptr_rhs_cast))|0);
      $funcr=$sub_ptr_sub;
      var $5=$func_addr;
      var $tt_=(($5+8)|0);
      var $6=HEAP32[(($tt_)>>2)];
      var $and=$6 & 63;
      if ((($and)|0)==22) {
        label = 3; break;
      }
      else if ((($and)|0)==38) {
        label = 4; break;
      }
      else if ((($and)|0)==6) {
        label = 14; break;
      }
      else {
      label = 30; break;
      }
      
    case 3: 
      var $7=$func_addr;
      var $value_=(($7)|0);
      var $f1=$value_;
      var $8=HEAP32[(($f1)>>2)];
      $f=$8;
      label = 5; break;
    case 4: 
      var $9=$func_addr;
      var $value_3=(($9)|0);
      var $gc=$value_3;
      var $10=HEAP32[(($gc)>>2)];
      var $cl=$10;
      var $c=$cl;
      var $f4=(($c+12)|0);
      var $11=HEAP32[(($f4)>>2)];
      $f=$11;
      label = 5; break;
    case 5: 
      var $12=$L_addr;
      var $stack_last=(($12+24)|0);
      var $13=HEAP32[(($stack_last)>>2)];
      var $14=$L_addr;
      var $top=(($14+8)|0);
      var $15=HEAP32[(($top)>>2)];
      var $sub_ptr_lhs_cast5=$13;
      var $sub_ptr_rhs_cast6=$15;
      var $sub_ptr_sub7=((($sub_ptr_lhs_cast5)-($sub_ptr_rhs_cast6))|0);
      var $sub_ptr_div=((((($sub_ptr_sub7)|0))/(12))&-1);
      var $cmp=(($sub_ptr_div)|0) <= 20;
      if ($cmp) { label = 6; break; } else { label = 7; break; }
    case 6: 
      var $16=$L_addr;
      _luaD_growstack($16, 20);
      label = 8; break;
    case 7: 
      label = 8; break;
    case 8: 
      var $17=$L_addr;
      var $ci8=(($17+16)|0);
      var $18=HEAP32[(($ci8)>>2)];
      var $next=(($18+12)|0);
      var $19=HEAP32[(($next)>>2)];
      var $tobool=(($19)|0)!=0;
      if ($tobool) { label = 9; break; } else { label = 10; break; }
    case 9: 
      var $20=$L_addr;
      var $ci9=(($20+16)|0);
      var $21=HEAP32[(($ci9)>>2)];
      var $next10=(($21+12)|0);
      var $22=HEAP32[(($next10)>>2)];
      var $cond = $22;label = 11; break;
    case 10: 
      var $23=$L_addr;
      var $call=_luaE_extendCI($23);
      var $cond = $call;label = 11; break;
    case 11: 
      var $cond;
      var $24=$L_addr;
      var $ci11=(($24+16)|0);
      HEAP32[(($ci11)>>2)]=$cond;
      $ci=$cond;
      var $25=$nresults_addr;
      var $conv=(($25) & 65535);
      var $26=$ci;
      var $nresults12=(($26+16)|0);
      HEAP16[(($nresults12)>>1)]=$conv;
      var $27=$L_addr;
      var $stack13=(($27+28)|0);
      var $28=HEAP32[(($stack13)>>2)];
      var $29=$28;
      var $30=$funcr;
      var $add_ptr=(($29+$30)|0);
      var $31=$add_ptr;
      var $32=$ci;
      var $func14=(($32)|0);
      HEAP32[(($func14)>>2)]=$31;
      var $33=$L_addr;
      var $top15=(($33+8)|0);
      var $34=HEAP32[(($top15)>>2)];
      var $add_ptr16=(($34+240)|0);
      var $35=$ci;
      var $top17=(($35+4)|0);
      HEAP32[(($top17)>>2)]=$add_ptr16;
      var $36=$ci;
      var $callstatus=(($36+18)|0);
      HEAP8[($callstatus)]=0;
      var $37=$L_addr;
      var $hookmask=(($37+40)|0);
      var $38=HEAP8[($hookmask)];
      var $conv18=(($38)&255);
      var $and19=$conv18 & 1;
      var $tobool20=(($and19)|0)!=0;
      if ($tobool20) { label = 12; break; } else { label = 13; break; }
    case 12: 
      var $39=$L_addr;
      _luaD_hook($39, 0, -1);
      label = 13; break;
    case 13: 
      var $40=$f;
      var $41=$L_addr;
      var $call23=FUNCTION_TABLE[$40]($41);
      $n=$call23;
      var $42=$L_addr;
      var $43=$L_addr;
      var $top24=(($43+8)|0);
      var $44=HEAP32[(($top24)>>2)];
      var $45=$n;
      var $idx_neg=(((-$45))|0);
      var $add_ptr25=(($44+((($idx_neg)*(12))&-1))|0);
      var $call26=_luaD_poscall($42, $add_ptr25);
      $retval=1;
      label = 31; break;
    case 14: 
      var $46=$func_addr;
      var $value_28=(($46)|0);
      var $gc29=$value_28;
      var $47=HEAP32[(($gc29)>>2)];
      var $cl30=$47;
      var $l=$cl30;
      var $p31=(($l+12)|0);
      var $48=HEAP32[(($p31)>>2)];
      $p=$48;
      var $49=$L_addr;
      var $stack_last32=(($49+24)|0);
      var $50=HEAP32[(($stack_last32)>>2)];
      var $51=$L_addr;
      var $top33=(($51+8)|0);
      var $52=HEAP32[(($top33)>>2)];
      var $sub_ptr_lhs_cast34=$50;
      var $sub_ptr_rhs_cast35=$52;
      var $sub_ptr_sub36=((($sub_ptr_lhs_cast34)-($sub_ptr_rhs_cast35))|0);
      var $sub_ptr_div37=((((($sub_ptr_sub36)|0))/(12))&-1);
      var $53=$p;
      var $maxstacksize=(($53+78)|0);
      var $54=HEAP8[($maxstacksize)];
      var $conv38=(($54)&255);
      var $cmp39=(($sub_ptr_div37)|0) <= (($conv38)|0);
      if ($cmp39) { label = 15; break; } else { label = 16; break; }
    case 15: 
      var $55=$L_addr;
      var $56=$p;
      var $maxstacksize42=(($56+78)|0);
      var $57=HEAP8[($maxstacksize42)];
      var $conv43=(($57)&255);
      _luaD_growstack($55, $conv43);
      label = 17; break;
    case 16: 
      label = 17; break;
    case 17: 
      var $58=$L_addr;
      var $stack46=(($58+28)|0);
      var $59=HEAP32[(($stack46)>>2)];
      var $60=$59;
      var $61=$funcr;
      var $add_ptr47=(($60+$61)|0);
      var $62=$add_ptr47;
      $func_addr=$62;
      var $63=$L_addr;
      var $top48=(($63+8)|0);
      var $64=HEAP32[(($top48)>>2)];
      var $65=$func_addr;
      var $sub_ptr_lhs_cast49=$64;
      var $sub_ptr_rhs_cast50=$65;
      var $sub_ptr_sub51=((($sub_ptr_lhs_cast49)-($sub_ptr_rhs_cast50))|0);
      var $sub_ptr_div52=((((($sub_ptr_sub51)|0))/(12))&-1);
      var $sub=((($sub_ptr_div52)-(1))|0);
      $n=$sub;
      label = 18; break;
    case 18: 
      var $66=$n;
      var $67=$p;
      var $numparams=(($67+76)|0);
      var $68=HEAP8[($numparams)];
      var $conv53=(($68)&255);
      var $cmp54=(($66)|0) < (($conv53)|0);
      if ($cmp54) { label = 19; break; } else { label = 21; break; }
    case 19: 
      var $69=$L_addr;
      var $top56=(($69+8)|0);
      var $70=HEAP32[(($top56)>>2)];
      var $incdec_ptr=(($70+12)|0);
      HEAP32[(($top56)>>2)]=$incdec_ptr;
      var $tt_57=(($70+8)|0);
      HEAP32[(($tt_57)>>2)]=0;
      label = 20; break;
    case 20: 
      var $71=$n;
      var $inc=((($71)+(1))|0);
      $n=$inc;
      label = 18; break;
    case 21: 
      var $72=$p;
      var $is_vararg=(($72+77)|0);
      var $73=HEAP8[($is_vararg)];
      var $tobool58=(($73 << 24) >> 24)!=0;
      if ($tobool58) { label = 23; break; } else { label = 22; break; }
    case 22: 
      var $74=$func_addr;
      var $add_ptr60=(($74+12)|0);
      var $cond64 = $add_ptr60;label = 24; break;
    case 23: 
      var $75=$L_addr;
      var $76=$p;
      var $77=$n;
      var $call62=_adjust_varargs($75, $76, $77);
      var $cond64 = $call62;label = 24; break;
    case 24: 
      var $cond64;
      $base=$cond64;
      var $78=$L_addr;
      var $ci65=(($78+16)|0);
      var $79=HEAP32[(($ci65)>>2)];
      var $next66=(($79+12)|0);
      var $80=HEAP32[(($next66)>>2)];
      var $tobool67=(($80)|0)!=0;
      if ($tobool67) { label = 25; break; } else { label = 26; break; }
    case 25: 
      var $81=$L_addr;
      var $ci69=(($81+16)|0);
      var $82=HEAP32[(($ci69)>>2)];
      var $next70=(($82+12)|0);
      var $83=HEAP32[(($next70)>>2)];
      var $cond74 = $83;label = 27; break;
    case 26: 
      var $84=$L_addr;
      var $call72=_luaE_extendCI($84);
      var $cond74 = $call72;label = 27; break;
    case 27: 
      var $cond74;
      var $85=$L_addr;
      var $ci75=(($85+16)|0);
      HEAP32[(($ci75)>>2)]=$cond74;
      $ci=$cond74;
      var $86=$nresults_addr;
      var $conv76=(($86) & 65535);
      var $87=$ci;
      var $nresults77=(($87+16)|0);
      HEAP16[(($nresults77)>>1)]=$conv76;
      var $88=$func_addr;
      var $89=$ci;
      var $func78=(($89)|0);
      HEAP32[(($func78)>>2)]=$88;
      var $90=$base;
      var $91=$ci;
      var $u=(($91+24)|0);
      var $l79=$u;
      var $base80=(($l79)|0);
      HEAP32[(($base80)>>2)]=$90;
      var $92=$base;
      var $93=$p;
      var $maxstacksize81=(($93+78)|0);
      var $94=HEAP8[($maxstacksize81)];
      var $conv82=(($94)&255);
      var $add_ptr83=(($92+((($conv82)*(12))&-1))|0);
      var $95=$ci;
      var $top84=(($95+4)|0);
      HEAP32[(($top84)>>2)]=$add_ptr83;
      var $96=$p;
      var $code=(($96+12)|0);
      var $97=HEAP32[(($code)>>2)];
      var $98=$ci;
      var $u85=(($98+24)|0);
      var $l86=$u85;
      var $savedpc=(($l86+4)|0);
      HEAP32[(($savedpc)>>2)]=$97;
      var $99=$ci;
      var $callstatus87=(($99+18)|0);
      HEAP8[($callstatus87)]=1;
      var $100=$ci;
      var $top88=(($100+4)|0);
      var $101=HEAP32[(($top88)>>2)];
      var $102=$L_addr;
      var $top89=(($102+8)|0);
      HEAP32[(($top89)>>2)]=$101;
      var $103=$L_addr;
      var $hookmask90=(($103+40)|0);
      var $104=HEAP8[($hookmask90)];
      var $conv91=(($104)&255);
      var $and92=$conv91 & 1;
      var $tobool93=(($and92)|0)!=0;
      if ($tobool93) { label = 28; break; } else { label = 29; break; }
    case 28: 
      var $105=$L_addr;
      var $106=$ci;
      _callhook($105, $106);
      label = 29; break;
    case 29: 
      $retval=0;
      label = 31; break;
    case 30: 
      var $107=$L_addr;
      var $108=$func_addr;
      var $call96=_tryfuncTM($107, $108);
      $func_addr=$call96;
      var $109=$L_addr;
      var $110=$func_addr;
      var $111=$nresults_addr;
      var $call97=_luaD_precall($109, $110, $111);
      $retval=$call97;
      label = 31; break;
    case 31: 
      var $112=$retval;

      Module.print(INDENT + 'Exiting: _luaD_precall');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return $112;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_luaD_precall["X"]=1;

function _luaD_poscall($L, $firstResult) {
  var label = 0;

  Module.print(INDENT + ' Entering: _luaD_poscall: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $L_addr;
      var $firstResult_addr;
      var $res;
      var $wanted;
      var $i;
      var $ci;
      var $fr;
      var $io2;
      var $io1;
      $L_addr=$L;
      $firstResult_addr=$firstResult;
      var $0=$L_addr;
      var $ci1=(($0+16)|0);
      var $1=HEAP32[(($ci1)>>2)];
      $ci=$1;
      var $2=$L_addr;
      var $hookmask=(($2+40)|0);
      var $3=HEAP8[($hookmask)];
      var $conv=(($3)&255);
      var $and=$conv & 6;
      var $tobool=(($and)|0)!=0;
      if ($tobool) { label = 3; break; } else { label = 6; break; }
    case 3: 
      var $4=$L_addr;
      var $hookmask2=(($4+40)|0);
      var $5=HEAP8[($hookmask2)];
      var $conv3=(($5)&255);
      var $and4=$conv3 & 2;
      var $tobool5=(($and4)|0)!=0;
      if ($tobool5) { label = 4; break; } else { label = 5; break; }
    case 4: 
      var $6=$firstResult_addr;
      var $7=$6;
      var $8=$L_addr;
      var $stack=(($8+28)|0);
      var $9=HEAP32[(($stack)>>2)];
      var $10=$9;
      var $sub_ptr_lhs_cast=$7;
      var $sub_ptr_rhs_cast=$10;
      var $sub_ptr_sub=((($sub_ptr_lhs_cast)-($sub_ptr_rhs_cast))|0);
      $fr=$sub_ptr_sub;
      var $11=$L_addr;
      _luaD_hook($11, 1, -1);
      var $12=$L_addr;
      var $stack7=(($12+28)|0);
      var $13=HEAP32[(($stack7)>>2)];
      var $14=$13;
      var $15=$fr;
      var $add_ptr=(($14+$15)|0);
      var $16=$add_ptr;
      $firstResult_addr=$16;
      label = 5; break;
    case 5: 
      var $17=$ci;
      var $previous=(($17+8)|0);
      var $18=HEAP32[(($previous)>>2)];
      var $u=(($18+24)|0);
      var $l=$u;
      var $savedpc=(($l+4)|0);
      var $19=HEAP32[(($savedpc)>>2)];
      var $20=$L_addr;
      var $oldpc=(($20+20)|0);
      HEAP32[(($oldpc)>>2)]=$19;
      label = 6; break;
    case 6: 
      var $21=$ci;
      var $func=(($21)|0);
      var $22=HEAP32[(($func)>>2)];
      $res=$22;
      var $23=$ci;
      var $nresults=(($23+16)|0);
      var $24=HEAP16[(($nresults)>>1)];
      var $conv9=(($24 << 16) >> 16);
      $wanted=$conv9;
      var $25=$ci;
      var $previous10=(($25+8)|0);
      var $26=HEAP32[(($previous10)>>2)];
      $ci=$26;
      var $27=$L_addr;
      var $ci11=(($27+16)|0);
      HEAP32[(($ci11)>>2)]=$26;
      var $28=$wanted;
      $i=$28;
      label = 7; break;
    case 7: 
      var $29=$i;
      var $cmp=(($29)|0)!=0;
      if ($cmp) { label = 8; break; } else { var $33 = 0;label = 9; break; }
    case 8: 
      var $30=$firstResult_addr;
      var $31=$L_addr;
      var $top=(($31+8)|0);
      var $32=HEAP32[(($top)>>2)];
      var $cmp13=(($30)>>>0) < (($32)>>>0);
      var $33 = $cmp13;label = 9; break;
    case 9: 
      var $33;
      if ($33) { label = 10; break; } else { label = 12; break; }
    case 10: 
      var $34=$firstResult_addr;
      var $incdec_ptr=(($34+12)|0);
      $firstResult_addr=$incdec_ptr;
      $io2=$34;
      var $35=$res;
      var $incdec_ptr15=(($35+12)|0);
      $res=$incdec_ptr15;
      $io1=$35;
      var $36=$io1;
      var $value_=(($36)|0);
      var $37=$io2;
      var $value_16=(($37)|0);
      var $38=$value_;
      var $39=$value_16;
      HEAP32[(($38)>>2)]=HEAP32[(($39)>>2)];HEAP32[((($38)+(4))>>2)]=HEAP32[((($39)+(4))>>2)];
      var $40=$io2;
      var $tt_=(($40+8)|0);
      var $41=HEAP32[(($tt_)>>2)];
      var $42=$io1;
      var $tt_17=(($42+8)|0);
      HEAP32[(($tt_17)>>2)]=$41;
      label = 11; break;
    case 11: 
      var $43=$i;
      var $dec=((($43)-(1))|0);
      $i=$dec;
      label = 7; break;
    case 12: 
      label = 13; break;
    case 13: 
      var $44=$i;
      var $dec18=((($44)-(1))|0);
      $i=$dec18;
      var $cmp19=(($44)|0) > 0;
      if ($cmp19) { label = 14; break; } else { label = 15; break; }
    case 14: 
      var $45=$res;
      var $incdec_ptr21=(($45+12)|0);
      $res=$incdec_ptr21;
      var $tt_22=(($45+8)|0);
      HEAP32[(($tt_22)>>2)]=0;
      label = 13; break;
    case 15: 
      var $46=$res;
      var $47=$L_addr;
      var $top23=(($47+8)|0);
      HEAP32[(($top23)>>2)]=$46;
      var $48=$wanted;
      var $sub=((($48)+(1))|0);

      Module.print(INDENT + 'Exiting: _luaD_poscall');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return $sub;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_luaD_poscall["X"]=1;

function _adjust_varargs($L, $p, $actual) {
  var label = 0;

  Module.print(INDENT + ' Entering: _adjust_varargs: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $L_addr;
      var $p_addr;
      var $actual_addr;
      var $i;
      var $nfixargs;
      var $base;
      var $fixed;
      var $io2;
      var $io1;
      $L_addr=$L;
      $p_addr=$p;
      $actual_addr=$actual;
      var $0=$p_addr;
      var $numparams=(($0+76)|0);
      var $1=HEAP8[($numparams)];
      var $conv=(($1)&255);
      $nfixargs=$conv;
      var $2=$L_addr;
      var $top=(($2+8)|0);
      var $3=HEAP32[(($top)>>2)];
      var $4=$actual_addr;
      var $idx_neg=(((-$4))|0);
      var $add_ptr=(($3+((($idx_neg)*(12))&-1))|0);
      $fixed=$add_ptr;
      var $5=$L_addr;
      var $top1=(($5+8)|0);
      var $6=HEAP32[(($top1)>>2)];
      $base=$6;
      $i=0;
      label = 3; break;
    case 3: 
      var $7=$i;
      var $8=$nfixargs;
      var $cmp=(($7)|0) < (($8)|0);
      if ($cmp) { label = 4; break; } else { label = 6; break; }
    case 4: 
      var $9=$fixed;
      var $10=$i;
      var $add_ptr3=(($9+((($10)*(12))&-1))|0);
      $io2=$add_ptr3;
      var $11=$L_addr;
      var $top4=(($11+8)|0);
      var $12=HEAP32[(($top4)>>2)];
      var $incdec_ptr=(($12+12)|0);
      HEAP32[(($top4)>>2)]=$incdec_ptr;
      $io1=$12;
      var $13=$io1;
      var $value_=(($13)|0);
      var $14=$io2;
      var $value_5=(($14)|0);
      var $15=$value_;
      var $16=$value_5;
      HEAP32[(($15)>>2)]=HEAP32[(($16)>>2)];HEAP32[((($15)+(4))>>2)]=HEAP32[((($16)+(4))>>2)];
      var $17=$io2;
      var $tt_=(($17+8)|0);
      var $18=HEAP32[(($tt_)>>2)];
      var $19=$io1;
      var $tt_6=(($19+8)|0);
      HEAP32[(($tt_6)>>2)]=$18;
      var $20=$fixed;
      var $21=$i;
      var $add_ptr7=(($20+((($21)*(12))&-1))|0);
      var $tt_8=(($add_ptr7+8)|0);
      HEAP32[(($tt_8)>>2)]=0;
      label = 5; break;
    case 5: 
      var $22=$i;
      var $inc=((($22)+(1))|0);
      $i=$inc;
      label = 3; break;
    case 6: 
      var $23=$base;

      Module.print(INDENT + 'Exiting: _adjust_varargs');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return $23;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_adjust_varargs["X"]=1;

function _callhook($L, $ci) {
  var label = 0;

  Module.print(INDENT + ' Entering: _callhook: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $L_addr;
      var $ci_addr;
      var $hook;
      $L_addr=$L;
      $ci_addr=$ci;
      $hook=0;
      var $0=$ci_addr;
      var $u=(($0+24)|0);
      var $l=$u;
      var $savedpc=(($l+4)|0);
      var $1=HEAP32[(($savedpc)>>2)];
      var $incdec_ptr=(($1+4)|0);
      HEAP32[(($savedpc)>>2)]=$incdec_ptr;
      var $2=$ci_addr;
      var $previous=(($2+8)|0);
      var $3=HEAP32[(($previous)>>2)];
      var $callstatus=(($3+18)|0);
      var $4=HEAP8[($callstatus)];
      var $conv=(($4)&255);
      var $and=$conv & 1;
      var $tobool=(($and)|0)!=0;
      if ($tobool) { label = 3; break; } else { label = 5; break; }
    case 3: 
      var $5=$ci_addr;
      var $previous1=(($5+8)|0);
      var $6=HEAP32[(($previous1)>>2)];
      var $u2=(($6+24)|0);
      var $l3=$u2;
      var $savedpc4=(($l3+4)|0);
      var $7=HEAP32[(($savedpc4)>>2)];
      var $add_ptr=((($7)-(4))|0);
      var $8=HEAP32[(($add_ptr)>>2)];
      var $shr=$8 >>> 0;
      var $and5=$shr & 63;
      var $cmp=(($and5)|0)==30;
      if ($cmp) { label = 4; break; } else { label = 5; break; }
    case 4: 
      var $9=$ci_addr;
      var $callstatus7=(($9+18)|0);
      var $10=HEAP8[($callstatus7)];
      var $conv8=(($10)&255);
      var $or=$conv8 | 64;
      var $conv9=(($or) & 255);
      HEAP8[($callstatus7)]=$conv9;
      $hook=4;
      label = 5; break;
    case 5: 
      var $11=$L_addr;
      var $12=$hook;
      _luaD_hook($11, $12, -1);
      var $13=$ci_addr;
      var $u10=(($13+24)|0);
      var $l11=$u10;
      var $savedpc12=(($l11+4)|0);
      var $14=HEAP32[(($savedpc12)>>2)];
      var $incdec_ptr13=((($14)-(4))|0);
      HEAP32[(($savedpc12)>>2)]=$incdec_ptr13;

      Module.print(INDENT + 'Exiting: _callhook');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_callhook["X"]=1;

function _tryfuncTM($L, $func) {
  var label = 0;

  Module.print(INDENT + ' Entering: _tryfuncTM: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $L_addr;
      var $func_addr;
      var $tm;
      var $p;
      var $funcr;
      var $io2;
      var $io1;
      var $io216;
      var $io117;
      $L_addr=$L;
      $func_addr=$func;
      var $0=$L_addr;
      var $1=$func_addr;
      var $call=_luaT_gettmbyobj($0, $1, 16);
      $tm=$call;
      var $2=$func_addr;
      var $3=$2;
      var $4=$L_addr;
      var $stack=(($4+28)|0);
      var $5=HEAP32[(($stack)>>2)];
      var $6=$5;
      var $sub_ptr_lhs_cast=$3;
      var $sub_ptr_rhs_cast=$6;
      var $sub_ptr_sub=((($sub_ptr_lhs_cast)-($sub_ptr_rhs_cast))|0);
      $funcr=$sub_ptr_sub;
      var $7=$tm;
      var $tt_=(($7+8)|0);
      var $8=HEAP32[(($tt_)>>2)];
      var $and=$8 & 15;
      var $cmp=(($and)|0)==6;
      if ($cmp) { label = 4; break; } else { label = 3; break; }
    case 3: 
      var $9=$L_addr;
      var $10=$func_addr;
      _luaG_typeerror($9, $10, ((5246964)|0));

    case 4: 
      var $11=$L_addr;
      var $top=(($11+8)|0);
      var $12=HEAP32[(($top)>>2)];
      $p=$12;
      label = 5; break;
    case 5: 
      var $13=$p;
      var $14=$func_addr;
      var $cmp1=(($13)>>>0) > (($14)>>>0);
      if ($cmp1) { label = 6; break; } else { label = 8; break; }
    case 6: 
      var $15=$p;
      var $add_ptr=((($15)-(12))|0);
      $io2=$add_ptr;
      var $16=$p;
      $io1=$16;
      var $17=$io1;
      var $value_=(($17)|0);
      var $18=$io2;
      var $value_2=(($18)|0);
      var $19=$value_;
      var $20=$value_2;
      HEAP32[(($19)>>2)]=HEAP32[(($20)>>2)];HEAP32[((($19)+(4))>>2)]=HEAP32[((($20)+(4))>>2)];
      var $21=$io2;
      var $tt_3=(($21+8)|0);
      var $22=HEAP32[(($tt_3)>>2)];
      var $23=$io1;
      var $tt_4=(($23+8)|0);
      HEAP32[(($tt_4)>>2)]=$22;
      label = 7; break;
    case 7: 
      var $24=$p;
      var $incdec_ptr=((($24)-(12))|0);
      $p=$incdec_ptr;
      label = 5; break;
    case 8: 
      var $25=$L_addr;
      var $top5=(($25+8)|0);
      var $26=HEAP32[(($top5)>>2)];
      var $incdec_ptr6=(($26+12)|0);
      HEAP32[(($top5)>>2)]=$incdec_ptr6;
      var $27=$L_addr;
      var $stack_last=(($27+24)|0);
      var $28=HEAP32[(($stack_last)>>2)];
      var $29=$L_addr;
      var $top7=(($29+8)|0);
      var $30=HEAP32[(($top7)>>2)];
      var $sub_ptr_lhs_cast8=$28;
      var $sub_ptr_rhs_cast9=$30;
      var $sub_ptr_sub10=((($sub_ptr_lhs_cast8)-($sub_ptr_rhs_cast9))|0);
      var $sub_ptr_div=((((($sub_ptr_sub10)|0))/(12))&-1);
      var $cmp11=(($sub_ptr_div)|0) <= 0;
      if ($cmp11) { label = 9; break; } else { label = 10; break; }
    case 9: 
      var $31=$L_addr;
      _luaD_growstack($31, 0);
      label = 11; break;
    case 10: 
      label = 11; break;
    case 11: 
      var $32=$L_addr;
      var $stack14=(($32+28)|0);
      var $33=HEAP32[(($stack14)>>2)];
      var $34=$33;
      var $35=$funcr;
      var $add_ptr15=(($34+$35)|0);
      var $36=$add_ptr15;
      $func_addr=$36;
      var $37=$tm;
      $io216=$37;
      var $38=$func_addr;
      $io117=$38;
      var $39=$io117;
      var $value_18=(($39)|0);
      var $40=$io216;
      var $value_19=(($40)|0);
      var $41=$value_18;
      var $42=$value_19;
      HEAP32[(($41)>>2)]=HEAP32[(($42)>>2)];HEAP32[((($41)+(4))>>2)]=HEAP32[((($42)+(4))>>2)];
      var $43=$io216;
      var $tt_20=(($43+8)|0);
      var $44=HEAP32[(($tt_20)>>2)];
      var $45=$io117;
      var $tt_21=(($45+8)|0);
      HEAP32[(($tt_21)>>2)]=$44;
      var $46=$func_addr;

      Module.print(INDENT + 'Exiting: _tryfuncTM');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return $46;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_tryfuncTM["X"]=1;

function _luaD_call($L, $func, $nResults, $allowyield) {
  var label = 0;
  var __stackBase__  = STACKTOP; _memset(__stackBase__, 0, 0);
  Module.print(INDENT + ' Entering: _luaD_call: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $L_addr;
      var $func_addr;
      var $nResults_addr;
      var $allowyield_addr;
      $L_addr=$L;
      $func_addr=$func;
      $nResults_addr=$nResults;
      $allowyield_addr=$allowyield;
      var $0=$L_addr;
      var $nCcalls=(($0+38)|0);
      var $1=HEAP16[(($nCcalls)>>1)];
      var $inc=((($1)+(1))&65535);
      HEAP16[(($nCcalls)>>1)]=$inc;
      var $conv=(($inc)&65535);
      var $cmp=(($conv)|0) >= 200;
      if ($cmp) { label = 3; break; } else { label = 9; break; }
    case 3: 
      var $2=$L_addr;
      var $nCcalls2=(($2+38)|0);
      var $3=HEAP16[(($nCcalls2)>>1)];
      var $conv3=(($3)&65535);
      var $cmp4=(($conv3)|0)==200;
      if ($cmp4) { label = 4; break; } else { label = 5; break; }
    case 4: 
      var $4=$L_addr;
      _luaG_runerror($4, ((5246796)|0), (tempInt=STACKTOP,_memset(STACKTOP, 0, 1),STACKTOP = (STACKTOP + 1)|0,STACKTOP = ((((STACKTOP)+3)>>2)<<2),HEAP32[((tempInt)>>2)]=0,tempInt));

    case 5: 
      var $5=$L_addr;
      var $nCcalls7=(($5+38)|0);
      var $6=HEAP16[(($nCcalls7)>>1)];
      var $conv8=(($6)&65535);
      var $cmp9=(($conv8)|0) >= 225;
      if ($cmp9) { label = 6; break; } else { label = 7; break; }
    case 6: 
      var $7=$L_addr;
      _luaD_throw($7, 6);

    case 7: 
      label = 8; break;
    case 8: 
      label = 9; break;
    case 9: 
      var $8=$allowyield_addr;
      var $tobool=(($8)|0)!=0;
      if ($tobool) { label = 11; break; } else { label = 10; break; }
    case 10: 
      var $9=$L_addr;
      var $nny=(($9+36)|0);
      var $10=HEAP16[(($nny)>>1)];
      var $inc15=((($10)+(1))&65535);
      HEAP16[(($nny)>>1)]=$inc15;
      label = 11; break;
    case 11: 
      var $11=$L_addr;
      var $12=$func_addr;
      var $13=$nResults_addr;
      var $call=_luaD_precall($11, $12, $13);
      var $tobool17=(($call)|0)!=0;
      if ($tobool17) { label = 13; break; } else { label = 12; break; }
    case 12: 
      var $14=$L_addr;
      _luaV_execute($14);
      label = 13; break;
    case 13: 
      var $15=$allowyield_addr;
      var $tobool20=(($15)|0)!=0;
      if ($tobool20) { label = 15; break; } else { label = 14; break; }
    case 14: 
      var $16=$L_addr;
      var $nny22=(($16+36)|0);
      var $17=HEAP16[(($nny22)>>1)];
      var $dec=((($17)-(1))&65535);
      HEAP16[(($nny22)>>1)]=$dec;
      label = 15; break;
    case 15: 
      var $18=$L_addr;
      var $nCcalls24=(($18+38)|0);
      var $19=HEAP16[(($nCcalls24)>>1)];
      var $dec25=((($19)-(1))&65535);
      HEAP16[(($nCcalls24)>>1)]=$dec25;
      var $20=$L_addr;
      var $l_G=(($20+12)|0);
      var $21=HEAP32[(($l_G)>>2)];
      var $GCdebt=(($21+12)|0);
      var $22=HEAP32[(($GCdebt)>>2)];
      var $cmp26=(($22)|0) > 0;
      if ($cmp26) { label = 16; break; } else { label = 17; break; }
    case 16: 
      var $23=$L_addr;
      _luaC_step($23);
      label = 17; break;
    case 17: 
      STACKTOP = __stackBase__;
      Module.print(INDENT + 'Exiting: _luaD_call');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_luaD_call["X"]=1;

function _lua_resume($L, $from, $nargs) {
  var label = 0;

  Module.print(INDENT + ' Entering: _lua_resume: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $L_addr;
      var $from_addr;
      var $nargs_addr;
      var $status;
      $L_addr=$L;
      $from_addr=$from;
      $nargs_addr=$nargs;
      var $0=$L_addr;
      var $1=$from_addr;
      var $tobool=(($1)|0)!=0;
      if ($tobool) { label = 3; break; } else { label = 4; break; }
    case 3: 
      var $2=$from_addr;
      var $nCcalls=(($2+38)|0);
      var $3=HEAP16[(($nCcalls)>>1)];
      var $conv=(($3)&65535);
      var $add=((($conv)+(1))|0);
      var $cond = $add;label = 5; break;
    case 4: 
      var $cond = 1;label = 5; break;
    case 5: 
      var $cond;
      var $conv1=(($cond) & 65535);
      var $4=$L_addr;
      var $nCcalls2=(($4+38)|0);
      HEAP16[(($nCcalls2)>>1)]=$conv1;
      var $5=$L_addr;
      var $nny=(($5+36)|0);
      HEAP16[(($nny)>>1)]=0;
      var $6=$L_addr;
      var $7=$L_addr;
      var $top=(($7+8)|0);
      var $8=HEAP32[(($top)>>2)];
      var $9=$nargs_addr;
      var $idx_neg=(((-$9))|0);
      var $add_ptr=(($8+((($idx_neg)*(12))&-1))|0);
      var $10=$add_ptr;
      var $call=_luaD_rawrunprotected($6, 10, $10);
      $status=$call;
      var $11=$status;
      var $cmp=(($11)|0)==-1;
      if ($cmp) { label = 6; break; } else { label = 7; break; }
    case 6: 
      $status=2;
      label = 16; break;
    case 7: 
      label = 8; break;
    case 8: 
      var $12=$status;
      var $cmp4=(($12)|0)!=0;
      if ($cmp4) { label = 9; break; } else { var $14 = 0;label = 10; break; }
    case 9: 
      var $13=$status;
      var $cmp6=(($13)|0)!=1;
      var $14 = $cmp6;label = 10; break;
    case 10: 
      var $14;
      if ($14) { label = 11; break; } else { label = 15; break; }
    case 11: 
      var $15=$L_addr;
      var $16=$status;
      var $call8=_recover($15, $16);
      var $tobool9=(($call8)|0)!=0;
      if ($tobool9) { label = 12; break; } else { label = 13; break; }
    case 12: 
      var $17=$L_addr;
      var $call11=_luaD_rawrunprotected($17, 14, 0);
      $status=$call11;
      label = 14; break;
    case 13: 
      var $18=$status;
      var $conv13=(($18) & 255);
      var $19=$L_addr;
      var $status14=(($19+6)|0);
      HEAP8[($status14)]=$conv13;
      var $20=$L_addr;
      var $21=$status;
      var $22=$L_addr;
      var $top15=(($22+8)|0);
      var $23=HEAP32[(($top15)>>2)];
      _seterrorobj($20, $21, $23);
      var $24=$L_addr;
      var $top16=(($24+8)|0);
      var $25=HEAP32[(($top16)>>2)];
      var $26=$L_addr;
      var $ci=(($26+16)|0);
      var $27=HEAP32[(($ci)>>2)];
      var $top17=(($27+4)|0);
      HEAP32[(($top17)>>2)]=$25;
      label = 15; break;
    case 14: 
      label = 8; break;
    case 15: 
      label = 16; break;
    case 16: 
      var $28=$L_addr;
      var $nny19=(($28+36)|0);
      HEAP16[(($nny19)>>1)]=1;
      var $29=$L_addr;
      var $nCcalls20=(($29+38)|0);
      var $30=HEAP16[(($nCcalls20)>>1)];
      var $dec=((($30)-(1))&65535);
      HEAP16[(($nCcalls20)>>1)]=$dec;
      var $31=$status;

      Module.print(INDENT + 'Exiting: _lua_resume');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return $31;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_lua_resume["X"]=1;

function _recover($L, $status) {
  var label = 0;

  Module.print(INDENT + ' Entering: _recover: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $retval;
      var $L_addr;
      var $status_addr;
      var $oldtop;
      var $ci;
      $L_addr=$L;
      $status_addr=$status;
      var $0=$L_addr;
      var $call=_findpcall($0);
      $ci=$call;
      var $1=$ci;
      var $cmp=(($1)|0)==0;
      if ($cmp) { label = 3; break; } else { label = 4; break; }
    case 3: 
      $retval=0;
      label = 5; break;
    case 4: 
      var $2=$L_addr;
      var $stack=(($2+28)|0);
      var $3=HEAP32[(($stack)>>2)];
      var $4=$3;
      var $5=$ci;
      var $extra=(($5+20)|0);
      var $6=HEAP32[(($extra)>>2)];
      var $add_ptr=(($4+$6)|0);
      var $7=$add_ptr;
      $oldtop=$7;
      var $8=$L_addr;
      var $9=$oldtop;
      _luaF_close($8, $9);
      var $10=$L_addr;
      var $11=$status_addr;
      var $12=$oldtop;
      _seterrorobj($10, $11, $12);
      var $13=$ci;
      var $14=$L_addr;
      var $ci1=(($14+16)|0);
      HEAP32[(($ci1)>>2)]=$13;
      var $15=$ci;
      var $u=(($15+24)|0);
      var $c=$u;
      var $old_allowhook=(($c+12)|0);
      var $16=HEAP8[($old_allowhook)];
      var $17=$L_addr;
      var $allowhook=(($17+41)|0);
      HEAP8[($allowhook)]=$16;
      var $18=$L_addr;
      var $nny=(($18+36)|0);
      HEAP16[(($nny)>>1)]=0;
      var $19=$L_addr;
      _luaD_shrinkstack($19);
      var $20=$ci;
      var $u2=(($20+24)|0);
      var $c3=$u2;
      var $old_errfunc=(($c3+8)|0);
      var $21=HEAP32[(($old_errfunc)>>2)];
      var $22=$L_addr;
      var $errfunc=(($22+68)|0);
      HEAP32[(($errfunc)>>2)]=$21;
      var $23=$ci;
      var $callstatus=(($23+18)|0);
      var $24=HEAP8[($callstatus)];
      var $conv=(($24)&255);
      var $or=$conv | 32;
      var $conv4=(($or) & 255);
      HEAP8[($callstatus)]=$conv4;
      var $25=$status_addr;
      var $conv5=(($25) & 255);
      var $26=$ci;
      var $u6=(($26+24)|0);
      var $c7=$u6;
      var $status8=(($c7+13)|0);
      HEAP8[($status8)]=$conv5;
      $retval=1;
      label = 5; break;
    case 5: 
      var $27=$retval;

      Module.print(INDENT + 'Exiting: _recover');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return $27;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_recover["X"]=1;

function _unroll($L, $ud) {
  var label = 0;

  Module.print(INDENT + ' Entering: _unroll: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $L_addr;
      var $ud_addr;
      $L_addr=$L;
      $ud_addr=$ud;
      var $0=$ud_addr;
      label = 3; break;
    case 3: 
      var $1=$L_addr;
      var $ci=(($1+16)|0);
      var $2=HEAP32[(($ci)>>2)];
      var $3=$L_addr;
      var $base_ci=(($3+72)|0);
      var $cmp=(($2)|0)==(($base_ci)|0);
      if ($cmp) { label = 4; break; } else { label = 5; break; }
    case 4: 

      Module.print(INDENT + 'Exiting: _unroll');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return;
    case 5: 
      var $4=$L_addr;
      var $ci1=(($4+16)|0);
      var $5=HEAP32[(($ci1)>>2)];
      var $callstatus=(($5+18)|0);
      var $6=HEAP8[($callstatus)];
      var $conv=(($6)&255);
      var $and=$conv & 1;
      var $tobool=(($and)|0)!=0;
      if ($tobool) { label = 7; break; } else { label = 6; break; }
    case 6: 
      var $7=$L_addr;
      _finishCcall($7);
      label = 8; break;
    case 7: 
      var $8=$L_addr;
      _luaV_finishOp($8);
      var $9=$L_addr;
      _luaV_execute($9);
      label = 8; break;
    case 8: 
      label = 3; break;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _seterrorobj($L, $errcode, $oldtop) {
  var label = 0;

  Module.print(INDENT + ' Entering: _seterrorobj: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $L_addr;
      var $errcode_addr;
      var $oldtop_addr;
      var $io;
      var $x_;
      var $io2;
      var $x_3;
      var $io211;
      var $io1;
      $L_addr=$L;
      $errcode_addr=$errcode;
      $oldtop_addr=$oldtop;
      var $0=$errcode_addr;
      if ((($0)|0)==4) {
        label = 3; break;
      }
      else if ((($0)|0)==6) {
        label = 4; break;
      }
      else {
      label = 5; break;
      }
      
    case 3: 
      var $1=$oldtop_addr;
      $io=$1;
      var $2=$L_addr;
      var $l_G=(($2+12)|0);
      var $3=HEAP32[(($l_G)>>2)];
      var $memerrmsg=(($3+160)|0);
      var $4=HEAP32[(($memerrmsg)>>2)];
      $x_=$4;
      var $5=$x_;
      var $6=$5;
      var $7=$io;
      var $value_=(($7)|0);
      var $gc=$value_;
      HEAP32[(($gc)>>2)]=$6;
      var $8=$x_;
      var $tsv=$8;
      var $tt=(($tsv+4)|0);
      var $9=HEAP8[($tt)];
      var $conv=(($9)&255);
      var $or=$conv | 64;
      var $10=$io;
      var $tt_=(($10+8)|0);
      HEAP32[(($tt_)>>2)]=$or;
      label = 6; break;
    case 4: 
      var $11=$oldtop_addr;
      $io2=$11;
      var $12=$L_addr;
      var $call=_luaS_newlstr($12, ((5244208)|0), 23);
      $x_3=$call;
      var $13=$x_3;
      var $14=$13;
      var $15=$io2;
      var $value_4=(($15)|0);
      var $gc5=$value_4;
      HEAP32[(($gc5)>>2)]=$14;
      var $16=$x_3;
      var $tsv6=$16;
      var $tt7=(($tsv6+4)|0);
      var $17=HEAP8[($tt7)];
      var $conv8=(($17)&255);
      var $or9=$conv8 | 64;
      var $18=$io2;
      var $tt_10=(($18+8)|0);
      HEAP32[(($tt_10)>>2)]=$or9;
      label = 6; break;
    case 5: 
      var $19=$L_addr;
      var $top=(($19+8)|0);
      var $20=HEAP32[(($top)>>2)];
      var $add_ptr=((($20)-(12))|0);
      $io211=$add_ptr;
      var $21=$oldtop_addr;
      $io1=$21;
      var $22=$io1;
      var $value_12=(($22)|0);
      var $23=$io211;
      var $value_13=(($23)|0);
      var $24=$value_12;
      var $25=$value_13;
      HEAP32[(($24)>>2)]=HEAP32[(($25)>>2)];HEAP32[((($24)+(4))>>2)]=HEAP32[((($25)+(4))>>2)];
      var $26=$io211;
      var $tt_14=(($26+8)|0);
      var $27=HEAP32[(($tt_14)>>2)];
      var $28=$io1;
      var $tt_15=(($28+8)|0);
      HEAP32[(($tt_15)>>2)]=$27;
      label = 6; break;
    case 6: 
      var $29=$oldtop_addr;
      var $add_ptr16=(($29+12)|0);
      var $30=$L_addr;
      var $top17=(($30+8)|0);
      HEAP32[(($top17)>>2)]=$add_ptr16;

      Module.print(INDENT + 'Exiting: _seterrorobj');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_seterrorobj["X"]=1;

function _luaD_pcall($L, $func, $u, $old_top, $ef) {
  var label = 0;

  Module.print(INDENT + ' Entering: _luaD_pcall: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $L_addr;
      var $func_addr;
      var $u_addr;
      var $old_top_addr;
      var $ef_addr;
      var $status;
      var $old_ci;
      var $old_allowhooks;
      var $old_nny;
      var $old_errfunc;
      var $oldtop;
      $L_addr=$L;
      $func_addr=$func;
      $u_addr=$u;
      $old_top_addr=$old_top;
      $ef_addr=$ef;
      var $0=$L_addr;
      var $ci=(($0+16)|0);
      var $1=HEAP32[(($ci)>>2)];
      $old_ci=$1;
      var $2=$L_addr;
      var $allowhook=(($2+41)|0);
      var $3=HEAP8[($allowhook)];
      $old_allowhooks=$3;
      var $4=$L_addr;
      var $nny=(($4+36)|0);
      var $5=HEAP16[(($nny)>>1)];
      $old_nny=$5;
      var $6=$L_addr;
      var $errfunc=(($6+68)|0);
      var $7=HEAP32[(($errfunc)>>2)];
      $old_errfunc=$7;
      var $8=$ef_addr;
      var $9=$L_addr;
      var $errfunc1=(($9+68)|0);
      HEAP32[(($errfunc1)>>2)]=$8;
      var $10=$L_addr;
      var $11=$func_addr;
      var $12=$u_addr;
      var $call=_luaD_rawrunprotected($10, $11, $12);
      $status=$call;
      var $13=$status;
      var $cmp=(($13)|0)!=0;
      if ($cmp) { label = 3; break; } else { label = 4; break; }
    case 3: 
      var $14=$L_addr;
      var $stack=(($14+28)|0);
      var $15=HEAP32[(($stack)>>2)];
      var $16=$15;
      var $17=$old_top_addr;
      var $add_ptr=(($16+$17)|0);
      var $18=$add_ptr;
      $oldtop=$18;
      var $19=$L_addr;
      var $20=$oldtop;
      _luaF_close($19, $20);
      var $21=$L_addr;
      var $22=$status;
      var $23=$oldtop;
      _seterrorobj($21, $22, $23);
      var $24=$old_ci;
      var $25=$L_addr;
      var $ci2=(($25+16)|0);
      HEAP32[(($ci2)>>2)]=$24;
      var $26=$old_allowhooks;
      var $27=$L_addr;
      var $allowhook3=(($27+41)|0);
      HEAP8[($allowhook3)]=$26;
      var $28=$old_nny;
      var $29=$L_addr;
      var $nny4=(($29+36)|0);
      HEAP16[(($nny4)>>1)]=$28;
      var $30=$L_addr;
      _luaD_shrinkstack($30);
      label = 4; break;
    case 4: 
      var $31=$old_errfunc;
      var $32=$L_addr;
      var $errfunc5=(($32+68)|0);
      HEAP32[(($errfunc5)>>2)]=$31;
      var $33=$status;

      Module.print(INDENT + 'Exiting: _luaD_pcall');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return $33;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_luaD_pcall["X"]=1;

function _luaD_protectedparser($L, $z, $name, $mode) {
  var label = 0;
  var __stackBase__  = STACKTOP; STACKTOP = (STACKTOP + 60)|0; _memset(__stackBase__, 0, 60);
  Module.print(INDENT + ' Entering: _luaD_protectedparser: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';

  var $L_addr;
  var $z_addr;
  var $name_addr;
  var $mode_addr;
  var $p=__stackBase__;
  var $status;
  $L_addr=$L;
  $z_addr=$z;
  $name_addr=$name;
  $mode_addr=$mode;
  var $0=$L_addr;
  var $nny=(($0+36)|0);
  var $1=HEAP16[(($nny)>>1)];
  var $inc=((($1)+(1))&65535);
  HEAP16[(($nny)>>1)]=$inc;
  var $2=$z_addr;
  var $z1=(($p)|0);
  HEAP32[(($z1)>>2)]=$2;
  var $3=$name_addr;
  var $name2=(($p+56)|0);
  HEAP32[(($name2)>>2)]=$3;
  var $4=$mode_addr;
  var $mode3=(($p+52)|0);
  HEAP32[(($mode3)>>2)]=$4;
  var $dyd=(($p+16)|0);
  var $actvar=(($dyd)|0);
  var $arr=(($actvar)|0);
  HEAP32[(($arr)>>2)]=0;
  var $dyd4=(($p+16)|0);
  var $actvar5=(($dyd4)|0);
  var $size=(($actvar5+8)|0);
  HEAP32[(($size)>>2)]=0;
  var $dyd6=(($p+16)|0);
  var $gt=(($dyd6+12)|0);
  var $arr7=(($gt)|0);
  HEAP32[(($arr7)>>2)]=0;
  var $dyd8=(($p+16)|0);
  var $gt9=(($dyd8+12)|0);
  var $size10=(($gt9+8)|0);
  HEAP32[(($size10)>>2)]=0;
  var $dyd11=(($p+16)|0);
  var $label=(($dyd11+24)|0);
  var $arr12=(($label)|0);
  HEAP32[(($arr12)>>2)]=0;
  var $dyd13=(($p+16)|0);
  var $label14=(($dyd13+24)|0);
  var $size15=(($label14+8)|0);
  HEAP32[(($size15)>>2)]=0;
  var $buff=(($p+4)|0);
  var $buffer=(($buff)|0);
  HEAP32[(($buffer)>>2)]=0;
  var $buff16=(($p+4)|0);
  var $buffsize=(($buff16+8)|0);
  HEAP32[(($buffsize)>>2)]=0;
  var $5=$L_addr;
  var $6=$p;
  var $7=$L_addr;
  var $top=(($7+8)|0);
  var $8=HEAP32[(($top)>>2)];
  var $9=$8;
  var $10=$L_addr;
  var $stack=(($10+28)|0);
  var $11=HEAP32[(($stack)>>2)];
  var $12=$11;
  var $sub_ptr_lhs_cast=$9;
  var $sub_ptr_rhs_cast=$12;
  var $sub_ptr_sub=((($sub_ptr_lhs_cast)-($sub_ptr_rhs_cast))|0);
  var $13=$L_addr;
  var $errfunc=(($13+68)|0);
  var $14=HEAP32[(($errfunc)>>2)];
  var $call=_luaD_pcall($5, 12, $6, $sub_ptr_sub, $14);
  $status=$call;
  var $15=$L_addr;
  var $buff17=(($p+4)|0);
  var $buffer18=(($buff17)|0);
  var $16=HEAP32[(($buffer18)>>2)];
  var $buff19=(($p+4)|0);
  var $buffsize20=(($buff19+8)|0);
  var $17=HEAP32[(($buffsize20)>>2)];
  var $mul=$17;
  var $call21=_luaM_realloc_($15, $16, $mul, 0);
  var $buff22=(($p+4)|0);
  var $buffer23=(($buff22)|0);
  HEAP32[(($buffer23)>>2)]=$call21;
  var $buff24=(($p+4)|0);
  var $buffsize25=(($buff24+8)|0);
  HEAP32[(($buffsize25)>>2)]=0;
  var $18=$L_addr;
  var $dyd26=(($p+16)|0);
  var $actvar27=(($dyd26)|0);
  var $arr28=(($actvar27)|0);
  var $19=HEAP32[(($arr28)>>2)];
  var $20=$19;
  var $dyd29=(($p+16)|0);
  var $actvar30=(($dyd29)|0);
  var $size31=(($actvar30+8)|0);
  var $21=HEAP32[(($size31)>>2)];
  var $mul32=($21<<1);
  var $call33=_luaM_realloc_($18, $20, $mul32, 0);
  var $22=$L_addr;
  var $dyd34=(($p+16)|0);
  var $gt35=(($dyd34+12)|0);
  var $arr36=(($gt35)|0);
  var $23=HEAP32[(($arr36)>>2)];
  var $24=$23;
  var $dyd37=(($p+16)|0);
  var $gt38=(($dyd37+12)|0);
  var $size39=(($gt38+8)|0);
  var $25=HEAP32[(($size39)>>2)];
  var $mul40=($25<<4);
  var $call41=_luaM_realloc_($22, $24, $mul40, 0);
  var $26=$L_addr;
  var $dyd42=(($p+16)|0);
  var $label43=(($dyd42+24)|0);
  var $arr44=(($label43)|0);
  var $27=HEAP32[(($arr44)>>2)];
  var $28=$27;
  var $dyd45=(($p+16)|0);
  var $label46=(($dyd45+24)|0);
  var $size47=(($label46+8)|0);
  var $29=HEAP32[(($size47)>>2)];
  var $mul48=($29<<4);
  var $call49=_luaM_realloc_($26, $28, $mul48, 0);
  var $30=$L_addr;
  var $nny50=(($30+36)|0);
  var $31=HEAP16[(($nny50)>>1)];
  var $dec=((($31)-(1))&65535);
  HEAP16[(($nny50)>>1)]=$dec;
  var $32=$status;
  STACKTOP = __stackBase__;
  Module.print(INDENT + 'Exiting: _luaD_protectedparser');
  INDENT = INDENT.substr(0, INDENT.length-2);
  return $32;
  INDENT = INDENT.substr(0, INDENT.length-2);
}
_luaD_protectedparser["X"]=1;

function _resume($L, $ud) {
  var label = 0;

  Module.print(INDENT + ' Entering: _resume: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $L_addr;
      var $ud_addr;
      var $nCcalls;
      var $firstArg;
      var $ci;
      var $n;
      $L_addr=$L;
      $ud_addr=$ud;
      var $0=$L_addr;
      var $nCcalls1=(($0+38)|0);
      var $1=HEAP16[(($nCcalls1)>>1)];
      var $conv=(($1)&65535);
      $nCcalls=$conv;
      var $2=$ud_addr;
      var $3=$2;
      $firstArg=$3;
      var $4=$L_addr;
      var $ci2=(($4+16)|0);
      var $5=HEAP32[(($ci2)>>2)];
      $ci=$5;
      var $6=$nCcalls;
      var $cmp=(($6)|0) >= 200;
      if ($cmp) { label = 3; break; } else { label = 4; break; }
    case 3: 
      var $7=$L_addr;
      var $8=$firstArg;
      _resume_error($7, ((5246796)|0), $8);

    case 4: 
      var $9=$L_addr;
      var $status=(($9+6)|0);
      var $10=HEAP8[($status)];
      var $conv4=(($10)&255);
      var $cmp5=(($conv4)|0)==0;
      if ($cmp5) { label = 5; break; } else { label = 10; break; }
    case 5: 
      var $11=$ci;
      var $12=$L_addr;
      var $base_ci=(($12+72)|0);
      var $cmp8=(($11)|0)!=(($base_ci)|0);
      if ($cmp8) { label = 6; break; } else { label = 7; break; }
    case 6: 
      var $13=$L_addr;
      var $14=$firstArg;
      _resume_error($13, ((5244108)|0), $14);

    case 7: 
      var $15=$L_addr;
      var $16=$firstArg;
      var $add_ptr=((($16)-(12))|0);
      var $call=_luaD_precall($15, $add_ptr, -1);
      var $tobool=(($call)|0)!=0;
      if ($tobool) { label = 9; break; } else { label = 8; break; }
    case 8: 
      var $17=$L_addr;
      _luaV_execute($17);
      label = 9; break;
    case 9: 
      label = 19; break;
    case 10: 
      var $18=$L_addr;
      var $status14=(($18+6)|0);
      var $19=HEAP8[($status14)];
      var $conv15=(($19)&255);
      var $cmp16=(($conv15)|0)!=1;
      if ($cmp16) { label = 11; break; } else { label = 12; break; }
    case 11: 
      var $20=$L_addr;
      var $21=$firstArg;
      _resume_error($20, ((5247112)|0), $21);

    case 12: 
      var $22=$L_addr;
      var $status20=(($22+6)|0);
      HEAP8[($status20)]=0;
      var $23=$L_addr;
      var $stack=(($23+28)|0);
      var $24=HEAP32[(($stack)>>2)];
      var $25=$24;
      var $26=$ci;
      var $extra=(($26+20)|0);
      var $27=HEAP32[(($extra)>>2)];
      var $add_ptr21=(($25+$27)|0);
      var $28=$add_ptr21;
      var $29=$ci;
      var $func=(($29)|0);
      HEAP32[(($func)>>2)]=$28;
      var $30=$ci;
      var $callstatus=(($30+18)|0);
      var $31=HEAP8[($callstatus)];
      var $conv22=(($31)&255);
      var $and=$conv22 & 1;
      var $tobool23=(($and)|0)!=0;
      if ($tobool23) { label = 13; break; } else { label = 14; break; }
    case 13: 
      var $32=$L_addr;
      _luaV_execute($32);
      label = 17; break;
    case 14: 
      var $33=$ci;
      var $u=(($33+24)|0);
      var $c=$u;
      var $k=(($c+4)|0);
      var $34=HEAP32[(($k)>>2)];
      var $cmp26=(($34)|0)!=0;
      if ($cmp26) { label = 15; break; } else { label = 16; break; }
    case 15: 
      var $35=$ci;
      var $u29=(($35+24)|0);
      var $c30=$u29;
      var $status31=(($c30+13)|0);
      HEAP8[($status31)]=1;
      var $36=$ci;
      var $callstatus32=(($36+18)|0);
      var $37=HEAP8[($callstatus32)];
      var $conv33=(($37)&255);
      var $or=$conv33 | 8;
      var $conv34=(($or) & 255);
      HEAP8[($callstatus32)]=$conv34;
      var $38=$ci;
      var $u35=(($38+24)|0);
      var $c36=$u35;
      var $k37=(($c36+4)|0);
      var $39=HEAP32[(($k37)>>2)];
      var $40=$L_addr;
      var $call38=FUNCTION_TABLE[$39]($40);
      $n=$call38;
      var $41=$L_addr;
      var $top=(($41+8)|0);
      var $42=HEAP32[(($top)>>2)];
      var $43=$n;
      var $idx_neg=(((-$43))|0);
      var $add_ptr39=(($42+((($idx_neg)*(12))&-1))|0);
      $firstArg=$add_ptr39;
      label = 16; break;
    case 16: 
      var $44=$L_addr;
      var $45=$firstArg;
      var $call41=_luaD_poscall($44, $45);
      label = 17; break;
    case 17: 
      var $46=$L_addr;
      _unroll($46, 0);
      label = 18; break;
    case 18: 
      label = 19; break;
    case 19: 

      Module.print(INDENT + 'Exiting: _resume');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_resume["X"]=1;

function _lua_yieldk($L, $nresults, $ctx, $k) {
  var label = 0;
  var __stackBase__  = STACKTOP; _memset(__stackBase__, 0, 0);
  Module.print(INDENT + ' Entering: _lua_yieldk: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $L_addr;
      var $nresults_addr;
      var $ctx_addr;
      var $k_addr;
      var $ci;
      $L_addr=$L;
      $nresults_addr=$nresults;
      $ctx_addr=$ctx;
      $k_addr=$k;
      var $0=$L_addr;
      var $ci1=(($0+16)|0);
      var $1=HEAP32[(($ci1)>>2)];
      $ci=$1;
      var $2=$L_addr;
      var $3=$L_addr;
      var $nny=(($3+36)|0);
      var $4=HEAP16[(($nny)>>1)];
      var $conv=(($4)&65535);
      var $cmp=(($conv)|0) > 0;
      if ($cmp) { label = 3; break; } else { label = 6; break; }
    case 3: 
      var $5=$L_addr;
      var $6=$L_addr;
      var $l_G=(($6+12)|0);
      var $7=HEAP32[(($l_G)>>2)];
      var $mainthread=(($7+152)|0);
      var $8=HEAP32[(($mainthread)>>2)];
      var $cmp3=(($5)|0)!=(($8)|0);
      if ($cmp3) { label = 4; break; } else { label = 5; break; }
    case 4: 
      var $9=$L_addr;
      _luaG_runerror($9, ((5245788)|0), (tempInt=STACKTOP,_memset(STACKTOP, 0, 1),STACKTOP = (STACKTOP + 1)|0,STACKTOP = ((((STACKTOP)+3)>>2)<<2),HEAP32[((tempInt)>>2)]=0,tempInt));

    case 5: 
      var $10=$L_addr;
      _luaG_runerror($10, ((5245260)|0), (tempInt=STACKTOP,_memset(STACKTOP, 0, 1),STACKTOP = (STACKTOP + 1)|0,STACKTOP = ((((STACKTOP)+3)>>2)<<2),HEAP32[((tempInt)>>2)]=0,tempInt));

    case 6: 
      var $11=$L_addr;
      var $status=(($11+6)|0);
      HEAP8[($status)]=1;
      var $12=$ci;
      var $func=(($12)|0);
      var $13=HEAP32[(($func)>>2)];
      var $14=$13;
      var $15=$L_addr;
      var $stack=(($15+28)|0);
      var $16=HEAP32[(($stack)>>2)];
      var $17=$16;
      var $sub_ptr_lhs_cast=$14;
      var $sub_ptr_rhs_cast=$17;
      var $sub_ptr_sub=((($sub_ptr_lhs_cast)-($sub_ptr_rhs_cast))|0);
      var $18=$ci;
      var $extra=(($18+20)|0);
      HEAP32[(($extra)>>2)]=$sub_ptr_sub;
      var $19=$ci;
      var $callstatus=(($19+18)|0);
      var $20=HEAP8[($callstatus)];
      var $conv6=(($20)&255);
      var $and=$conv6 & 1;
      var $tobool=(($and)|0)!=0;
      if ($tobool) { label = 7; break; } else { label = 8; break; }
    case 7: 
      label = 11; break;
    case 8: 
      var $21=$k_addr;
      var $22=$ci;
      var $u=(($22+24)|0);
      var $c=$u;
      var $k9=(($c+4)|0);
      HEAP32[(($k9)>>2)]=$21;
      var $cmp10=(($21)|0)!=0;
      if ($cmp10) { label = 9; break; } else { label = 10; break; }
    case 9: 
      var $23=$ctx_addr;
      var $24=$ci;
      var $u13=(($24+24)|0);
      var $c14=$u13;
      var $ctx15=(($c14)|0);
      HEAP32[(($ctx15)>>2)]=$23;
      label = 10; break;
    case 10: 
      var $25=$L_addr;
      var $top=(($25+8)|0);
      var $26=HEAP32[(($top)>>2)];
      var $27=$nresults_addr;
      var $idx_neg=(((-$27))|0);
      var $add_ptr=(($26+((($idx_neg)*(12))&-1))|0);
      var $add_ptr17=((($add_ptr)-(12))|0);
      var $28=$ci;
      var $func18=(($28)|0);
      HEAP32[(($func18)>>2)]=$add_ptr17;
      var $29=$L_addr;
      _luaD_throw($29, 1);

    case 11: 
      STACKTOP = __stackBase__;
      Module.print(INDENT + 'Exiting: _lua_yieldk');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return 0;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_lua_yieldk["X"]=1;

function _findpcall($L) {
  var label = 0;

  Module.print(INDENT + ' Entering: _findpcall: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $retval;
      var $L_addr;
      var $ci;
      $L_addr=$L;
      var $0=$L_addr;
      var $ci1=(($0+16)|0);
      var $1=HEAP32[(($ci1)>>2)];
      $ci=$1;
      label = 3; break;
    case 3: 
      var $2=$ci;
      var $cmp=(($2)|0)!=0;
      if ($cmp) { label = 4; break; } else { label = 8; break; }
    case 4: 
      var $3=$ci;
      var $callstatus=(($3+18)|0);
      var $4=HEAP8[($callstatus)];
      var $conv=(($4)&255);
      var $and=$conv & 16;
      var $tobool=(($and)|0)!=0;
      if ($tobool) { label = 5; break; } else { label = 6; break; }
    case 5: 
      var $5=$ci;
      $retval=$5;
      label = 9; break;
    case 6: 
      label = 7; break;
    case 7: 
      var $6=$ci;
      var $previous=(($6+8)|0);
      var $7=HEAP32[(($previous)>>2)];
      $ci=$7;
      label = 3; break;
    case 8: 
      $retval=0;
      label = 9; break;
    case 9: 
      var $8=$retval;

      Module.print(INDENT + 'Exiting: _findpcall');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return $8;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _f_parser($L, $ud) {
  var label = 0;

  Module.print(INDENT + ' Entering: _f_parser: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $L_addr;
      var $ud_addr;
      var $i;
      var $cl;
      var $p;
      var $c;
      var $up;
      $L_addr=$L;
      $ud_addr=$ud;
      var $0=$ud_addr;
      var $1=$0;
      $p=$1;
      var $2=$p;
      var $z=(($2)|0);
      var $3=HEAP32[(($z)>>2)];
      var $n=(($3)|0);
      var $4=HEAP32[(($n)>>2)];
      var $dec=((($4)-(1))|0);
      HEAP32[(($n)>>2)]=$dec;
      var $cmp=(($4)>>>0) > 0;
      if ($cmp) { label = 3; break; } else { label = 4; break; }
    case 3: 
      var $5=$p;
      var $z1=(($5)|0);
      var $6=HEAP32[(($z1)>>2)];
      var $p2=(($6+4)|0);
      var $7=HEAP32[(($p2)>>2)];
      var $incdec_ptr=(($7+1)|0);
      HEAP32[(($p2)>>2)]=$incdec_ptr;
      var $8=HEAP8[($7)];
      var $conv=(($8)&255);
      var $cond = $conv;label = 5; break;
    case 4: 
      var $9=$p;
      var $z3=(($9)|0);
      var $10=HEAP32[(($z3)>>2)];
      var $call=_luaZ_fill($10);
      var $cond = $call;label = 5; break;
    case 5: 
      var $cond;
      $c=$cond;
      var $11=$c;
      var $12=HEAP8[((((5244996)|0))|0)];
      var $conv4=(($12 << 24) >> 24);
      var $cmp5=(($11)|0)==(($conv4)|0);
      if ($cmp5) { label = 6; break; } else { label = 7; break; }
    case 6: 
      var $13=$L_addr;
      var $14=$p;
      var $mode=(($14+52)|0);
      var $15=HEAP32[(($mode)>>2)];
      _checkmode($13, $15, ((5244664)|0));
      var $16=$L_addr;
      var $17=$p;
      var $z7=(($17)|0);
      var $18=HEAP32[(($z7)>>2)];
      var $19=$p;
      var $buff=(($19+4)|0);
      var $20=$p;
      var $name=(($20+56)|0);
      var $21=HEAP32[(($name)>>2)];
      var $call8=_luaU_undump($16, $18, $buff, $21);
      $cl=$call8;
      label = 8; break;
    case 7: 
      var $22=$L_addr;
      var $23=$p;
      var $mode9=(($23+52)|0);
      var $24=HEAP32[(($mode9)>>2)];
      _checkmode($22, $24, ((5244540)|0));
      var $25=$L_addr;
      var $26=$p;
      var $z10=(($26)|0);
      var $27=HEAP32[(($z10)>>2)];
      var $28=$p;
      var $buff11=(($28+4)|0);
      var $29=$p;
      var $dyd=(($29+16)|0);
      var $30=$p;
      var $name12=(($30+56)|0);
      var $31=HEAP32[(($name12)>>2)];
      var $32=$c;
      var $call13=_luaY_parser($25, $27, $buff11, $dyd, $31, $32);
      $cl=$call13;
      label = 8; break;
    case 8: 
      $i=0;
      label = 9; break;
    case 9: 
      var $33=$i;
      var $34=$cl;
      var $l=$34;
      var $nupvalues=(($l+6)|0);
      var $35=HEAP8[($nupvalues)];
      var $conv14=(($35)&255);
      var $cmp15=(($33)|0) < (($conv14)|0);
      if ($cmp15) { label = 10; break; } else { label = 15; break; }
    case 10: 
      var $36=$L_addr;
      var $call17=_luaF_newupval($36);
      $up=$call17;
      var $37=$up;
      var $38=$i;
      var $39=$cl;
      var $l18=$39;
      var $upvals=(($l18+16)|0);
      var $arrayidx=(($upvals+($38<<2))|0);
      HEAP32[(($arrayidx)>>2)]=$37;
      var $40=$up;
      var $41=$40;
      var $gch=$41;
      var $marked=(($gch+5)|0);
      var $42=HEAP8[($marked)];
      var $conv19=(($42)&255);
      var $and=$conv19 & 3;
      var $tobool=(($and)|0)!=0;
      if ($tobool) { label = 11; break; } else { label = 13; break; }
    case 11: 
      var $43=$cl;
      var $44=$43;
      var $gch20=$44;
      var $marked21=(($gch20+5)|0);
      var $45=HEAP8[($marked21)];
      var $conv22=(($45)&255);
      var $and23=$conv22 & 4;
      var $tobool24=(($and23)|0)!=0;
      if ($tobool24) { label = 12; break; } else { label = 13; break; }
    case 12: 
      var $46=$L_addr;
      var $47=$cl;
      var $48=$47;
      var $49=$up;
      var $50=$49;
      _luaC_barrier_($46, $48, $50);
      label = 13; break;
    case 13: 
      label = 14; break;
    case 14: 
      var $51=$i;
      var $inc=((($51)+(1))|0);
      $i=$inc;
      label = 9; break;
    case 15: 

      Module.print(INDENT + 'Exiting: _f_parser');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_f_parser["X"]=1;

function _finishCcall($L) {
  var label = 0;

  Module.print(INDENT + ' Entering: _finishCcall: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $L_addr;
      var $ci;
      var $n;
      $L_addr=$L;
      var $0=$L_addr;
      var $ci1=(($0+16)|0);
      var $1=HEAP32[(($ci1)>>2)];
      $ci=$1;
      var $2=$ci;
      var $nresults=(($2+16)|0);
      var $3=HEAP16[(($nresults)>>1)];
      var $conv=(($3 << 16) >> 16);
      var $cmp=(($conv)|0)==-1;
      if ($cmp) { label = 3; break; } else { label = 5; break; }
    case 3: 
      var $4=$L_addr;
      var $ci3=(($4+16)|0);
      var $5=HEAP32[(($ci3)>>2)];
      var $top=(($5+4)|0);
      var $6=HEAP32[(($top)>>2)];
      var $7=$L_addr;
      var $top4=(($7+8)|0);
      var $8=HEAP32[(($top4)>>2)];
      var $cmp5=(($6)>>>0) < (($8)>>>0);
      if ($cmp5) { label = 4; break; } else { label = 5; break; }
    case 4: 
      var $9=$L_addr;
      var $top7=(($9+8)|0);
      var $10=HEAP32[(($top7)>>2)];
      var $11=$L_addr;
      var $ci8=(($11+16)|0);
      var $12=HEAP32[(($ci8)>>2)];
      var $top9=(($12+4)|0);
      HEAP32[(($top9)>>2)]=$10;
      label = 5; break;
    case 5: 
      var $13=$ci;
      var $callstatus=(($13+18)|0);
      var $14=HEAP8[($callstatus)];
      var $conv10=(($14)&255);
      var $and=$conv10 & 32;
      var $tobool=(($and)|0)!=0;
      if ($tobool) { label = 7; break; } else { label = 6; break; }
    case 6: 
      var $15=$ci;
      var $u=(($15+24)|0);
      var $c=$u;
      var $status=(($c+13)|0);
      HEAP8[($status)]=1;
      label = 7; break;
    case 7: 
      var $16=$ci;
      var $callstatus13=(($16+18)|0);
      var $17=HEAP8[($callstatus13)];
      var $conv14=(($17)&255);
      var $and15=$conv14 & -49;
      var $or=$and15 | 8;
      var $conv16=(($or) & 255);
      var $18=$ci;
      var $callstatus17=(($18+18)|0);
      HEAP8[($callstatus17)]=$conv16;
      var $19=$ci;
      var $u18=(($19+24)|0);
      var $c19=$u18;
      var $k=(($c19+4)|0);
      var $20=HEAP32[(($k)>>2)];
      var $21=$L_addr;
      var $call=FUNCTION_TABLE[$20]($21);
      $n=$call;
      var $22=$L_addr;
      var $23=$L_addr;
      var $top20=(($23+8)|0);
      var $24=HEAP32[(($top20)>>2)];
      var $25=$n;
      var $idx_neg=(((-$25))|0);
      var $add_ptr=(($24+((($idx_neg)*(12))&-1))|0);
      var $call21=_luaD_poscall($22, $add_ptr);

      Module.print(INDENT + 'Exiting: _finishCcall');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_finishCcall["X"]=1;

function _luaU_dump($L, $f, $w, $data, $strip) {
  var label = 0;
  var __stackBase__  = STACKTOP; STACKTOP = (STACKTOP + 20)|0; _memset(__stackBase__, 0, 20);
  Module.print(INDENT + ' Entering: _luaU_dump: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';

  var $L_addr;
  var $f_addr;
  var $w_addr;
  var $data_addr;
  var $strip_addr;
  var $D=__stackBase__;
  $L_addr=$L;
  $f_addr=$f;
  $w_addr=$w;
  $data_addr=$data;
  $strip_addr=$strip;
  var $0=$L_addr;
  var $L1=(($D)|0);
  HEAP32[(($L1)>>2)]=$0;
  var $1=$w_addr;
  var $writer=(($D+4)|0);
  HEAP32[(($writer)>>2)]=$1;
  var $2=$data_addr;
  var $data2=(($D+8)|0);
  HEAP32[(($data2)>>2)]=$2;
  var $3=$strip_addr;
  var $strip3=(($D+12)|0);
  HEAP32[(($strip3)>>2)]=$3;
  var $status=(($D+16)|0);
  HEAP32[(($status)>>2)]=0;
  _DumpHeader($D);
  var $4=$f_addr;
  _DumpFunction($4, $D);
  var $status4=(($D+16)|0);
  var $5=HEAP32[(($status4)>>2)];
  STACKTOP = __stackBase__;
  Module.print(INDENT + 'Exiting: _luaU_dump');
  INDENT = INDENT.substr(0, INDENT.length-2);
  return $5;
  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _DumpHeader($D) {
  var label = 0;
  var __stackBase__  = STACKTOP; STACKTOP = (STACKTOP + 20)|0; _memset(__stackBase__, 0, 20);
  Module.print(INDENT + ' Entering: _DumpHeader: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';

  var $D_addr;
  var $h=__stackBase__;
  $D_addr=$D;
  var $arraydecay=(($h)|0);
  _luaU_header($arraydecay);
  var $arraydecay1=(($h)|0);
  var $0=$D_addr;
  _DumpBlock($arraydecay1, 18, $0);
  STACKTOP = __stackBase__;
  Module.print(INDENT + 'Exiting: _DumpHeader');
  INDENT = INDENT.substr(0, INDENT.length-2);
  return;
  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _DumpFunction($f, $D) {
  var label = 0;

  Module.print(INDENT + ' Entering: _DumpFunction: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';

  var $f_addr;
  var $D_addr;
  $f_addr=$f;
  $D_addr=$D;
  var $0=$f_addr;
  var $linedefined=(($0+64)|0);
  var $1=HEAP32[(($linedefined)>>2)];
  var $2=$D_addr;
  _DumpInt($1, $2);
  var $3=$f_addr;
  var $lastlinedefined=(($3+68)|0);
  var $4=HEAP32[(($lastlinedefined)>>2)];
  var $5=$D_addr;
  _DumpInt($4, $5);
  var $6=$f_addr;
  var $numparams=(($6+76)|0);
  var $7=HEAP8[($numparams)];
  var $conv=(($7)&255);
  var $8=$D_addr;
  _DumpChar($conv, $8);
  var $9=$f_addr;
  var $is_vararg=(($9+77)|0);
  var $10=HEAP8[($is_vararg)];
  var $conv1=(($10)&255);
  var $11=$D_addr;
  _DumpChar($conv1, $11);
  var $12=$f_addr;
  var $maxstacksize=(($12+78)|0);
  var $13=HEAP8[($maxstacksize)];
  var $conv2=(($13)&255);
  var $14=$D_addr;
  _DumpChar($conv2, $14);
  var $15=$f_addr;
  var $code=(($15+12)|0);
  var $16=HEAP32[(($code)>>2)];
  var $17=$16;
  var $18=$f_addr;
  var $sizecode=(($18+48)|0);
  var $19=HEAP32[(($sizecode)>>2)];
  var $20=$D_addr;
  _DumpVector($17, $19, 4, $20);
  var $21=$f_addr;
  var $22=$D_addr;
  _DumpConstants($21, $22);
  var $23=$f_addr;
  var $24=$D_addr;
  _DumpUpvalues($23, $24);
  var $25=$f_addr;
  var $26=$D_addr;
  _DumpDebug($25, $26);

  Module.print(INDENT + 'Exiting: _DumpFunction');
  INDENT = INDENT.substr(0, INDENT.length-2);
  return;
  INDENT = INDENT.substr(0, INDENT.length-2);
}
_DumpFunction["X"]=1;

function _DumpInt($x, $D) {
  var label = 0;
  var __stackBase__  = STACKTOP; STACKTOP = (STACKTOP + 4)|0; _memset(__stackBase__, 0, 4);
  Module.print(INDENT + ' Entering: _DumpInt: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';

  var $x_addr=__stackBase__;
  var $D_addr;
  HEAP32[(($x_addr)>>2)]=$x;
  $D_addr=$D;
  var $0=$x_addr;
  var $1=$D_addr;
  _DumpBlock($0, 4, $1);
  STACKTOP = __stackBase__;
  Module.print(INDENT + 'Exiting: _DumpInt');
  INDENT = INDENT.substr(0, INDENT.length-2);
  return;
  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _DumpChar($y, $D) {
  var label = 0;
  var __stackBase__  = STACKTOP; STACKTOP = (STACKTOP + 4)|0; _memset(__stackBase__, 0, 4);
  Module.print(INDENT + ' Entering: _DumpChar: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';

  var $y_addr;
  var $D_addr;
  var $x=__stackBase__;
  $y_addr=$y;
  $D_addr=$D;
  var $0=$y_addr;
  var $conv=(($0) & 255);
  HEAP8[($x)]=$conv;
  var $1=$D_addr;
  _DumpBlock($x, 1, $1);
  STACKTOP = __stackBase__;
  Module.print(INDENT + 'Exiting: _DumpChar');
  INDENT = INDENT.substr(0, INDENT.length-2);
  return;
  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _DumpVector($b, $n, $size, $D) {
  var label = 0;

  Module.print(INDENT + ' Entering: _DumpVector: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';

  var $b_addr;
  var $n_addr;
  var $size_addr;
  var $D_addr;
  $b_addr=$b;
  $n_addr=$n;
  $size_addr=$size;
  $D_addr=$D;
  var $0=$n_addr;
  var $1=$D_addr;
  _DumpInt($0, $1);
  var $2=$b_addr;
  var $3=$n_addr;
  var $4=$size_addr;
  var $mul=Math.imul($3,$4);
  var $5=$D_addr;
  _DumpBlock($2, $mul, $5);

  Module.print(INDENT + 'Exiting: _DumpVector');
  INDENT = INDENT.substr(0, INDENT.length-2);
  return;
  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _DumpConstants($f, $D) {
  var label = 0;

  Module.print(INDENT + ' Entering: _DumpConstants: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $f_addr;
      var $D_addr;
      var $i;
      var $n;
      var $o;
      $f_addr=$f;
      $D_addr=$D;
      var $0=$f_addr;
      var $sizek=(($0+44)|0);
      var $1=HEAP32[(($sizek)>>2)];
      $n=$1;
      var $2=$n;
      var $3=$D_addr;
      _DumpInt($2, $3);
      $i=0;
      label = 3; break;
    case 3: 
      var $4=$i;
      var $5=$n;
      var $cmp=(($4)|0) < (($5)|0);
      if ($cmp) { label = 4; break; } else { label = 12; break; }
    case 4: 
      var $6=$i;
      var $7=$f_addr;
      var $k=(($7+8)|0);
      var $8=HEAP32[(($k)>>2)];
      var $arrayidx=(($8+((($6)*(12))&-1))|0);
      $o=$arrayidx;
      var $9=$o;
      var $tt_=(($9+8)|0);
      var $10=HEAP32[(($tt_)>>2)];
      var $and=$10 & 15;
      var $11=$D_addr;
      _DumpChar($and, $11);
      var $12=$o;
      var $tt_1=(($12+8)|0);
      var $13=HEAP32[(($tt_1)>>2)];
      var $and2=$13 & 15;
      if ((($and2)|0)==0) {
        label = 5; break;
      }
      else if ((($and2)|0)==1) {
        label = 6; break;
      }
      else if ((($and2)|0)==3) {
        label = 7; break;
      }
      else if ((($and2)|0)==4) {
        label = 8; break;
      }
      else {
      label = 9; break;
      }
      
    case 5: 
      label = 10; break;
    case 6: 
      var $14=$o;
      var $value_=(($14)|0);
      var $b=$value_;
      var $15=HEAP32[(($b)>>2)];
      var $16=$D_addr;
      _DumpChar($15, $16);
      label = 10; break;
    case 7: 
      var $17=$o;
      var $value_5=(($17)|0);
      var $n6=$value_5;
      var $18=(HEAP32[((tempDoublePtr)>>2)]=HEAP32[(($n6)>>2)],HEAP32[(((tempDoublePtr)+(4))>>2)]=HEAP32[((($n6)+(4))>>2)],HEAPF64[(tempDoublePtr)>>3]);
      var $19=$D_addr;
      _DumpNumber($18, $19);
      label = 10; break;
    case 8: 
      var $20=$o;
      var $value_8=(($20)|0);
      var $gc=$value_8;
      var $21=HEAP32[(($gc)>>2)];
      var $ts=$21;
      var $22=$D_addr;
      _DumpString($ts, $22);
      label = 10; break;
    case 9: 
      label = 10; break;
    case 10: 
      label = 11; break;
    case 11: 
      var $23=$i;
      var $inc=((($23)+(1))|0);
      $i=$inc;
      label = 3; break;
    case 12: 
      var $24=$f_addr;
      var $sizep=(($24+56)|0);
      var $25=HEAP32[(($sizep)>>2)];
      $n=$25;
      var $26=$n;
      var $27=$D_addr;
      _DumpInt($26, $27);
      $i=0;
      label = 13; break;
    case 13: 
      var $28=$i;
      var $29=$n;
      var $cmp10=(($28)|0) < (($29)|0);
      if ($cmp10) { label = 14; break; } else { label = 16; break; }
    case 14: 
      var $30=$i;
      var $31=$f_addr;
      var $p=(($31+16)|0);
      var $32=HEAP32[(($p)>>2)];
      var $arrayidx12=(($32+($30<<2))|0);
      var $33=HEAP32[(($arrayidx12)>>2)];
      var $34=$D_addr;
      _DumpFunction($33, $34);
      label = 15; break;
    case 15: 
      var $35=$i;
      var $inc14=((($35)+(1))|0);
      $i=$inc14;
      label = 13; break;
    case 16: 

      Module.print(INDENT + 'Exiting: _DumpConstants');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_DumpConstants["X"]=1;

function _DumpUpvalues($f, $D) {
  var label = 0;

  Module.print(INDENT + ' Entering: _DumpUpvalues: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $f_addr;
      var $D_addr;
      var $i;
      var $n;
      $f_addr=$f;
      $D_addr=$D;
      var $0=$f_addr;
      var $sizeupvalues=(($0+40)|0);
      var $1=HEAP32[(($sizeupvalues)>>2)];
      $n=$1;
      var $2=$n;
      var $3=$D_addr;
      _DumpInt($2, $3);
      $i=0;
      label = 3; break;
    case 3: 
      var $4=$i;
      var $5=$n;
      var $cmp=(($4)|0) < (($5)|0);
      if ($cmp) { label = 4; break; } else { label = 6; break; }
    case 4: 
      var $6=$i;
      var $7=$f_addr;
      var $upvalues=(($7+28)|0);
      var $8=HEAP32[(($upvalues)>>2)];
      var $arrayidx=(($8+($6<<3))|0);
      var $instack=(($arrayidx+4)|0);
      var $9=HEAP8[($instack)];
      var $conv=(($9)&255);
      var $10=$D_addr;
      _DumpChar($conv, $10);
      var $11=$i;
      var $12=$f_addr;
      var $upvalues1=(($12+28)|0);
      var $13=HEAP32[(($upvalues1)>>2)];
      var $arrayidx2=(($13+($11<<3))|0);
      var $idx=(($arrayidx2+5)|0);
      var $14=HEAP8[($idx)];
      var $conv3=(($14)&255);
      var $15=$D_addr;
      _DumpChar($conv3, $15);
      label = 5; break;
    case 5: 
      var $16=$i;
      var $inc=((($16)+(1))|0);
      $i=$inc;
      label = 3; break;
    case 6: 

      Module.print(INDENT + 'Exiting: _DumpUpvalues');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _DumpDebug($f, $D) {
  var label = 0;

  Module.print(INDENT + ' Entering: _DumpDebug: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $f_addr;
      var $D_addr;
      var $i;
      var $n;
      $f_addr=$f;
      $D_addr=$D;
      var $0=$D_addr;
      var $strip=(($0+12)|0);
      var $1=HEAP32[(($strip)>>2)];
      var $tobool=(($1)|0)!=0;
      if ($tobool) { label = 3; break; } else { label = 4; break; }
    case 3: 
      var $cond = 0;label = 5; break;
    case 4: 
      var $2=$f_addr;
      var $source=(($2+36)|0);
      var $3=HEAP32[(($source)>>2)];
      var $cond = $3;label = 5; break;
    case 5: 
      var $cond;
      var $4=$D_addr;
      _DumpString($cond, $4);
      var $5=$D_addr;
      var $strip1=(($5+12)|0);
      var $6=HEAP32[(($strip1)>>2)];
      var $tobool2=(($6)|0)!=0;
      if ($tobool2) { label = 6; break; } else { label = 7; break; }
    case 6: 
      var $cond6 = 0;label = 8; break;
    case 7: 
      var $7=$f_addr;
      var $sizelineinfo=(($7+52)|0);
      var $8=HEAP32[(($sizelineinfo)>>2)];
      var $cond6 = $8;label = 8; break;
    case 8: 
      var $cond6;
      $n=$cond6;
      var $9=$f_addr;
      var $lineinfo=(($9+20)|0);
      var $10=HEAP32[(($lineinfo)>>2)];
      var $11=$10;
      var $12=$n;
      var $13=$D_addr;
      _DumpVector($11, $12, 4, $13);
      var $14=$D_addr;
      var $strip7=(($14+12)|0);
      var $15=HEAP32[(($strip7)>>2)];
      var $tobool8=(($15)|0)!=0;
      if ($tobool8) { label = 9; break; } else { label = 10; break; }
    case 9: 
      var $cond12 = 0;label = 11; break;
    case 10: 
      var $16=$f_addr;
      var $sizelocvars=(($16+60)|0);
      var $17=HEAP32[(($sizelocvars)>>2)];
      var $cond12 = $17;label = 11; break;
    case 11: 
      var $cond12;
      $n=$cond12;
      var $18=$n;
      var $19=$D_addr;
      _DumpInt($18, $19);
      $i=0;
      label = 12; break;
    case 12: 
      var $20=$i;
      var $21=$n;
      var $cmp=(($20)|0) < (($21)|0);
      if ($cmp) { label = 13; break; } else { label = 15; break; }
    case 13: 
      var $22=$i;
      var $23=$f_addr;
      var $locvars=(($23+24)|0);
      var $24=HEAP32[(($locvars)>>2)];
      var $arrayidx=(($24+((($22)*(12))&-1))|0);
      var $varname=(($arrayidx)|0);
      var $25=HEAP32[(($varname)>>2)];
      var $26=$D_addr;
      _DumpString($25, $26);
      var $27=$i;
      var $28=$f_addr;
      var $locvars13=(($28+24)|0);
      var $29=HEAP32[(($locvars13)>>2)];
      var $arrayidx14=(($29+((($27)*(12))&-1))|0);
      var $startpc=(($arrayidx14+4)|0);
      var $30=HEAP32[(($startpc)>>2)];
      var $31=$D_addr;
      _DumpInt($30, $31);
      var $32=$i;
      var $33=$f_addr;
      var $locvars15=(($33+24)|0);
      var $34=HEAP32[(($locvars15)>>2)];
      var $arrayidx16=(($34+((($32)*(12))&-1))|0);
      var $endpc=(($arrayidx16+8)|0);
      var $35=HEAP32[(($endpc)>>2)];
      var $36=$D_addr;
      _DumpInt($35, $36);
      label = 14; break;
    case 14: 
      var $37=$i;
      var $inc=((($37)+(1))|0);
      $i=$inc;
      label = 12; break;
    case 15: 
      var $38=$D_addr;
      var $strip17=(($38+12)|0);
      var $39=HEAP32[(($strip17)>>2)];
      var $tobool18=(($39)|0)!=0;
      if ($tobool18) { label = 16; break; } else { label = 17; break; }
    case 16: 
      var $cond22 = 0;label = 18; break;
    case 17: 
      var $40=$f_addr;
      var $sizeupvalues=(($40+40)|0);
      var $41=HEAP32[(($sizeupvalues)>>2)];
      var $cond22 = $41;label = 18; break;
    case 18: 
      var $cond22;
      $n=$cond22;
      var $42=$n;
      var $43=$D_addr;
      _DumpInt($42, $43);
      $i=0;
      label = 19; break;
    case 19: 
      var $44=$i;
      var $45=$n;
      var $cmp24=(($44)|0) < (($45)|0);
      if ($cmp24) { label = 20; break; } else { label = 22; break; }
    case 20: 
      var $46=$i;
      var $47=$f_addr;
      var $upvalues=(($47+28)|0);
      var $48=HEAP32[(($upvalues)>>2)];
      var $arrayidx26=(($48+($46<<3))|0);
      var $name=(($arrayidx26)|0);
      var $49=HEAP32[(($name)>>2)];
      var $50=$D_addr;
      _DumpString($49, $50);
      label = 21; break;
    case 21: 
      var $51=$i;
      var $inc28=((($51)+(1))|0);
      $i=$inc28;
      label = 19; break;
    case 22: 

      Module.print(INDENT + 'Exiting: _DumpDebug');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_DumpDebug["X"]=1;

function _DumpString($s, $D) {
  var label = 0;
  var __stackBase__  = STACKTOP; STACKTOP = (STACKTOP + 8)|0; _memset(__stackBase__, 0, 8);
  Module.print(INDENT + ' Entering: _DumpString: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $s_addr;
      var $D_addr;
      var $size=__stackBase__;
      var $size1=(__stackBase__)+(4);
      $s_addr=$s;
      $D_addr=$D;
      var $0=$s_addr;
      var $cmp=(($0)|0)==0;
      if ($cmp) { label = 3; break; } else { label = 4; break; }
    case 3: 
      HEAP32[(($size)>>2)]=0;
      var $1=$size;
      var $2=$D_addr;
      _DumpBlock($1, 4, $2);
      label = 5; break;
    case 4: 
      var $3=$s_addr;
      var $tsv=$3;
      var $len=(($tsv+12)|0);
      var $4=HEAP32[(($len)>>2)];
      var $add=((($4)+(1))|0);
      HEAP32[(($size1)>>2)]=$add;
      var $5=$size1;
      var $6=$D_addr;
      _DumpBlock($5, 4, $6);
      var $7=$s_addr;
      var $add_ptr=(($7+16)|0);
      var $8=$add_ptr;
      var $9=HEAP32[(($size1)>>2)];
      var $mul=$9;
      var $10=$D_addr;
      _DumpBlock($8, $mul, $10);
      label = 5; break;
    case 5: 
      STACKTOP = __stackBase__;
      Module.print(INDENT + 'Exiting: _DumpString');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _DumpBlock($b, $size, $D) {
  var label = 0;

  Module.print(INDENT + ' Entering: _DumpBlock: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $b_addr;
      var $size_addr;
      var $D_addr;
      $b_addr=$b;
      $size_addr=$size;
      $D_addr=$D;
      var $0=$D_addr;
      var $status=(($0+16)|0);
      var $1=HEAP32[(($status)>>2)];
      var $cmp=(($1)|0)==0;
      if ($cmp) { label = 3; break; } else { label = 4; break; }
    case 3: 
      var $2=$D_addr;
      var $writer=(($2+4)|0);
      var $3=HEAP32[(($writer)>>2)];
      var $4=$D_addr;
      var $L=(($4)|0);
      var $5=HEAP32[(($L)>>2)];
      var $6=$b_addr;
      var $7=$size_addr;
      var $8=$D_addr;
      var $data=(($8+8)|0);
      var $9=HEAP32[(($data)>>2)];
      var $call=FUNCTION_TABLE[$3]($5, $6, $7, $9);
      var $10=$D_addr;
      var $status1=(($10+16)|0);
      HEAP32[(($status1)>>2)]=$call;
      label = 4; break;
    case 4: 

      Module.print(INDENT + 'Exiting: _DumpBlock');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _DumpNumber($x, $D) {
  var label = 0;
  var __stackBase__  = STACKTOP; STACKTOP = (STACKTOP + 8)|0; _memset(__stackBase__, 0, 8);
  Module.print(INDENT + ' Entering: _DumpNumber: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';

  var $x_addr=__stackBase__;
  var $D_addr;
  (HEAPF64[(tempDoublePtr)>>3]=$x,HEAP32[(($x_addr)>>2)]=HEAP32[((tempDoublePtr)>>2)],HEAP32[((($x_addr)+(4))>>2)]=HEAP32[(((tempDoublePtr)+(4))>>2)]);
  $D_addr=$D;
  var $0=$x_addr;
  var $1=$D_addr;
  _DumpBlock($0, 8, $1);
  STACKTOP = __stackBase__;
  Module.print(INDENT + 'Exiting: _DumpNumber');
  INDENT = INDENT.substr(0, INDENT.length-2);
  return;
  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _checkmode($L, $mode, $x) {
  var label = 0;
  var __stackBase__  = STACKTOP; _memset(__stackBase__, 0, 0);
  Module.print(INDENT + ' Entering: _checkmode: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $L_addr;
      var $mode_addr;
      var $x_addr;
      $L_addr=$L;
      $mode_addr=$mode;
      $x_addr=$x;
      var $0=$mode_addr;
      var $tobool=(($0)|0)!=0;
      if ($tobool) { label = 3; break; } else { label = 5; break; }
    case 3: 
      var $1=$mode_addr;
      var $2=$x_addr;
      var $arrayidx=(($2)|0);
      var $3=HEAP8[($arrayidx)];
      var $conv=(($3 << 24) >> 24);
      var $call=_strchr($1, $conv);
      var $cmp=(($call)|0)==0;
      if ($cmp) { label = 4; break; } else { label = 5; break; }
    case 4: 
      var $4=$L_addr;
      var $5=$x_addr;
      var $6=$mode_addr;
      var $call2=_luaO_pushfstring($4, ((5244356)|0), (tempInt=STACKTOP,_memset(STACKTOP, 0, 8),STACKTOP = (STACKTOP + 8)|0,HEAP32[((tempInt)>>2)]=$5,HEAP32[(((tempInt)+(4))>>2)]=$6,tempInt));
      var $7=$L_addr;
      _luaD_throw($7, 3);

    case 5: 
      STACKTOP = __stackBase__;
      Module.print(INDENT + 'Exiting: _checkmode');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _resume_error($L, $msg, $firstArg) {
  var label = 0;

  Module.print(INDENT + ' Entering: _resume_error: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $L_addr;
      var $msg_addr;
      var $firstArg_addr;
      var $io;
      var $x_;
      $L_addr=$L;
      $msg_addr=$msg;
      $firstArg_addr=$firstArg;
      var $0=$firstArg_addr;
      var $1=$L_addr;
      var $top=(($1+8)|0);
      HEAP32[(($top)>>2)]=$0;
      var $2=$L_addr;
      var $top1=(($2+8)|0);
      var $3=HEAP32[(($top1)>>2)];
      $io=$3;
      var $4=$L_addr;
      var $5=$msg_addr;
      var $call=_luaS_new($4, $5);
      $x_=$call;
      var $6=$x_;
      var $7=$6;
      var $8=$io;
      var $value_=(($8)|0);
      var $gc=$value_;
      HEAP32[(($gc)>>2)]=$7;
      var $9=$x_;
      var $tsv=$9;
      var $tt=(($tsv+4)|0);
      var $10=HEAP8[($tt)];
      var $conv=(($10)&255);
      var $or=$conv | 64;
      var $11=$io;
      var $tt_=(($11+8)|0);
      HEAP32[(($tt_)>>2)]=$or;
      var $12=$L_addr;
      var $top2=(($12+8)|0);
      var $13=HEAP32[(($top2)>>2)];
      var $incdec_ptr=(($13+12)|0);
      HEAP32[(($top2)>>2)]=$incdec_ptr;
      var $14=$L_addr;
      var $stack_last=(($14+24)|0);
      var $15=HEAP32[(($stack_last)>>2)];
      var $16=$L_addr;
      var $top3=(($16+8)|0);
      var $17=HEAP32[(($top3)>>2)];
      var $sub_ptr_lhs_cast=$15;
      var $sub_ptr_rhs_cast=$17;
      var $sub_ptr_sub=((($sub_ptr_lhs_cast)-($sub_ptr_rhs_cast))|0);
      var $sub_ptr_div=((((($sub_ptr_sub)|0))/(12))&-1);
      var $cmp=(($sub_ptr_div)|0) <= 0;
      if ($cmp) { label = 3; break; } else { label = 4; break; }
    case 3: 
      var $18=$L_addr;
      _luaD_growstack($18, 0);
      label = 5; break;
    case 4: 
      label = 5; break;
    case 5: 
      var $19=$L_addr;
      _luaD_throw($19, -1);

    case 6: 

      Module.print(INDENT + 'Exiting: _resume_error');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_resume_error["X"]=1;

function _unlinkupval($uv) {
  var label = 0;

  Module.print(INDENT + ' Entering: _unlinkupval: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';

  var $uv_addr;
  $uv_addr=$uv;
  var $0=$uv_addr;
  var $u=(($0+12)|0);
  var $l=$u;
  var $prev=(($l)|0);
  var $1=HEAP32[(($prev)>>2)];
  var $2=$uv_addr;
  var $u1=(($2+12)|0);
  var $l2=$u1;
  var $next=(($l2+4)|0);
  var $3=HEAP32[(($next)>>2)];
  var $u3=(($3+12)|0);
  var $l4=$u3;
  var $prev5=(($l4)|0);
  HEAP32[(($prev5)>>2)]=$1;
  var $4=$uv_addr;
  var $u6=(($4+12)|0);
  var $l7=$u6;
  var $next8=(($l7+4)|0);
  var $5=HEAP32[(($next8)>>2)];
  var $6=$uv_addr;
  var $u9=(($6+12)|0);
  var $l10=$u9;
  var $prev11=(($l10)|0);
  var $7=HEAP32[(($prev11)>>2)];
  var $u12=(($7+12)|0);
  var $l13=$u12;
  var $next14=(($l13+4)|0);
  HEAP32[(($next14)>>2)]=$5;

  Module.print(INDENT + 'Exiting: _unlinkupval');
  INDENT = INDENT.substr(0, INDENT.length-2);
  return;
  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _luaF_getlocalname($f, $local_number, $pc) {
  var label = 0;

  Module.print(INDENT + ' Entering: _luaF_getlocalname: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $retval;
      var $f_addr;
      var $local_number_addr;
      var $pc_addr;
      var $i;
      $f_addr=$f;
      $local_number_addr=$local_number;
      $pc_addr=$pc;
      $i=0;
      label = 3; break;
    case 3: 
      var $0=$i;
      var $1=$f_addr;
      var $sizelocvars=(($1+60)|0);
      var $2=HEAP32[(($sizelocvars)>>2)];
      var $cmp=(($0)|0) < (($2)|0);
      if ($cmp) { label = 4; break; } else { var $8 = 0;label = 5; break; }
    case 4: 
      var $3=$i;
      var $4=$f_addr;
      var $locvars=(($4+24)|0);
      var $5=HEAP32[(($locvars)>>2)];
      var $arrayidx=(($5+((($3)*(12))&-1))|0);
      var $startpc=(($arrayidx+4)|0);
      var $6=HEAP32[(($startpc)>>2)];
      var $7=$pc_addr;
      var $cmp1=(($6)|0) <= (($7)|0);
      var $8 = $cmp1;label = 5; break;
    case 5: 
      var $8;
      if ($8) { label = 6; break; } else { label = 12; break; }
    case 6: 
      var $9=$pc_addr;
      var $10=$i;
      var $11=$f_addr;
      var $locvars2=(($11+24)|0);
      var $12=HEAP32[(($locvars2)>>2)];
      var $arrayidx3=(($12+((($10)*(12))&-1))|0);
      var $endpc=(($arrayidx3+8)|0);
      var $13=HEAP32[(($endpc)>>2)];
      var $cmp4=(($9)|0) < (($13)|0);
      if ($cmp4) { label = 7; break; } else { label = 10; break; }
    case 7: 
      var $14=$local_number_addr;
      var $dec=((($14)-(1))|0);
      $local_number_addr=$dec;
      var $15=$local_number_addr;
      var $cmp5=(($15)|0)==0;
      if ($cmp5) { label = 8; break; } else { label = 9; break; }
    case 8: 
      var $16=$i;
      var $17=$f_addr;
      var $locvars7=(($17+24)|0);
      var $18=HEAP32[(($locvars7)>>2)];
      var $arrayidx8=(($18+((($16)*(12))&-1))|0);
      var $varname=(($arrayidx8)|0);
      var $19=HEAP32[(($varname)>>2)];
      var $add_ptr=(($19+16)|0);
      var $20=$add_ptr;
      $retval=$20;
      label = 13; break;
    case 9: 
      label = 10; break;
    case 10: 
      label = 11; break;
    case 11: 
      var $21=$i;
      var $inc=((($21)+(1))|0);
      $i=$inc;
      label = 3; break;
    case 12: 
      $retval=0;
      label = 13; break;
    case 13: 
      var $22=$retval;

      Module.print(INDENT + 'Exiting: _luaF_getlocalname');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return $22;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_luaF_getlocalname["X"]=1;

function _luaF_newCclosure($L, $n) {
  var label = 0;

  Module.print(INDENT + ' Entering: _luaF_newCclosure: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';

  var $L_addr;
  var $n_addr;
  var $c;
  $L_addr=$L;
  $n_addr=$n;
  var $0=$L_addr;
  var $1=$n_addr;
  var $sub=((($1)-(1))|0);
  var $mul=((($sub)*(12))&-1);
  var $add=((($mul)+(28))|0);
  var $call=_luaC_newobj($0, 38, $add, 0, 0);
  var $cl=$call;
  $c=$cl;
  var $2=$n_addr;
  var $conv=(($2) & 255);
  var $3=$c;
  var $c1=$3;
  var $nupvalues=(($c1+6)|0);
  HEAP8[($nupvalues)]=$conv;
  var $4=$c;

  Module.print(INDENT + 'Exiting: _luaF_newCclosure');
  INDENT = INDENT.substr(0, INDENT.length-2);
  return $4;
  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _luaF_newLclosure($L, $n) {
  var label = 0;

  Module.print(INDENT + ' Entering: _luaF_newLclosure: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $L_addr;
      var $n_addr;
      var $c;
      $L_addr=$L;
      $n_addr=$n;
      var $0=$L_addr;
      var $1=$n_addr;
      var $sub=((($1)-(1))|0);
      var $mul=($sub<<2);
      var $add=((($mul)+(20))|0);
      var $call=_luaC_newobj($0, 6, $add, 0, 0);
      var $cl=$call;
      $c=$cl;
      var $2=$c;
      var $l=$2;
      var $p=(($l+12)|0);
      HEAP32[(($p)>>2)]=0;
      var $3=$n_addr;
      var $conv=(($3) & 255);
      var $4=$c;
      var $l1=$4;
      var $nupvalues=(($l1+6)|0);
      HEAP8[($nupvalues)]=$conv;
      label = 3; break;
    case 3: 
      var $5=$n_addr;
      var $dec=((($5)-(1))|0);
      $n_addr=$dec;
      var $tobool=(($5)|0)!=0;
      if ($tobool) { label = 4; break; } else { label = 5; break; }
    case 4: 
      var $6=$n_addr;
      var $7=$c;
      var $l2=$7;
      var $upvals=(($l2+16)|0);
      var $arrayidx=(($upvals+($6<<2))|0);
      HEAP32[(($arrayidx)>>2)]=0;
      label = 3; break;
    case 5: 
      var $8=$c;

      Module.print(INDENT + 'Exiting: _luaF_newLclosure');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return $8;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _luaF_newupval($L) {
  var label = 0;

  Module.print(INDENT + ' Entering: _luaF_newupval: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';

  var $L_addr;
  var $uv;
  $L_addr=$L;
  var $0=$L_addr;
  var $call=_luaC_newobj($0, 10, 24, 0, 0);
  var $uv1=$call;
  $uv=$uv1;
  var $1=$uv;
  var $u=(($1+12)|0);
  var $value=$u;
  var $2=$uv;
  var $v=(($2+8)|0);
  HEAP32[(($v)>>2)]=$value;
  var $3=$uv;
  var $v2=(($3+8)|0);
  var $4=HEAP32[(($v2)>>2)];
  var $tt_=(($4+8)|0);
  HEAP32[(($tt_)>>2)]=0;
  var $5=$uv;

  Module.print(INDENT + 'Exiting: _luaF_newupval');
  INDENT = INDENT.substr(0, INDENT.length-2);
  return $5;
  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _luaF_findupval($L, $level) {
  var label = 0;

  Module.print(INDENT + ' Entering: _luaF_findupval: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $retval;
      var $L_addr;
      var $level_addr;
      var $g;
      var $pp;
      var $p;
      var $uv;
      var $o;
      $L_addr=$L;
      $level_addr=$level;
      var $0=$L_addr;
      var $l_G=(($0+12)|0);
      var $1=HEAP32[(($l_G)>>2)];
      $g=$1;
      var $2=$L_addr;
      var $openupval=(($2+56)|0);
      $pp=$openupval;
      label = 3; break;
    case 3: 
      var $3=$pp;
      var $4=HEAP32[(($3)>>2)];
      var $cmp=(($4)|0)!=0;
      if ($cmp) { label = 4; break; } else { var $9 = 0;label = 5; break; }
    case 4: 
      var $5=$pp;
      var $6=HEAP32[(($5)>>2)];
      var $uv1=$6;
      $p=$uv1;
      var $v=(($uv1+8)|0);
      var $7=HEAP32[(($v)>>2)];
      var $8=$level_addr;
      var $cmp2=(($7)>>>0) >= (($8)>>>0);
      var $9 = $cmp2;label = 5; break;
    case 5: 
      var $9;
      if ($9) { label = 6; break; } else { label = 11; break; }
    case 6: 
      var $10=$p;
      var $11=$10;
      $o=$11;
      var $12=$p;
      var $v3=(($12+8)|0);
      var $13=HEAP32[(($v3)>>2)];
      var $14=$level_addr;
      var $cmp4=(($13)|0)==(($14)|0);
      if ($cmp4) { label = 7; break; } else { label = 10; break; }
    case 7: 
      var $15=$o;
      var $gch=$15;
      var $marked=(($gch+5)|0);
      var $16=HEAP8[($marked)];
      var $conv=(($16)&255);
      var $xor=$conv ^ 3;
      var $17=$g;
      var $currentwhite=(($17+52)|0);
      var $18=HEAP8[($currentwhite)];
      var $conv5=(($18)&255);
      var $xor6=$conv5 ^ 3;
      var $and=$xor & $xor6;
      var $tobool=(($and)|0)!=0;
      if ($tobool) { label = 9; break; } else { label = 8; break; }
    case 8: 
      var $19=$o;
      var $gch8=$19;
      var $marked9=(($gch8+5)|0);
      var $20=HEAP8[($marked9)];
      var $conv10=(($20)&255);
      var $xor11=$conv10 ^ 3;
      var $conv12=(($xor11) & 255);
      HEAP8[($marked9)]=$conv12;
      label = 9; break;
    case 9: 
      var $21=$p;
      $retval=$21;
      label = 12; break;
    case 10: 
      var $22=$o;
      var $gch14=$22;
      var $marked15=(($gch14+5)|0);
      var $23=HEAP8[($marked15)];
      var $conv16=(($23)&255);
      var $and17=$conv16 & 191;
      var $conv18=(($and17) & 255);
      HEAP8[($marked15)]=$conv18;
      var $24=$p;
      var $next=(($24)|0);
      $pp=$next;
      label = 3; break;
    case 11: 
      var $25=$L_addr;
      var $26=$pp;
      var $call=_luaC_newobj($25, 10, 24, $26, 0);
      var $uv19=$call;
      $uv=$uv19;
      var $27=$level_addr;
      var $28=$uv;
      var $v20=(($28+8)|0);
      HEAP32[(($v20)>>2)]=$27;
      var $29=$g;
      var $uvhead=(($29+100)|0);
      var $30=$uv;
      var $u=(($30+12)|0);
      var $l=$u;
      var $prev=(($l)|0);
      HEAP32[(($prev)>>2)]=$uvhead;
      var $31=$g;
      var $uvhead21=(($31+100)|0);
      var $u22=(($uvhead21+12)|0);
      var $l23=$u22;
      var $next24=(($l23+4)|0);
      var $32=HEAP32[(($next24)>>2)];
      var $33=$uv;
      var $u25=(($33+12)|0);
      var $l26=$u25;
      var $next27=(($l26+4)|0);
      HEAP32[(($next27)>>2)]=$32;
      var $34=$uv;
      var $35=$uv;
      var $u28=(($35+12)|0);
      var $l29=$u28;
      var $next30=(($l29+4)|0);
      var $36=HEAP32[(($next30)>>2)];
      var $u31=(($36+12)|0);
      var $l32=$u31;
      var $prev33=(($l32)|0);
      HEAP32[(($prev33)>>2)]=$34;
      var $37=$uv;
      var $38=$g;
      var $uvhead34=(($38+100)|0);
      var $u35=(($uvhead34+12)|0);
      var $l36=$u35;
      var $next37=(($l36+4)|0);
      HEAP32[(($next37)>>2)]=$37;
      var $39=$uv;
      $retval=$39;
      label = 12; break;
    case 12: 
      var $40=$retval;

      Module.print(INDENT + 'Exiting: _luaF_findupval');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return $40;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_luaF_findupval["X"]=1;

function _luaF_freeupval($L, $uv) {
  var label = 0;

  Module.print(INDENT + ' Entering: _luaF_freeupval: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $L_addr;
      var $uv_addr;
      $L_addr=$L;
      $uv_addr=$uv;
      var $0=$uv_addr;
      var $v=(($0+8)|0);
      var $1=HEAP32[(($v)>>2)];
      var $2=$uv_addr;
      var $u=(($2+12)|0);
      var $value=$u;
      var $cmp=(($1)|0)!=(($value)|0);
      if ($cmp) { label = 3; break; } else { label = 4; break; }
    case 3: 
      var $3=$uv_addr;
      _unlinkupval($3);
      label = 4; break;
    case 4: 
      var $4=$L_addr;
      var $5=$uv_addr;
      var $6=$5;
      var $call=_luaM_realloc_($4, $6, 24, 0);

      Module.print(INDENT + 'Exiting: _luaF_freeupval');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _luaF_close($L, $level) {
  var label = 0;

  Module.print(INDENT + ' Entering: _luaF_close: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $L_addr;
      var $level_addr;
      var $uv;
      var $g;
      var $o;
      var $io2;
      var $io1;
      $L_addr=$L;
      $level_addr=$level;
      var $0=$L_addr;
      var $l_G=(($0+12)|0);
      var $1=HEAP32[(($l_G)>>2)];
      $g=$1;
      label = 3; break;
    case 3: 
      var $2=$L_addr;
      var $openupval=(($2+56)|0);
      var $3=HEAP32[(($openupval)>>2)];
      var $cmp=(($3)|0)!=0;
      if ($cmp) { label = 4; break; } else { var $8 = 0;label = 5; break; }
    case 4: 
      var $4=$L_addr;
      var $openupval1=(($4+56)|0);
      var $5=HEAP32[(($openupval1)>>2)];
      var $uv2=$5;
      $uv=$uv2;
      var $v=(($uv2+8)|0);
      var $6=HEAP32[(($v)>>2)];
      var $7=$level_addr;
      var $cmp3=(($6)>>>0) >= (($7)>>>0);
      var $8 = $cmp3;label = 5; break;
    case 5: 
      var $8;
      if ($8) { label = 6; break; } else { label = 10; break; }
    case 6: 
      var $9=$uv;
      var $10=$9;
      $o=$10;
      var $11=$uv;
      var $next=(($11)|0);
      var $12=HEAP32[(($next)>>2)];
      var $13=$L_addr;
      var $openupval4=(($13+56)|0);
      HEAP32[(($openupval4)>>2)]=$12;
      var $14=$o;
      var $gch=$14;
      var $marked=(($gch+5)|0);
      var $15=HEAP8[($marked)];
      var $conv=(($15)&255);
      var $xor=$conv ^ 3;
      var $16=$g;
      var $currentwhite=(($16+52)|0);
      var $17=HEAP8[($currentwhite)];
      var $conv5=(($17)&255);
      var $xor6=$conv5 ^ 3;
      var $and=$xor & $xor6;
      var $tobool=(($and)|0)!=0;
      if ($tobool) { label = 8; break; } else { label = 7; break; }
    case 7: 
      var $18=$L_addr;
      var $19=$uv;
      _luaF_freeupval($18, $19);
      label = 9; break;
    case 8: 
      var $20=$uv;
      _unlinkupval($20);
      var $21=$uv;
      var $v7=(($21+8)|0);
      var $22=HEAP32[(($v7)>>2)];
      $io2=$22;
      var $23=$uv;
      var $u=(($23+12)|0);
      var $value=$u;
      $io1=$value;
      var $24=$io1;
      var $value_=(($24)|0);
      var $25=$io2;
      var $value_8=(($25)|0);
      var $26=$value_;
      var $27=$value_8;
      HEAP32[(($26)>>2)]=HEAP32[(($27)>>2)];HEAP32[((($26)+(4))>>2)]=HEAP32[((($27)+(4))>>2)];
      var $28=$io2;
      var $tt_=(($28+8)|0);
      var $29=HEAP32[(($tt_)>>2)];
      var $30=$io1;
      var $tt_9=(($30+8)|0);
      HEAP32[(($tt_9)>>2)]=$29;
      var $31=$uv;
      var $u10=(($31+12)|0);
      var $value11=$u10;
      var $32=$uv;
      var $v12=(($32+8)|0);
      HEAP32[(($v12)>>2)]=$value11;
      var $33=$g;
      var $allgc=(($33+60)|0);
      var $34=HEAP32[(($allgc)>>2)];
      var $35=$o;
      var $gch13=$35;
      var $next14=(($gch13)|0);
      HEAP32[(($next14)>>2)]=$34;
      var $36=$o;
      var $37=$g;
      var $allgc15=(($37+60)|0);
      HEAP32[(($allgc15)>>2)]=$36;
      var $38=$g;
      var $39=$uv;
      _luaC_checkupvalcolor($38, $39);
      label = 9; break;
    case 9: 
      label = 3; break;
    case 10: 

      Module.print(INDENT + 'Exiting: _luaF_close');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_luaF_close["X"]=1;

function _luaF_newproto($L) {
  var label = 0;

  Module.print(INDENT + ' Entering: _luaF_newproto: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';

  var $L_addr;
  var $f;
  $L_addr=$L;
  var $0=$L_addr;
  var $call=_luaC_newobj($0, 9, 80, 0, 0);
  var $p=$call;
  $f=$p;
  var $1=$f;
  var $k=(($1+8)|0);
  HEAP32[(($k)>>2)]=0;
  var $2=$f;
  var $sizek=(($2+44)|0);
  HEAP32[(($sizek)>>2)]=0;
  var $3=$f;
  var $p1=(($3+16)|0);
  HEAP32[(($p1)>>2)]=0;
  var $4=$f;
  var $sizep=(($4+56)|0);
  HEAP32[(($sizep)>>2)]=0;
  var $5=$f;
  var $code=(($5+12)|0);
  HEAP32[(($code)>>2)]=0;
  var $6=$f;
  var $cache=(($6+32)|0);
  HEAP32[(($cache)>>2)]=0;
  var $7=$f;
  var $sizecode=(($7+48)|0);
  HEAP32[(($sizecode)>>2)]=0;
  var $8=$f;
  var $lineinfo=(($8+20)|0);
  HEAP32[(($lineinfo)>>2)]=0;
  var $9=$f;
  var $sizelineinfo=(($9+52)|0);
  HEAP32[(($sizelineinfo)>>2)]=0;
  var $10=$f;
  var $upvalues=(($10+28)|0);
  HEAP32[(($upvalues)>>2)]=0;
  var $11=$f;
  var $sizeupvalues=(($11+40)|0);
  HEAP32[(($sizeupvalues)>>2)]=0;
  var $12=$f;
  var $numparams=(($12+76)|0);
  HEAP8[($numparams)]=0;
  var $13=$f;
  var $is_vararg=(($13+77)|0);
  HEAP8[($is_vararg)]=0;
  var $14=$f;
  var $maxstacksize=(($14+78)|0);
  HEAP8[($maxstacksize)]=0;
  var $15=$f;
  var $locvars=(($15+24)|0);
  HEAP32[(($locvars)>>2)]=0;
  var $16=$f;
  var $sizelocvars=(($16+60)|0);
  HEAP32[(($sizelocvars)>>2)]=0;
  var $17=$f;
  var $linedefined=(($17+64)|0);
  HEAP32[(($linedefined)>>2)]=0;
  var $18=$f;
  var $lastlinedefined=(($18+68)|0);
  HEAP32[(($lastlinedefined)>>2)]=0;
  var $19=$f;
  var $source=(($19+36)|0);
  HEAP32[(($source)>>2)]=0;
  var $20=$f;

  Module.print(INDENT + 'Exiting: _luaF_newproto');
  INDENT = INDENT.substr(0, INDENT.length-2);
  return $20;
  INDENT = INDENT.substr(0, INDENT.length-2);
}
_luaF_newproto["X"]=1;

function _luaF_freeproto($L, $f) {
  var label = 0;

  Module.print(INDENT + ' Entering: _luaF_freeproto: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';

  var $L_addr;
  var $f_addr;
  $L_addr=$L;
  $f_addr=$f;
  var $0=$L_addr;
  var $1=$f_addr;
  var $code=(($1+12)|0);
  var $2=HEAP32[(($code)>>2)];
  var $3=$2;
  var $4=$f_addr;
  var $sizecode=(($4+48)|0);
  var $5=HEAP32[(($sizecode)>>2)];
  var $mul=($5<<2);
  var $call=_luaM_realloc_($0, $3, $mul, 0);
  var $6=$L_addr;
  var $7=$f_addr;
  var $p=(($7+16)|0);
  var $8=HEAP32[(($p)>>2)];
  var $9=$8;
  var $10=$f_addr;
  var $sizep=(($10+56)|0);
  var $11=HEAP32[(($sizep)>>2)];
  var $mul1=($11<<2);
  var $call2=_luaM_realloc_($6, $9, $mul1, 0);
  var $12=$L_addr;
  var $13=$f_addr;
  var $k=(($13+8)|0);
  var $14=HEAP32[(($k)>>2)];
  var $15=$14;
  var $16=$f_addr;
  var $sizek=(($16+44)|0);
  var $17=HEAP32[(($sizek)>>2)];
  var $mul3=((($17)*(12))&-1);
  var $call4=_luaM_realloc_($12, $15, $mul3, 0);
  var $18=$L_addr;
  var $19=$f_addr;
  var $lineinfo=(($19+20)|0);
  var $20=HEAP32[(($lineinfo)>>2)];
  var $21=$20;
  var $22=$f_addr;
  var $sizelineinfo=(($22+52)|0);
  var $23=HEAP32[(($sizelineinfo)>>2)];
  var $mul5=($23<<2);
  var $call6=_luaM_realloc_($18, $21, $mul5, 0);
  var $24=$L_addr;
  var $25=$f_addr;
  var $locvars=(($25+24)|0);
  var $26=HEAP32[(($locvars)>>2)];
  var $27=$26;
  var $28=$f_addr;
  var $sizelocvars=(($28+60)|0);
  var $29=HEAP32[(($sizelocvars)>>2)];
  var $mul7=((($29)*(12))&-1);
  var $call8=_luaM_realloc_($24, $27, $mul7, 0);
  var $30=$L_addr;
  var $31=$f_addr;
  var $upvalues=(($31+28)|0);
  var $32=HEAP32[(($upvalues)>>2)];
  var $33=$32;
  var $34=$f_addr;
  var $sizeupvalues=(($34+40)|0);
  var $35=HEAP32[(($sizeupvalues)>>2)];
  var $mul9=($35<<3);
  var $call10=_luaM_realloc_($30, $33, $mul9, 0);
  var $36=$L_addr;
  var $37=$f_addr;
  var $38=$37;
  var $call11=_luaM_realloc_($36, $38, 80, 0);

  Module.print(INDENT + 'Exiting: _luaF_freeproto');
  INDENT = INDENT.substr(0, INDENT.length-2);
  return;
  INDENT = INDENT.substr(0, INDENT.length-2);
}
_luaF_freeproto["X"]=1;

function _luaC_barrier_($L, $o, $v) {
  var label = 0;

  Module.print(INDENT + ' Entering: _luaC_barrier_: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $L_addr;
      var $o_addr;
      var $v_addr;
      var $g;
      $L_addr=$L;
      $o_addr=$o;
      $v_addr=$v;
      var $0=$L_addr;
      var $l_G=(($0+12)|0);
      var $1=HEAP32[(($l_G)>>2)];
      $g=$1;
      var $2=$g;
      var $gckind=(($2+54)|0);
      var $3=HEAP8[($gckind)];
      var $conv=(($3)&255);
      var $cmp=(($conv)|0)==2;
      if ($cmp) { label = 4; break; } else { label = 3; break; }
    case 3: 
      var $4=$g;
      var $gcstate=(($4+53)|0);
      var $5=HEAP8[($gcstate)];
      var $conv2=(($5)&255);
      var $cmp3=(($conv2)|0) <= 1;
      if ($cmp3) { label = 4; break; } else { label = 5; break; }
    case 4: 
      var $6=$g;
      var $7=$v_addr;
      _reallymarkobject($6, $7);
      label = 6; break;
    case 5: 
      var $8=$o_addr;
      var $gch=$8;
      var $marked=(($gch+5)|0);
      var $9=HEAP8[($marked)];
      var $conv5=(($9)&255);
      var $and=$conv5 & -72;
      var $10=$g;
      var $currentwhite=(($10+52)|0);
      var $11=HEAP8[($currentwhite)];
      var $conv6=(($11)&255);
      var $and7=$conv6 & 3;
      var $conv8=(($and7) & 255);
      var $conv9=(($conv8)&255);
      var $or=$and | $conv9;
      var $conv10=(($or) & 255);
      var $12=$o_addr;
      var $gch11=$12;
      var $marked12=(($gch11+5)|0);
      HEAP8[($marked12)]=$conv10;
      label = 6; break;
    case 6: 

      Module.print(INDENT + 'Exiting: _luaC_barrier_');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _reallymarkobject($g, $o) {
  var label = 0;

  Module.print(INDENT + ' Entering: _reallymarkobject: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $g_addr;
      var $o_addr;
      var $size;
      var $mt;
      var $uv33;
      $g_addr=$g;
      $o_addr=$o;
      var $0=$o_addr;
      var $gch=$0;
      var $marked=(($gch+5)|0);
      var $1=HEAP8[($marked)];
      var $conv=(($1)&255);
      var $and=$conv & 252;
      var $conv1=(($and) & 255);
      HEAP8[($marked)]=$conv1;
      var $2=$o_addr;
      var $gch2=$2;
      var $tt=(($gch2+4)|0);
      var $3=HEAP8[($tt)];
      var $conv3=(($3)&255);
      if ((($conv3)|0)==4 | (($conv3)|0)==20) {
        label = 3; break;
      }
      else if ((($conv3)|0)==7) {
        label = 4; break;
      }
      else if ((($conv3)|0)==10) {
        label = 11; break;
      }
      else if ((($conv3)|0)==6) {
        label = 17; break;
      }
      else if ((($conv3)|0)==38) {
        label = 18; break;
      }
      else if ((($conv3)|0)==5) {
        label = 19; break;
      }
      else if ((($conv3)|0)==8) {
        label = 20; break;
      }
      else if ((($conv3)|0)==9) {
        label = 21; break;
      }
      else {
      label = 22; break;
      }
      
    case 3: 
      var $4=$o_addr;
      var $ts=$4;
      var $tsv=$ts;
      var $len=(($tsv+12)|0);
      var $5=HEAP32[(($len)>>2)];
      var $add=((($5)+(1))|0);
      var $mul=$add;
      var $add4=((($mul)+(16))|0);
      $size=$add4;
      label = 23; break;
    case 4: 
      var $6=$o_addr;
      var $u=$6;
      var $uv=$u;
      var $metatable=(($uv+8)|0);
      var $7=HEAP32[(($metatable)>>2)];
      $mt=$7;
      var $8=$mt;
      var $tobool=(($8)|0)!=0;
      if ($tobool) { label = 5; break; } else { label = 7; break; }
    case 5: 
      var $9=$mt;
      var $10=$9;
      var $gch6=$10;
      var $marked7=(($gch6+5)|0);
      var $11=HEAP8[($marked7)];
      var $conv8=(($11)&255);
      var $and9=$conv8 & 3;
      var $tobool10=(($and9)|0)!=0;
      if ($tobool10) { label = 6; break; } else { label = 7; break; }
    case 6: 
      var $12=$g_addr;
      var $13=$mt;
      var $14=$13;
      _reallymarkobject($12, $14);
      label = 7; break;
    case 7: 
      var $15=$o_addr;
      var $u11=$15;
      var $uv12=$u11;
      var $env=(($uv12+12)|0);
      var $16=HEAP32[(($env)>>2)];
      var $tobool13=(($16)|0)!=0;
      if ($tobool13) { label = 8; break; } else { label = 10; break; }
    case 8: 
      var $17=$o_addr;
      var $u15=$17;
      var $uv16=$u15;
      var $env17=(($uv16+12)|0);
      var $18=HEAP32[(($env17)>>2)];
      var $19=$18;
      var $gch18=$19;
      var $marked19=(($gch18+5)|0);
      var $20=HEAP8[($marked19)];
      var $conv20=(($20)&255);
      var $and21=$conv20 & 3;
      var $tobool22=(($and21)|0)!=0;
      if ($tobool22) { label = 9; break; } else { label = 10; break; }
    case 9: 
      var $21=$g_addr;
      var $22=$o_addr;
      var $u24=$22;
      var $uv25=$u24;
      var $env26=(($uv25+12)|0);
      var $23=HEAP32[(($env26)>>2)];
      var $24=$23;
      _reallymarkobject($21, $24);
      label = 10; break;
    case 10: 
      var $25=$o_addr;
      var $u28=$25;
      var $uv29=$u28;
      var $len30=(($uv29+16)|0);
      var $26=HEAP32[(($len30)>>2)];
      var $add31=((($26)+(20))|0);
      $size=$add31;
      label = 23; break;
    case 11: 
      var $27=$o_addr;
      var $uv34=$27;
      $uv33=$uv34;
      var $28=$uv33;
      var $v=(($28+8)|0);
      var $29=HEAP32[(($v)>>2)];
      var $tt_=(($29+8)|0);
      var $30=HEAP32[(($tt_)>>2)];
      var $and35=$30 & 64;
      var $tobool36=(($and35)|0)!=0;
      if ($tobool36) { label = 12; break; } else { label = 14; break; }
    case 12: 
      var $31=$uv33;
      var $v38=(($31+8)|0);
      var $32=HEAP32[(($v38)>>2)];
      var $value_=(($32)|0);
      var $gc=$value_;
      var $33=HEAP32[(($gc)>>2)];
      var $gch39=$33;
      var $marked40=(($gch39+5)|0);
      var $34=HEAP8[($marked40)];
      var $conv41=(($34)&255);
      var $and42=$conv41 & 3;
      var $tobool43=(($and42)|0)!=0;
      if ($tobool43) { label = 13; break; } else { label = 14; break; }
    case 13: 
      var $35=$g_addr;
      var $36=$uv33;
      var $v45=(($36+8)|0);
      var $37=HEAP32[(($v45)>>2)];
      var $value_46=(($37)|0);
      var $gc47=$value_46;
      var $38=HEAP32[(($gc47)>>2)];
      _reallymarkobject($35, $38);
      label = 14; break;
    case 14: 
      var $39=$uv33;
      var $v49=(($39+8)|0);
      var $40=HEAP32[(($v49)>>2)];
      var $41=$uv33;
      var $u50=(($41+12)|0);
      var $value=$u50;
      var $cmp=(($40)|0)!=(($value)|0);
      if ($cmp) { label = 15; break; } else { label = 16; break; }
    case 15: 
      label = 24; break;
    case 16: 
      $size=24;
      label = 23; break;
    case 17: 
      var $42=$g_addr;
      var $gray=(($42+76)|0);
      var $43=HEAP32[(($gray)>>2)];
      var $44=$o_addr;
      var $cl=$44;
      var $l=$cl;
      var $gclist=(($l+8)|0);
      HEAP32[(($gclist)>>2)]=$43;
      var $45=$o_addr;
      var $46=$g_addr;
      var $gray55=(($46+76)|0);
      HEAP32[(($gray55)>>2)]=$45;
      label = 24; break;
    case 18: 
      var $47=$g_addr;
      var $gray57=(($47+76)|0);
      var $48=HEAP32[(($gray57)>>2)];
      var $49=$o_addr;
      var $cl58=$49;
      var $c=$cl58;
      var $gclist59=(($c+8)|0);
      HEAP32[(($gclist59)>>2)]=$48;
      var $50=$o_addr;
      var $51=$g_addr;
      var $gray60=(($51+76)|0);
      HEAP32[(($gray60)>>2)]=$50;
      label = 24; break;
    case 19: 
      var $52=$g_addr;
      var $gray62=(($52+76)|0);
      var $53=HEAP32[(($gray62)>>2)];
      var $54=$o_addr;
      var $h=$54;
      var $gclist63=(($h+24)|0);
      HEAP32[(($gclist63)>>2)]=$53;
      var $55=$o_addr;
      var $h64=$55;
      var $56=$h64;
      var $57=$g_addr;
      var $gray65=(($57+76)|0);
      HEAP32[(($gray65)>>2)]=$56;
      label = 24; break;
    case 20: 
      var $58=$g_addr;
      var $gray67=(($58+76)|0);
      var $59=HEAP32[(($gray67)>>2)];
      var $60=$o_addr;
      var $th=$60;
      var $gclist68=(($th+60)|0);
      HEAP32[(($gclist68)>>2)]=$59;
      var $61=$o_addr;
      var $62=$g_addr;
      var $gray69=(($62+76)|0);
      HEAP32[(($gray69)>>2)]=$61;
      label = 24; break;
    case 21: 
      var $63=$g_addr;
      var $gray71=(($63+76)|0);
      var $64=HEAP32[(($gray71)>>2)];
      var $65=$o_addr;
      var $p=$65;
      var $gclist72=(($p+72)|0);
      HEAP32[(($gclist72)>>2)]=$64;
      var $66=$o_addr;
      var $67=$g_addr;
      var $gray73=(($67+76)|0);
      HEAP32[(($gray73)>>2)]=$66;
      label = 24; break;
    case 22: 
      label = 24; break;
    case 23: 
      var $68=$o_addr;
      var $gch74=$68;
      var $marked75=(($gch74+5)|0);
      var $69=HEAP8[($marked75)];
      var $conv76=(($69)&255);
      var $or=$conv76 | 4;
      var $conv77=(($or) & 255);
      HEAP8[($marked75)]=$conv77;
      var $70=$size;
      var $71=$g_addr;
      var $GCmemtrav=(($71+16)|0);
      var $72=HEAP32[(($GCmemtrav)>>2)];
      var $add78=((($72)+($70))|0);
      HEAP32[(($GCmemtrav)>>2)]=$add78;
      label = 24; break;
    case 24: 

      Module.print(INDENT + 'Exiting: _reallymarkobject');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_reallymarkobject["X"]=1;

function _luaC_barrierback_($L, $o) {
  var label = 0;

  Module.print(INDENT + ' Entering: _luaC_barrierback_: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';

  var $L_addr;
  var $o_addr;
  var $g;
  $L_addr=$L;
  $o_addr=$o;
  var $0=$L_addr;
  var $l_G=(($0+12)|0);
  var $1=HEAP32[(($l_G)>>2)];
  $g=$1;
  var $2=$o_addr;
  var $gch=$2;
  var $marked=(($gch+5)|0);
  var $3=HEAP8[($marked)];
  var $conv=(($3)&255);
  var $and=$conv & 251;
  var $conv1=(($and) & 255);
  HEAP8[($marked)]=$conv1;
  var $4=$g;
  var $grayagain=(($4+80)|0);
  var $5=HEAP32[(($grayagain)>>2)];
  var $6=$o_addr;
  var $h=$6;
  var $gclist=(($h+24)|0);
  HEAP32[(($gclist)>>2)]=$5;
  var $7=$o_addr;
  var $8=$g;
  var $grayagain2=(($8+80)|0);
  HEAP32[(($grayagain2)>>2)]=$7;

  Module.print(INDENT + 'Exiting: _luaC_barrierback_');
  INDENT = INDENT.substr(0, INDENT.length-2);
  return;
  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _separatetobefnz($L, $all) {
  var label = 0;

  Module.print(INDENT + ' Entering: _separatetobefnz: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $L_addr;
      var $all_addr;
      var $g;
      var $p;
      var $curr;
      var $lastnext;
      $L_addr=$L;
      $all_addr=$all;
      var $0=$L_addr;
      var $l_G=(($0+12)|0);
      var $1=HEAP32[(($l_G)>>2)];
      $g=$1;
      var $2=$g;
      var $finobj=(($2+64)|0);
      $p=$finobj;
      var $3=$g;
      var $tobefnz=(($3+96)|0);
      $lastnext=$tobefnz;
      label = 3; break;
    case 3: 
      var $4=$lastnext;
      var $5=HEAP32[(($4)>>2)];
      var $cmp=(($5)|0)!=0;
      if ($cmp) { label = 4; break; } else { label = 5; break; }
    case 4: 
      var $6=$lastnext;
      var $7=HEAP32[(($6)>>2)];
      var $gch=$7;
      var $next=(($gch)|0);
      $lastnext=$next;
      label = 3; break;
    case 5: 
      label = 6; break;
    case 6: 
      var $8=$p;
      var $9=HEAP32[(($8)>>2)];
      $curr=$9;
      var $cmp2=(($9)|0)!=0;
      if ($cmp2) { label = 7; break; } else { label = 12; break; }
    case 7: 
      var $10=$all_addr;
      var $tobool=(($10)|0)!=0;
      if ($tobool) { label = 10; break; } else { label = 8; break; }
    case 8: 
      var $11=$curr;
      var $gch4=$11;
      var $marked=(($gch4+5)|0);
      var $12=HEAP8[($marked)];
      var $conv=(($12)&255);
      var $and=$conv & 3;
      var $tobool5=(($and)|0)!=0;
      if ($tobool5) { label = 10; break; } else { label = 9; break; }
    case 9: 
      var $13=$curr;
      var $gch6=$13;
      var $next7=(($gch6)|0);
      $p=$next7;
      label = 11; break;
    case 10: 
      var $14=$curr;
      var $gch8=$14;
      var $marked9=(($gch8+5)|0);
      var $15=HEAP8[($marked9)];
      var $conv10=(($15)&255);
      var $or=$conv10 | 8;
      var $conv11=(($or) & 255);
      HEAP8[($marked9)]=$conv11;
      var $16=$curr;
      var $gch12=$16;
      var $next13=(($gch12)|0);
      var $17=HEAP32[(($next13)>>2)];
      var $18=$p;
      HEAP32[(($18)>>2)]=$17;
      var $19=$lastnext;
      var $20=HEAP32[(($19)>>2)];
      var $21=$curr;
      var $gch14=$21;
      var $next15=(($gch14)|0);
      HEAP32[(($next15)>>2)]=$20;
      var $22=$curr;
      var $23=$lastnext;
      HEAP32[(($23)>>2)]=$22;
      var $24=$curr;
      var $gch16=$24;
      var $next17=(($gch16)|0);
      $lastnext=$next17;
      label = 11; break;
    case 11: 
      label = 6; break;
    case 12: 

      Module.print(INDENT + 'Exiting: _separatetobefnz');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_separatetobefnz["X"]=1;

function _luaC_barrierproto_($L, $p, $c) {
  var label = 0;

  Module.print(INDENT + ' Entering: _luaC_barrierproto_: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $L_addr;
      var $p_addr;
      var $c_addr;
      var $g;
      $L_addr=$L;
      $p_addr=$p;
      $c_addr=$c;
      var $0=$L_addr;
      var $l_G=(($0+12)|0);
      var $1=HEAP32[(($l_G)>>2)];
      $g=$1;
      var $2=$p_addr;
      var $cache=(($2+32)|0);
      var $3=HEAP32[(($cache)>>2)];
      var $cmp=(($3)|0)==0;
      if ($cmp) { label = 3; break; } else { label = 7; break; }
    case 3: 
      var $4=$c_addr;
      var $5=$4;
      var $gch=$5;
      var $marked=(($gch+5)|0);
      var $6=HEAP8[($marked)];
      var $conv=(($6)&255);
      var $and=$conv & 3;
      var $tobool=(($and)|0)!=0;
      if ($tobool) { label = 4; break; } else { label = 6; break; }
    case 4: 
      var $7=$p_addr;
      var $8=$7;
      var $gch1=$8;
      var $marked2=(($gch1+5)|0);
      var $9=HEAP8[($marked2)];
      var $conv3=(($9)&255);
      var $and4=$conv3 & 4;
      var $tobool5=(($and4)|0)!=0;
      if ($tobool5) { label = 5; break; } else { label = 6; break; }
    case 5: 
      var $10=$L_addr;
      var $11=$p_addr;
      var $12=$11;
      var $13=$c_addr;
      var $14=$13;
      _luaC_barrier_($10, $12, $14);
      label = 6; break;
    case 6: 
      label = 8; break;
    case 7: 
      var $15=$p_addr;
      var $16=$15;
      var $gch7=$16;
      var $marked8=(($gch7+5)|0);
      var $17=HEAP8[($marked8)];
      var $conv9=(($17)&255);
      var $and10=$conv9 & 251;
      var $conv11=(($and10) & 255);
      HEAP8[($marked8)]=$conv11;
      var $18=$g;
      var $grayagain=(($18+80)|0);
      var $19=HEAP32[(($grayagain)>>2)];
      var $20=$p_addr;
      var $gclist=(($20+72)|0);
      HEAP32[(($gclist)>>2)]=$19;
      var $21=$p_addr;
      var $22=$21;
      var $23=$g;
      var $grayagain12=(($23+80)|0);
      HEAP32[(($grayagain12)>>2)]=$22;
      label = 8; break;
    case 8: 

      Module.print(INDENT + 'Exiting: _luaC_barrierproto_');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_luaC_barrierproto_["X"]=1;

function _luaC_checkupvalcolor($g, $uv) {
  var label = 0;

  Module.print(INDENT + ' Entering: _luaC_checkupvalcolor: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $g_addr;
      var $uv_addr;
      var $o;
      $g_addr=$g;
      $uv_addr=$uv;
      var $0=$uv_addr;
      var $1=$0;
      $o=$1;
      var $2=$o;
      var $gch=$2;
      var $marked=(($gch+5)|0);
      var $3=HEAP8[($marked)];
      var $conv=(($3)&255);
      var $and=$conv & 7;
      var $tobool=(($and)|0)!=0;
      if ($tobool) { label = 11; break; } else { label = 3; break; }
    case 3: 
      var $4=$g_addr;
      var $gckind=(($4+54)|0);
      var $5=HEAP8[($gckind)];
      var $conv1=(($5)&255);
      var $cmp=(($conv1)|0)==2;
      if ($cmp) { label = 5; break; } else { label = 4; break; }
    case 4: 
      var $6=$g_addr;
      var $gcstate=(($6+53)|0);
      var $7=HEAP8[($gcstate)];
      var $conv3=(($7)&255);
      var $cmp4=(($conv3)|0) <= 1;
      if ($cmp4) { label = 5; break; } else { label = 9; break; }
    case 5: 
      var $8=$o;
      var $gch7=$8;
      var $marked8=(($gch7+5)|0);
      var $9=HEAP8[($marked8)];
      var $conv9=(($9)&255);
      var $and10=$conv9 & 191;
      var $conv11=(($and10) & 255);
      HEAP8[($marked8)]=$conv11;
      var $10=$o;
      var $gch12=$10;
      var $marked13=(($gch12+5)|0);
      var $11=HEAP8[($marked13)];
      var $conv14=(($11)&255);
      var $or=$conv14 | 4;
      var $conv15=(($or) & 255);
      HEAP8[($marked13)]=$conv15;
      var $12=$uv_addr;
      var $v=(($12+8)|0);
      var $13=HEAP32[(($v)>>2)];
      var $tt_=(($13+8)|0);
      var $14=HEAP32[(($tt_)>>2)];
      var $and16=$14 & 64;
      var $tobool17=(($and16)|0)!=0;
      if ($tobool17) { label = 6; break; } else { label = 8; break; }
    case 6: 
      var $15=$uv_addr;
      var $v18=(($15+8)|0);
      var $16=HEAP32[(($v18)>>2)];
      var $value_=(($16)|0);
      var $gc=$value_;
      var $17=HEAP32[(($gc)>>2)];
      var $gch19=$17;
      var $marked20=(($gch19+5)|0);
      var $18=HEAP8[($marked20)];
      var $conv21=(($18)&255);
      var $and22=$conv21 & 3;
      var $tobool23=(($and22)|0)!=0;
      if ($tobool23) { label = 7; break; } else { label = 8; break; }
    case 7: 
      var $19=$g_addr;
      var $20=$uv_addr;
      var $v25=(($20+8)|0);
      var $21=HEAP32[(($v25)>>2)];
      var $value_26=(($21)|0);
      var $gc27=$value_26;
      var $22=HEAP32[(($gc27)>>2)];
      _reallymarkobject($19, $22);
      label = 8; break;
    case 8: 
      label = 10; break;
    case 9: 
      var $23=$o;
      var $gch28=$23;
      var $marked29=(($gch28+5)|0);
      var $24=HEAP8[($marked29)];
      var $conv30=(($24)&255);
      var $and31=$conv30 & -72;
      var $25=$g_addr;
      var $currentwhite=(($25+52)|0);
      var $26=HEAP8[($currentwhite)];
      var $conv32=(($26)&255);
      var $and33=$conv32 & 3;
      var $conv34=(($and33) & 255);
      var $conv35=(($conv34)&255);
      var $or36=$and31 | $conv35;
      var $conv37=(($or36) & 255);
      var $27=$o;
      var $gch38=$27;
      var $marked39=(($gch38+5)|0);
      HEAP8[($marked39)]=$conv37;
      label = 10; break;
    case 10: 
      label = 11; break;
    case 11: 

      Module.print(INDENT + 'Exiting: _luaC_checkupvalcolor');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_luaC_checkupvalcolor["X"]=1;

function _luaC_newobj($L, $tt, $sz, $list, $offset) {
  var label = 0;

  Module.print(INDENT + ' Entering: _luaC_newobj: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $L_addr;
      var $tt_addr;
      var $sz_addr;
      var $list_addr;
      var $offset_addr;
      var $g;
      var $raw;
      var $o;
      $L_addr=$L;
      $tt_addr=$tt;
      $sz_addr=$sz;
      $list_addr=$list;
      $offset_addr=$offset;
      var $0=$L_addr;
      var $l_G=(($0+12)|0);
      var $1=HEAP32[(($l_G)>>2)];
      $g=$1;
      var $2=$L_addr;
      var $3=$tt_addr;
      var $and=$3 & 15;
      var $4=$sz_addr;
      var $call=_luaM_realloc_($2, 0, $and, $4);
      $raw=$call;
      var $5=$raw;
      var $6=$offset_addr;
      var $add_ptr=(($5+$6)|0);
      var $7=$add_ptr;
      $o=$7;
      var $8=$list_addr;
      var $cmp=(($8)|0)==0;
      if ($cmp) { label = 3; break; } else { label = 4; break; }
    case 3: 
      var $9=$g;
      var $allgc=(($9+60)|0);
      $list_addr=$allgc;
      label = 4; break;
    case 4: 
      var $10=$g;
      var $currentwhite=(($10+52)|0);
      var $11=HEAP8[($currentwhite)];
      var $conv=(($11)&255);
      var $and1=$conv & 3;
      var $conv2=(($and1) & 255);
      var $12=$o;
      var $gch=$12;
      var $marked=(($gch+5)|0);
      HEAP8[($marked)]=$conv2;
      var $13=$tt_addr;
      var $conv3=(($13) & 255);
      var $14=$o;
      var $gch4=$14;
      var $tt5=(($gch4+4)|0);
      HEAP8[($tt5)]=$conv3;
      var $15=$list_addr;
      var $16=HEAP32[(($15)>>2)];
      var $17=$o;
      var $gch6=$17;
      var $next=(($gch6)|0);
      HEAP32[(($next)>>2)]=$16;
      var $18=$o;
      var $19=$list_addr;
      HEAP32[(($19)>>2)]=$18;
      var $20=$o;

      Module.print(INDENT + 'Exiting: _luaC_newobj');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return $20;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_luaC_newobj["X"]=1;

function _luaC_checkfinalizer($L, $o, $mt) {
  var label = 0;

  Module.print(INDENT + ' Entering: _luaC_checkfinalizer: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $L_addr;
      var $o_addr;
      var $mt_addr;
      var $g;
      var $p;
      var $ho;
      $L_addr=$L;
      $o_addr=$o;
      $mt_addr=$mt;
      var $0=$L_addr;
      var $l_G=(($0+12)|0);
      var $1=HEAP32[(($l_G)>>2)];
      $g=$1;
      var $2=$o_addr;
      var $gch=$2;
      var $marked=(($gch+5)|0);
      var $3=HEAP8[($marked)];
      var $conv=(($3)&255);
      var $and=$conv & 16;
      var $tobool=(($and)|0)!=0;
      if ($tobool) { label = 11; break; } else { label = 3; break; }
    case 3: 
      var $4=$o_addr;
      var $gch1=$4;
      var $marked2=(($gch1+5)|0);
      var $5=HEAP8[($marked2)];
      var $conv3=(($5)&255);
      var $and4=$conv3 & 8;
      var $tobool5=(($and4)|0)!=0;
      if ($tobool5) { label = 11; break; } else { label = 4; break; }
    case 4: 
      var $6=$mt_addr;
      var $cmp=(($6)|0)==0;
      if ($cmp) { label = 5; break; } else { label = 6; break; }
    case 5: 
      var $cond14 = 0;label = 10; break;
    case 6: 
      var $7=$mt_addr;
      var $flags=(($7+6)|0);
      var $8=HEAP8[($flags)];
      var $conv8=(($8)&255);
      var $and9=$conv8 & 4;
      var $tobool10=(($and9)|0)!=0;
      if ($tobool10) { label = 7; break; } else { label = 8; break; }
    case 7: 
      var $cond = 0;label = 9; break;
    case 8: 
      var $9=$mt_addr;
      var $10=$g;
      var $tmname=(($10+164)|0);
      var $arrayidx=(($tmname+8)|0);
      var $11=HEAP32[(($arrayidx)>>2)];
      var $call=_luaT_gettm($9, 2, $11);
      var $cond = $call;label = 9; break;
    case 9: 
      var $cond;
      var $cond14 = $cond;label = 10; break;
    case 10: 
      var $cond14;
      var $cmp15=(($cond14)|0)==0;
      if ($cmp15) { label = 11; break; } else { label = 12; break; }
    case 11: 
      label = 23; break;
    case 12: 
      var $12=$o_addr;
      var $gch17=$12;
      $ho=$gch17;
      var $13=$g;
      var $sweepgc=(($13+68)|0);
      var $14=HEAP32[(($sweepgc)>>2)];
      var $15=$ho;
      var $next=(($15)|0);
      var $cmp18=(($14)|0)==(($next)|0);
      if ($cmp18) { label = 13; break; } else { label = 14; break; }
    case 13: 
      var $16=$L_addr;
      var $17=$g;
      var $sweepgc21=(($17+68)|0);
      var $18=HEAP32[(($sweepgc21)>>2)];
      var $call22=_sweeptolive($16, $18, 0);
      var $19=$g;
      var $sweepgc23=(($19+68)|0);
      HEAP32[(($sweepgc23)>>2)]=$call22;
      label = 14; break;
    case 14: 
      var $20=$g;
      var $allgc=(($20+60)|0);
      $p=$allgc;
      label = 15; break;
    case 15: 
      var $21=$p;
      var $22=HEAP32[(($21)>>2)];
      var $23=$o_addr;
      var $cmp24=(($22)|0)!=(($23)|0);
      if ($cmp24) { label = 16; break; } else { label = 18; break; }
    case 16: 
      label = 17; break;
    case 17: 
      var $24=$p;
      var $25=HEAP32[(($24)>>2)];
      var $gch26=$25;
      var $next27=(($gch26)|0);
      $p=$next27;
      label = 15; break;
    case 18: 
      var $26=$ho;
      var $next28=(($26)|0);
      var $27=HEAP32[(($next28)>>2)];
      var $28=$p;
      HEAP32[(($28)>>2)]=$27;
      var $29=$g;
      var $finobj=(($29+64)|0);
      var $30=HEAP32[(($finobj)>>2)];
      var $31=$ho;
      var $next29=(($31)|0);
      HEAP32[(($next29)>>2)]=$30;
      var $32=$o_addr;
      var $33=$g;
      var $finobj30=(($33+64)|0);
      HEAP32[(($finobj30)>>2)]=$32;
      var $34=$ho;
      var $marked31=(($34+5)|0);
      var $35=HEAP8[($marked31)];
      var $conv32=(($35)&255);
      var $or=$conv32 | 16;
      var $conv33=(($or) & 255);
      HEAP8[($marked31)]=$conv33;
      var $36=$g;
      var $gckind=(($36+54)|0);
      var $37=HEAP8[($gckind)];
      var $conv34=(($37)&255);
      var $cmp35=(($conv34)|0)==2;
      if ($cmp35) { label = 21; break; } else { label = 19; break; }
    case 19: 
      var $38=$g;
      var $gcstate=(($38+53)|0);
      var $39=HEAP8[($gcstate)];
      var $conv38=(($39)&255);
      var $cmp39=(($conv38)|0) <= 1;
      if ($cmp39) { label = 21; break; } else { label = 20; break; }
    case 20: 
      var $40=$o_addr;
      var $gch42=$40;
      var $marked43=(($gch42+5)|0);
      var $41=HEAP8[($marked43)];
      var $conv44=(($41)&255);
      var $and45=$conv44 & -72;
      var $42=$g;
      var $currentwhite=(($42+52)|0);
      var $43=HEAP8[($currentwhite)];
      var $conv46=(($43)&255);
      var $and47=$conv46 & 3;
      var $conv48=(($and47) & 255);
      var $conv49=(($conv48)&255);
      var $or50=$and45 | $conv49;
      var $conv51=(($or50) & 255);
      var $44=$o_addr;
      var $gch52=$44;
      var $marked53=(($gch52+5)|0);
      HEAP8[($marked53)]=$conv51;
      label = 22; break;
    case 21: 
      var $45=$o_addr;
      var $gch55=$45;
      var $marked56=(($gch55+5)|0);
      var $46=HEAP8[($marked56)];
      var $conv57=(($46)&255);
      var $and58=$conv57 & 191;
      var $conv59=(($and58) & 255);
      HEAP8[($marked56)]=$conv59;
      label = 22; break;
    case 22: 
      label = 23; break;
    case 23: 

      Module.print(INDENT + 'Exiting: _luaC_checkfinalizer');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_luaC_checkfinalizer["X"]=1;

function _sweeptolive($L, $p, $n) {
  var label = 0;

  Module.print(INDENT + ' Entering: _sweeptolive: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $L_addr;
      var $p_addr;
      var $n_addr;
      var $old;
      var $i;
      $L_addr=$L;
      $p_addr=$p;
      $n_addr=$n;
      var $0=$p_addr;
      $old=$0;
      $i=0;
      label = 3; break;
    case 3: 
      var $1=$i;
      var $inc=((($1)+(1))|0);
      $i=$inc;
      var $2=$L_addr;
      var $3=$p_addr;
      var $call=_sweeplist($2, $3, 1);
      $p_addr=$call;
      label = 4; break;
    case 4: 
      var $4=$p_addr;
      var $5=$old;
      var $cmp=(($4)|0)==(($5)|0);
      if ($cmp) { label = 3; break; } else { label = 5; break; }
    case 5: 
      var $6=$n_addr;
      var $tobool=(($6)|0)!=0;
      if ($tobool) { label = 6; break; } else { label = 7; break; }
    case 6: 
      var $7=$i;
      var $8=$n_addr;
      var $9=HEAP32[(($8)>>2)];
      var $add=((($9)+($7))|0);
      HEAP32[(($8)>>2)]=$add;
      label = 7; break;
    case 7: 
      var $10=$p_addr;

      Module.print(INDENT + 'Exiting: _sweeptolive');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return $10;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _luaC_changemode($L, $mode) {
  var label = 0;

  Module.print(INDENT + ' Entering: _luaC_changemode: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $L_addr;
      var $mode_addr;
      var $g;
      $L_addr=$L;
      $mode_addr=$mode;
      var $0=$L_addr;
      var $l_G=(($0+12)|0);
      var $1=HEAP32[(($l_G)>>2)];
      $g=$1;
      var $2=$mode_addr;
      var $3=$g;
      var $gckind=(($3+54)|0);
      var $4=HEAP8[($gckind)];
      var $conv=(($4)&255);
      var $cmp=(($2)|0)==(($conv)|0);
      if ($cmp) { label = 3; break; } else { label = 4; break; }
    case 3: 
      label = 7; break;
    case 4: 
      var $5=$mode_addr;
      var $cmp2=(($5)|0)==2;
      if ($cmp2) { label = 5; break; } else { label = 6; break; }
    case 5: 
      var $6=$L_addr;
      _luaC_runtilstate($6, 1);
      var $7=$g;
      var $totalbytes=(($7+8)|0);
      var $8=HEAP32[(($totalbytes)>>2)];
      var $9=$g;
      var $GCdebt=(($9+12)|0);
      var $10=HEAP32[(($GCdebt)>>2)];
      var $add=((($8)+($10))|0);
      var $11=$g;
      var $GCestimate=(($11+20)|0);
      HEAP32[(($GCestimate)>>2)]=$add;
      var $12=$g;
      var $gckind5=(($12+54)|0);
      HEAP8[($gckind5)]=2;
      label = 7; break;
    case 6: 
      var $13=$g;
      var $gckind6=(($13+54)|0);
      HEAP8[($gckind6)]=0;
      var $14=$L_addr;
      var $call=_entersweep($14);
      var $15=$L_addr;
      _luaC_runtilstate($15, -29);
      label = 7; break;
    case 7: 

      Module.print(INDENT + 'Exiting: _luaC_changemode');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _luaC_runtilstate($L, $statesmask) {
  var label = 0;

  Module.print(INDENT + ' Entering: _luaC_runtilstate: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $L_addr;
      var $statesmask_addr;
      var $g;
      $L_addr=$L;
      $statesmask_addr=$statesmask;
      var $0=$L_addr;
      var $l_G=(($0+12)|0);
      var $1=HEAP32[(($l_G)>>2)];
      $g=$1;
      label = 3; break;
    case 3: 
      var $2=$statesmask_addr;
      var $3=$g;
      var $gcstate=(($3+53)|0);
      var $4=HEAP8[($gcstate)];
      var $conv=(($4)&255);
      var $shl=1 << $conv;
      var $and=$2 & $shl;
      var $tobool=(($and)|0)!=0;
      var $lnot=$tobool ^ 1;
      if ($lnot) { label = 4; break; } else { label = 5; break; }
    case 4: 
      var $5=$L_addr;
      var $call=_singlestep($5);
      label = 3; break;
    case 5: 

      Module.print(INDENT + 'Exiting: _luaC_runtilstate');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _entersweep($L) {
  var label = 0;
  var __stackBase__  = STACKTOP; STACKTOP = (STACKTOP + 4)|0; _memset(__stackBase__, 0, 4);
  Module.print(INDENT + ' Entering: _entersweep: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';

  var $L_addr;
  var $g;
  var $n=__stackBase__;
  $L_addr=$L;
  var $0=$L_addr;
  var $l_G=(($0+12)|0);
  var $1=HEAP32[(($l_G)>>2)];
  $g=$1;
  HEAP32[(($n)>>2)]=0;
  var $2=$g;
  var $gcstate=(($2+53)|0);
  HEAP8[($gcstate)]=2;
  var $3=$g;
  var $sweepstrgc=(($3+56)|0);
  HEAP32[(($sweepstrgc)>>2)]=0;
  var $4=$L_addr;
  var $5=$g;
  var $finobj=(($5+64)|0);
  var $call=_sweeptolive($4, $finobj, $n);
  var $6=$g;
  var $sweepfin=(($6+72)|0);
  HEAP32[(($sweepfin)>>2)]=$call;
  var $7=$L_addr;
  var $8=$g;
  var $allgc=(($8+60)|0);
  var $call1=_sweeptolive($7, $allgc, $n);
  var $9=$g;
  var $sweepgc=(($9+68)|0);
  HEAP32[(($sweepgc)>>2)]=$call1;
  var $10=HEAP32[(($n)>>2)];
  STACKTOP = __stackBase__;
  Module.print(INDENT + 'Exiting: _entersweep');
  INDENT = INDENT.substr(0, INDENT.length-2);
  return $10;
  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _luaC_freeallobjects($L) {
  var label = 0;

  Module.print(INDENT + ' Entering: _luaC_freeallobjects: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $L_addr;
      var $g;
      var $i;
      $L_addr=$L;
      var $0=$L_addr;
      var $l_G=(($0+12)|0);
      var $1=HEAP32[(($l_G)>>2)];
      $g=$1;
      var $2=$L_addr;
      _separatetobefnz($2, 1);
      var $3=$L_addr;
      _callallpendingfinalizers($3, 0);
      var $4=$g;
      var $currentwhite=(($4+52)|0);
      HEAP8[($currentwhite)]=3;
      var $5=$g;
      var $gckind=(($5+54)|0);
      HEAP8[($gckind)]=0;
      var $6=$L_addr;
      var $7=$g;
      var $finobj=(($7+64)|0);
      var $call=_sweeplist($6, $finobj, -3);
      var $8=$L_addr;
      var $9=$g;
      var $allgc=(($9+60)|0);
      var $call1=_sweeplist($8, $allgc, -3);
      $i=0;
      label = 3; break;
    case 3: 
      var $10=$i;
      var $11=$g;
      var $strt=(($11+24)|0);
      var $size=(($strt+8)|0);
      var $12=HEAP32[(($size)>>2)];
      var $cmp=(($10)|0) < (($12)|0);
      if ($cmp) { label = 4; break; } else { label = 6; break; }
    case 4: 
      var $13=$L_addr;
      var $14=$i;
      var $15=$g;
      var $strt2=(($15+24)|0);
      var $hash=(($strt2)|0);
      var $16=HEAP32[(($hash)>>2)];
      var $arrayidx=(($16+($14<<2))|0);
      var $call3=_sweeplist($13, $arrayidx, -3);
      label = 5; break;
    case 5: 
      var $17=$i;
      var $inc=((($17)+(1))|0);
      $i=$inc;
      label = 3; break;
    case 6: 

      Module.print(INDENT + 'Exiting: _luaC_freeallobjects');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _callallpendingfinalizers($L, $propagateerrors) {
  var label = 0;

  Module.print(INDENT + ' Entering: _callallpendingfinalizers: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $L_addr;
      var $propagateerrors_addr;
      var $g;
      $L_addr=$L;
      $propagateerrors_addr=$propagateerrors;
      var $0=$L_addr;
      var $l_G=(($0+12)|0);
      var $1=HEAP32[(($l_G)>>2)];
      $g=$1;
      label = 3; break;
    case 3: 
      var $2=$g;
      var $tobefnz=(($2+96)|0);
      var $3=HEAP32[(($tobefnz)>>2)];
      var $tobool=(($3)|0)!=0;
      if ($tobool) { label = 4; break; } else { label = 5; break; }
    case 4: 
      var $4=$g;
      var $tobefnz1=(($4+96)|0);
      var $5=HEAP32[(($tobefnz1)>>2)];
      var $gch=$5;
      var $marked=(($gch+5)|0);
      var $6=HEAP8[($marked)];
      var $conv=(($6)&255);
      var $and=$conv & 191;
      var $conv2=(($and) & 255);
      HEAP8[($marked)]=$conv2;
      var $7=$L_addr;
      var $8=$propagateerrors_addr;
      _GCTM($7, $8);
      label = 3; break;
    case 5: 

      Module.print(INDENT + 'Exiting: _callallpendingfinalizers');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _sweeplist($L, $p, $count) {
  var label = 0;

  Module.print(INDENT + ' Entering: _sweeplist: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $retval;
      var $L_addr;
      var $p_addr;
      var $count_addr;
      var $g;
      var $ow;
      var $toclear;
      var $toset;
      var $tostop;
      var $curr;
      var $marked;
      $L_addr=$L;
      $p_addr=$p;
      $count_addr=$count;
      var $0=$L_addr;
      var $l_G=(($0+12)|0);
      var $1=HEAP32[(($l_G)>>2)];
      $g=$1;
      var $2=$g;
      var $currentwhite=(($2+52)|0);
      var $3=HEAP8[($currentwhite)];
      var $conv=(($3)&255);
      var $xor=$conv ^ 3;
      $ow=$xor;
      var $4=$g;
      var $gckind=(($4+54)|0);
      var $5=HEAP8[($gckind)];
      var $conv1=(($5)&255);
      var $cmp=(($conv1)|0)==2;
      if ($cmp) { label = 3; break; } else { label = 4; break; }
    case 3: 
      $toclear=-1;
      $toset=64;
      $tostop=64;
      label = 5; break;
    case 4: 
      $toclear=-72;
      var $6=$g;
      var $currentwhite3=(($6+52)|0);
      var $7=HEAP8[($currentwhite3)];
      var $conv4=(($7)&255);
      var $and=$conv4 & 3;
      var $conv5=(($and) & 255);
      var $conv6=(($conv5)&255);
      $toset=$conv6;
      $tostop=0;
      label = 5; break;
    case 5: 
      label = 6; break;
    case 6: 
      var $8=$p_addr;
      var $9=HEAP32[(($8)>>2)];
      var $cmp7=(($9)|0)!=0;
      if ($cmp7) { label = 7; break; } else { var $11 = 0;label = 8; break; }
    case 7: 
      var $10=$count_addr;
      var $dec=((($10)-(1))|0);
      $count_addr=$dec;
      var $cmp9=(($10)>>>0) > 0;
      var $11 = $cmp9;label = 8; break;
    case 8: 
      var $11;
      if ($11) { label = 9; break; } else { label = 17; break; }
    case 9: 
      var $12=$p_addr;
      var $13=HEAP32[(($12)>>2)];
      $curr=$13;
      var $14=$curr;
      var $gch=$14;
      var $marked11=(($gch+5)|0);
      var $15=HEAP8[($marked11)];
      var $conv12=(($15)&255);
      $marked=$conv12;
      var $16=$marked;
      var $xor13=$16 ^ 3;
      var $17=$ow;
      var $and14=$xor13 & $17;
      var $tobool=(($and14)|0)!=0;
      if ($tobool) { label = 11; break; } else { label = 10; break; }
    case 10: 
      var $18=$curr;
      var $gch16=$18;
      var $next=(($gch16)|0);
      var $19=HEAP32[(($next)>>2)];
      var $20=$p_addr;
      HEAP32[(($20)>>2)]=$19;
      var $21=$L_addr;
      var $22=$curr;
      _freeobj($21, $22);
      label = 16; break;
    case 11: 
      var $23=$marked;
      var $24=$tostop;
      var $and18=$23 & $24;
      var $tobool19=(($and18)|0)!=0;
      if ($tobool19) { label = 12; break; } else { label = 13; break; }
    case 12: 
      $retval=0;
      label = 21; break;
    case 13: 
      var $25=$curr;
      var $gch22=$25;
      var $tt=(($gch22+4)|0);
      var $26=HEAP8[($tt)];
      var $conv23=(($26)&255);
      var $cmp24=(($conv23)|0)==8;
      if ($cmp24) { label = 14; break; } else { label = 15; break; }
    case 14: 
      var $27=$L_addr;
      var $28=$curr;
      var $th=$28;
      _sweepthread($27, $th);
      label = 15; break;
    case 15: 
      var $29=$marked;
      var $30=$toclear;
      var $and28=$29 & $30;
      var $31=$toset;
      var $or=$and28 | $31;
      var $conv29=(($or) & 255);
      var $32=$curr;
      var $gch30=$32;
      var $marked31=(($gch30+5)|0);
      HEAP8[($marked31)]=$conv29;
      var $33=$curr;
      var $gch32=$33;
      var $next33=(($gch32)|0);
      $p_addr=$next33;
      label = 16; break;
    case 16: 
      label = 6; break;
    case 17: 
      var $34=$p_addr;
      var $35=HEAP32[(($34)>>2)];
      var $cmp35=(($35)|0)==0;
      if ($cmp35) { label = 18; break; } else { label = 19; break; }
    case 18: 
      var $cond = 0;label = 20; break;
    case 19: 
      var $36=$p_addr;
      var $cond = $36;label = 20; break;
    case 20: 
      var $cond;
      $retval=$cond;
      label = 21; break;
    case 21: 
      var $37=$retval;

      Module.print(INDENT + 'Exiting: _sweeplist');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return $37;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_sweeplist["X"]=1;

function _singlestep($L) {
  var label = 0;
  var __stackBase__  = STACKTOP; STACKTOP = (STACKTOP + 4)|0; _memset(__stackBase__, 0, 4);
  Module.print(INDENT + ' Entering: _singlestep: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $retval;
      var $L_addr;
      var $g;
      var $oldtrav;
      var $work;
      var $sw;
      var $i;
      var $mt=__stackBase__;
      $L_addr=$L;
      var $0=$L_addr;
      var $l_G=(($0+12)|0);
      var $1=HEAP32[(($l_G)>>2)];
      $g=$1;
      var $2=$g;
      var $gcstate=(($2+53)|0);
      var $3=HEAP8[($gcstate)];
      var $conv=(($3)&255);
      if ((($conv)|0)==5) {
        label = 3; break;
      }
      else if ((($conv)|0)==0) {
        label = 6; break;
      }
      else if ((($conv)|0)==2) {
        label = 9; break;
      }
      else if ((($conv)|0)==3) {
        label = 18; break;
      }
      else if ((($conv)|0)==4) {
        label = 21; break;
      }
      else {
      label = 24; break;
      }
      
    case 3: 
      var $4=$g;
      var $GCmemtrav=(($4+16)|0);
      HEAP32[(($GCmemtrav)>>2)]=0;
      var $5=$g;
      var $gckind=(($5+54)|0);
      var $6=HEAP8[($gckind)];
      var $conv1=(($6)&255);
      var $cmp=(($conv1)|0)==2;
      if ($cmp) { label = 5; break; } else { label = 4; break; }
    case 4: 
      var $7=$g;
      _markroot($7);
      label = 5; break;
    case 5: 
      var $8=$g;
      var $gcstate3=(($8+53)|0);
      HEAP8[($gcstate3)]=0;
      var $9=$g;
      var $GCmemtrav4=(($9+16)|0);
      var $10=HEAP32[(($GCmemtrav4)>>2)];
      $retval=$10;
      label = 25; break;
    case 6: 
      var $11=$g;
      var $gray=(($11+76)|0);
      var $12=HEAP32[(($gray)>>2)];
      var $tobool=(($12)|0)!=0;
      if ($tobool) { label = 7; break; } else { label = 8; break; }
    case 7: 
      var $13=$g;
      var $GCmemtrav7=(($13+16)|0);
      var $14=HEAP32[(($GCmemtrav7)>>2)];
      $oldtrav=$14;
      var $15=$g;
      _propagatemark($15);
      var $16=$g;
      var $GCmemtrav8=(($16+16)|0);
      var $17=HEAP32[(($GCmemtrav8)>>2)];
      var $18=$oldtrav;
      var $sub=((($17)-($18))|0);
      $retval=$sub;
      label = 25; break;
    case 8: 
      var $19=$g;
      var $gcstate9=(($19+53)|0);
      HEAP8[($gcstate9)]=1;
      var $20=$g;
      var $GCmemtrav10=(($20+16)|0);
      var $21=HEAP32[(($GCmemtrav10)>>2)];
      var $22=$g;
      var $GCestimate=(($22+20)|0);
      HEAP32[(($GCestimate)>>2)]=$21;
      var $23=$L_addr;
      var $call=_atomic($23);
      $work=$call;
      var $24=$work;
      var $25=$g;
      var $GCestimate11=(($25+20)|0);
      var $26=HEAP32[(($GCestimate11)>>2)];
      var $add=((($26)+($24))|0);
      HEAP32[(($GCestimate11)>>2)]=$add;
      var $27=$L_addr;
      var $call12=_entersweep($27);
      $sw=$call12;
      var $28=$work;
      var $29=$sw;
      var $mul=((($29)*(5))&-1);
      var $add13=((($28)+($mul))|0);
      $retval=$add13;
      label = 25; break;
    case 9: 
      $i=0;
      label = 10; break;
    case 10: 
      var $30=$i;
      var $cmp15=(($30)|0) < 80;
      if ($cmp15) { label = 11; break; } else { var $36 = 0;label = 12; break; }
    case 11: 
      var $31=$g;
      var $sweepstrgc=(($31+56)|0);
      var $32=HEAP32[(($sweepstrgc)>>2)];
      var $33=$i;
      var $add17=((($32)+($33))|0);
      var $34=$g;
      var $strt=(($34+24)|0);
      var $size=(($strt+8)|0);
      var $35=HEAP32[(($size)>>2)];
      var $cmp18=(($add17)|0) < (($35)|0);
      var $36 = $cmp18;label = 12; break;
    case 12: 
      var $36;
      if ($36) { label = 13; break; } else { label = 15; break; }
    case 13: 
      var $37=$L_addr;
      var $38=$g;
      var $sweepstrgc20=(($38+56)|0);
      var $39=HEAP32[(($sweepstrgc20)>>2)];
      var $40=$i;
      var $add21=((($39)+($40))|0);
      var $41=$g;
      var $strt22=(($41+24)|0);
      var $hash=(($strt22)|0);
      var $42=HEAP32[(($hash)>>2)];
      var $arrayidx=(($42+($add21<<2))|0);
      var $call23=_sweeplist($37, $arrayidx, -3);
      label = 14; break;
    case 14: 
      var $43=$i;
      var $inc=((($43)+(1))|0);
      $i=$inc;
      label = 10; break;
    case 15: 
      var $44=$i;
      var $45=$g;
      var $sweepstrgc24=(($45+56)|0);
      var $46=HEAP32[(($sweepstrgc24)>>2)];
      var $add25=((($46)+($44))|0);
      HEAP32[(($sweepstrgc24)>>2)]=$add25;
      var $47=$g;
      var $sweepstrgc26=(($47+56)|0);
      var $48=HEAP32[(($sweepstrgc26)>>2)];
      var $49=$g;
      var $strt27=(($49+24)|0);
      var $size28=(($strt27+8)|0);
      var $50=HEAP32[(($size28)>>2)];
      var $cmp29=(($48)|0) >= (($50)|0);
      if ($cmp29) { label = 16; break; } else { label = 17; break; }
    case 16: 
      var $51=$g;
      var $gcstate32=(($51+53)|0);
      HEAP8[($gcstate32)]=3;
      label = 17; break;
    case 17: 
      var $52=$i;
      var $mul34=((($52)*(5))&-1);
      $retval=$mul34;
      label = 25; break;
    case 18: 
      var $53=$g;
      var $sweepfin=(($53+72)|0);
      var $54=HEAP32[(($sweepfin)>>2)];
      var $tobool36=(($54)|0)!=0;
      if ($tobool36) { label = 19; break; } else { label = 20; break; }
    case 19: 
      var $55=$L_addr;
      var $56=$g;
      var $sweepfin38=(($56+72)|0);
      var $57=HEAP32[(($sweepfin38)>>2)];
      var $call39=_sweeplist($55, $57, 80);
      var $58=$g;
      var $sweepfin40=(($58+72)|0);
      HEAP32[(($sweepfin40)>>2)]=$call39;
      $retval=400;
      label = 25; break;
    case 20: 
      var $59=$g;
      var $gcstate42=(($59+53)|0);
      HEAP8[($gcstate42)]=4;
      $retval=0;
      label = 25; break;
    case 21: 
      var $60=$g;
      var $sweepgc=(($60+68)|0);
      var $61=HEAP32[(($sweepgc)>>2)];
      var $tobool44=(($61)|0)!=0;
      if ($tobool44) { label = 22; break; } else { label = 23; break; }
    case 22: 
      var $62=$L_addr;
      var $63=$g;
      var $sweepgc46=(($63+68)|0);
      var $64=HEAP32[(($sweepgc46)>>2)];
      var $call47=_sweeplist($62, $64, 80);
      var $65=$g;
      var $sweepgc48=(($65+68)|0);
      HEAP32[(($sweepgc48)>>2)]=$call47;
      $retval=400;
      label = 25; break;
    case 23: 
      var $66=$g;
      var $mainthread=(($66+152)|0);
      var $67=HEAP32[(($mainthread)>>2)];
      var $68=$67;
      HEAP32[(($mt)>>2)]=$68;
      var $69=$L_addr;
      var $call50=_sweeplist($69, $mt, 1);
      var $70=$L_addr;
      _checkSizes($70);
      var $71=$g;
      var $gcstate51=(($71+53)|0);
      HEAP8[($gcstate51)]=5;
      $retval=5;
      label = 25; break;
    case 24: 
      $retval=0;
      label = 25; break;
    case 25: 
      var $72=$retval;
      STACKTOP = __stackBase__;
      Module.print(INDENT + 'Exiting: _singlestep');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return $72;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_singlestep["X"]=1;

function _luaC_forcestep($L) {
  var label = 0;

  Module.print(INDENT + ' Entering: _luaC_forcestep: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $L_addr;
      var $g;
      var $i;
      $L_addr=$L;
      var $0=$L_addr;
      var $l_G=(($0+12)|0);
      var $1=HEAP32[(($l_G)>>2)];
      $g=$1;
      var $2=$g;
      var $gckind=(($2+54)|0);
      var $3=HEAP8[($gckind)];
      var $conv=(($3)&255);
      var $cmp=(($conv)|0)==2;
      if ($cmp) { label = 3; break; } else { label = 4; break; }
    case 3: 
      var $4=$L_addr;
      _generationalcollection($4);
      label = 5; break;
    case 4: 
      var $5=$L_addr;
      _incstep($5);
      label = 5; break;
    case 5: 
      $i=0;
      label = 6; break;
    case 6: 
      var $6=$g;
      var $tobefnz=(($6+96)|0);
      var $7=HEAP32[(($tobefnz)>>2)];
      var $tobool=(($7)|0)!=0;
      if ($tobool) { label = 7; break; } else { var $12 = 0;label = 10; break; }
    case 7: 
      var $8=$i;
      var $cmp2=(($8)|0) < 4;
      if ($cmp2) { var $11 = 1;label = 9; break; } else { label = 8; break; }
    case 8: 
      var $9=$g;
      var $gcstate=(($9+53)|0);
      var $10=HEAP8[($gcstate)];
      var $conv4=(($10)&255);
      var $cmp5=(($conv4)|0)==5;
      var $11 = $cmp5;label = 9; break;
    case 9: 
      var $11;
      var $12 = $11;label = 10; break;
    case 10: 
      var $12;
      if ($12) { label = 11; break; } else { label = 13; break; }
    case 11: 
      var $13=$L_addr;
      _GCTM($13, 1);
      label = 12; break;
    case 12: 
      var $14=$i;
      var $inc=((($14)+(1))|0);
      $i=$inc;
      label = 6; break;
    case 13: 

      Module.print(INDENT + 'Exiting: _luaC_forcestep');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _generationalcollection($L) {
  var label = 0;

  Module.print(INDENT + ' Entering: _generationalcollection: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $L_addr;
      var $g;
      var $estimate;
      $L_addr=$L;
      var $0=$L_addr;
      var $l_G=(($0+12)|0);
      var $1=HEAP32[(($l_G)>>2)];
      $g=$1;
      var $2=$g;
      var $GCestimate=(($2+20)|0);
      var $3=HEAP32[(($GCestimate)>>2)];
      var $cmp=(($3)|0)==0;
      if ($cmp) { label = 3; break; } else { label = 4; break; }
    case 3: 
      var $4=$L_addr;
      _luaC_fullgc($4, 0);
      var $5=$g;
      var $totalbytes=(($5+8)|0);
      var $6=HEAP32[(($totalbytes)>>2)];
      var $7=$g;
      var $GCdebt=(($7+12)|0);
      var $8=HEAP32[(($GCdebt)>>2)];
      var $add=((($6)+($8))|0);
      var $9=$g;
      var $GCestimate1=(($9+20)|0);
      HEAP32[(($GCestimate1)>>2)]=$add;
      label = 7; break;
    case 4: 
      var $10=$g;
      var $GCestimate2=(($10+20)|0);
      var $11=HEAP32[(($GCestimate2)>>2)];
      $estimate=$11;
      var $12=$L_addr;
      _luaC_runtilstate($12, -33);
      var $13=$L_addr;
      _luaC_runtilstate($13, 32);
      var $14=$g;
      var $totalbytes3=(($14+8)|0);
      var $15=HEAP32[(($totalbytes3)>>2)];
      var $16=$g;
      var $GCdebt4=(($16+12)|0);
      var $17=HEAP32[(($GCdebt4)>>2)];
      var $add5=((($15)+($17))|0);
      var $18=$estimate;
      var $div=Math.floor(((($18)>>>0))/(100));
      var $19=$g;
      var $gcmajorinc=(($19+140)|0);
      var $20=HEAP32[(($gcmajorinc)>>2)];
      var $mul=Math.imul($div,$20);
      var $cmp6=(($add5)>>>0) > (($mul)>>>0);
      if ($cmp6) { label = 5; break; } else { label = 6; break; }
    case 5: 
      var $21=$g;
      var $GCestimate8=(($21+20)|0);
      HEAP32[(($GCestimate8)>>2)]=0;
      label = 6; break;
    case 6: 
      label = 7; break;
    case 7: 
      var $22=$g;
      var $23=$g;
      var $totalbytes10=(($23+8)|0);
      var $24=HEAP32[(($totalbytes10)>>2)];
      var $25=$g;
      var $GCdebt11=(($25+12)|0);
      var $26=HEAP32[(($GCdebt11)>>2)];
      var $add12=((($24)+($26))|0);
      var $div13=Math.floor(((($add12)>>>0))/(200));
      var $sub=(((-$div13))|0);
      var $27=$g;
      var $gcpause=(($27+136)|0);
      var $28=HEAP32[(($gcpause)>>2)];
      var $mul14=Math.imul($sub,$28);
      _luaE_setdebt($22, $mul14);

      Module.print(INDENT + 'Exiting: _generationalcollection');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_generationalcollection["X"]=1;

function _incstep($L) {
  var label = 0;

  Module.print(INDENT + ' Entering: _incstep: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $L_addr;
      var $g;
      var $debt;
      var $stepmul;
      var $work;
      $L_addr=$L;
      var $0=$L_addr;
      var $l_G=(($0+12)|0);
      var $1=HEAP32[(($l_G)>>2)];
      $g=$1;
      var $2=$g;
      var $GCdebt=(($2+12)|0);
      var $3=HEAP32[(($GCdebt)>>2)];
      $debt=$3;
      var $4=$g;
      var $gcstepmul=(($4+144)|0);
      var $5=HEAP32[(($gcstepmul)>>2)];
      $stepmul=$5;
      var $6=$stepmul;
      var $cmp=(($6)|0) < 40;
      if ($cmp) { label = 3; break; } else { label = 4; break; }
    case 3: 
      $stepmul=40;
      label = 4; break;
    case 4: 
      var $7=$debt;
      var $div=((((($7)|0))/(200))&-1);
      var $add=((($div)+(1))|0);
      $debt=$add;
      var $8=$debt;
      var $9=$stepmul;
      var $div1=(((2147483644)/((($9)|0)))&-1);
      var $cmp2=(($8)|0) < (($div1)|0);
      if ($cmp2) { label = 5; break; } else { label = 6; break; }
    case 5: 
      var $10=$debt;
      var $11=$stepmul;
      var $mul=Math.imul($10,$11);
      var $cond = $mul;label = 7; break;
    case 6: 
      var $cond = 2147483644;label = 7; break;
    case 7: 
      var $cond;
      $debt=$cond;
      label = 8; break;
    case 8: 
      var $12=$L_addr;
      var $call=_singlestep($12);
      $work=$call;
      var $13=$work;
      var $14=$debt;
      var $sub=((($14)-($13))|0);
      $debt=$sub;
      label = 9; break;
    case 9: 
      var $15=$debt;
      var $cmp3=(($15)|0) > -1600;
      if ($cmp3) { label = 10; break; } else { var $18 = 0;label = 11; break; }
    case 10: 
      var $16=$g;
      var $gcstate=(($16+53)|0);
      var $17=HEAP8[($gcstate)];
      var $conv=(($17)&255);
      var $cmp4=(($conv)|0)!=5;
      var $18 = $cmp4;label = 11; break;
    case 11: 
      var $18;
      if ($18) { label = 8; break; } else { label = 12; break; }
    case 12: 
      var $19=$g;
      var $gcstate6=(($19+53)|0);
      var $20=HEAP8[($gcstate6)];
      var $conv7=(($20)&255);
      var $cmp8=(($conv7)|0)==5;
      if ($cmp8) { label = 13; break; } else { label = 14; break; }
    case 13: 
      var $21=$g;
      var $GCestimate=(($21+20)|0);
      var $22=HEAP32[(($GCestimate)>>2)];
      var $div11=Math.floor(((($22)>>>0))/(200));
      var $sub12=(((-$div11))|0);
      var $23=$g;
      var $gcpause=(($23+136)|0);
      var $24=HEAP32[(($gcpause)>>2)];
      var $mul13=Math.imul($sub12,$24);
      $debt=$mul13;
      label = 15; break;
    case 14: 
      var $25=$debt;
      var $26=$stepmul;
      var $div14=((((($25)|0))/((($26)|0)))&-1);
      var $mul15=((($div14)*(200))&-1);
      $debt=$mul15;
      label = 15; break;
    case 15: 
      var $27=$g;
      var $28=$debt;
      _luaE_setdebt($27, $28);

      Module.print(INDENT + 'Exiting: _incstep');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_incstep["X"]=1;

function _luaC_step($L) {
  var label = 0;

  Module.print(INDENT + ' Entering: _luaC_step: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $L_addr;
      var $g;
      $L_addr=$L;
      var $0=$L_addr;
      var $l_G=(($0+12)|0);
      var $1=HEAP32[(($l_G)>>2)];
      $g=$1;
      var $2=$g;
      var $gcrunning=(($2+55)|0);
      var $3=HEAP8[($gcrunning)];
      var $tobool=(($3 << 24) >> 24)!=0;
      if ($tobool) { label = 3; break; } else { label = 4; break; }
    case 3: 
      var $4=$L_addr;
      _luaC_forcestep($4);
      label = 5; break;
    case 4: 
      var $5=$g;
      _luaE_setdebt($5, -1600);
      label = 5; break;
    case 5: 

      Module.print(INDENT + 'Exiting: _luaC_step');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _GCTM($L, $propagateerrors) {
  var label = 0;
  var __stackBase__  = STACKTOP; STACKTOP = (STACKTOP + 12)|0; _memset(__stackBase__, 0, 12);
  Module.print(INDENT + ' Entering: _GCTM: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $L_addr;
      var $propagateerrors_addr;
      var $g;
      var $tm;
      var $v=__stackBase__;
      var $io;
      var $i_g;
      var $status;
      var $oldah;
      var $running;
      var $io2;
      var $io1;
      var $io213;
      var $io114;
      var $msg;
      $L_addr=$L;
      $propagateerrors_addr=$propagateerrors;
      var $0=$L_addr;
      var $l_G=(($0+12)|0);
      var $1=HEAP32[(($l_G)>>2)];
      $g=$1;
      $io=$v;
      var $2=$g;
      var $call=_udata2finalize($2);
      $i_g=$call;
      var $3=$i_g;
      var $4=$io;
      var $value_=(($4)|0);
      var $gc=$value_;
      HEAP32[(($gc)>>2)]=$3;
      var $5=$i_g;
      var $gch=$5;
      var $tt=(($gch+4)|0);
      var $6=HEAP8[($tt)];
      var $conv=(($6)&255);
      var $or=$conv | 64;
      var $7=$io;
      var $tt_=(($7+8)|0);
      HEAP32[(($tt_)>>2)]=$or;
      var $8=$L_addr;
      var $call1=_luaT_gettmbyobj($8, $v, 2);
      $tm=$call1;
      var $9=$tm;
      var $cmp=(($9)|0)!=0;
      if ($cmp) { label = 3; break; } else { label = 13; break; }
    case 3: 
      var $10=$tm;
      var $tt_3=(($10+8)|0);
      var $11=HEAP32[(($tt_3)>>2)];
      var $and=$11 & 15;
      var $cmp4=(($and)|0)==6;
      if ($cmp4) { label = 4; break; } else { label = 13; break; }
    case 4: 
      var $12=$L_addr;
      var $allowhook=(($12+41)|0);
      var $13=HEAP8[($allowhook)];
      $oldah=$13;
      var $14=$g;
      var $gcrunning=(($14+55)|0);
      var $15=HEAP8[($gcrunning)];
      var $conv6=(($15)&255);
      $running=$conv6;
      var $16=$L_addr;
      var $allowhook7=(($16+41)|0);
      HEAP8[($allowhook7)]=0;
      var $17=$g;
      var $gcrunning8=(($17+55)|0);
      HEAP8[($gcrunning8)]=0;
      var $18=$tm;
      $io2=$18;
      var $19=$L_addr;
      var $top=(($19+8)|0);
      var $20=HEAP32[(($top)>>2)];
      $io1=$20;
      var $21=$io1;
      var $value_9=(($21)|0);
      var $22=$io2;
      var $value_10=(($22)|0);
      var $23=$value_9;
      var $24=$value_10;
      HEAP32[(($23)>>2)]=HEAP32[(($24)>>2)];HEAP32[((($23)+(4))>>2)]=HEAP32[((($24)+(4))>>2)];
      var $25=$io2;
      var $tt_11=(($25+8)|0);
      var $26=HEAP32[(($tt_11)>>2)];
      var $27=$io1;
      var $tt_12=(($27+8)|0);
      HEAP32[(($tt_12)>>2)]=$26;
      $io213=$v;
      var $28=$L_addr;
      var $top15=(($28+8)|0);
      var $29=HEAP32[(($top15)>>2)];
      var $add_ptr=(($29+12)|0);
      $io114=$add_ptr;
      var $30=$io114;
      var $value_16=(($30)|0);
      var $31=$io213;
      var $value_17=(($31)|0);
      var $32=$value_16;
      var $33=$value_17;
      HEAP32[(($32)>>2)]=HEAP32[(($33)>>2)];HEAP32[((($32)+(4))>>2)]=HEAP32[((($33)+(4))>>2)];
      var $34=$io213;
      var $tt_18=(($34+8)|0);
      var $35=HEAP32[(($tt_18)>>2)];
      var $36=$io114;
      var $tt_19=(($36+8)|0);
      HEAP32[(($tt_19)>>2)]=$35;
      var $37=$L_addr;
      var $top20=(($37+8)|0);
      var $38=HEAP32[(($top20)>>2)];
      var $add_ptr21=(($38+24)|0);
      HEAP32[(($top20)>>2)]=$add_ptr21;
      var $39=$L_addr;
      var $40=$L_addr;
      var $top22=(($40+8)|0);
      var $41=HEAP32[(($top22)>>2)];
      var $add_ptr23=((($41)-(24))|0);
      var $42=$add_ptr23;
      var $43=$L_addr;
      var $stack=(($43+28)|0);
      var $44=HEAP32[(($stack)>>2)];
      var $45=$44;
      var $sub_ptr_lhs_cast=$42;
      var $sub_ptr_rhs_cast=$45;
      var $sub_ptr_sub=((($sub_ptr_lhs_cast)-($sub_ptr_rhs_cast))|0);
      var $call24=_luaD_pcall($39, 8, 0, $sub_ptr_sub, 0);
      $status=$call24;
      var $46=$oldah;
      var $47=$L_addr;
      var $allowhook25=(($47+41)|0);
      HEAP8[($allowhook25)]=$46;
      var $48=$running;
      var $conv26=(($48) & 255);
      var $49=$g;
      var $gcrunning27=(($49+55)|0);
      HEAP8[($gcrunning27)]=$conv26;
      var $50=$status;
      var $cmp28=(($50)|0)!=0;
      if ($cmp28) { label = 5; break; } else { label = 12; break; }
    case 5: 
      var $51=$propagateerrors_addr;
      var $tobool=(($51)|0)!=0;
      if ($tobool) { label = 6; break; } else { label = 12; break; }
    case 6: 
      var $52=$status;
      var $cmp32=(($52)|0)==2;
      if ($cmp32) { label = 7; break; } else { label = 11; break; }
    case 7: 
      var $53=$L_addr;
      var $top35=(($53+8)|0);
      var $54=HEAP32[(($top35)>>2)];
      var $add_ptr36=((($54)-(12))|0);
      var $tt_37=(($add_ptr36+8)|0);
      var $55=HEAP32[(($tt_37)>>2)];
      var $and38=$55 & 15;
      var $cmp39=(($and38)|0)==4;
      if ($cmp39) { label = 8; break; } else { label = 9; break; }
    case 8: 
      var $56=$L_addr;
      var $top41=(($56+8)|0);
      var $57=HEAP32[(($top41)>>2)];
      var $add_ptr42=((($57)-(12))|0);
      var $value_43=(($add_ptr42)|0);
      var $gc44=$value_43;
      var $58=HEAP32[(($gc44)>>2)];
      var $ts=$58;
      var $add_ptr45=(($ts+16)|0);
      var $59=$add_ptr45;
      var $cond = $59;label = 10; break;
    case 9: 
      var $cond = ((5244632)|0);label = 10; break;
    case 10: 
      var $cond;
      $msg=$cond;
      var $60=$L_addr;
      var $61=$msg;
      var $call46=_luaO_pushfstring($60, ((5246468)|0), (tempInt=STACKTOP,_memset(STACKTOP, 0, 4),STACKTOP = (STACKTOP + 4)|0,HEAP32[((tempInt)>>2)]=$61,tempInt));
      $status=5;
      label = 11; break;
    case 11: 
      var $62=$L_addr;
      var $63=$status;
      _luaD_throw($62, $63);

    case 12: 
      label = 13; break;
    case 13: 
      STACKTOP = __stackBase__;
      Module.print(INDENT + 'Exiting: _GCTM');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_GCTM["X"]=1;

function _udata2finalize($g) {
  var label = 0;

  Module.print(INDENT + ' Entering: _udata2finalize: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $g_addr;
      var $o;
      $g_addr=$g;
      var $0=$g_addr;
      var $tobefnz=(($0+96)|0);
      var $1=HEAP32[(($tobefnz)>>2)];
      $o=$1;
      var $2=$o;
      var $gch=$2;
      var $next=(($gch)|0);
      var $3=HEAP32[(($next)>>2)];
      var $4=$g_addr;
      var $tobefnz1=(($4+96)|0);
      HEAP32[(($tobefnz1)>>2)]=$3;
      var $5=$g_addr;
      var $allgc=(($5+60)|0);
      var $6=HEAP32[(($allgc)>>2)];
      var $7=$o;
      var $gch2=$7;
      var $next3=(($gch2)|0);
      HEAP32[(($next3)>>2)]=$6;
      var $8=$o;
      var $9=$g_addr;
      var $allgc4=(($9+60)|0);
      HEAP32[(($allgc4)>>2)]=$8;
      var $10=$o;
      var $gch5=$10;
      var $marked=(($gch5+5)|0);
      var $11=HEAP8[($marked)];
      var $conv=(($11)&255);
      var $and=$conv & 239;
      var $conv6=(($and) & 255);
      HEAP8[($marked)]=$conv6;
      var $12=$g_addr;
      var $gckind=(($12+54)|0);
      var $13=HEAP8[($gckind)];
      var $conv7=(($13)&255);
      var $cmp=(($conv7)|0)==2;
      if ($cmp) { label = 5; break; } else { label = 3; break; }
    case 3: 
      var $14=$g_addr;
      var $gcstate=(($14+53)|0);
      var $15=HEAP8[($gcstate)];
      var $conv9=(($15)&255);
      var $cmp10=(($conv9)|0) <= 1;
      if ($cmp10) { label = 5; break; } else { label = 4; break; }
    case 4: 
      var $16=$o;
      var $gch12=$16;
      var $marked13=(($gch12+5)|0);
      var $17=HEAP8[($marked13)];
      var $conv14=(($17)&255);
      var $and15=$conv14 & -72;
      var $18=$g_addr;
      var $currentwhite=(($18+52)|0);
      var $19=HEAP8[($currentwhite)];
      var $conv16=(($19)&255);
      var $and17=$conv16 & 3;
      var $conv18=(($and17) & 255);
      var $conv19=(($conv18)&255);
      var $or=$and15 | $conv19;
      var $conv20=(($or) & 255);
      var $20=$o;
      var $gch21=$20;
      var $marked22=(($gch21+5)|0);
      HEAP8[($marked22)]=$conv20;
      label = 5; break;
    case 5: 
      var $21=$o;

      Module.print(INDENT + 'Exiting: _udata2finalize');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return $21;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_udata2finalize["X"]=1;

function _luaC_fullgc($L, $isemergency) {
  var label = 0;

  Module.print(INDENT + ' Entering: _luaC_fullgc: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $L_addr;
      var $isemergency_addr;
      var $g;
      var $origkind;
      var $someblack;
      $L_addr=$L;
      $isemergency_addr=$isemergency;
      var $0=$L_addr;
      var $l_G=(($0+12)|0);
      var $1=HEAP32[(($l_G)>>2)];
      $g=$1;
      var $2=$g;
      var $gckind=(($2+54)|0);
      var $3=HEAP8[($gckind)];
      var $conv=(($3)&255);
      $origkind=$conv;
      var $4=$g;
      var $gckind1=(($4+54)|0);
      var $5=HEAP8[($gckind1)];
      var $conv2=(($5)&255);
      var $cmp=(($conv2)|0)==2;
      if ($cmp) { var $8 = 1;label = 4; break; } else { label = 3; break; }
    case 3: 
      var $6=$g;
      var $gcstate=(($6+53)|0);
      var $7=HEAP8[($gcstate)];
      var $conv4=(($7)&255);
      var $cmp5=(($conv4)|0) <= 1;
      var $8 = $cmp5;label = 4; break;
    case 4: 
      var $8;
      var $lor_ext=(($8)&1);
      $someblack=$lor_ext;
      var $9=$isemergency_addr;
      var $tobool=(($9)|0)!=0;
      if ($tobool) { label = 5; break; } else { label = 6; break; }
    case 5: 
      var $10=$g;
      var $gckind7=(($10+54)|0);
      HEAP8[($gckind7)]=1;
      label = 7; break;
    case 6: 
      var $11=$g;
      var $gckind8=(($11+54)|0);
      HEAP8[($gckind8)]=0;
      var $12=$L_addr;
      _callallpendingfinalizers($12, 1);
      label = 7; break;
    case 7: 
      var $13=$someblack;
      var $tobool9=(($13)|0)!=0;
      if ($tobool9) { label = 8; break; } else { label = 9; break; }
    case 8: 
      var $14=$L_addr;
      var $call=_entersweep($14);
      label = 9; break;
    case 9: 
      var $15=$L_addr;
      _luaC_runtilstate($15, 32);
      var $16=$L_addr;
      _luaC_runtilstate($16, -33);
      var $17=$L_addr;
      _luaC_runtilstate($17, 32);
      var $18=$origkind;
      var $cmp12=(($18)|0)==2;
      if ($cmp12) { label = 10; break; } else { label = 11; break; }
    case 10: 
      var $19=$L_addr;
      _luaC_runtilstate($19, 1);
      label = 11; break;
    case 11: 
      var $20=$origkind;
      var $conv16=(($20) & 255);
      var $21=$g;
      var $gckind17=(($21+54)|0);
      HEAP8[($gckind17)]=$conv16;
      var $22=$g;
      var $23=$g;
      var $totalbytes=(($23+8)|0);
      var $24=HEAP32[(($totalbytes)>>2)];
      var $25=$g;
      var $GCdebt=(($25+12)|0);
      var $26=HEAP32[(($GCdebt)>>2)];
      var $add=((($24)+($26))|0);
      var $div=Math.floor(((($add)>>>0))/(200));
      var $sub=(((-$div))|0);
      var $27=$g;
      var $gcpause=(($27+136)|0);
      var $28=HEAP32[(($gcpause)>>2)];
      var $mul=Math.imul($sub,$28);
      _luaE_setdebt($22, $mul);
      var $29=$isemergency_addr;
      var $tobool18=(($29)|0)!=0;
      if ($tobool18) { label = 13; break; } else { label = 12; break; }
    case 12: 
      var $30=$L_addr;
      _callallpendingfinalizers($30, 1);
      label = 13; break;
    case 13: 

      Module.print(INDENT + 'Exiting: _luaC_fullgc');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_luaC_fullgc["X"]=1;

function _dothecall($L, $ud) {
  var label = 0;

  Module.print(INDENT + ' Entering: _dothecall: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';

  var $L_addr;
  var $ud_addr;
  $L_addr=$L;
  $ud_addr=$ud;
  var $0=$ud_addr;
  var $1=$L_addr;
  var $2=$L_addr;
  var $top=(($2+8)|0);
  var $3=HEAP32[(($top)>>2)];
  var $add_ptr=((($3)-(24))|0);
  _luaD_call($1, $add_ptr, 0, 0);

  Module.print(INDENT + 'Exiting: _dothecall');
  INDENT = INDENT.substr(0, INDENT.length-2);
  return;
  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _markroot($g) {
  var label = 0;

  Module.print(INDENT + ' Entering: _markroot: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $g_addr;
      $g_addr=$g;
      var $0=$g_addr;
      var $grayagain=(($0+80)|0);
      HEAP32[(($grayagain)>>2)]=0;
      var $1=$g_addr;
      var $gray=(($1+76)|0);
      HEAP32[(($gray)>>2)]=0;
      var $2=$g_addr;
      var $ephemeron=(($2+88)|0);
      HEAP32[(($ephemeron)>>2)]=0;
      var $3=$g_addr;
      var $allweak=(($3+92)|0);
      HEAP32[(($allweak)>>2)]=0;
      var $4=$g_addr;
      var $weak=(($4+84)|0);
      HEAP32[(($weak)>>2)]=0;
      var $5=$g_addr;
      var $mainthread=(($5+152)|0);
      var $6=HEAP32[(($mainthread)>>2)];
      var $tobool=(($6)|0)!=0;
      if ($tobool) { label = 3; break; } else { label = 5; break; }
    case 3: 
      var $7=$g_addr;
      var $mainthread1=(($7+152)|0);
      var $8=HEAP32[(($mainthread1)>>2)];
      var $9=$8;
      var $gch=$9;
      var $marked=(($gch+5)|0);
      var $10=HEAP8[($marked)];
      var $conv=(($10)&255);
      var $and=$conv & 3;
      var $tobool2=(($and)|0)!=0;
      if ($tobool2) { label = 4; break; } else { label = 5; break; }
    case 4: 
      var $11=$g_addr;
      var $12=$g_addr;
      var $mainthread3=(($12+152)|0);
      var $13=HEAP32[(($mainthread3)>>2)];
      var $14=$13;
      _reallymarkobject($11, $14);
      label = 5; break;
    case 5: 
      var $15=$g_addr;
      var $l_registry=(($15+36)|0);
      var $tt_=(($l_registry+8)|0);
      var $16=HEAP32[(($tt_)>>2)];
      var $and4=$16 & 64;
      var $tobool5=(($and4)|0)!=0;
      if ($tobool5) { label = 6; break; } else { label = 8; break; }
    case 6: 
      var $17=$g_addr;
      var $l_registry7=(($17+36)|0);
      var $value_=(($l_registry7)|0);
      var $gc=$value_;
      var $18=HEAP32[(($gc)>>2)];
      var $gch8=$18;
      var $marked9=(($gch8+5)|0);
      var $19=HEAP8[($marked9)];
      var $conv10=(($19)&255);
      var $and11=$conv10 & 3;
      var $tobool12=(($and11)|0)!=0;
      if ($tobool12) { label = 7; break; } else { label = 8; break; }
    case 7: 
      var $20=$g_addr;
      var $21=$g_addr;
      var $l_registry14=(($21+36)|0);
      var $value_15=(($l_registry14)|0);
      var $gc16=$value_15;
      var $22=HEAP32[(($gc16)>>2)];
      _reallymarkobject($20, $22);
      label = 8; break;
    case 8: 
      var $23=$g_addr;
      _markmt($23);
      var $24=$g_addr;
      _markbeingfnz($24);

      Module.print(INDENT + 'Exiting: _markroot');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_markroot["X"]=1;

function _propagatemark($g) {
  var label = 0;

  Module.print(INDENT + ' Entering: _propagatemark: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $g_addr;
      var $size;
      var $o;
      var $h;
      var $cl;
      var $cl12;
      var $th;
      var $p;
      $g_addr=$g;
      var $0=$g_addr;
      var $gray=(($0+76)|0);
      var $1=HEAP32[(($gray)>>2)];
      $o=$1;
      var $2=$o;
      var $gch=$2;
      var $marked=(($gch+5)|0);
      var $3=HEAP8[($marked)];
      var $conv=(($3)&255);
      var $or=$conv | 4;
      var $conv1=(($or) & 255);
      HEAP8[($marked)]=$conv1;
      var $4=$o;
      var $gch2=$4;
      var $tt=(($gch2+4)|0);
      var $5=HEAP8[($tt)];
      var $conv3=(($5)&255);
      if ((($conv3)|0)==5) {
        label = 3; break;
      }
      else if ((($conv3)|0)==6) {
        label = 4; break;
      }
      else if ((($conv3)|0)==38) {
        label = 5; break;
      }
      else if ((($conv3)|0)==8) {
        label = 6; break;
      }
      else if ((($conv3)|0)==9) {
        label = 7; break;
      }
      else {
      label = 8; break;
      }
      
    case 3: 
      var $6=$o;
      var $h4=$6;
      $h=$h4;
      var $7=$h;
      var $gclist=(($7+24)|0);
      var $8=HEAP32[(($gclist)>>2)];
      var $9=$g_addr;
      var $gray5=(($9+76)|0);
      HEAP32[(($gray5)>>2)]=$8;
      var $10=$g_addr;
      var $11=$h;
      var $call=_traversetable($10, $11);
      $size=$call;
      label = 9; break;
    case 4: 
      var $12=$o;
      var $cl7=$12;
      var $l=$cl7;
      $cl=$l;
      var $13=$cl;
      var $gclist8=(($13+8)|0);
      var $14=HEAP32[(($gclist8)>>2)];
      var $15=$g_addr;
      var $gray9=(($15+76)|0);
      HEAP32[(($gray9)>>2)]=$14;
      var $16=$g_addr;
      var $17=$cl;
      var $call10=_traverseLclosure($16, $17);
      $size=$call10;
      label = 9; break;
    case 5: 
      var $18=$o;
      var $cl13=$18;
      var $c=$cl13;
      $cl12=$c;
      var $19=$cl12;
      var $gclist14=(($19+8)|0);
      var $20=HEAP32[(($gclist14)>>2)];
      var $21=$g_addr;
      var $gray15=(($21+76)|0);
      HEAP32[(($gray15)>>2)]=$20;
      var $22=$g_addr;
      var $23=$cl12;
      var $call16=_traverseCclosure($22, $23);
      $size=$call16;
      label = 9; break;
    case 6: 
      var $24=$o;
      var $th18=$24;
      $th=$th18;
      var $25=$th;
      var $gclist19=(($25+60)|0);
      var $26=HEAP32[(($gclist19)>>2)];
      var $27=$g_addr;
      var $gray20=(($27+76)|0);
      HEAP32[(($gray20)>>2)]=$26;
      var $28=$g_addr;
      var $grayagain=(($28+80)|0);
      var $29=HEAP32[(($grayagain)>>2)];
      var $30=$th;
      var $gclist21=(($30+60)|0);
      HEAP32[(($gclist21)>>2)]=$29;
      var $31=$o;
      var $32=$g_addr;
      var $grayagain22=(($32+80)|0);
      HEAP32[(($grayagain22)>>2)]=$31;
      var $33=$o;
      var $gch23=$33;
      var $marked24=(($gch23+5)|0);
      var $34=HEAP8[($marked24)];
      var $conv25=(($34)&255);
      var $and=$conv25 & 251;
      var $conv26=(($and) & 255);
      HEAP8[($marked24)]=$conv26;
      var $35=$g_addr;
      var $36=$th;
      var $call27=_traversestack($35, $36);
      $size=$call27;
      label = 9; break;
    case 7: 
      var $37=$o;
      var $p29=$37;
      $p=$p29;
      var $38=$p;
      var $gclist30=(($38+72)|0);
      var $39=HEAP32[(($gclist30)>>2)];
      var $40=$g_addr;
      var $gray31=(($40+76)|0);
      HEAP32[(($gray31)>>2)]=$39;
      var $41=$g_addr;
      var $42=$p;
      var $call32=_traverseproto($41, $42);
      $size=$call32;
      label = 9; break;
    case 8: 
      label = 10; break;
    case 9: 
      var $43=$size;
      var $44=$g_addr;
      var $GCmemtrav=(($44+16)|0);
      var $45=HEAP32[(($GCmemtrav)>>2)];
      var $add=((($45)+($43))|0);
      HEAP32[(($GCmemtrav)>>2)]=$add;
      label = 10; break;
    case 10: 

      Module.print(INDENT + 'Exiting: _propagatemark');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_propagatemark["X"]=1;

function _atomic($L) {
  var label = 0;

  Module.print(INDENT + ' Entering: _atomic: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $L_addr;
      var $g;
      var $work;
      var $origweak;
      var $origall;
      $L_addr=$L;
      var $0=$L_addr;
      var $l_G=(($0+12)|0);
      var $1=HEAP32[(($l_G)>>2)];
      $g=$1;
      var $2=$g;
      var $GCmemtrav=(($2+16)|0);
      var $3=HEAP32[(($GCmemtrav)>>2)];
      var $sub=(((-$3))|0);
      $work=$sub;
      var $4=$L_addr;
      var $tobool=(($4)|0)!=0;
      if ($tobool) { label = 3; break; } else { label = 5; break; }
    case 3: 
      var $5=$L_addr;
      var $6=$5;
      var $gch=$6;
      var $marked=(($gch+5)|0);
      var $7=HEAP8[($marked)];
      var $conv=(($7)&255);
      var $and=$conv & 3;
      var $tobool1=(($and)|0)!=0;
      if ($tobool1) { label = 4; break; } else { label = 5; break; }
    case 4: 
      var $8=$g;
      var $9=$L_addr;
      var $10=$9;
      _reallymarkobject($8, $10);
      label = 5; break;
    case 5: 
      var $11=$g;
      var $l_registry=(($11+36)|0);
      var $tt_=(($l_registry+8)|0);
      var $12=HEAP32[(($tt_)>>2)];
      var $and2=$12 & 64;
      var $tobool3=(($and2)|0)!=0;
      if ($tobool3) { label = 6; break; } else { label = 8; break; }
    case 6: 
      var $13=$g;
      var $l_registry5=(($13+36)|0);
      var $value_=(($l_registry5)|0);
      var $gc=$value_;
      var $14=HEAP32[(($gc)>>2)];
      var $gch6=$14;
      var $marked7=(($gch6+5)|0);
      var $15=HEAP8[($marked7)];
      var $conv8=(($15)&255);
      var $and9=$conv8 & 3;
      var $tobool10=(($and9)|0)!=0;
      if ($tobool10) { label = 7; break; } else { label = 8; break; }
    case 7: 
      var $16=$g;
      var $17=$g;
      var $l_registry12=(($17+36)|0);
      var $value_13=(($l_registry12)|0);
      var $gc14=$value_13;
      var $18=HEAP32[(($gc14)>>2)];
      _reallymarkobject($16, $18);
      label = 8; break;
    case 8: 
      var $19=$g;
      _markmt($19);
      var $20=$g;
      _remarkupvals($20);
      var $21=$g;
      _propagateall($21);
      var $22=$g;
      var $GCmemtrav16=(($22+16)|0);
      var $23=HEAP32[(($GCmemtrav16)>>2)];
      var $24=$work;
      var $add=((($24)+($23))|0);
      $work=$add;
      var $25=$g;
      _retraversegrays($25);
      var $26=$g;
      var $GCmemtrav17=(($26+16)|0);
      var $27=HEAP32[(($GCmemtrav17)>>2)];
      var $28=$work;
      var $sub18=((($28)-($27))|0);
      $work=$sub18;
      var $29=$g;
      _convergeephemerons($29);
      var $30=$g;
      var $31=$g;
      var $weak=(($31+84)|0);
      var $32=HEAP32[(($weak)>>2)];
      _clearvalues($30, $32, 0);
      var $33=$g;
      var $34=$g;
      var $allweak=(($34+92)|0);
      var $35=HEAP32[(($allweak)>>2)];
      _clearvalues($33, $35, 0);
      var $36=$g;
      var $weak19=(($36+84)|0);
      var $37=HEAP32[(($weak19)>>2)];
      $origweak=$37;
      var $38=$g;
      var $allweak20=(($38+92)|0);
      var $39=HEAP32[(($allweak20)>>2)];
      $origall=$39;
      var $40=$g;
      var $GCmemtrav21=(($40+16)|0);
      var $41=HEAP32[(($GCmemtrav21)>>2)];
      var $42=$work;
      var $add22=((($42)+($41))|0);
      $work=$add22;
      var $43=$L_addr;
      _separatetobefnz($43, 0);
      var $44=$g;
      _markbeingfnz($44);
      var $45=$g;
      _propagateall($45);
      var $46=$g;
      var $GCmemtrav23=(($46+16)|0);
      var $47=HEAP32[(($GCmemtrav23)>>2)];
      var $48=$work;
      var $sub24=((($48)-($47))|0);
      $work=$sub24;
      var $49=$g;
      _convergeephemerons($49);
      var $50=$g;
      var $51=$g;
      var $ephemeron=(($51+88)|0);
      var $52=HEAP32[(($ephemeron)>>2)];
      _clearkeys($50, $52, 0);
      var $53=$g;
      var $54=$g;
      var $allweak25=(($54+92)|0);
      var $55=HEAP32[(($allweak25)>>2)];
      _clearkeys($53, $55, 0);
      var $56=$g;
      var $57=$g;
      var $weak26=(($57+84)|0);
      var $58=HEAP32[(($weak26)>>2)];
      var $59=$origweak;
      _clearvalues($56, $58, $59);
      var $60=$g;
      var $61=$g;
      var $allweak27=(($61+92)|0);
      var $62=HEAP32[(($allweak27)>>2)];
      var $63=$origall;
      _clearvalues($60, $62, $63);
      var $64=$g;
      var $currentwhite=(($64+52)|0);
      var $65=HEAP8[($currentwhite)];
      var $conv28=(($65)&255);
      var $xor=$conv28 ^ 3;
      var $conv29=(($xor) & 255);
      var $66=$g;
      var $currentwhite30=(($66+52)|0);
      HEAP8[($currentwhite30)]=$conv29;
      var $67=$g;
      var $GCmemtrav31=(($67+16)|0);
      var $68=HEAP32[(($GCmemtrav31)>>2)];
      var $69=$work;
      var $add32=((($69)+($68))|0);
      $work=$add32;
      var $70=$work;

      Module.print(INDENT + 'Exiting: _atomic');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return $70;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_atomic["X"]=1;

function _checkSizes($L) {
  var label = 0;

  Module.print(INDENT + ' Entering: _checkSizes: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $L_addr;
      var $g;
      var $hs;
      $L_addr=$L;
      var $0=$L_addr;
      var $l_G=(($0+12)|0);
      var $1=HEAP32[(($l_G)>>2)];
      $g=$1;
      var $2=$g;
      var $gckind=(($2+54)|0);
      var $3=HEAP8[($gckind)];
      var $conv=(($3)&255);
      var $cmp=(($conv)|0)!=1;
      if ($cmp) { label = 3; break; } else { label = 6; break; }
    case 3: 
      var $4=$g;
      var $strt=(($4+24)|0);
      var $size=(($strt+8)|0);
      var $5=HEAP32[(($size)>>2)];
      var $div=((((($5)|0))/(2))&-1);
      $hs=$div;
      var $6=$g;
      var $strt2=(($6+24)|0);
      var $nuse=(($strt2+4)|0);
      var $7=HEAP32[(($nuse)>>2)];
      var $8=$hs;
      var $cmp3=(($7)>>>0) < (($8)>>>0);
      if ($cmp3) { label = 4; break; } else { label = 5; break; }
    case 4: 
      var $9=$L_addr;
      var $10=$hs;
      _luaS_resize($9, $10);
      label = 5; break;
    case 5: 
      var $11=$L_addr;
      var $12=$g;
      var $buff=(($12+124)|0);
      var $buffer=(($buff)|0);
      var $13=HEAP32[(($buffer)>>2)];
      var $14=$g;
      var $buff6=(($14+124)|0);
      var $buffsize=(($buff6+8)|0);
      var $15=HEAP32[(($buffsize)>>2)];
      var $mul=$15;
      var $call=_luaM_realloc_($11, $13, $mul, 0);
      var $16=$g;
      var $buff7=(($16+124)|0);
      var $buffer8=(($buff7)|0);
      HEAP32[(($buffer8)>>2)]=$call;
      var $17=$g;
      var $buff9=(($17+124)|0);
      var $buffsize10=(($buff9+8)|0);
      HEAP32[(($buffsize10)>>2)]=0;
      label = 6; break;
    case 6: 

      Module.print(INDENT + 'Exiting: _checkSizes');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_checkSizes["X"]=1;

function _markmt($g) {
  var label = 0;

  Module.print(INDENT + ' Entering: _markmt: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $g_addr;
      var $i;
      $g_addr=$g;
      $i=0;
      label = 3; break;
    case 3: 
      var $0=$i;
      var $cmp=(($0)|0) < 9;
      if ($cmp) { label = 4; break; } else { label = 9; break; }
    case 4: 
      var $1=$i;
      var $2=$g_addr;
      var $mt=(($2+232)|0);
      var $arrayidx=(($mt+($1<<2))|0);
      var $3=HEAP32[(($arrayidx)>>2)];
      var $tobool=(($3)|0)!=0;
      if ($tobool) { label = 5; break; } else { label = 7; break; }
    case 5: 
      var $4=$i;
      var $5=$g_addr;
      var $mt1=(($5+232)|0);
      var $arrayidx2=(($mt1+($4<<2))|0);
      var $6=HEAP32[(($arrayidx2)>>2)];
      var $7=$6;
      var $gch=$7;
      var $marked=(($gch+5)|0);
      var $8=HEAP8[($marked)];
      var $conv=(($8)&255);
      var $and=$conv & 3;
      var $tobool3=(($and)|0)!=0;
      if ($tobool3) { label = 6; break; } else { label = 7; break; }
    case 6: 
      var $9=$g_addr;
      var $10=$i;
      var $11=$g_addr;
      var $mt4=(($11+232)|0);
      var $arrayidx5=(($mt4+($10<<2))|0);
      var $12=HEAP32[(($arrayidx5)>>2)];
      var $13=$12;
      _reallymarkobject($9, $13);
      label = 7; break;
    case 7: 
      label = 8; break;
    case 8: 
      var $14=$i;
      var $inc=((($14)+(1))|0);
      $i=$inc;
      label = 3; break;
    case 9: 

      Module.print(INDENT + 'Exiting: _markmt');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _remarkupvals($g) {
  var label = 0;

  Module.print(INDENT + ' Entering: _remarkupvals: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $g_addr;
      var $uv;
      $g_addr=$g;
      var $0=$g_addr;
      var $uvhead=(($0+100)|0);
      var $u=(($uvhead+12)|0);
      var $l=$u;
      var $next=(($l+4)|0);
      var $1=HEAP32[(($next)>>2)];
      $uv=$1;
      label = 3; break;
    case 3: 
      var $2=$uv;
      var $3=$g_addr;
      var $uvhead1=(($3+100)|0);
      var $cmp=(($2)|0)!=(($uvhead1)|0);
      if ($cmp) { label = 4; break; } else { label = 11; break; }
    case 4: 
      var $4=$uv;
      var $5=$4;
      var $gch=$5;
      var $marked=(($gch+5)|0);
      var $6=HEAP8[($marked)];
      var $conv=(($6)&255);
      var $and=$conv & 7;
      var $tobool=(($and)|0)!=0;
      if ($tobool) { label = 9; break; } else { label = 5; break; }
    case 5: 
      var $7=$uv;
      var $v=(($7+8)|0);
      var $8=HEAP32[(($v)>>2)];
      var $tt_=(($8+8)|0);
      var $9=HEAP32[(($tt_)>>2)];
      var $and2=$9 & 64;
      var $tobool3=(($and2)|0)!=0;
      if ($tobool3) { label = 6; break; } else { label = 8; break; }
    case 6: 
      var $10=$uv;
      var $v4=(($10+8)|0);
      var $11=HEAP32[(($v4)>>2)];
      var $value_=(($11)|0);
      var $gc=$value_;
      var $12=HEAP32[(($gc)>>2)];
      var $gch5=$12;
      var $marked6=(($gch5+5)|0);
      var $13=HEAP8[($marked6)];
      var $conv7=(($13)&255);
      var $and8=$conv7 & 3;
      var $tobool9=(($and8)|0)!=0;
      if ($tobool9) { label = 7; break; } else { label = 8; break; }
    case 7: 
      var $14=$g_addr;
      var $15=$uv;
      var $v11=(($15+8)|0);
      var $16=HEAP32[(($v11)>>2)];
      var $value_12=(($16)|0);
      var $gc13=$value_12;
      var $17=HEAP32[(($gc13)>>2)];
      _reallymarkobject($14, $17);
      label = 8; break;
    case 8: 
      label = 9; break;
    case 9: 
      label = 10; break;
    case 10: 
      var $18=$uv;
      var $u15=(($18+12)|0);
      var $l16=$u15;
      var $next17=(($l16+4)|0);
      var $19=HEAP32[(($next17)>>2)];
      $uv=$19;
      label = 3; break;
    case 11: 

      Module.print(INDENT + 'Exiting: _remarkupvals');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_remarkupvals["X"]=1;

function _propagateall($g) {
  var label = 0;

  Module.print(INDENT + ' Entering: _propagateall: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $g_addr;
      $g_addr=$g;
      label = 3; break;
    case 3: 
      var $0=$g_addr;
      var $gray=(($0+76)|0);
      var $1=HEAP32[(($gray)>>2)];
      var $tobool=(($1)|0)!=0;
      if ($tobool) { label = 4; break; } else { label = 5; break; }
    case 4: 
      var $2=$g_addr;
      _propagatemark($2);
      label = 3; break;
    case 5: 

      Module.print(INDENT + 'Exiting: _propagateall');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _retraversegrays($g) {
  var label = 0;

  Module.print(INDENT + ' Entering: _retraversegrays: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';

  var $g_addr;
  var $weak;
  var $grayagain;
  var $ephemeron;
  $g_addr=$g;
  var $0=$g_addr;
  var $weak1=(($0+84)|0);
  var $1=HEAP32[(($weak1)>>2)];
  $weak=$1;
  var $2=$g_addr;
  var $grayagain2=(($2+80)|0);
  var $3=HEAP32[(($grayagain2)>>2)];
  $grayagain=$3;
  var $4=$g_addr;
  var $ephemeron3=(($4+88)|0);
  var $5=HEAP32[(($ephemeron3)>>2)];
  $ephemeron=$5;
  var $6=$g_addr;
  var $ephemeron4=(($6+88)|0);
  HEAP32[(($ephemeron4)>>2)]=0;
  var $7=$g_addr;
  var $grayagain5=(($7+80)|0);
  HEAP32[(($grayagain5)>>2)]=0;
  var $8=$g_addr;
  var $weak6=(($8+84)|0);
  HEAP32[(($weak6)>>2)]=0;
  var $9=$g_addr;
  _propagateall($9);
  var $10=$g_addr;
  var $11=$grayagain;
  _propagatelist($10, $11);
  var $12=$g_addr;
  var $13=$weak;
  _propagatelist($12, $13);
  var $14=$g_addr;
  var $15=$ephemeron;
  _propagatelist($14, $15);

  Module.print(INDENT + 'Exiting: _retraversegrays');
  INDENT = INDENT.substr(0, INDENT.length-2);
  return;
  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _convergeephemerons($g) {
  var label = 0;

  Module.print(INDENT + ' Entering: _convergeephemerons: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $g_addr;
      var $changed;
      var $w;
      var $next;
      $g_addr=$g;
      label = 3; break;
    case 3: 
      var $0=$g_addr;
      var $ephemeron=(($0+88)|0);
      var $1=HEAP32[(($ephemeron)>>2)];
      $next=$1;
      var $2=$g_addr;
      var $ephemeron1=(($2+88)|0);
      HEAP32[(($ephemeron1)>>2)]=0;
      $changed=0;
      label = 4; break;
    case 4: 
      var $3=$next;
      $w=$3;
      var $cmp=(($3)|0)!=0;
      if ($cmp) { label = 5; break; } else { label = 8; break; }
    case 5: 
      var $4=$w;
      var $h=$4;
      var $gclist=(($h+24)|0);
      var $5=HEAP32[(($gclist)>>2)];
      $next=$5;
      var $6=$g_addr;
      var $7=$w;
      var $h2=$7;
      var $call=_traverseephemeron($6, $h2);
      var $tobool=(($call)|0)!=0;
      if ($tobool) { label = 6; break; } else { label = 7; break; }
    case 6: 
      var $8=$g_addr;
      _propagateall($8);
      $changed=1;
      label = 7; break;
    case 7: 
      label = 4; break;
    case 8: 
      label = 9; break;
    case 9: 
      var $9=$changed;
      var $tobool3=(($9)|0)!=0;
      if ($tobool3) { label = 3; break; } else { label = 10; break; }
    case 10: 

      Module.print(INDENT + 'Exiting: _convergeephemerons');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _removeentry($n) {
  var label = 0;

  Module.print(INDENT + ' Entering: _removeentry: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $n_addr;
      $n_addr=$n;
      var $0=$n_addr;
      var $i_key=(($0+12)|0);
      var $tvk=$i_key;
      var $tt_=(($tvk+8)|0);
      var $1=HEAP32[(($tt_)>>2)];
      var $and=$1 & 64;
      var $tobool=(($and)|0)!=0;
      if ($tobool) { label = 3; break; } else { label = 5; break; }
    case 3: 
      var $2=$n_addr;
      var $i_key1=(($2+12)|0);
      var $tvk2=$i_key1;
      var $value_=(($tvk2)|0);
      var $gc=$value_;
      var $3=HEAP32[(($gc)>>2)];
      var $gch=$3;
      var $marked=(($gch+5)|0);
      var $4=HEAP8[($marked)];
      var $conv=(($4)&255);
      var $and3=$conv & 3;
      var $tobool4=(($and3)|0)!=0;
      if ($tobool4) { label = 4; break; } else { label = 5; break; }
    case 4: 
      var $5=$n_addr;
      var $i_key5=(($5+12)|0);
      var $tvk6=$i_key5;
      var $tt_7=(($tvk6+8)|0);
      HEAP32[(($tt_7)>>2)]=11;
      label = 5; break;
    case 5: 

      Module.print(INDENT + 'Exiting: _removeentry');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _clearvalues($g, $l, $f) {
  var label = 0;

  Module.print(INDENT + ' Entering: _clearvalues: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $g_addr;
      var $l_addr;
      var $f_addr;
      var $h;
      var $n;
      var $limit;
      var $i;
      var $o;
      $g_addr=$g;
      $l_addr=$l;
      $f_addr=$f;
      label = 3; break;
    case 3: 
      var $0=$l_addr;
      var $1=$f_addr;
      var $cmp=(($0)|0)!=(($1)|0);
      if ($cmp) { label = 4; break; } else { label = 19; break; }
    case 4: 
      var $2=$l_addr;
      var $h1=$2;
      $h=$h1;
      var $3=$h;
      var $lsizenode=(($3+7)|0);
      var $4=HEAP8[($lsizenode)];
      var $conv=(($4)&255);
      var $shl=1 << $conv;
      var $5=$h;
      var $node=(($5+16)|0);
      var $6=HEAP32[(($node)>>2)];
      var $arrayidx=(($6+((($shl)*(28))&-1))|0);
      $limit=$arrayidx;
      $i=0;
      label = 5; break;
    case 5: 
      var $7=$i;
      var $8=$h;
      var $sizearray=(($8+28)|0);
      var $9=HEAP32[(($sizearray)>>2)];
      var $cmp3=(($7)|0) < (($9)|0);
      if ($cmp3) { label = 6; break; } else { label = 10; break; }
    case 6: 
      var $10=$i;
      var $11=$h;
      var $array=(($11+12)|0);
      var $12=HEAP32[(($array)>>2)];
      var $arrayidx6=(($12+((($10)*(12))&-1))|0);
      $o=$arrayidx6;
      var $13=$g_addr;
      var $14=$o;
      var $call=_iscleared($13, $14);
      var $tobool=(($call)|0)!=0;
      if ($tobool) { label = 7; break; } else { label = 8; break; }
    case 7: 
      var $15=$o;
      var $tt_=(($15+8)|0);
      HEAP32[(($tt_)>>2)]=0;
      label = 8; break;
    case 8: 
      label = 9; break;
    case 9: 
      var $16=$i;
      var $inc=((($16)+(1))|0);
      $i=$inc;
      label = 5; break;
    case 10: 
      var $17=$h;
      var $node7=(($17+16)|0);
      var $18=HEAP32[(($node7)>>2)];
      var $arrayidx8=(($18)|0);
      $n=$arrayidx8;
      label = 11; break;
    case 11: 
      var $19=$n;
      var $20=$limit;
      var $cmp10=(($19)>>>0) < (($20)>>>0);
      if ($cmp10) { label = 12; break; } else { label = 17; break; }
    case 12: 
      var $21=$n;
      var $i_val=(($21)|0);
      var $tt_13=(($i_val+8)|0);
      var $22=HEAP32[(($tt_13)>>2)];
      var $cmp14=(($22)|0)==0;
      if ($cmp14) { label = 15; break; } else { label = 13; break; }
    case 13: 
      var $23=$g_addr;
      var $24=$n;
      var $i_val16=(($24)|0);
      var $call17=_iscleared($23, $i_val16);
      var $tobool18=(($call17)|0)!=0;
      if ($tobool18) { label = 14; break; } else { label = 15; break; }
    case 14: 
      var $25=$n;
      var $i_val20=(($25)|0);
      var $tt_21=(($i_val20+8)|0);
      HEAP32[(($tt_21)>>2)]=0;
      var $26=$n;
      _removeentry($26);
      label = 15; break;
    case 15: 
      label = 16; break;
    case 16: 
      var $27=$n;
      var $incdec_ptr=(($27+28)|0);
      $n=$incdec_ptr;
      label = 11; break;
    case 17: 
      label = 18; break;
    case 18: 
      var $28=$l_addr;
      var $h26=$28;
      var $gclist=(($h26+24)|0);
      var $29=HEAP32[(($gclist)>>2)];
      $l_addr=$29;
      label = 3; break;
    case 19: 

      Module.print(INDENT + 'Exiting: _clearvalues');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_clearvalues["X"]=1;

function _markbeingfnz($g) {
  var label = 0;

  Module.print(INDENT + ' Entering: _markbeingfnz: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $g_addr;
      var $o;
      $g_addr=$g;
      var $0=$g_addr;
      var $tobefnz=(($0+96)|0);
      var $1=HEAP32[(($tobefnz)>>2)];
      $o=$1;
      label = 3; break;
    case 3: 
      var $2=$o;
      var $cmp=(($2)|0)!=0;
      if ($cmp) { label = 4; break; } else { label = 6; break; }
    case 4: 
      var $3=$o;
      var $gch=$3;
      var $marked=(($gch+5)|0);
      var $4=HEAP8[($marked)];
      var $conv=(($4)&255);
      var $and=$conv & -72;
      var $5=$g_addr;
      var $currentwhite=(($5+52)|0);
      var $6=HEAP8[($currentwhite)];
      var $conv1=(($6)&255);
      var $and2=$conv1 & 3;
      var $conv3=(($and2) & 255);
      var $conv4=(($conv3)&255);
      var $or=$and | $conv4;
      var $conv5=(($or) & 255);
      var $7=$o;
      var $gch6=$7;
      var $marked7=(($gch6+5)|0);
      HEAP8[($marked7)]=$conv5;
      var $8=$g_addr;
      var $9=$o;
      _reallymarkobject($8, $9);
      label = 5; break;
    case 5: 
      var $10=$o;
      var $gch8=$10;
      var $next=(($gch8)|0);
      var $11=HEAP32[(($next)>>2)];
      $o=$11;
      label = 3; break;
    case 6: 

      Module.print(INDENT + 'Exiting: _markbeingfnz');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _clearkeys($g, $l, $f) {
  var label = 0;

  Module.print(INDENT + ' Entering: _clearkeys: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $g_addr;
      var $l_addr;
      var $f_addr;
      var $h;
      var $n;
      var $limit;
      $g_addr=$g;
      $l_addr=$l;
      $f_addr=$f;
      label = 3; break;
    case 3: 
      var $0=$l_addr;
      var $1=$f_addr;
      var $cmp=(($0)|0)!=(($1)|0);
      if ($cmp) { label = 4; break; } else { label = 13; break; }
    case 4: 
      var $2=$l_addr;
      var $h1=$2;
      $h=$h1;
      var $3=$h;
      var $lsizenode=(($3+7)|0);
      var $4=HEAP8[($lsizenode)];
      var $conv=(($4)&255);
      var $shl=1 << $conv;
      var $5=$h;
      var $node=(($5+16)|0);
      var $6=HEAP32[(($node)>>2)];
      var $arrayidx=(($6+((($shl)*(28))&-1))|0);
      $limit=$arrayidx;
      var $7=$h;
      var $node2=(($7+16)|0);
      var $8=HEAP32[(($node2)>>2)];
      var $arrayidx3=(($8)|0);
      $n=$arrayidx3;
      label = 5; break;
    case 5: 
      var $9=$n;
      var $10=$limit;
      var $cmp5=(($9)>>>0) < (($10)>>>0);
      if ($cmp5) { label = 6; break; } else { label = 11; break; }
    case 6: 
      var $11=$n;
      var $i_val=(($11)|0);
      var $tt_=(($i_val+8)|0);
      var $12=HEAP32[(($tt_)>>2)];
      var $cmp8=(($12)|0)==0;
      if ($cmp8) { label = 9; break; } else { label = 7; break; }
    case 7: 
      var $13=$g_addr;
      var $14=$n;
      var $i_key=(($14+12)|0);
      var $tvk=$i_key;
      var $call=_iscleared($13, $tvk);
      var $tobool=(($call)|0)!=0;
      if ($tobool) { label = 8; break; } else { label = 9; break; }
    case 8: 
      var $15=$n;
      var $i_val10=(($15)|0);
      var $tt_11=(($i_val10+8)|0);
      HEAP32[(($tt_11)>>2)]=0;
      var $16=$n;
      _removeentry($16);
      label = 9; break;
    case 9: 
      label = 10; break;
    case 10: 
      var $17=$n;
      var $incdec_ptr=(($17+28)|0);
      $n=$incdec_ptr;
      label = 5; break;
    case 11: 
      label = 12; break;
    case 12: 
      var $18=$l_addr;
      var $h13=$18;
      var $gclist=(($h13+24)|0);
      var $19=HEAP32[(($gclist)>>2)];
      $l_addr=$19;
      label = 3; break;
    case 13: 

      Module.print(INDENT + 'Exiting: _clearkeys');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_clearkeys["X"]=1;

function _iscleared($g, $o) {
  var label = 0;

  Module.print(INDENT + ' Entering: _iscleared: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $retval;
      var $g_addr;
      var $o_addr;
      $g_addr=$g;
      $o_addr=$o;
      var $0=$o_addr;
      var $tt_=(($0+8)|0);
      var $1=HEAP32[(($tt_)>>2)];
      var $and=$1 & 64;
      var $tobool=(($and)|0)!=0;
      if ($tobool) { label = 4; break; } else { label = 3; break; }
    case 3: 
      $retval=0;
      label = 10; break;
    case 4: 
      var $2=$o_addr;
      var $tt_1=(($2+8)|0);
      var $3=HEAP32[(($tt_1)>>2)];
      var $and2=$3 & 15;
      var $cmp=(($and2)|0)==4;
      if ($cmp) { label = 5; break; } else { label = 9; break; }
    case 5: 
      var $4=$o_addr;
      var $value_=(($4)|0);
      var $gc=$value_;
      var $5=HEAP32[(($gc)>>2)];
      var $ts=$5;
      var $tobool4=(($ts)|0)!=0;
      if ($tobool4) { label = 6; break; } else { label = 8; break; }
    case 6: 
      var $6=$o_addr;
      var $value_5=(($6)|0);
      var $gc6=$value_5;
      var $7=HEAP32[(($gc6)>>2)];
      var $ts7=$7;
      var $8=$ts7;
      var $gch=$8;
      var $marked=(($gch+5)|0);
      var $9=HEAP8[($marked)];
      var $conv=(($9)&255);
      var $and8=$conv & 3;
      var $tobool9=(($and8)|0)!=0;
      if ($tobool9) { label = 7; break; } else { label = 8; break; }
    case 7: 
      var $10=$g_addr;
      var $11=$o_addr;
      var $value_11=(($11)|0);
      var $gc12=$value_11;
      var $12=HEAP32[(($gc12)>>2)];
      var $ts13=$12;
      var $13=$ts13;
      _reallymarkobject($10, $13);
      label = 8; break;
    case 8: 
      $retval=0;
      label = 10; break;
    case 9: 
      var $14=$o_addr;
      var $value_15=(($14)|0);
      var $gc16=$value_15;
      var $15=HEAP32[(($gc16)>>2)];
      var $gch17=$15;
      var $marked18=(($gch17+5)|0);
      var $16=HEAP8[($marked18)];
      var $conv19=(($16)&255);
      var $and20=$conv19 & 3;
      $retval=$and20;
      label = 10; break;
    case 10: 
      var $17=$retval;

      Module.print(INDENT + 'Exiting: _iscleared');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return $17;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_iscleared["X"]=1;

function _traverseephemeron($g, $h) {
  var label = 0;

  Module.print(INDENT + ' Entering: _traverseephemeron: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $g_addr;
      var $h_addr;
      var $marked;
      var $hasclears;
      var $prop;
      var $n;
      var $limit;
      var $i;
      $g_addr=$g;
      $h_addr=$h;
      $marked=0;
      $hasclears=0;
      $prop=0;
      var $0=$h_addr;
      var $lsizenode=(($0+7)|0);
      var $1=HEAP8[($lsizenode)];
      var $conv=(($1)&255);
      var $shl=1 << $conv;
      var $2=$h_addr;
      var $node=(($2+16)|0);
      var $3=HEAP32[(($node)>>2)];
      var $arrayidx=(($3+((($shl)*(28))&-1))|0);
      $limit=$arrayidx;
      $i=0;
      label = 3; break;
    case 3: 
      var $4=$i;
      var $5=$h_addr;
      var $sizearray=(($5+28)|0);
      var $6=HEAP32[(($sizearray)>>2)];
      var $cmp=(($4)|0) < (($6)|0);
      if ($cmp) { label = 4; break; } else { label = 9; break; }
    case 4: 
      var $7=$i;
      var $8=$h_addr;
      var $array=(($8+12)|0);
      var $9=HEAP32[(($array)>>2)];
      var $arrayidx2=(($9+((($7)*(12))&-1))|0);
      var $tt_=(($arrayidx2+8)|0);
      var $10=HEAP32[(($tt_)>>2)];
      var $and=$10 & 64;
      var $tobool=(($and)|0)!=0;
      if ($tobool) { label = 5; break; } else { label = 7; break; }
    case 5: 
      var $11=$i;
      var $12=$h_addr;
      var $array3=(($12+12)|0);
      var $13=HEAP32[(($array3)>>2)];
      var $arrayidx4=(($13+((($11)*(12))&-1))|0);
      var $value_=(($arrayidx4)|0);
      var $gc=$value_;
      var $14=HEAP32[(($gc)>>2)];
      var $gch=$14;
      var $marked5=(($gch+5)|0);
      var $15=HEAP8[($marked5)];
      var $conv6=(($15)&255);
      var $and7=$conv6 & 3;
      var $tobool8=(($and7)|0)!=0;
      if ($tobool8) { label = 6; break; } else { label = 7; break; }
    case 6: 
      $marked=1;
      var $16=$g_addr;
      var $17=$i;
      var $18=$h_addr;
      var $array9=(($18+12)|0);
      var $19=HEAP32[(($array9)>>2)];
      var $arrayidx10=(($19+((($17)*(12))&-1))|0);
      var $value_11=(($arrayidx10)|0);
      var $gc12=$value_11;
      var $20=HEAP32[(($gc12)>>2)];
      _reallymarkobject($16, $20);
      label = 7; break;
    case 7: 
      label = 8; break;
    case 8: 
      var $21=$i;
      var $inc=((($21)+(1))|0);
      $i=$inc;
      label = 3; break;
    case 9: 
      var $22=$h_addr;
      var $node13=(($22+16)|0);
      var $23=HEAP32[(($node13)>>2)];
      var $arrayidx14=(($23)|0);
      $n=$arrayidx14;
      label = 10; break;
    case 10: 
      var $24=$n;
      var $25=$limit;
      var $cmp16=(($24)>>>0) < (($25)>>>0);
      if ($cmp16) { label = 11; break; } else { label = 25; break; }
    case 11: 
      var $26=$n;
      var $i_val=(($26)|0);
      var $tt_19=(($i_val+8)|0);
      var $27=HEAP32[(($tt_19)>>2)];
      var $cmp20=(($27)|0)==0;
      if ($cmp20) { label = 12; break; } else { label = 13; break; }
    case 12: 
      var $28=$n;
      _removeentry($28);
      label = 23; break;
    case 13: 
      var $29=$g_addr;
      var $30=$n;
      var $i_key=(($30+12)|0);
      var $tvk=$i_key;
      var $call=_iscleared($29, $tvk);
      var $tobool23=(($call)|0)!=0;
      if ($tobool23) { label = 14; break; } else { label = 18; break; }
    case 14: 
      $hasclears=1;
      var $31=$n;
      var $i_val25=(($31)|0);
      var $tt_26=(($i_val25+8)|0);
      var $32=HEAP32[(($tt_26)>>2)];
      var $and27=$32 & 64;
      var $tobool28=(($and27)|0)!=0;
      if ($tobool28) { label = 15; break; } else { label = 17; break; }
    case 15: 
      var $33=$n;
      var $i_val30=(($33)|0);
      var $value_31=(($i_val30)|0);
      var $gc32=$value_31;
      var $34=HEAP32[(($gc32)>>2)];
      var $gch33=$34;
      var $marked34=(($gch33+5)|0);
      var $35=HEAP8[($marked34)];
      var $conv35=(($35)&255);
      var $and36=$conv35 & 3;
      var $tobool37=(($and36)|0)!=0;
      if ($tobool37) { label = 16; break; } else { label = 17; break; }
    case 16: 
      $prop=1;
      label = 17; break;
    case 17: 
      label = 22; break;
    case 18: 
      var $36=$n;
      var $i_val41=(($36)|0);
      var $tt_42=(($i_val41+8)|0);
      var $37=HEAP32[(($tt_42)>>2)];
      var $and43=$37 & 64;
      var $tobool44=(($and43)|0)!=0;
      if ($tobool44) { label = 19; break; } else { label = 21; break; }
    case 19: 
      var $38=$n;
      var $i_val46=(($38)|0);
      var $value_47=(($i_val46)|0);
      var $gc48=$value_47;
      var $39=HEAP32[(($gc48)>>2)];
      var $gch49=$39;
      var $marked50=(($gch49+5)|0);
      var $40=HEAP8[($marked50)];
      var $conv51=(($40)&255);
      var $and52=$conv51 & 3;
      var $tobool53=(($and52)|0)!=0;
      if ($tobool53) { label = 20; break; } else { label = 21; break; }
    case 20: 
      $marked=1;
      var $41=$g_addr;
      var $42=$n;
      var $i_val55=(($42)|0);
      var $value_56=(($i_val55)|0);
      var $gc57=$value_56;
      var $43=HEAP32[(($gc57)>>2)];
      _reallymarkobject($41, $43);
      label = 21; break;
    case 21: 
      label = 22; break;
    case 22: 
      label = 23; break;
    case 23: 
      label = 24; break;
    case 24: 
      var $44=$n;
      var $incdec_ptr=(($44+28)|0);
      $n=$incdec_ptr;
      label = 10; break;
    case 25: 
      var $45=$prop;
      var $tobool63=(($45)|0)!=0;
      if ($tobool63) { label = 26; break; } else { label = 27; break; }
    case 26: 
      var $46=$g_addr;
      var $ephemeron=(($46+88)|0);
      var $47=HEAP32[(($ephemeron)>>2)];
      var $48=$h_addr;
      var $gclist=(($48+24)|0);
      HEAP32[(($gclist)>>2)]=$47;
      var $49=$h_addr;
      var $50=$49;
      var $51=$g_addr;
      var $ephemeron65=(($51+88)|0);
      HEAP32[(($ephemeron65)>>2)]=$50;
      label = 31; break;
    case 27: 
      var $52=$hasclears;
      var $tobool67=(($52)|0)!=0;
      if ($tobool67) { label = 28; break; } else { label = 29; break; }
    case 28: 
      var $53=$g_addr;
      var $allweak=(($53+92)|0);
      var $54=HEAP32[(($allweak)>>2)];
      var $55=$h_addr;
      var $gclist69=(($55+24)|0);
      HEAP32[(($gclist69)>>2)]=$54;
      var $56=$h_addr;
      var $57=$56;
      var $58=$g_addr;
      var $allweak70=(($58+92)|0);
      HEAP32[(($allweak70)>>2)]=$57;
      label = 30; break;
    case 29: 
      var $59=$g_addr;
      var $grayagain=(($59+80)|0);
      var $60=HEAP32[(($grayagain)>>2)];
      var $61=$h_addr;
      var $gclist72=(($61+24)|0);
      HEAP32[(($gclist72)>>2)]=$60;
      var $62=$h_addr;
      var $63=$62;
      var $64=$g_addr;
      var $grayagain73=(($64+80)|0);
      HEAP32[(($grayagain73)>>2)]=$63;
      label = 30; break;
    case 30: 
      label = 31; break;
    case 31: 
      var $65=$marked;

      Module.print(INDENT + 'Exiting: _traverseephemeron');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return $65;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_traverseephemeron["X"]=1;

function _propagatelist($g, $l) {
  var label = 0;

  Module.print(INDENT + ' Entering: _propagatelist: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';

  var $g_addr;
  var $l_addr;
  $g_addr=$g;
  $l_addr=$l;
  var $0=$l_addr;
  var $1=$g_addr;
  var $gray=(($1+76)|0);
  HEAP32[(($gray)>>2)]=$0;
  var $2=$g_addr;
  _propagateall($2);

  Module.print(INDENT + 'Exiting: _propagatelist');
  INDENT = INDENT.substr(0, INDENT.length-2);
  return;
  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _traversetable($g, $h) {
  var label = 0;

  Module.print(INDENT + ' Entering: _traversetable: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $g_addr;
      var $h_addr;
      var $weakkey;
      var $weakvalue;
      var $mode;
      $g_addr=$g;
      $h_addr=$h;
      var $0=$h_addr;
      var $metatable=(($0+8)|0);
      var $1=HEAP32[(($metatable)>>2)];
      var $cmp=(($1)|0)==0;
      if ($cmp) { label = 3; break; } else { label = 4; break; }
    case 3: 
      var $cond6 = 0;label = 8; break;
    case 4: 
      var $2=$h_addr;
      var $metatable1=(($2+8)|0);
      var $3=HEAP32[(($metatable1)>>2)];
      var $flags=(($3+6)|0);
      var $4=HEAP8[($flags)];
      var $conv=(($4)&255);
      var $and=$conv & 8;
      var $tobool=(($and)|0)!=0;
      if ($tobool) { label = 5; break; } else { label = 6; break; }
    case 5: 
      var $cond = 0;label = 7; break;
    case 6: 
      var $5=$h_addr;
      var $metatable4=(($5+8)|0);
      var $6=HEAP32[(($metatable4)>>2)];
      var $7=$g_addr;
      var $tmname=(($7+164)|0);
      var $arrayidx=(($tmname+12)|0);
      var $8=HEAP32[(($arrayidx)>>2)];
      var $call=_luaT_gettm($6, 3, $8);
      var $cond = $call;label = 7; break;
    case 7: 
      var $cond;
      var $cond6 = $cond;label = 8; break;
    case 8: 
      var $cond6;
      $mode=$cond6;
      var $9=$h_addr;
      var $metatable7=(($9+8)|0);
      var $10=HEAP32[(($metatable7)>>2)];
      var $tobool8=(($10)|0)!=0;
      if ($tobool8) { label = 9; break; } else { label = 11; break; }
    case 9: 
      var $11=$h_addr;
      var $metatable9=(($11+8)|0);
      var $12=HEAP32[(($metatable9)>>2)];
      var $13=$12;
      var $gch=$13;
      var $marked=(($gch+5)|0);
      var $14=HEAP8[($marked)];
      var $conv10=(($14)&255);
      var $and11=$conv10 & 3;
      var $tobool12=(($and11)|0)!=0;
      if ($tobool12) { label = 10; break; } else { label = 11; break; }
    case 10: 
      var $15=$g_addr;
      var $16=$h_addr;
      var $metatable13=(($16+8)|0);
      var $17=HEAP32[(($metatable13)>>2)];
      var $18=$17;
      _reallymarkobject($15, $18);
      label = 11; break;
    case 11: 
      var $19=$mode;
      var $tobool14=(($19)|0)!=0;
      if ($tobool14) { label = 12; break; } else { label = 23; break; }
    case 12: 
      var $20=$mode;
      var $tt_=(($20+8)|0);
      var $21=HEAP32[(($tt_)>>2)];
      var $and16=$21 & 15;
      var $cmp17=(($and16)|0)==4;
      if ($cmp17) { label = 13; break; } else { label = 23; break; }
    case 13: 
      var $22=$mode;
      var $value_=(($22)|0);
      var $gc=$value_;
      var $23=HEAP32[(($gc)>>2)];
      var $ts=$23;
      var $add_ptr=(($ts+16)|0);
      var $24=$add_ptr;
      var $call20=_strchr($24, 107);
      $weakkey=$call20;
      var $25=$mode;
      var $value_21=(($25)|0);
      var $gc22=$value_21;
      var $26=HEAP32[(($gc22)>>2)];
      var $ts23=$26;
      var $add_ptr24=(($ts23+16)|0);
      var $27=$add_ptr24;
      var $call25=_strchr($27, 118);
      $weakvalue=$call25;
      var $28=$weakkey;
      var $tobool26=(($28)|0)!=0;
      if ($tobool26) { var $30 = 1;label = 15; break; } else { label = 14; break; }
    case 14: 
      var $29=$weakvalue;
      var $tobool27=(($29)|0)!=0;
      var $30 = $tobool27;label = 15; break;
    case 15: 
      var $30;
      if ($30) { label = 16; break; } else { label = 23; break; }
    case 16: 
      var $31=$h_addr;
      var $32=$31;
      var $gch29=$32;
      var $marked30=(($gch29+5)|0);
      var $33=HEAP8[($marked30)];
      var $conv31=(($33)&255);
      var $and32=$conv31 & 251;
      var $conv33=(($and32) & 255);
      HEAP8[($marked30)]=$conv33;
      var $34=$weakkey;
      var $tobool34=(($34)|0)!=0;
      if ($tobool34) { label = 18; break; } else { label = 17; break; }
    case 17: 
      var $35=$g_addr;
      var $36=$h_addr;
      _traverseweakvalue($35, $36);
      label = 22; break;
    case 18: 
      var $37=$weakvalue;
      var $tobool36=(($37)|0)!=0;
      if ($tobool36) { label = 20; break; } else { label = 19; break; }
    case 19: 
      var $38=$g_addr;
      var $39=$h_addr;
      var $call38=_traverseephemeron($38, $39);
      label = 21; break;
    case 20: 
      var $40=$g_addr;
      var $allweak=(($40+92)|0);
      var $41=HEAP32[(($allweak)>>2)];
      var $42=$h_addr;
      var $gclist=(($42+24)|0);
      HEAP32[(($gclist)>>2)]=$41;
      var $43=$h_addr;
      var $44=$43;
      var $45=$g_addr;
      var $allweak40=(($45+92)|0);
      HEAP32[(($allweak40)>>2)]=$44;
      label = 21; break;
    case 21: 
      label = 22; break;
    case 22: 
      label = 24; break;
    case 23: 
      var $46=$g_addr;
      var $47=$h_addr;
      _traversestrongtable($46, $47);
      label = 24; break;
    case 24: 
      var $48=$h_addr;
      var $sizearray=(($48+28)|0);
      var $49=HEAP32[(($sizearray)>>2)];
      var $mul=((($49)*(12))&-1);
      var $add=((($mul)+(32))|0);
      var $50=$h_addr;
      var $lsizenode=(($50+7)|0);
      var $51=HEAP8[($lsizenode)];
      var $conv45=(($51)&255);
      var $shl=1 << $conv45;
      var $mul46=((($shl)*(28))&-1);
      var $add47=((($add)+($mul46))|0);

      Module.print(INDENT + 'Exiting: _traversetable');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return $add47;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_traversetable["X"]=1;

function _traverseLclosure($g, $cl) {
  var label = 0;

  Module.print(INDENT + ' Entering: _traverseLclosure: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $g_addr;
      var $cl_addr;
      var $i;
      $g_addr=$g;
      $cl_addr=$cl;
      var $0=$cl_addr;
      var $p=(($0+12)|0);
      var $1=HEAP32[(($p)>>2)];
      var $tobool=(($1)|0)!=0;
      if ($tobool) { label = 3; break; } else { label = 5; break; }
    case 3: 
      var $2=$cl_addr;
      var $p1=(($2+12)|0);
      var $3=HEAP32[(($p1)>>2)];
      var $4=$3;
      var $gch=$4;
      var $marked=(($gch+5)|0);
      var $5=HEAP8[($marked)];
      var $conv=(($5)&255);
      var $and=$conv & 3;
      var $tobool2=(($and)|0)!=0;
      if ($tobool2) { label = 4; break; } else { label = 5; break; }
    case 4: 
      var $6=$g_addr;
      var $7=$cl_addr;
      var $p3=(($7+12)|0);
      var $8=HEAP32[(($p3)>>2)];
      var $9=$8;
      _reallymarkobject($6, $9);
      label = 5; break;
    case 5: 
      $i=0;
      label = 6; break;
    case 6: 
      var $10=$i;
      var $11=$cl_addr;
      var $nupvalues=(($11+6)|0);
      var $12=HEAP8[($nupvalues)];
      var $conv4=(($12)&255);
      var $cmp=(($10)|0) < (($conv4)|0);
      if ($cmp) { label = 7; break; } else { label = 12; break; }
    case 7: 
      var $13=$i;
      var $14=$cl_addr;
      var $upvals=(($14+16)|0);
      var $arrayidx=(($upvals+($13<<2))|0);
      var $15=HEAP32[(($arrayidx)>>2)];
      var $tobool6=(($15)|0)!=0;
      if ($tobool6) { label = 8; break; } else { label = 10; break; }
    case 8: 
      var $16=$i;
      var $17=$cl_addr;
      var $upvals8=(($17+16)|0);
      var $arrayidx9=(($upvals8+($16<<2))|0);
      var $18=HEAP32[(($arrayidx9)>>2)];
      var $19=$18;
      var $gch10=$19;
      var $marked11=(($gch10+5)|0);
      var $20=HEAP8[($marked11)];
      var $conv12=(($20)&255);
      var $and13=$conv12 & 3;
      var $tobool14=(($and13)|0)!=0;
      if ($tobool14) { label = 9; break; } else { label = 10; break; }
    case 9: 
      var $21=$g_addr;
      var $22=$i;
      var $23=$cl_addr;
      var $upvals16=(($23+16)|0);
      var $arrayidx17=(($upvals16+($22<<2))|0);
      var $24=HEAP32[(($arrayidx17)>>2)];
      var $25=$24;
      _reallymarkobject($21, $25);
      label = 10; break;
    case 10: 
      label = 11; break;
    case 11: 
      var $26=$i;
      var $inc=((($26)+(1))|0);
      $i=$inc;
      label = 6; break;
    case 12: 
      var $27=$cl_addr;
      var $nupvalues19=(($27+6)|0);
      var $28=HEAP8[($nupvalues19)];
      var $conv20=(($28)&255);
      var $sub=((($conv20)-(1))|0);
      var $mul=($sub<<2);
      var $add=((($mul)+(20))|0);

      Module.print(INDENT + 'Exiting: _traverseLclosure');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return $add;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_traverseLclosure["X"]=1;

function _traverseCclosure($g, $cl) {
  var label = 0;

  Module.print(INDENT + ' Entering: _traverseCclosure: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $g_addr;
      var $cl_addr;
      var $i;
      $g_addr=$g;
      $cl_addr=$cl;
      $i=0;
      label = 3; break;
    case 3: 
      var $0=$i;
      var $1=$cl_addr;
      var $nupvalues=(($1+6)|0);
      var $2=HEAP8[($nupvalues)];
      var $conv=(($2)&255);
      var $cmp=(($0)|0) < (($conv)|0);
      if ($cmp) { label = 4; break; } else { label = 9; break; }
    case 4: 
      var $3=$i;
      var $4=$cl_addr;
      var $upvalue=(($4+16)|0);
      var $arrayidx=(($upvalue+((($3)*(12))&-1))|0);
      var $tt_=(($arrayidx+8)|0);
      var $5=HEAP32[(($tt_)>>2)];
      var $and=$5 & 64;
      var $tobool=(($and)|0)!=0;
      if ($tobool) { label = 5; break; } else { label = 7; break; }
    case 5: 
      var $6=$i;
      var $7=$cl_addr;
      var $upvalue2=(($7+16)|0);
      var $arrayidx3=(($upvalue2+((($6)*(12))&-1))|0);
      var $value_=(($arrayidx3)|0);
      var $gc=$value_;
      var $8=HEAP32[(($gc)>>2)];
      var $gch=$8;
      var $marked=(($gch+5)|0);
      var $9=HEAP8[($marked)];
      var $conv4=(($9)&255);
      var $and5=$conv4 & 3;
      var $tobool6=(($and5)|0)!=0;
      if ($tobool6) { label = 6; break; } else { label = 7; break; }
    case 6: 
      var $10=$g_addr;
      var $11=$i;
      var $12=$cl_addr;
      var $upvalue7=(($12+16)|0);
      var $arrayidx8=(($upvalue7+((($11)*(12))&-1))|0);
      var $value_9=(($arrayidx8)|0);
      var $gc10=$value_9;
      var $13=HEAP32[(($gc10)>>2)];
      _reallymarkobject($10, $13);
      label = 7; break;
    case 7: 
      label = 8; break;
    case 8: 
      var $14=$i;
      var $inc=((($14)+(1))|0);
      $i=$inc;
      label = 3; break;
    case 9: 
      var $15=$cl_addr;
      var $nupvalues11=(($15+6)|0);
      var $16=HEAP8[($nupvalues11)];
      var $conv12=(($16)&255);
      var $sub=((($conv12)-(1))|0);
      var $mul=((($sub)*(12))&-1);
      var $add=((($mul)+(28))|0);

      Module.print(INDENT + 'Exiting: _traverseCclosure');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return $add;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_traverseCclosure["X"]=1;

function _traversestack($g, $th) {
  var label = 0;

  Module.print(INDENT + ' Entering: _traversestack: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $retval;
      var $g_addr;
      var $th_addr;
      var $o;
      var $lim;
      $g_addr=$g;
      $th_addr=$th;
      var $0=$th_addr;
      var $stack=(($0+28)|0);
      var $1=HEAP32[(($stack)>>2)];
      $o=$1;
      var $2=$o;
      var $cmp=(($2)|0)==0;
      if ($cmp) { label = 3; break; } else { label = 4; break; }
    case 3: 
      $retval=1;
      label = 18; break;
    case 4: 
      label = 5; break;
    case 5: 
      var $3=$o;
      var $4=$th_addr;
      var $top=(($4+8)|0);
      var $5=HEAP32[(($top)>>2)];
      var $cmp1=(($3)>>>0) < (($5)>>>0);
      if ($cmp1) { label = 6; break; } else { label = 11; break; }
    case 6: 
      var $6=$o;
      var $tt_=(($6+8)|0);
      var $7=HEAP32[(($tt_)>>2)];
      var $and=$7 & 64;
      var $tobool=(($and)|0)!=0;
      if ($tobool) { label = 7; break; } else { label = 9; break; }
    case 7: 
      var $8=$o;
      var $value_=(($8)|0);
      var $gc=$value_;
      var $9=HEAP32[(($gc)>>2)];
      var $gch=$9;
      var $marked=(($gch+5)|0);
      var $10=HEAP8[($marked)];
      var $conv=(($10)&255);
      var $and2=$conv & 3;
      var $tobool3=(($and2)|0)!=0;
      if ($tobool3) { label = 8; break; } else { label = 9; break; }
    case 8: 
      var $11=$g_addr;
      var $12=$o;
      var $value_5=(($12)|0);
      var $gc6=$value_5;
      var $13=HEAP32[(($gc6)>>2)];
      _reallymarkobject($11, $13);
      label = 9; break;
    case 9: 
      label = 10; break;
    case 10: 
      var $14=$o;
      var $incdec_ptr=(($14+12)|0);
      $o=$incdec_ptr;
      label = 5; break;
    case 11: 
      var $15=$g_addr;
      var $gcstate=(($15+53)|0);
      var $16=HEAP8[($gcstate)];
      var $conv8=(($16)&255);
      var $cmp9=(($conv8)|0)==1;
      if ($cmp9) { label = 12; break; } else { label = 17; break; }
    case 12: 
      var $17=$th_addr;
      var $stack12=(($17+28)|0);
      var $18=HEAP32[(($stack12)>>2)];
      var $19=$th_addr;
      var $stacksize=(($19+32)|0);
      var $20=HEAP32[(($stacksize)>>2)];
      var $add_ptr=(($18+((($20)*(12))&-1))|0);
      $lim=$add_ptr;
      label = 13; break;
    case 13: 
      var $21=$o;
      var $22=$lim;
      var $cmp14=(($21)>>>0) < (($22)>>>0);
      if ($cmp14) { label = 14; break; } else { label = 16; break; }
    case 14: 
      var $23=$o;
      var $tt_17=(($23+8)|0);
      HEAP32[(($tt_17)>>2)]=0;
      label = 15; break;
    case 15: 
      var $24=$o;
      var $incdec_ptr19=(($24+12)|0);
      $o=$incdec_ptr19;
      label = 13; break;
    case 16: 
      label = 17; break;
    case 17: 
      var $25=$th_addr;
      var $stacksize22=(($25+32)|0);
      var $26=HEAP32[(($stacksize22)>>2)];
      var $mul=((($26)*(12))&-1);
      var $add=((($mul)+(112))|0);
      $retval=$add;
      label = 18; break;
    case 18: 
      var $27=$retval;

      Module.print(INDENT + 'Exiting: _traversestack');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return $27;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_traversestack["X"]=1;

function _traverseproto($g, $f) {
  var label = 0;

  Module.print(INDENT + ' Entering: _traverseproto: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $g_addr;
      var $f_addr;
      var $i;
      $g_addr=$g;
      $f_addr=$f;
      var $0=$f_addr;
      var $cache=(($0+32)|0);
      var $1=HEAP32[(($cache)>>2)];
      var $tobool=(($1)|0)!=0;
      if ($tobool) { label = 3; break; } else { label = 5; break; }
    case 3: 
      var $2=$f_addr;
      var $cache1=(($2+32)|0);
      var $3=HEAP32[(($cache1)>>2)];
      var $4=$3;
      var $gch=$4;
      var $marked=(($gch+5)|0);
      var $5=HEAP8[($marked)];
      var $conv=(($5)&255);
      var $and=$conv & 3;
      var $tobool2=(($and)|0)!=0;
      if ($tobool2) { label = 4; break; } else { label = 5; break; }
    case 4: 
      var $6=$f_addr;
      var $cache3=(($6+32)|0);
      HEAP32[(($cache3)>>2)]=0;
      label = 5; break;
    case 5: 
      var $7=$f_addr;
      var $source=(($7+36)|0);
      var $8=HEAP32[(($source)>>2)];
      var $tobool4=(($8)|0)!=0;
      if ($tobool4) { label = 6; break; } else { label = 8; break; }
    case 6: 
      var $9=$f_addr;
      var $source6=(($9+36)|0);
      var $10=HEAP32[(($source6)>>2)];
      var $11=$10;
      var $gch7=$11;
      var $marked8=(($gch7+5)|0);
      var $12=HEAP8[($marked8)];
      var $conv9=(($12)&255);
      var $and10=$conv9 & 3;
      var $tobool11=(($and10)|0)!=0;
      if ($tobool11) { label = 7; break; } else { label = 8; break; }
    case 7: 
      var $13=$g_addr;
      var $14=$f_addr;
      var $source13=(($14+36)|0);
      var $15=HEAP32[(($source13)>>2)];
      var $16=$15;
      _reallymarkobject($13, $16);
      label = 8; break;
    case 8: 
      $i=0;
      label = 9; break;
    case 9: 
      var $17=$i;
      var $18=$f_addr;
      var $sizek=(($18+44)|0);
      var $19=HEAP32[(($sizek)>>2)];
      var $cmp=(($17)|0) < (($19)|0);
      if ($cmp) { label = 10; break; } else { label = 15; break; }
    case 10: 
      var $20=$i;
      var $21=$f_addr;
      var $k=(($21+8)|0);
      var $22=HEAP32[(($k)>>2)];
      var $arrayidx=(($22+((($20)*(12))&-1))|0);
      var $tt_=(($arrayidx+8)|0);
      var $23=HEAP32[(($tt_)>>2)];
      var $and16=$23 & 64;
      var $tobool17=(($and16)|0)!=0;
      if ($tobool17) { label = 11; break; } else { label = 13; break; }
    case 11: 
      var $24=$i;
      var $25=$f_addr;
      var $k19=(($25+8)|0);
      var $26=HEAP32[(($k19)>>2)];
      var $arrayidx20=(($26+((($24)*(12))&-1))|0);
      var $value_=(($arrayidx20)|0);
      var $gc=$value_;
      var $27=HEAP32[(($gc)>>2)];
      var $gch21=$27;
      var $marked22=(($gch21+5)|0);
      var $28=HEAP8[($marked22)];
      var $conv23=(($28)&255);
      var $and24=$conv23 & 3;
      var $tobool25=(($and24)|0)!=0;
      if ($tobool25) { label = 12; break; } else { label = 13; break; }
    case 12: 
      var $29=$g_addr;
      var $30=$i;
      var $31=$f_addr;
      var $k27=(($31+8)|0);
      var $32=HEAP32[(($k27)>>2)];
      var $arrayidx28=(($32+((($30)*(12))&-1))|0);
      var $value_29=(($arrayidx28)|0);
      var $gc30=$value_29;
      var $33=HEAP32[(($gc30)>>2)];
      _reallymarkobject($29, $33);
      label = 13; break;
    case 13: 
      label = 14; break;
    case 14: 
      var $34=$i;
      var $inc=((($34)+(1))|0);
      $i=$inc;
      label = 9; break;
    case 15: 
      $i=0;
      label = 16; break;
    case 16: 
      var $35=$i;
      var $36=$f_addr;
      var $sizeupvalues=(($36+40)|0);
      var $37=HEAP32[(($sizeupvalues)>>2)];
      var $cmp33=(($35)|0) < (($37)|0);
      if ($cmp33) { label = 17; break; } else { label = 22; break; }
    case 17: 
      var $38=$i;
      var $39=$f_addr;
      var $upvalues=(($39+28)|0);
      var $40=HEAP32[(($upvalues)>>2)];
      var $arrayidx36=(($40+($38<<3))|0);
      var $name=(($arrayidx36)|0);
      var $41=HEAP32[(($name)>>2)];
      var $tobool37=(($41)|0)!=0;
      if ($tobool37) { label = 18; break; } else { label = 20; break; }
    case 18: 
      var $42=$i;
      var $43=$f_addr;
      var $upvalues39=(($43+28)|0);
      var $44=HEAP32[(($upvalues39)>>2)];
      var $arrayidx40=(($44+($42<<3))|0);
      var $name41=(($arrayidx40)|0);
      var $45=HEAP32[(($name41)>>2)];
      var $46=$45;
      var $gch42=$46;
      var $marked43=(($gch42+5)|0);
      var $47=HEAP8[($marked43)];
      var $conv44=(($47)&255);
      var $and45=$conv44 & 3;
      var $tobool46=(($and45)|0)!=0;
      if ($tobool46) { label = 19; break; } else { label = 20; break; }
    case 19: 
      var $48=$g_addr;
      var $49=$i;
      var $50=$f_addr;
      var $upvalues48=(($50+28)|0);
      var $51=HEAP32[(($upvalues48)>>2)];
      var $arrayidx49=(($51+($49<<3))|0);
      var $name50=(($arrayidx49)|0);
      var $52=HEAP32[(($name50)>>2)];
      var $53=$52;
      _reallymarkobject($48, $53);
      label = 20; break;
    case 20: 
      label = 21; break;
    case 21: 
      var $54=$i;
      var $inc53=((($54)+(1))|0);
      $i=$inc53;
      label = 16; break;
    case 22: 
      $i=0;
      label = 23; break;
    case 23: 
      var $55=$i;
      var $56=$f_addr;
      var $sizep=(($56+56)|0);
      var $57=HEAP32[(($sizep)>>2)];
      var $cmp56=(($55)|0) < (($57)|0);
      if ($cmp56) { label = 24; break; } else { label = 29; break; }
    case 24: 
      var $58=$i;
      var $59=$f_addr;
      var $p=(($59+16)|0);
      var $60=HEAP32[(($p)>>2)];
      var $arrayidx59=(($60+($58<<2))|0);
      var $61=HEAP32[(($arrayidx59)>>2)];
      var $tobool60=(($61)|0)!=0;
      if ($tobool60) { label = 25; break; } else { label = 27; break; }
    case 25: 
      var $62=$i;
      var $63=$f_addr;
      var $p62=(($63+16)|0);
      var $64=HEAP32[(($p62)>>2)];
      var $arrayidx63=(($64+($62<<2))|0);
      var $65=HEAP32[(($arrayidx63)>>2)];
      var $66=$65;
      var $gch64=$66;
      var $marked65=(($gch64+5)|0);
      var $67=HEAP8[($marked65)];
      var $conv66=(($67)&255);
      var $and67=$conv66 & 3;
      var $tobool68=(($and67)|0)!=0;
      if ($tobool68) { label = 26; break; } else { label = 27; break; }
    case 26: 
      var $68=$g_addr;
      var $69=$i;
      var $70=$f_addr;
      var $p70=(($70+16)|0);
      var $71=HEAP32[(($p70)>>2)];
      var $arrayidx71=(($71+($69<<2))|0);
      var $72=HEAP32[(($arrayidx71)>>2)];
      var $73=$72;
      _reallymarkobject($68, $73);
      label = 27; break;
    case 27: 
      label = 28; break;
    case 28: 
      var $74=$i;
      var $inc74=((($74)+(1))|0);
      $i=$inc74;
      label = 23; break;
    case 29: 
      $i=0;
      label = 30; break;
    case 30: 
      var $75=$i;
      var $76=$f_addr;
      var $sizelocvars=(($76+60)|0);
      var $77=HEAP32[(($sizelocvars)>>2)];
      var $cmp77=(($75)|0) < (($77)|0);
      if ($cmp77) { label = 31; break; } else { label = 36; break; }
    case 31: 
      var $78=$i;
      var $79=$f_addr;
      var $locvars=(($79+24)|0);
      var $80=HEAP32[(($locvars)>>2)];
      var $arrayidx80=(($80+((($78)*(12))&-1))|0);
      var $varname=(($arrayidx80)|0);
      var $81=HEAP32[(($varname)>>2)];
      var $tobool81=(($81)|0)!=0;
      if ($tobool81) { label = 32; break; } else { label = 34; break; }
    case 32: 
      var $82=$i;
      var $83=$f_addr;
      var $locvars83=(($83+24)|0);
      var $84=HEAP32[(($locvars83)>>2)];
      var $arrayidx84=(($84+((($82)*(12))&-1))|0);
      var $varname85=(($arrayidx84)|0);
      var $85=HEAP32[(($varname85)>>2)];
      var $86=$85;
      var $gch86=$86;
      var $marked87=(($gch86+5)|0);
      var $87=HEAP8[($marked87)];
      var $conv88=(($87)&255);
      var $and89=$conv88 & 3;
      var $tobool90=(($and89)|0)!=0;
      if ($tobool90) { label = 33; break; } else { label = 34; break; }
    case 33: 
      var $88=$g_addr;
      var $89=$i;
      var $90=$f_addr;
      var $locvars92=(($90+24)|0);
      var $91=HEAP32[(($locvars92)>>2)];
      var $arrayidx93=(($91+((($89)*(12))&-1))|0);
      var $varname94=(($arrayidx93)|0);
      var $92=HEAP32[(($varname94)>>2)];
      var $93=$92;
      _reallymarkobject($88, $93);
      label = 34; break;
    case 34: 
      label = 35; break;
    case 35: 
      var $94=$i;
      var $inc97=((($94)+(1))|0);
      $i=$inc97;
      label = 30; break;
    case 36: 
      var $95=$f_addr;
      var $sizecode=(($95+48)|0);
      var $96=HEAP32[(($sizecode)>>2)];
      var $mul=($96<<2);
      var $add=((($mul)+(80))|0);
      var $97=$f_addr;
      var $sizep99=(($97+56)|0);
      var $98=HEAP32[(($sizep99)>>2)];
      var $mul100=($98<<2);
      var $add101=((($add)+($mul100))|0);
      var $99=$f_addr;
      var $sizek102=(($99+44)|0);
      var $100=HEAP32[(($sizek102)>>2)];
      var $mul103=((($100)*(12))&-1);
      var $add104=((($add101)+($mul103))|0);
      var $101=$f_addr;
      var $sizelineinfo=(($101+52)|0);
      var $102=HEAP32[(($sizelineinfo)>>2)];
      var $mul105=($102<<2);
      var $add106=((($add104)+($mul105))|0);
      var $103=$f_addr;
      var $sizelocvars107=(($103+60)|0);
      var $104=HEAP32[(($sizelocvars107)>>2)];
      var $mul108=((($104)*(12))&-1);
      var $add109=((($add106)+($mul108))|0);
      var $105=$f_addr;
      var $sizeupvalues110=(($105+40)|0);
      var $106=HEAP32[(($sizeupvalues110)>>2)];
      var $mul111=($106<<3);
      var $add112=((($add109)+($mul111))|0);

      Module.print(INDENT + 'Exiting: _traverseproto');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return $add112;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_traverseproto["X"]=1;

function _traverseweakvalue($g, $h) {
  var label = 0;

  Module.print(INDENT + ' Entering: _traverseweakvalue: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $g_addr;
      var $h_addr;
      var $n;
      var $limit;
      var $hasclears;
      $g_addr=$g;
      $h_addr=$h;
      var $0=$h_addr;
      var $lsizenode=(($0+7)|0);
      var $1=HEAP8[($lsizenode)];
      var $conv=(($1)&255);
      var $shl=1 << $conv;
      var $2=$h_addr;
      var $node=(($2+16)|0);
      var $3=HEAP32[(($node)>>2)];
      var $arrayidx=(($3+((($shl)*(28))&-1))|0);
      $limit=$arrayidx;
      var $4=$h_addr;
      var $sizearray=(($4+28)|0);
      var $5=HEAP32[(($sizearray)>>2)];
      var $cmp=(($5)|0) > 0;
      var $conv1=(($cmp)&1);
      $hasclears=$conv1;
      var $6=$h_addr;
      var $node2=(($6+16)|0);
      var $7=HEAP32[(($node2)>>2)];
      var $arrayidx3=(($7)|0);
      $n=$arrayidx3;
      label = 3; break;
    case 3: 
      var $8=$n;
      var $9=$limit;
      var $cmp4=(($8)>>>0) < (($9)>>>0);
      if ($cmp4) { label = 4; break; } else { label = 15; break; }
    case 4: 
      var $10=$n;
      var $i_val=(($10)|0);
      var $tt_=(($i_val+8)|0);
      var $11=HEAP32[(($tt_)>>2)];
      var $cmp6=(($11)|0)==0;
      if ($cmp6) { label = 5; break; } else { label = 6; break; }
    case 5: 
      var $12=$n;
      _removeentry($12);
      label = 13; break;
    case 6: 
      var $13=$n;
      var $i_key=(($13+12)|0);
      var $tvk=$i_key;
      var $tt_8=(($tvk+8)|0);
      var $14=HEAP32[(($tt_8)>>2)];
      var $and=$14 & 64;
      var $tobool=(($and)|0)!=0;
      if ($tobool) { label = 7; break; } else { label = 9; break; }
    case 7: 
      var $15=$n;
      var $i_key9=(($15+12)|0);
      var $tvk10=$i_key9;
      var $value_=(($tvk10)|0);
      var $gc=$value_;
      var $16=HEAP32[(($gc)>>2)];
      var $gch=$16;
      var $marked=(($gch+5)|0);
      var $17=HEAP8[($marked)];
      var $conv11=(($17)&255);
      var $and12=$conv11 & 3;
      var $tobool13=(($and12)|0)!=0;
      if ($tobool13) { label = 8; break; } else { label = 9; break; }
    case 8: 
      var $18=$g_addr;
      var $19=$n;
      var $i_key15=(($19+12)|0);
      var $tvk16=$i_key15;
      var $value_17=(($tvk16)|0);
      var $gc18=$value_17;
      var $20=HEAP32[(($gc18)>>2)];
      _reallymarkobject($18, $20);
      label = 9; break;
    case 9: 
      var $21=$hasclears;
      var $tobool19=(($21)|0)!=0;
      if ($tobool19) { label = 12; break; } else { label = 10; break; }
    case 10: 
      var $22=$g_addr;
      var $23=$n;
      var $i_val21=(($23)|0);
      var $call=_iscleared($22, $i_val21);
      var $tobool22=(($call)|0)!=0;
      if ($tobool22) { label = 11; break; } else { label = 12; break; }
    case 11: 
      $hasclears=1;
      label = 12; break;
    case 12: 
      label = 13; break;
    case 13: 
      label = 14; break;
    case 14: 
      var $24=$n;
      var $incdec_ptr=(($24+28)|0);
      $n=$incdec_ptr;
      label = 3; break;
    case 15: 
      var $25=$hasclears;
      var $tobool26=(($25)|0)!=0;
      if ($tobool26) { label = 16; break; } else { label = 17; break; }
    case 16: 
      var $26=$g_addr;
      var $weak=(($26+84)|0);
      var $27=HEAP32[(($weak)>>2)];
      var $28=$h_addr;
      var $gclist=(($28+24)|0);
      HEAP32[(($gclist)>>2)]=$27;
      var $29=$h_addr;
      var $30=$29;
      var $31=$g_addr;
      var $weak28=(($31+84)|0);
      HEAP32[(($weak28)>>2)]=$30;
      label = 18; break;
    case 17: 
      var $32=$g_addr;
      var $grayagain=(($32+80)|0);
      var $33=HEAP32[(($grayagain)>>2)];
      var $34=$h_addr;
      var $gclist30=(($34+24)|0);
      HEAP32[(($gclist30)>>2)]=$33;
      var $35=$h_addr;
      var $36=$35;
      var $37=$g_addr;
      var $grayagain31=(($37+80)|0);
      HEAP32[(($grayagain31)>>2)]=$36;
      label = 18; break;
    case 18: 

      Module.print(INDENT + 'Exiting: _traverseweakvalue');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_traverseweakvalue["X"]=1;

function _traversestrongtable($g, $h) {
  var label = 0;

  Module.print(INDENT + ' Entering: _traversestrongtable: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $g_addr;
      var $h_addr;
      var $n;
      var $limit;
      var $i;
      $g_addr=$g;
      $h_addr=$h;
      var $0=$h_addr;
      var $lsizenode=(($0+7)|0);
      var $1=HEAP8[($lsizenode)];
      var $conv=(($1)&255);
      var $shl=1 << $conv;
      var $2=$h_addr;
      var $node=(($2+16)|0);
      var $3=HEAP32[(($node)>>2)];
      var $arrayidx=(($3+((($shl)*(28))&-1))|0);
      $limit=$arrayidx;
      $i=0;
      label = 3; break;
    case 3: 
      var $4=$i;
      var $5=$h_addr;
      var $sizearray=(($5+28)|0);
      var $6=HEAP32[(($sizearray)>>2)];
      var $cmp=(($4)|0) < (($6)|0);
      if ($cmp) { label = 4; break; } else { label = 9; break; }
    case 4: 
      var $7=$i;
      var $8=$h_addr;
      var $array=(($8+12)|0);
      var $9=HEAP32[(($array)>>2)];
      var $arrayidx2=(($9+((($7)*(12))&-1))|0);
      var $tt_=(($arrayidx2+8)|0);
      var $10=HEAP32[(($tt_)>>2)];
      var $and=$10 & 64;
      var $tobool=(($and)|0)!=0;
      if ($tobool) { label = 5; break; } else { label = 7; break; }
    case 5: 
      var $11=$i;
      var $12=$h_addr;
      var $array3=(($12+12)|0);
      var $13=HEAP32[(($array3)>>2)];
      var $arrayidx4=(($13+((($11)*(12))&-1))|0);
      var $value_=(($arrayidx4)|0);
      var $gc=$value_;
      var $14=HEAP32[(($gc)>>2)];
      var $gch=$14;
      var $marked=(($gch+5)|0);
      var $15=HEAP8[($marked)];
      var $conv5=(($15)&255);
      var $and6=$conv5 & 3;
      var $tobool7=(($and6)|0)!=0;
      if ($tobool7) { label = 6; break; } else { label = 7; break; }
    case 6: 
      var $16=$g_addr;
      var $17=$i;
      var $18=$h_addr;
      var $array8=(($18+12)|0);
      var $19=HEAP32[(($array8)>>2)];
      var $arrayidx9=(($19+((($17)*(12))&-1))|0);
      var $value_10=(($arrayidx9)|0);
      var $gc11=$value_10;
      var $20=HEAP32[(($gc11)>>2)];
      _reallymarkobject($16, $20);
      label = 7; break;
    case 7: 
      label = 8; break;
    case 8: 
      var $21=$i;
      var $inc=((($21)+(1))|0);
      $i=$inc;
      label = 3; break;
    case 9: 
      var $22=$h_addr;
      var $node12=(($22+16)|0);
      var $23=HEAP32[(($node12)>>2)];
      var $arrayidx13=(($23)|0);
      $n=$arrayidx13;
      label = 10; break;
    case 10: 
      var $24=$n;
      var $25=$limit;
      var $cmp15=(($24)>>>0) < (($25)>>>0);
      if ($cmp15) { label = 11; break; } else { label = 22; break; }
    case 11: 
      var $26=$n;
      var $i_val=(($26)|0);
      var $tt_18=(($i_val+8)|0);
      var $27=HEAP32[(($tt_18)>>2)];
      var $cmp19=(($27)|0)==0;
      if ($cmp19) { label = 12; break; } else { label = 13; break; }
    case 12: 
      var $28=$n;
      _removeentry($28);
      label = 20; break;
    case 13: 
      var $29=$n;
      var $i_key=(($29+12)|0);
      var $tvk=$i_key;
      var $tt_22=(($tvk+8)|0);
      var $30=HEAP32[(($tt_22)>>2)];
      var $and23=$30 & 64;
      var $tobool24=(($and23)|0)!=0;
      if ($tobool24) { label = 14; break; } else { label = 16; break; }
    case 14: 
      var $31=$n;
      var $i_key26=(($31+12)|0);
      var $tvk27=$i_key26;
      var $value_28=(($tvk27)|0);
      var $gc29=$value_28;
      var $32=HEAP32[(($gc29)>>2)];
      var $gch30=$32;
      var $marked31=(($gch30+5)|0);
      var $33=HEAP8[($marked31)];
      var $conv32=(($33)&255);
      var $and33=$conv32 & 3;
      var $tobool34=(($and33)|0)!=0;
      if ($tobool34) { label = 15; break; } else { label = 16; break; }
    case 15: 
      var $34=$g_addr;
      var $35=$n;
      var $i_key36=(($35+12)|0);
      var $tvk37=$i_key36;
      var $value_38=(($tvk37)|0);
      var $gc39=$value_38;
      var $36=HEAP32[(($gc39)>>2)];
      _reallymarkobject($34, $36);
      label = 16; break;
    case 16: 
      var $37=$n;
      var $i_val41=(($37)|0);
      var $tt_42=(($i_val41+8)|0);
      var $38=HEAP32[(($tt_42)>>2)];
      var $and43=$38 & 64;
      var $tobool44=(($and43)|0)!=0;
      if ($tobool44) { label = 17; break; } else { label = 19; break; }
    case 17: 
      var $39=$n;
      var $i_val46=(($39)|0);
      var $value_47=(($i_val46)|0);
      var $gc48=$value_47;
      var $40=HEAP32[(($gc48)>>2)];
      var $gch49=$40;
      var $marked50=(($gch49+5)|0);
      var $41=HEAP8[($marked50)];
      var $conv51=(($41)&255);
      var $and52=$conv51 & 3;
      var $tobool53=(($and52)|0)!=0;
      if ($tobool53) { label = 18; break; } else { label = 19; break; }
    case 18: 
      var $42=$g_addr;
      var $43=$n;
      var $i_val55=(($43)|0);
      var $value_56=(($i_val55)|0);
      var $gc57=$value_56;
      var $44=HEAP32[(($gc57)>>2)];
      _reallymarkobject($42, $44);
      label = 19; break;
    case 19: 
      label = 20; break;
    case 20: 
      label = 21; break;
    case 21: 
      var $45=$n;
      var $incdec_ptr=(($45+28)|0);
      $n=$incdec_ptr;
      label = 10; break;
    case 22: 

      Module.print(INDENT + 'Exiting: _traversestrongtable');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_traversestrongtable["X"]=1;

function _freeobj($L, $o) {
  var label = 0;

  Module.print(INDENT + ' Entering: _freeobj: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $L_addr;
      var $o_addr;
      $L_addr=$L;
      $o_addr=$o;
      var $0=$o_addr;
      var $gch=$0;
      var $tt=(($gch+4)|0);
      var $1=HEAP8[($tt)];
      var $conv=(($1)&255);
      if ((($conv)|0)==9) {
        label = 3; break;
      }
      else if ((($conv)|0)==6) {
        label = 4; break;
      }
      else if ((($conv)|0)==38) {
        label = 5; break;
      }
      else if ((($conv)|0)==10) {
        label = 6; break;
      }
      else if ((($conv)|0)==5) {
        label = 7; break;
      }
      else if ((($conv)|0)==8) {
        label = 8; break;
      }
      else if ((($conv)|0)==7) {
        label = 9; break;
      }
      else if ((($conv)|0)==4) {
        label = 10; break;
      }
      else if ((($conv)|0)==20) {
        label = 11; break;
      }
      else {
      label = 12; break;
      }
      
    case 3: 
      var $2=$L_addr;
      var $3=$o_addr;
      var $p=$3;
      _luaF_freeproto($2, $p);
      label = 13; break;
    case 4: 
      var $4=$L_addr;
      var $5=$o_addr;
      var $6=$5;
      var $7=$o_addr;
      var $cl=$7;
      var $l=$cl;
      var $nupvalues=(($l+6)|0);
      var $8=HEAP8[($nupvalues)];
      var $conv2=(($8)&255);
      var $sub=((($conv2)-(1))|0);
      var $mul=($sub<<2);
      var $add=((($mul)+(20))|0);
      var $call=_luaM_realloc_($4, $6, $add, 0);
      label = 13; break;
    case 5: 
      var $9=$L_addr;
      var $10=$o_addr;
      var $11=$10;
      var $12=$o_addr;
      var $cl4=$12;
      var $c=$cl4;
      var $nupvalues5=(($c+6)|0);
      var $13=HEAP8[($nupvalues5)];
      var $conv6=(($13)&255);
      var $sub7=((($conv6)-(1))|0);
      var $mul8=((($sub7)*(12))&-1);
      var $add9=((($mul8)+(28))|0);
      var $call10=_luaM_realloc_($9, $11, $add9, 0);
      label = 13; break;
    case 6: 
      var $14=$L_addr;
      var $15=$o_addr;
      var $uv=$15;
      _luaF_freeupval($14, $uv);
      label = 13; break;
    case 7: 
      var $16=$L_addr;
      var $17=$o_addr;
      var $h=$17;
      _luaH_free($16, $h);
      label = 13; break;
    case 8: 
      var $18=$L_addr;
      var $19=$o_addr;
      var $th=$19;
      _luaE_freethread($18, $th);
      label = 13; break;
    case 9: 
      var $20=$L_addr;
      var $21=$o_addr;
      var $22=$21;
      var $23=$o_addr;
      var $u=$23;
      var $uv15=$u;
      var $len=(($uv15+16)|0);
      var $24=HEAP32[(($len)>>2)];
      var $add16=((($24)+(20))|0);
      var $call17=_luaM_realloc_($20, $22, $add16, 0);
      label = 13; break;
    case 10: 
      var $25=$L_addr;
      var $l_G=(($25+12)|0);
      var $26=HEAP32[(($l_G)>>2)];
      var $strt=(($26+24)|0);
      var $nuse=(($strt+4)|0);
      var $27=HEAP32[(($nuse)>>2)];
      var $dec=((($27)-(1))|0);
      HEAP32[(($nuse)>>2)]=$dec;
      label = 11; break;
    case 11: 
      var $28=$L_addr;
      var $29=$o_addr;
      var $30=$29;
      var $31=$o_addr;
      var $ts=$31;
      var $tsv=$ts;
      var $len20=(($tsv+12)|0);
      var $32=HEAP32[(($len20)>>2)];
      var $add21=((($32)+(1))|0);
      var $mul22=$add21;
      var $add23=((($mul22)+(16))|0);
      var $call24=_luaM_realloc_($28, $30, $add23, 0);
      label = 13; break;
    case 12: 
      label = 13; break;
    case 13: 

      Module.print(INDENT + 'Exiting: _freeobj');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_freeobj["X"]=1;

function _sweepthread($L, $L1) {
  var label = 0;

  Module.print(INDENT + ' Entering: _sweepthread: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $L_addr;
      var $L1_addr;
      $L_addr=$L;
      $L1_addr=$L1;
      var $0=$L1_addr;
      var $stack=(($0+28)|0);
      var $1=HEAP32[(($stack)>>2)];
      var $cmp=(($1)|0)==0;
      if ($cmp) { label = 3; break; } else { label = 4; break; }
    case 3: 
      label = 6; break;
    case 4: 
      var $2=$L_addr;
      var $3=$L1_addr;
      var $openupval=(($3+56)|0);
      var $call=_sweeplist($2, $openupval, -3);
      var $4=$L1_addr;
      _luaE_freeCI($4);
      var $5=$L_addr;
      var $l_G=(($5+12)|0);
      var $6=HEAP32[(($l_G)>>2)];
      var $gckind=(($6+54)|0);
      var $7=HEAP8[($gckind)];
      var $conv=(($7)&255);
      var $cmp1=(($conv)|0)!=1;
      if ($cmp1) { label = 5; break; } else { label = 6; break; }
    case 5: 
      var $8=$L1_addr;
      _luaD_shrinkstack($8);
      label = 6; break;
    case 6: 

      Module.print(INDENT + 'Exiting: _sweepthread');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _luaX_init($L) {
  var label = 0;

  Module.print(INDENT + ' Entering: _luaX_init: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $L_addr;
      var $i;
      var $ts;
      $L_addr=$L;
      $i=0;
      label = 3; break;
    case 3: 
      var $0=$i;
      var $cmp=(($0)|0) < 22;
      if ($cmp) { label = 4; break; } else { label = 6; break; }
    case 4: 
      var $1=$L_addr;
      var $2=$i;
      var $arrayidx=((5243332+($2<<2))|0);
      var $3=HEAP32[(($arrayidx)>>2)];
      var $call=_luaS_new($1, $3);
      $ts=$call;
      var $4=$ts;
      var $tsv=$4;
      var $marked=(($tsv+5)|0);
      var $5=HEAP8[($marked)];
      var $conv=(($5)&255);
      var $or=$conv | 32;
      var $conv1=(($or) & 255);
      HEAP8[($marked)]=$conv1;
      var $6=$i;
      var $add=((($6)+(1))|0);
      var $conv2=(($add) & 255);
      var $7=$ts;
      var $tsv3=$7;
      var $extra=(($tsv3+6)|0);
      HEAP8[($extra)]=$conv2;
      label = 5; break;
    case 5: 
      var $8=$i;
      var $inc=((($8)+(1))|0);
      $i=$inc;
      label = 3; break;
    case 6: 

      Module.print(INDENT + 'Exiting: _luaX_init');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _luaX_token2str($ls, $token) {
  var label = 0;
  var __stackBase__  = STACKTOP; _memset(__stackBase__, 0, 0);
  Module.print(INDENT + ' Entering: _luaX_token2str: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $retval;
      var $ls_addr;
      var $token_addr;
      var $s;
      $ls_addr=$ls;
      $token_addr=$token;
      var $0=$token_addr;
      var $cmp=(($0)|0) < 257;
      if ($cmp) { label = 3; break; } else { label = 7; break; }
    case 3: 
      var $1=$token_addr;
      var $add=((($1)+(1))|0);
      var $arrayidx=((5242924+$add)|0);
      var $2=HEAP8[($arrayidx)];
      var $conv=(($2)&255);
      var $and=$conv & 4;
      var $tobool=(($and)|0)!=0;
      if ($tobool) { label = 4; break; } else { label = 5; break; }
    case 4: 
      var $3=$ls_addr;
      var $L=(($3+40)|0);
      var $4=HEAP32[(($L)>>2)];
      var $5=$token_addr;
      var $call=_luaO_pushfstring($4, ((5244344)|0), (tempInt=STACKTOP,_memset(STACKTOP, 0, 4),STACKTOP = (STACKTOP + 4)|0,HEAP32[((tempInt)>>2)]=$5,tempInt));
      var $cond = $call;label = 6; break;
    case 5: 
      var $6=$ls_addr;
      var $L1=(($6+40)|0);
      var $7=HEAP32[(($L1)>>2)];
      var $8=$token_addr;
      var $call2=_luaO_pushfstring($7, ((5246288)|0), (tempInt=STACKTOP,_memset(STACKTOP, 0, 4),STACKTOP = (STACKTOP + 4)|0,HEAP32[((tempInt)>>2)]=$8,tempInt));
      var $cond = $call2;label = 6; break;
    case 6: 
      var $cond;
      $retval=$cond;
      label = 10; break;
    case 7: 
      var $9=$token_addr;
      var $sub=((($9)-(257))|0);
      var $arrayidx3=((5243332+($sub<<2))|0);
      var $10=HEAP32[(($arrayidx3)>>2)];
      $s=$10;
      var $11=$token_addr;
      var $cmp4=(($11)|0) < 286;
      if ($cmp4) { label = 8; break; } else { label = 9; break; }
    case 8: 
      var $12=$ls_addr;
      var $L7=(($12+40)|0);
      var $13=HEAP32[(($L7)>>2)];
      var $14=$s;
      var $call8=_luaO_pushfstring($13, ((5245468)|0), (tempInt=STACKTOP,_memset(STACKTOP, 0, 4),STACKTOP = (STACKTOP + 4)|0,HEAP32[((tempInt)>>2)]=$14,tempInt));
      $retval=$call8;
      label = 10; break;
    case 9: 
      var $15=$s;
      $retval=$15;
      label = 10; break;
    case 10: 
      var $16=$retval;
      STACKTOP = __stackBase__;
      Module.print(INDENT + 'Exiting: _luaX_token2str');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return $16;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_luaX_token2str["X"]=1;

function _luaX_newstring($ls, $str, $l) {
  var label = 0;

  Module.print(INDENT + ' Entering: _luaX_newstring: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $ls_addr;
      var $str_addr;
      var $l_addr;
      var $L;
      var $o;
      var $ts;
      var $io;
      var $x_;
      var $io6;
      $ls_addr=$ls;
      $str_addr=$str;
      $l_addr=$l;
      var $0=$ls_addr;
      var $L1=(($0+40)|0);
      var $1=HEAP32[(($L1)>>2)];
      $L=$1;
      var $2=$L;
      var $3=$str_addr;
      var $4=$l_addr;
      var $call=_luaS_newlstr($2, $3, $4);
      $ts=$call;
      var $5=$L;
      var $top=(($5+8)|0);
      var $6=HEAP32[(($top)>>2)];
      var $incdec_ptr=(($6+12)|0);
      HEAP32[(($top)>>2)]=$incdec_ptr;
      $io=$6;
      var $7=$ts;
      $x_=$7;
      var $8=$x_;
      var $9=$8;
      var $10=$io;
      var $value_=(($10)|0);
      var $gc=$value_;
      HEAP32[(($gc)>>2)]=$9;
      var $11=$x_;
      var $tsv=$11;
      var $tt=(($tsv+4)|0);
      var $12=HEAP8[($tt)];
      var $conv=(($12)&255);
      var $or=$conv | 64;
      var $13=$io;
      var $tt_=(($13+8)|0);
      HEAP32[(($tt_)>>2)]=$or;
      var $14=$L;
      var $15=$ls_addr;
      var $fs=(($15+36)|0);
      var $16=HEAP32[(($fs)>>2)];
      var $h=(($16+4)|0);
      var $17=HEAP32[(($h)>>2)];
      var $18=$L;
      var $top2=(($18+8)|0);
      var $19=HEAP32[(($top2)>>2)];
      var $add_ptr=((($19)-(12))|0);
      var $call3=_luaH_set($14, $17, $add_ptr);
      $o=$call3;
      var $20=$o;
      var $tt_4=(($20+8)|0);
      var $21=HEAP32[(($tt_4)>>2)];
      var $cmp=(($21)|0)==0;
      if ($cmp) { label = 3; break; } else { label = 6; break; }
    case 3: 
      var $22=$o;
      $io6=$22;
      var $23=$io6;
      var $value_7=(($23)|0);
      var $b=$value_7;
      HEAP32[(($b)>>2)]=1;
      var $24=$io6;
      var $tt_8=(($24+8)|0);
      HEAP32[(($tt_8)>>2)]=1;
      var $25=$L;
      var $l_G=(($25+12)|0);
      var $26=HEAP32[(($l_G)>>2)];
      var $GCdebt=(($26+12)|0);
      var $27=HEAP32[(($GCdebt)>>2)];
      var $cmp9=(($27)|0) > 0;
      if ($cmp9) { label = 4; break; } else { label = 5; break; }
    case 4: 
      var $28=$L;
      _luaC_step($28);
      label = 5; break;
    case 5: 
      label = 6; break;
    case 6: 
      var $29=$L;
      var $top13=(($29+8)|0);
      var $30=HEAP32[(($top13)>>2)];
      var $incdec_ptr14=((($30)-(12))|0);
      HEAP32[(($top13)>>2)]=$incdec_ptr14;
      var $31=$ts;

      Module.print(INDENT + 'Exiting: _luaX_newstring');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return $31;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_luaX_newstring["X"]=1;

function _luaX_setinput($L, $ls, $z, $source, $firstchar) {
  var label = 0;

  Module.print(INDENT + ' Entering: _luaX_setinput: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';

  var $L_addr;
  var $ls_addr;
  var $z_addr;
  var $source_addr;
  var $firstchar_addr;
  $L_addr=$L;
  $ls_addr=$ls;
  $z_addr=$z;
  $source_addr=$source;
  $firstchar_addr=$firstchar;
  var $0=$ls_addr;
  var $decpoint=(($0+64)|0);
  HEAP8[($decpoint)]=46;
  var $1=$L_addr;
  var $2=$ls_addr;
  var $L1=(($2+40)|0);
  HEAP32[(($L1)>>2)]=$1;
  var $3=$firstchar_addr;
  var $4=$ls_addr;
  var $current=(($4)|0);
  HEAP32[(($current)>>2)]=$3;
  var $5=$ls_addr;
  var $lookahead=(($5+24)|0);
  var $token=(($lookahead)|0);
  HEAP32[(($token)>>2)]=286;
  var $6=$z_addr;
  var $7=$ls_addr;
  var $z2=(($7+44)|0);
  HEAP32[(($z2)>>2)]=$6;
  var $8=$ls_addr;
  var $fs=(($8+36)|0);
  HEAP32[(($fs)>>2)]=0;
  var $9=$ls_addr;
  var $linenumber=(($9+4)|0);
  HEAP32[(($linenumber)>>2)]=1;
  var $10=$ls_addr;
  var $lastline=(($10+8)|0);
  HEAP32[(($lastline)>>2)]=1;
  var $11=$source_addr;
  var $12=$ls_addr;
  var $source3=(($12+56)|0);
  HEAP32[(($source3)>>2)]=$11;
  var $13=$L_addr;
  var $call=_luaS_new($13, ((5245112)|0));
  var $14=$ls_addr;
  var $envn=(($14+60)|0);
  HEAP32[(($envn)>>2)]=$call;
  var $15=$ls_addr;
  var $envn4=(($15+60)|0);
  var $16=HEAP32[(($envn4)>>2)];
  var $tsv=$16;
  var $marked=(($tsv+5)|0);
  var $17=HEAP8[($marked)];
  var $conv=(($17)&255);
  var $or=$conv | 32;
  var $conv5=(($or) & 255);
  HEAP8[($marked)]=$conv5;
  var $18=$ls_addr;
  var $L6=(($18+40)|0);
  var $19=HEAP32[(($L6)>>2)];
  var $20=$ls_addr;
  var $buff=(($20+48)|0);
  var $21=HEAP32[(($buff)>>2)];
  var $buffer=(($21)|0);
  var $22=HEAP32[(($buffer)>>2)];
  var $23=$ls_addr;
  var $buff7=(($23+48)|0);
  var $24=HEAP32[(($buff7)>>2)];
  var $buffsize=(($24+8)|0);
  var $25=HEAP32[(($buffsize)>>2)];
  var $mul=$25;
  var $call8=_luaM_realloc_($19, $22, $mul, 32);
  var $26=$ls_addr;
  var $buff9=(($26+48)|0);
  var $27=HEAP32[(($buff9)>>2)];
  var $buffer10=(($27)|0);
  HEAP32[(($buffer10)>>2)]=$call8;
  var $28=$ls_addr;
  var $buff11=(($28+48)|0);
  var $29=HEAP32[(($buff11)>>2)];
  var $buffsize12=(($29+8)|0);
  HEAP32[(($buffsize12)>>2)]=32;

  Module.print(INDENT + 'Exiting: _luaX_setinput');
  INDENT = INDENT.substr(0, INDENT.length-2);
  return;
  INDENT = INDENT.substr(0, INDENT.length-2);
}
_luaX_setinput["X"]=1;

function _luaX_next($ls) {
  var label = 0;

  Module.print(INDENT + ' Entering: _luaX_next: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $ls_addr;
      $ls_addr=$ls;
      var $0=$ls_addr;
      var $linenumber=(($0+4)|0);
      var $1=HEAP32[(($linenumber)>>2)];
      var $2=$ls_addr;
      var $lastline=(($2+8)|0);
      HEAP32[(($lastline)>>2)]=$1;
      var $3=$ls_addr;
      var $lookahead=(($3+24)|0);
      var $token=(($lookahead)|0);
      var $4=HEAP32[(($token)>>2)];
      var $cmp=(($4)|0)!=286;
      if ($cmp) { label = 3; break; } else { label = 4; break; }
    case 3: 
      var $5=$ls_addr;
      var $t=(($5+12)|0);
      var $6=$ls_addr;
      var $lookahead1=(($6+24)|0);
      var $7=$t;
      var $8=$lookahead1;
      HEAP32[(($7)>>2)]=HEAP32[(($8)>>2)];HEAP32[((($7)+(4))>>2)]=HEAP32[((($8)+(4))>>2)];HEAP32[((($7)+(8))>>2)]=HEAP32[((($8)+(8))>>2)];
      var $9=$ls_addr;
      var $lookahead2=(($9+24)|0);
      var $token3=(($lookahead2)|0);
      HEAP32[(($token3)>>2)]=286;
      label = 5; break;
    case 4: 
      var $10=$ls_addr;
      var $11=$ls_addr;
      var $t4=(($11+12)|0);
      var $seminfo=(($t4+4)|0);
      var $call=_llex($10, $seminfo);
      var $12=$ls_addr;
      var $t5=(($12+12)|0);
      var $token6=(($t5)|0);
      HEAP32[(($token6)>>2)]=$call;
      label = 5; break;
    case 5: 

      Module.print(INDENT + 'Exiting: _luaX_next');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _luaX_syntaxerror($ls, $msg) {
  var label = 0;

  Module.print(INDENT + ' Entering: _luaX_syntaxerror: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $ls_addr;
      var $msg_addr;
      $ls_addr=$ls;
      $msg_addr=$msg;
      var $0=$ls_addr;
      var $1=$msg_addr;
      var $2=$ls_addr;
      var $t=(($2+12)|0);
      var $token=(($t)|0);
      var $3=HEAP32[(($token)>>2)];
      _lexerror($0, $1, $3);

    case 3: 

      Module.print(INDENT + 'Exiting: _luaX_syntaxerror');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _lexerror($ls, $msg, $token) {
  var label = 0;
  var __stackBase__  = STACKTOP; STACKTOP = (STACKTOP + 60)|0; _memset(__stackBase__, 0, 60);
  Module.print(INDENT + ' Entering: _lexerror: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $ls_addr;
      var $msg_addr;
      var $token_addr;
      var $buff=__stackBase__;
      $ls_addr=$ls;
      $msg_addr=$msg;
      $token_addr=$token;
      var $arraydecay=(($buff)|0);
      var $0=$ls_addr;
      var $source=(($0+56)|0);
      var $1=HEAP32[(($source)>>2)];
      var $add_ptr=(($1+16)|0);
      var $2=$add_ptr;
      _luaO_chunkid($arraydecay, $2, 60);
      var $3=$ls_addr;
      var $L=(($3+40)|0);
      var $4=HEAP32[(($L)>>2)];
      var $arraydecay1=(($buff)|0);
      var $5=$ls_addr;
      var $linenumber=(($5+4)|0);
      var $6=HEAP32[(($linenumber)>>2)];
      var $7=$msg_addr;
      var $call=_luaO_pushfstring($4, ((5246124)|0), (tempInt=STACKTOP,_memset(STACKTOP, 0, 12),STACKTOP = (STACKTOP + 12)|0,HEAP32[((tempInt)>>2)]=$arraydecay1,HEAP32[(((tempInt)+(4))>>2)]=$6,HEAP32[(((tempInt)+(8))>>2)]=$7,tempInt));
      $msg_addr=$call;
      var $8=$token_addr;
      var $tobool=(($8)|0)!=0;
      if ($tobool) { label = 3; break; } else { label = 4; break; }
    case 3: 
      var $9=$ls_addr;
      var $L2=(($9+40)|0);
      var $10=HEAP32[(($L2)>>2)];
      var $11=$msg_addr;
      var $12=$ls_addr;
      var $13=$token_addr;
      var $call3=_txtToken($12, $13);
      var $call4=_luaO_pushfstring($10, ((5246036)|0), (tempInt=STACKTOP,_memset(STACKTOP, 0, 8),STACKTOP = (STACKTOP + 8)|0,HEAP32[((tempInt)>>2)]=$11,HEAP32[(((tempInt)+(4))>>2)]=$call3,tempInt));
      label = 4; break;
    case 4: 
      var $14=$ls_addr;
      var $L5=(($14+40)|0);
      var $15=HEAP32[(($L5)>>2)];
      _luaD_throw($15, 3);

    case 5: 
      STACKTOP = __stackBase__;
      Module.print(INDENT + 'Exiting: _lexerror');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _llex($ls, $seminfo) {
  var label = 0;

  Module.print(INDENT + ' Entering: _llex: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $retval;
      var $ls_addr;
      var $seminfo_addr;
      var $sep;
      var $sep82;
      var $ts;
      var $c;
      $ls_addr=$ls;
      $seminfo_addr=$seminfo;
      var $0=$ls_addr;
      var $buff=(($0+48)|0);
      var $1=HEAP32[(($buff)>>2)];
      var $n=(($1+4)|0);
      HEAP32[(($n)>>2)]=0;
      label = 3; break;
    case 3: 
      var $2=$ls_addr;
      var $current=(($2)|0);
      var $3=HEAP32[(($current)>>2)];
      if ((($3)|0)==10 | (($3)|0)==13) {
        label = 4; break;
      }
      else if ((($3)|0)==32 | (($3)|0)==12 | (($3)|0)==9 | (($3)|0)==11) {
        label = 5; break;
      }
      else if ((($3)|0)==45) {
        label = 9; break;
      }
      else if ((($3)|0)==91) {
        label = 31; break;
      }
      else if ((($3)|0)==61) {
        label = 36; break;
      }
      else if ((($3)|0)==60) {
        label = 45; break;
      }
      else if ((($3)|0)==62) {
        label = 54; break;
      }
      else if ((($3)|0)==126) {
        label = 63; break;
      }
      else if ((($3)|0)==58) {
        label = 72; break;
      }
      else if ((($3)|0)==34 | (($3)|0)==39) {
        label = 81; break;
      }
      else if ((($3)|0)==46) {
        label = 82; break;
      }
      else if ((($3)|0)==48 | (($3)|0)==49 | (($3)|0)==50 | (($3)|0)==51 | (($3)|0)==52 | (($3)|0)==53 | (($3)|0)==54 | (($3)|0)==55 | (($3)|0)==56 | (($3)|0)==57) {
        label = 93; break;
      }
      else if ((($3)|0)==-1) {
        label = 94; break;
      }
      else {
      label = 95; break;
      }
      
    case 4: 
      var $4=$ls_addr;
      _inclinenumber($4);
      label = 110; break;
    case 5: 
      var $5=$ls_addr;
      var $z=(($5+44)|0);
      var $6=HEAP32[(($z)>>2)];
      var $n2=(($6)|0);
      var $7=HEAP32[(($n2)>>2)];
      var $dec=((($7)-(1))|0);
      HEAP32[(($n2)>>2)]=$dec;
      var $cmp=(($7)>>>0) > 0;
      if ($cmp) { label = 6; break; } else { label = 7; break; }
    case 6: 
      var $8=$ls_addr;
      var $z3=(($8+44)|0);
      var $9=HEAP32[(($z3)>>2)];
      var $p=(($9+4)|0);
      var $10=HEAP32[(($p)>>2)];
      var $incdec_ptr=(($10+1)|0);
      HEAP32[(($p)>>2)]=$incdec_ptr;
      var $11=HEAP8[($10)];
      var $conv=(($11)&255);
      var $cond = $conv;label = 8; break;
    case 7: 
      var $12=$ls_addr;
      var $z4=(($12+44)|0);
      var $13=HEAP32[(($z4)>>2)];
      var $call=_luaZ_fill($13);
      var $cond = $call;label = 8; break;
    case 8: 
      var $cond;
      var $14=$ls_addr;
      var $current5=(($14)|0);
      HEAP32[(($current5)>>2)]=$cond;
      label = 110; break;
    case 9: 
      var $15=$ls_addr;
      var $z7=(($15+44)|0);
      var $16=HEAP32[(($z7)>>2)];
      var $n8=(($16)|0);
      var $17=HEAP32[(($n8)>>2)];
      var $dec9=((($17)-(1))|0);
      HEAP32[(($n8)>>2)]=$dec9;
      var $cmp10=(($17)>>>0) > 0;
      if ($cmp10) { label = 10; break; } else { label = 11; break; }
    case 10: 
      var $18=$ls_addr;
      var $z13=(($18+44)|0);
      var $19=HEAP32[(($z13)>>2)];
      var $p14=(($19+4)|0);
      var $20=HEAP32[(($p14)>>2)];
      var $incdec_ptr15=(($20+1)|0);
      HEAP32[(($p14)>>2)]=$incdec_ptr15;
      var $21=HEAP8[($20)];
      var $conv16=(($21)&255);
      var $cond21 = $conv16;label = 12; break;
    case 11: 
      var $22=$ls_addr;
      var $z18=(($22+44)|0);
      var $23=HEAP32[(($z18)>>2)];
      var $call19=_luaZ_fill($23);
      var $cond21 = $call19;label = 12; break;
    case 12: 
      var $cond21;
      var $24=$ls_addr;
      var $current22=(($24)|0);
      HEAP32[(($current22)>>2)]=$cond21;
      var $25=$ls_addr;
      var $current23=(($25)|0);
      var $26=HEAP32[(($current23)>>2)];
      var $cmp24=(($26)|0)!=45;
      if ($cmp24) { label = 13; break; } else { label = 14; break; }
    case 13: 
      $retval=45;
      label = 111; break;
    case 14: 
      var $27=$ls_addr;
      var $z26=(($27+44)|0);
      var $28=HEAP32[(($z26)>>2)];
      var $n27=(($28)|0);
      var $29=HEAP32[(($n27)>>2)];
      var $dec28=((($29)-(1))|0);
      HEAP32[(($n27)>>2)]=$dec28;
      var $cmp29=(($29)>>>0) > 0;
      if ($cmp29) { label = 15; break; } else { label = 16; break; }
    case 15: 
      var $30=$ls_addr;
      var $z32=(($30+44)|0);
      var $31=HEAP32[(($z32)>>2)];
      var $p33=(($31+4)|0);
      var $32=HEAP32[(($p33)>>2)];
      var $incdec_ptr34=(($32+1)|0);
      HEAP32[(($p33)>>2)]=$incdec_ptr34;
      var $33=HEAP8[($32)];
      var $conv35=(($33)&255);
      var $cond40 = $conv35;label = 17; break;
    case 16: 
      var $34=$ls_addr;
      var $z37=(($34+44)|0);
      var $35=HEAP32[(($z37)>>2)];
      var $call38=_luaZ_fill($35);
      var $cond40 = $call38;label = 17; break;
    case 17: 
      var $cond40;
      var $36=$ls_addr;
      var $current41=(($36)|0);
      HEAP32[(($current41)>>2)]=$cond40;
      var $37=$ls_addr;
      var $current42=(($37)|0);
      var $38=HEAP32[(($current42)>>2)];
      var $cmp43=(($38)|0)==91;
      if ($cmp43) { label = 18; break; } else { label = 21; break; }
    case 18: 
      var $39=$ls_addr;
      var $call46=_skip_sep($39);
      $sep=$call46;
      var $40=$ls_addr;
      var $buff47=(($40+48)|0);
      var $41=HEAP32[(($buff47)>>2)];
      var $n48=(($41+4)|0);
      HEAP32[(($n48)>>2)]=0;
      var $42=$sep;
      var $cmp49=(($42)|0) >= 0;
      if ($cmp49) { label = 19; break; } else { label = 20; break; }
    case 19: 
      var $43=$ls_addr;
      var $44=$sep;
      _read_long_string($43, 0, $44);
      var $45=$ls_addr;
      var $buff52=(($45+48)|0);
      var $46=HEAP32[(($buff52)>>2)];
      var $n53=(($46+4)|0);
      HEAP32[(($n53)>>2)]=0;
      label = 110; break;
    case 20: 
      label = 21; break;
    case 21: 
      label = 22; break;
    case 22: 
      var $47=$ls_addr;
      var $current56=(($47)|0);
      var $48=HEAP32[(($current56)>>2)];
      var $cmp57=(($48)|0)==10;
      if ($cmp57) { var $53 = 0;label = 25; break; } else { label = 23; break; }
    case 23: 
      var $49=$ls_addr;
      var $current59=(($49)|0);
      var $50=HEAP32[(($current59)>>2)];
      var $cmp60=(($50)|0)==13;
      if ($cmp60) { var $53 = 0;label = 25; break; } else { label = 24; break; }
    case 24: 
      var $51=$ls_addr;
      var $current62=(($51)|0);
      var $52=HEAP32[(($current62)>>2)];
      var $cmp63=(($52)|0)!=-1;
      var $53 = $cmp63;label = 25; break;
    case 25: 
      var $53;
      if ($53) { label = 26; break; } else { label = 30; break; }
    case 26: 
      var $54=$ls_addr;
      var $z65=(($54+44)|0);
      var $55=HEAP32[(($z65)>>2)];
      var $n66=(($55)|0);
      var $56=HEAP32[(($n66)>>2)];
      var $dec67=((($56)-(1))|0);
      HEAP32[(($n66)>>2)]=$dec67;
      var $cmp68=(($56)>>>0) > 0;
      if ($cmp68) { label = 27; break; } else { label = 28; break; }
    case 27: 
      var $57=$ls_addr;
      var $z71=(($57+44)|0);
      var $58=HEAP32[(($z71)>>2)];
      var $p72=(($58+4)|0);
      var $59=HEAP32[(($p72)>>2)];
      var $incdec_ptr73=(($59+1)|0);
      HEAP32[(($p72)>>2)]=$incdec_ptr73;
      var $60=HEAP8[($59)];
      var $conv74=(($60)&255);
      var $cond79 = $conv74;label = 29; break;
    case 28: 
      var $61=$ls_addr;
      var $z76=(($61+44)|0);
      var $62=HEAP32[(($z76)>>2)];
      var $call77=_luaZ_fill($62);
      var $cond79 = $call77;label = 29; break;
    case 29: 
      var $cond79;
      var $63=$ls_addr;
      var $current80=(($63)|0);
      HEAP32[(($current80)>>2)]=$cond79;
      label = 22; break;
    case 30: 
      label = 110; break;
    case 31: 
      var $64=$ls_addr;
      var $call83=_skip_sep($64);
      $sep82=$call83;
      var $65=$sep82;
      var $cmp84=(($65)|0) >= 0;
      if ($cmp84) { label = 32; break; } else { label = 33; break; }
    case 32: 
      var $66=$ls_addr;
      var $67=$seminfo_addr;
      var $68=$sep82;
      _read_long_string($66, $67, $68);
      $retval=289;
      label = 111; break;
    case 33: 
      var $69=$sep82;
      var $cmp87=(($69)|0)==-1;
      if ($cmp87) { label = 34; break; } else { label = 35; break; }
    case 34: 
      $retval=91;
      label = 111; break;
    case 35: 
      var $70=$ls_addr;
      _lexerror($70, ((5244908)|0), 289);

    case 36: 
      var $71=$ls_addr;
      var $z92=(($71+44)|0);
      var $72=HEAP32[(($z92)>>2)];
      var $n93=(($72)|0);
      var $73=HEAP32[(($n93)>>2)];
      var $dec94=((($73)-(1))|0);
      HEAP32[(($n93)>>2)]=$dec94;
      var $cmp95=(($73)>>>0) > 0;
      if ($cmp95) { label = 37; break; } else { label = 38; break; }
    case 37: 
      var $74=$ls_addr;
      var $z98=(($74+44)|0);
      var $75=HEAP32[(($z98)>>2)];
      var $p99=(($75+4)|0);
      var $76=HEAP32[(($p99)>>2)];
      var $incdec_ptr100=(($76+1)|0);
      HEAP32[(($p99)>>2)]=$incdec_ptr100;
      var $77=HEAP8[($76)];
      var $conv101=(($77)&255);
      var $cond106 = $conv101;label = 39; break;
    case 38: 
      var $78=$ls_addr;
      var $z103=(($78+44)|0);
      var $79=HEAP32[(($z103)>>2)];
      var $call104=_luaZ_fill($79);
      var $cond106 = $call104;label = 39; break;
    case 39: 
      var $cond106;
      var $80=$ls_addr;
      var $current107=(($80)|0);
      HEAP32[(($current107)>>2)]=$cond106;
      var $81=$ls_addr;
      var $current108=(($81)|0);
      var $82=HEAP32[(($current108)>>2)];
      var $cmp109=(($82)|0)!=61;
      if ($cmp109) { label = 40; break; } else { label = 41; break; }
    case 40: 
      $retval=61;
      label = 111; break;
    case 41: 
      var $83=$ls_addr;
      var $z113=(($83+44)|0);
      var $84=HEAP32[(($z113)>>2)];
      var $n114=(($84)|0);
      var $85=HEAP32[(($n114)>>2)];
      var $dec115=((($85)-(1))|0);
      HEAP32[(($n114)>>2)]=$dec115;
      var $cmp116=(($85)>>>0) > 0;
      if ($cmp116) { label = 42; break; } else { label = 43; break; }
    case 42: 
      var $86=$ls_addr;
      var $z119=(($86+44)|0);
      var $87=HEAP32[(($z119)>>2)];
      var $p120=(($87+4)|0);
      var $88=HEAP32[(($p120)>>2)];
      var $incdec_ptr121=(($88+1)|0);
      HEAP32[(($p120)>>2)]=$incdec_ptr121;
      var $89=HEAP8[($88)];
      var $conv122=(($89)&255);
      var $cond127 = $conv122;label = 44; break;
    case 43: 
      var $90=$ls_addr;
      var $z124=(($90+44)|0);
      var $91=HEAP32[(($z124)>>2)];
      var $call125=_luaZ_fill($91);
      var $cond127 = $call125;label = 44; break;
    case 44: 
      var $cond127;
      var $92=$ls_addr;
      var $current128=(($92)|0);
      HEAP32[(($current128)>>2)]=$cond127;
      $retval=281;
      label = 111; break;
    case 45: 
      var $93=$ls_addr;
      var $z130=(($93+44)|0);
      var $94=HEAP32[(($z130)>>2)];
      var $n131=(($94)|0);
      var $95=HEAP32[(($n131)>>2)];
      var $dec132=((($95)-(1))|0);
      HEAP32[(($n131)>>2)]=$dec132;
      var $cmp133=(($95)>>>0) > 0;
      if ($cmp133) { label = 46; break; } else { label = 47; break; }
    case 46: 
      var $96=$ls_addr;
      var $z136=(($96+44)|0);
      var $97=HEAP32[(($z136)>>2)];
      var $p137=(($97+4)|0);
      var $98=HEAP32[(($p137)>>2)];
      var $incdec_ptr138=(($98+1)|0);
      HEAP32[(($p137)>>2)]=$incdec_ptr138;
      var $99=HEAP8[($98)];
      var $conv139=(($99)&255);
      var $cond144 = $conv139;label = 48; break;
    case 47: 
      var $100=$ls_addr;
      var $z141=(($100+44)|0);
      var $101=HEAP32[(($z141)>>2)];
      var $call142=_luaZ_fill($101);
      var $cond144 = $call142;label = 48; break;
    case 48: 
      var $cond144;
      var $102=$ls_addr;
      var $current145=(($102)|0);
      HEAP32[(($current145)>>2)]=$cond144;
      var $103=$ls_addr;
      var $current146=(($103)|0);
      var $104=HEAP32[(($current146)>>2)];
      var $cmp147=(($104)|0)!=61;
      if ($cmp147) { label = 49; break; } else { label = 50; break; }
    case 49: 
      $retval=60;
      label = 111; break;
    case 50: 
      var $105=$ls_addr;
      var $z151=(($105+44)|0);
      var $106=HEAP32[(($z151)>>2)];
      var $n152=(($106)|0);
      var $107=HEAP32[(($n152)>>2)];
      var $dec153=((($107)-(1))|0);
      HEAP32[(($n152)>>2)]=$dec153;
      var $cmp154=(($107)>>>0) > 0;
      if ($cmp154) { label = 51; break; } else { label = 52; break; }
    case 51: 
      var $108=$ls_addr;
      var $z157=(($108+44)|0);
      var $109=HEAP32[(($z157)>>2)];
      var $p158=(($109+4)|0);
      var $110=HEAP32[(($p158)>>2)];
      var $incdec_ptr159=(($110+1)|0);
      HEAP32[(($p158)>>2)]=$incdec_ptr159;
      var $111=HEAP8[($110)];
      var $conv160=(($111)&255);
      var $cond165 = $conv160;label = 53; break;
    case 52: 
      var $112=$ls_addr;
      var $z162=(($112+44)|0);
      var $113=HEAP32[(($z162)>>2)];
      var $call163=_luaZ_fill($113);
      var $cond165 = $call163;label = 53; break;
    case 53: 
      var $cond165;
      var $114=$ls_addr;
      var $current166=(($114)|0);
      HEAP32[(($current166)>>2)]=$cond165;
      $retval=283;
      label = 111; break;
    case 54: 
      var $115=$ls_addr;
      var $z168=(($115+44)|0);
      var $116=HEAP32[(($z168)>>2)];
      var $n169=(($116)|0);
      var $117=HEAP32[(($n169)>>2)];
      var $dec170=((($117)-(1))|0);
      HEAP32[(($n169)>>2)]=$dec170;
      var $cmp171=(($117)>>>0) > 0;
      if ($cmp171) { label = 55; break; } else { label = 56; break; }
    case 55: 
      var $118=$ls_addr;
      var $z174=(($118+44)|0);
      var $119=HEAP32[(($z174)>>2)];
      var $p175=(($119+4)|0);
      var $120=HEAP32[(($p175)>>2)];
      var $incdec_ptr176=(($120+1)|0);
      HEAP32[(($p175)>>2)]=$incdec_ptr176;
      var $121=HEAP8[($120)];
      var $conv177=(($121)&255);
      var $cond182 = $conv177;label = 57; break;
    case 56: 
      var $122=$ls_addr;
      var $z179=(($122+44)|0);
      var $123=HEAP32[(($z179)>>2)];
      var $call180=_luaZ_fill($123);
      var $cond182 = $call180;label = 57; break;
    case 57: 
      var $cond182;
      var $124=$ls_addr;
      var $current183=(($124)|0);
      HEAP32[(($current183)>>2)]=$cond182;
      var $125=$ls_addr;
      var $current184=(($125)|0);
      var $126=HEAP32[(($current184)>>2)];
      var $cmp185=(($126)|0)!=61;
      if ($cmp185) { label = 58; break; } else { label = 59; break; }
    case 58: 
      $retval=62;
      label = 111; break;
    case 59: 
      var $127=$ls_addr;
      var $z189=(($127+44)|0);
      var $128=HEAP32[(($z189)>>2)];
      var $n190=(($128)|0);
      var $129=HEAP32[(($n190)>>2)];
      var $dec191=((($129)-(1))|0);
      HEAP32[(($n190)>>2)]=$dec191;
      var $cmp192=(($129)>>>0) > 0;
      if ($cmp192) { label = 60; break; } else { label = 61; break; }
    case 60: 
      var $130=$ls_addr;
      var $z195=(($130+44)|0);
      var $131=HEAP32[(($z195)>>2)];
      var $p196=(($131+4)|0);
      var $132=HEAP32[(($p196)>>2)];
      var $incdec_ptr197=(($132+1)|0);
      HEAP32[(($p196)>>2)]=$incdec_ptr197;
      var $133=HEAP8[($132)];
      var $conv198=(($133)&255);
      var $cond203 = $conv198;label = 62; break;
    case 61: 
      var $134=$ls_addr;
      var $z200=(($134+44)|0);
      var $135=HEAP32[(($z200)>>2)];
      var $call201=_luaZ_fill($135);
      var $cond203 = $call201;label = 62; break;
    case 62: 
      var $cond203;
      var $136=$ls_addr;
      var $current204=(($136)|0);
      HEAP32[(($current204)>>2)]=$cond203;
      $retval=282;
      label = 111; break;
    case 63: 
      var $137=$ls_addr;
      var $z206=(($137+44)|0);
      var $138=HEAP32[(($z206)>>2)];
      var $n207=(($138)|0);
      var $139=HEAP32[(($n207)>>2)];
      var $dec208=((($139)-(1))|0);
      HEAP32[(($n207)>>2)]=$dec208;
      var $cmp209=(($139)>>>0) > 0;
      if ($cmp209) { label = 64; break; } else { label = 65; break; }
    case 64: 
      var $140=$ls_addr;
      var $z212=(($140+44)|0);
      var $141=HEAP32[(($z212)>>2)];
      var $p213=(($141+4)|0);
      var $142=HEAP32[(($p213)>>2)];
      var $incdec_ptr214=(($142+1)|0);
      HEAP32[(($p213)>>2)]=$incdec_ptr214;
      var $143=HEAP8[($142)];
      var $conv215=(($143)&255);
      var $cond220 = $conv215;label = 66; break;
    case 65: 
      var $144=$ls_addr;
      var $z217=(($144+44)|0);
      var $145=HEAP32[(($z217)>>2)];
      var $call218=_luaZ_fill($145);
      var $cond220 = $call218;label = 66; break;
    case 66: 
      var $cond220;
      var $146=$ls_addr;
      var $current221=(($146)|0);
      HEAP32[(($current221)>>2)]=$cond220;
      var $147=$ls_addr;
      var $current222=(($147)|0);
      var $148=HEAP32[(($current222)>>2)];
      var $cmp223=(($148)|0)!=61;
      if ($cmp223) { label = 67; break; } else { label = 68; break; }
    case 67: 
      $retval=126;
      label = 111; break;
    case 68: 
      var $149=$ls_addr;
      var $z227=(($149+44)|0);
      var $150=HEAP32[(($z227)>>2)];
      var $n228=(($150)|0);
      var $151=HEAP32[(($n228)>>2)];
      var $dec229=((($151)-(1))|0);
      HEAP32[(($n228)>>2)]=$dec229;
      var $cmp230=(($151)>>>0) > 0;
      if ($cmp230) { label = 69; break; } else { label = 70; break; }
    case 69: 
      var $152=$ls_addr;
      var $z233=(($152+44)|0);
      var $153=HEAP32[(($z233)>>2)];
      var $p234=(($153+4)|0);
      var $154=HEAP32[(($p234)>>2)];
      var $incdec_ptr235=(($154+1)|0);
      HEAP32[(($p234)>>2)]=$incdec_ptr235;
      var $155=HEAP8[($154)];
      var $conv236=(($155)&255);
      var $cond241 = $conv236;label = 71; break;
    case 70: 
      var $156=$ls_addr;
      var $z238=(($156+44)|0);
      var $157=HEAP32[(($z238)>>2)];
      var $call239=_luaZ_fill($157);
      var $cond241 = $call239;label = 71; break;
    case 71: 
      var $cond241;
      var $158=$ls_addr;
      var $current242=(($158)|0);
      HEAP32[(($current242)>>2)]=$cond241;
      $retval=284;
      label = 111; break;
    case 72: 
      var $159=$ls_addr;
      var $z244=(($159+44)|0);
      var $160=HEAP32[(($z244)>>2)];
      var $n245=(($160)|0);
      var $161=HEAP32[(($n245)>>2)];
      var $dec246=((($161)-(1))|0);
      HEAP32[(($n245)>>2)]=$dec246;
      var $cmp247=(($161)>>>0) > 0;
      if ($cmp247) { label = 73; break; } else { label = 74; break; }
    case 73: 
      var $162=$ls_addr;
      var $z250=(($162+44)|0);
      var $163=HEAP32[(($z250)>>2)];
      var $p251=(($163+4)|0);
      var $164=HEAP32[(($p251)>>2)];
      var $incdec_ptr252=(($164+1)|0);
      HEAP32[(($p251)>>2)]=$incdec_ptr252;
      var $165=HEAP8[($164)];
      var $conv253=(($165)&255);
      var $cond258 = $conv253;label = 75; break;
    case 74: 
      var $166=$ls_addr;
      var $z255=(($166+44)|0);
      var $167=HEAP32[(($z255)>>2)];
      var $call256=_luaZ_fill($167);
      var $cond258 = $call256;label = 75; break;
    case 75: 
      var $cond258;
      var $168=$ls_addr;
      var $current259=(($168)|0);
      HEAP32[(($current259)>>2)]=$cond258;
      var $169=$ls_addr;
      var $current260=(($169)|0);
      var $170=HEAP32[(($current260)>>2)];
      var $cmp261=(($170)|0)!=58;
      if ($cmp261) { label = 76; break; } else { label = 77; break; }
    case 76: 
      $retval=58;
      label = 111; break;
    case 77: 
      var $171=$ls_addr;
      var $z265=(($171+44)|0);
      var $172=HEAP32[(($z265)>>2)];
      var $n266=(($172)|0);
      var $173=HEAP32[(($n266)>>2)];
      var $dec267=((($173)-(1))|0);
      HEAP32[(($n266)>>2)]=$dec267;
      var $cmp268=(($173)>>>0) > 0;
      if ($cmp268) { label = 78; break; } else { label = 79; break; }
    case 78: 
      var $174=$ls_addr;
      var $z271=(($174+44)|0);
      var $175=HEAP32[(($z271)>>2)];
      var $p272=(($175+4)|0);
      var $176=HEAP32[(($p272)>>2)];
      var $incdec_ptr273=(($176+1)|0);
      HEAP32[(($p272)>>2)]=$incdec_ptr273;
      var $177=HEAP8[($176)];
      var $conv274=(($177)&255);
      var $cond279 = $conv274;label = 80; break;
    case 79: 
      var $178=$ls_addr;
      var $z276=(($178+44)|0);
      var $179=HEAP32[(($z276)>>2)];
      var $call277=_luaZ_fill($179);
      var $cond279 = $call277;label = 80; break;
    case 80: 
      var $cond279;
      var $180=$ls_addr;
      var $current280=(($180)|0);
      HEAP32[(($current280)>>2)]=$cond279;
      $retval=285;
      label = 111; break;
    case 81: 
      var $181=$ls_addr;
      var $182=$ls_addr;
      var $current282=(($182)|0);
      var $183=HEAP32[(($current282)>>2)];
      var $184=$seminfo_addr;
      _read_string($181, $183, $184);
      $retval=289;
      label = 111; break;
    case 82: 
      var $185=$ls_addr;
      var $186=$ls_addr;
      var $current284=(($186)|0);
      var $187=HEAP32[(($current284)>>2)];
      _save($185, $187);
      var $188=$ls_addr;
      var $z285=(($188+44)|0);
      var $189=HEAP32[(($z285)>>2)];
      var $n286=(($189)|0);
      var $190=HEAP32[(($n286)>>2)];
      var $dec287=((($190)-(1))|0);
      HEAP32[(($n286)>>2)]=$dec287;
      var $cmp288=(($190)>>>0) > 0;
      if ($cmp288) { label = 83; break; } else { label = 84; break; }
    case 83: 
      var $191=$ls_addr;
      var $z291=(($191+44)|0);
      var $192=HEAP32[(($z291)>>2)];
      var $p292=(($192+4)|0);
      var $193=HEAP32[(($p292)>>2)];
      var $incdec_ptr293=(($193+1)|0);
      HEAP32[(($p292)>>2)]=$incdec_ptr293;
      var $194=HEAP8[($193)];
      var $conv294=(($194)&255);
      var $cond299 = $conv294;label = 85; break;
    case 84: 
      var $195=$ls_addr;
      var $z296=(($195+44)|0);
      var $196=HEAP32[(($z296)>>2)];
      var $call297=_luaZ_fill($196);
      var $cond299 = $call297;label = 85; break;
    case 85: 
      var $cond299;
      var $197=$ls_addr;
      var $current300=(($197)|0);
      HEAP32[(($current300)>>2)]=$cond299;
      var $198=$ls_addr;
      var $call301=_check_next($198, ((5244644)|0));
      var $tobool=(($call301)|0)!=0;
      if ($tobool) { label = 86; break; } else { label = 89; break; }
    case 86: 
      var $199=$ls_addr;
      var $call303=_check_next($199, ((5244644)|0));
      var $tobool304=(($call303)|0)!=0;
      if ($tobool304) { label = 87; break; } else { label = 88; break; }
    case 87: 
      $retval=280;
      label = 111; break;
    case 88: 
      $retval=279;
      label = 111; break;
    case 89: 
      var $200=$ls_addr;
      var $current308=(($200)|0);
      var $201=HEAP32[(($current308)>>2)];
      var $add=((($201)+(1))|0);
      var $arrayidx=((5242924+$add)|0);
      var $202=HEAP8[($arrayidx)];
      var $conv309=(($202)&255);
      var $and=$conv309 & 2;
      var $tobool310=(($and)|0)!=0;
      if ($tobool310) { label = 91; break; } else { label = 90; break; }
    case 90: 
      $retval=46;
      label = 111; break;
    case 91: 
      label = 92; break;
    case 92: 
      label = 93; break;
    case 93: 
      var $203=$ls_addr;
      var $204=$seminfo_addr;
      _read_numeral($203, $204);
      $retval=287;
      label = 111; break;
    case 94: 
      $retval=286;
      label = 111; break;
    case 95: 
      var $205=$ls_addr;
      var $current316=(($205)|0);
      var $206=HEAP32[(($current316)>>2)];
      var $add317=((($206)+(1))|0);
      var $arrayidx318=((5242924+$add317)|0);
      var $207=HEAP8[($arrayidx318)];
      var $conv319=(($207)&255);
      var $and320=$conv319 & 1;
      var $tobool321=(($and320)|0)!=0;
      if ($tobool321) { label = 96; break; } else { label = 106; break; }
    case 96: 
      label = 97; break;
    case 97: 
      var $208=$ls_addr;
      var $209=$ls_addr;
      var $current323=(($209)|0);
      var $210=HEAP32[(($current323)>>2)];
      _save($208, $210);
      var $211=$ls_addr;
      var $z324=(($211+44)|0);
      var $212=HEAP32[(($z324)>>2)];
      var $n325=(($212)|0);
      var $213=HEAP32[(($n325)>>2)];
      var $dec326=((($213)-(1))|0);
      HEAP32[(($n325)>>2)]=$dec326;
      var $cmp327=(($213)>>>0) > 0;
      if ($cmp327) { label = 98; break; } else { label = 99; break; }
    case 98: 
      var $214=$ls_addr;
      var $z330=(($214+44)|0);
      var $215=HEAP32[(($z330)>>2)];
      var $p331=(($215+4)|0);
      var $216=HEAP32[(($p331)>>2)];
      var $incdec_ptr332=(($216+1)|0);
      HEAP32[(($p331)>>2)]=$incdec_ptr332;
      var $217=HEAP8[($216)];
      var $conv333=(($217)&255);
      var $cond338 = $conv333;label = 100; break;
    case 99: 
      var $218=$ls_addr;
      var $z335=(($218+44)|0);
      var $219=HEAP32[(($z335)>>2)];
      var $call336=_luaZ_fill($219);
      var $cond338 = $call336;label = 100; break;
    case 100: 
      var $cond338;
      var $220=$ls_addr;
      var $current339=(($220)|0);
      HEAP32[(($current339)>>2)]=$cond338;
      label = 101; break;
    case 101: 
      var $221=$ls_addr;
      var $current340=(($221)|0);
      var $222=HEAP32[(($current340)>>2)];
      var $add341=((($222)+(1))|0);
      var $arrayidx342=((5242924+$add341)|0);
      var $223=HEAP8[($arrayidx342)];
      var $conv343=(($223)&255);
      var $and344=$conv343 & 3;
      var $tobool345=(($and344)|0)!=0;
      if ($tobool345) { label = 97; break; } else { label = 102; break; }
    case 102: 
      var $224=$ls_addr;
      var $225=$ls_addr;
      var $buff346=(($225+48)|0);
      var $226=HEAP32[(($buff346)>>2)];
      var $buffer=(($226)|0);
      var $227=HEAP32[(($buffer)>>2)];
      var $228=$ls_addr;
      var $buff347=(($228+48)|0);
      var $229=HEAP32[(($buff347)>>2)];
      var $n348=(($229+4)|0);
      var $230=HEAP32[(($n348)>>2)];
      var $call349=_luaX_newstring($224, $227, $230);
      $ts=$call349;
      var $231=$ts;
      var $232=$seminfo_addr;
      var $ts350=$232;
      HEAP32[(($ts350)>>2)]=$231;
      var $233=$ts;
      var $tsv=$233;
      var $tt=(($tsv+4)|0);
      var $234=HEAP8[($tt)];
      var $conv351=(($234)&255);
      var $cmp352=(($conv351)|0)==4;
      if ($cmp352) { label = 103; break; } else { label = 105; break; }
    case 103: 
      var $235=$ts;
      var $tsv354=$235;
      var $extra=(($tsv354+6)|0);
      var $236=HEAP8[($extra)];
      var $conv355=(($236)&255);
      var $cmp356=(($conv355)|0) > 0;
      if ($cmp356) { label = 104; break; } else { label = 105; break; }
    case 104: 
      var $237=$ts;
      var $tsv359=$237;
      var $extra360=(($tsv359+6)|0);
      var $238=HEAP8[($extra360)];
      var $conv361=(($238)&255);
      var $sub=((($conv361)-(1))|0);
      var $add362=((($sub)+(257))|0);
      $retval=$add362;
      label = 111; break;
    case 105: 
      $retval=288;
      label = 111; break;
    case 106: 
      var $239=$ls_addr;
      var $current365=(($239)|0);
      var $240=HEAP32[(($current365)>>2)];
      $c=$240;
      var $241=$ls_addr;
      var $z366=(($241+44)|0);
      var $242=HEAP32[(($z366)>>2)];
      var $n367=(($242)|0);
      var $243=HEAP32[(($n367)>>2)];
      var $dec368=((($243)-(1))|0);
      HEAP32[(($n367)>>2)]=$dec368;
      var $cmp369=(($243)>>>0) > 0;
      if ($cmp369) { label = 107; break; } else { label = 108; break; }
    case 107: 
      var $244=$ls_addr;
      var $z372=(($244+44)|0);
      var $245=HEAP32[(($z372)>>2)];
      var $p373=(($245+4)|0);
      var $246=HEAP32[(($p373)>>2)];
      var $incdec_ptr374=(($246+1)|0);
      HEAP32[(($p373)>>2)]=$incdec_ptr374;
      var $247=HEAP8[($246)];
      var $conv375=(($247)&255);
      var $cond380 = $conv375;label = 109; break;
    case 108: 
      var $248=$ls_addr;
      var $z377=(($248+44)|0);
      var $249=HEAP32[(($z377)>>2)];
      var $call378=_luaZ_fill($249);
      var $cond380 = $call378;label = 109; break;
    case 109: 
      var $cond380;
      var $250=$ls_addr;
      var $current381=(($250)|0);
      HEAP32[(($current381)>>2)]=$cond380;
      var $251=$c;
      $retval=$251;
      label = 111; break;
    case 110: 
      label = 3; break;
    case 111: 
      var $252=$retval;

      Module.print(INDENT + 'Exiting: _llex');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return $252;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_llex["X"]=1;

function _luaX_lookahead($ls) {
  var label = 0;

  Module.print(INDENT + ' Entering: _luaX_lookahead: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';

  var $ls_addr;
  $ls_addr=$ls;
  var $0=$ls_addr;
  var $1=$ls_addr;
  var $lookahead=(($1+24)|0);
  var $seminfo=(($lookahead+4)|0);
  var $call=_llex($0, $seminfo);
  var $2=$ls_addr;
  var $lookahead1=(($2+24)|0);
  var $token=(($lookahead1)|0);
  HEAP32[(($token)>>2)]=$call;
  var $3=$ls_addr;
  var $lookahead2=(($3+24)|0);
  var $token3=(($lookahead2)|0);
  var $4=HEAP32[(($token3)>>2)];

  Module.print(INDENT + 'Exiting: _luaX_lookahead');
  INDENT = INDENT.substr(0, INDENT.length-2);
  return $4;
  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _skip_sep($ls) {
  var label = 0;

  Module.print(INDENT + ' Entering: _skip_sep: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $ls_addr;
      var $count;
      var $s;
      $ls_addr=$ls;
      $count=0;
      var $0=$ls_addr;
      var $current=(($0)|0);
      var $1=HEAP32[(($current)>>2)];
      $s=$1;
      var $2=$ls_addr;
      var $3=$ls_addr;
      var $current1=(($3)|0);
      var $4=HEAP32[(($current1)>>2)];
      _save($2, $4);
      var $5=$ls_addr;
      var $z=(($5+44)|0);
      var $6=HEAP32[(($z)>>2)];
      var $n=(($6)|0);
      var $7=HEAP32[(($n)>>2)];
      var $dec=((($7)-(1))|0);
      HEAP32[(($n)>>2)]=$dec;
      var $cmp=(($7)>>>0) > 0;
      if ($cmp) { label = 3; break; } else { label = 4; break; }
    case 3: 
      var $8=$ls_addr;
      var $z2=(($8+44)|0);
      var $9=HEAP32[(($z2)>>2)];
      var $p=(($9+4)|0);
      var $10=HEAP32[(($p)>>2)];
      var $incdec_ptr=(($10+1)|0);
      HEAP32[(($p)>>2)]=$incdec_ptr;
      var $11=HEAP8[($10)];
      var $conv=(($11)&255);
      var $cond = $conv;label = 5; break;
    case 4: 
      var $12=$ls_addr;
      var $z3=(($12+44)|0);
      var $13=HEAP32[(($z3)>>2)];
      var $call=_luaZ_fill($13);
      var $cond = $call;label = 5; break;
    case 5: 
      var $cond;
      var $14=$ls_addr;
      var $current4=(($14)|0);
      HEAP32[(($current4)>>2)]=$cond;
      label = 6; break;
    case 6: 
      var $15=$ls_addr;
      var $current5=(($15)|0);
      var $16=HEAP32[(($current5)>>2)];
      var $cmp6=(($16)|0)==61;
      if ($cmp6) { label = 7; break; } else { label = 11; break; }
    case 7: 
      var $17=$ls_addr;
      var $18=$ls_addr;
      var $current8=(($18)|0);
      var $19=HEAP32[(($current8)>>2)];
      _save($17, $19);
      var $20=$ls_addr;
      var $z9=(($20+44)|0);
      var $21=HEAP32[(($z9)>>2)];
      var $n10=(($21)|0);
      var $22=HEAP32[(($n10)>>2)];
      var $dec11=((($22)-(1))|0);
      HEAP32[(($n10)>>2)]=$dec11;
      var $cmp12=(($22)>>>0) > 0;
      if ($cmp12) { label = 8; break; } else { label = 9; break; }
    case 8: 
      var $23=$ls_addr;
      var $z15=(($23+44)|0);
      var $24=HEAP32[(($z15)>>2)];
      var $p16=(($24+4)|0);
      var $25=HEAP32[(($p16)>>2)];
      var $incdec_ptr17=(($25+1)|0);
      HEAP32[(($p16)>>2)]=$incdec_ptr17;
      var $26=HEAP8[($25)];
      var $conv18=(($26)&255);
      var $cond23 = $conv18;label = 10; break;
    case 9: 
      var $27=$ls_addr;
      var $z20=(($27+44)|0);
      var $28=HEAP32[(($z20)>>2)];
      var $call21=_luaZ_fill($28);
      var $cond23 = $call21;label = 10; break;
    case 10: 
      var $cond23;
      var $29=$ls_addr;
      var $current24=(($29)|0);
      HEAP32[(($current24)>>2)]=$cond23;
      var $30=$count;
      var $inc=((($30)+(1))|0);
      $count=$inc;
      label = 6; break;
    case 11: 
      var $31=$ls_addr;
      var $current25=(($31)|0);
      var $32=HEAP32[(($current25)>>2)];
      var $33=$s;
      var $cmp26=(($32)|0)==(($33)|0);
      if ($cmp26) { label = 12; break; } else { label = 13; break; }
    case 12: 
      var $34=$count;
      var $cond32 = $34;label = 14; break;
    case 13: 
      var $35=$count;
      var $sub=(((-$35))|0);
      var $sub30=((($sub)-(1))|0);
      var $cond32 = $sub30;label = 14; break;
    case 14: 
      var $cond32;

      Module.print(INDENT + 'Exiting: _skip_sep');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return $cond32;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_skip_sep["X"]=1;

function _inclinenumber($ls) {
  var label = 0;

  Module.print(INDENT + ' Entering: _inclinenumber: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $ls_addr;
      var $old;
      $ls_addr=$ls;
      var $0=$ls_addr;
      var $current=(($0)|0);
      var $1=HEAP32[(($current)>>2)];
      $old=$1;
      var $2=$ls_addr;
      var $z=(($2+44)|0);
      var $3=HEAP32[(($z)>>2)];
      var $n=(($3)|0);
      var $4=HEAP32[(($n)>>2)];
      var $dec=((($4)-(1))|0);
      HEAP32[(($n)>>2)]=$dec;
      var $cmp=(($4)>>>0) > 0;
      if ($cmp) { label = 3; break; } else { label = 4; break; }
    case 3: 
      var $5=$ls_addr;
      var $z1=(($5+44)|0);
      var $6=HEAP32[(($z1)>>2)];
      var $p=(($6+4)|0);
      var $7=HEAP32[(($p)>>2)];
      var $incdec_ptr=(($7+1)|0);
      HEAP32[(($p)>>2)]=$incdec_ptr;
      var $8=HEAP8[($7)];
      var $conv=(($8)&255);
      var $cond = $conv;label = 5; break;
    case 4: 
      var $9=$ls_addr;
      var $z2=(($9+44)|0);
      var $10=HEAP32[(($z2)>>2)];
      var $call=_luaZ_fill($10);
      var $cond = $call;label = 5; break;
    case 5: 
      var $cond;
      var $11=$ls_addr;
      var $current3=(($11)|0);
      HEAP32[(($current3)>>2)]=$cond;
      var $12=$ls_addr;
      var $current4=(($12)|0);
      var $13=HEAP32[(($current4)>>2)];
      var $cmp5=(($13)|0)==10;
      if ($cmp5) { label = 7; break; } else { label = 6; break; }
    case 6: 
      var $14=$ls_addr;
      var $current7=(($14)|0);
      var $15=HEAP32[(($current7)>>2)];
      var $cmp8=(($15)|0)==13;
      if ($cmp8) { label = 7; break; } else { label = 12; break; }
    case 7: 
      var $16=$ls_addr;
      var $current10=(($16)|0);
      var $17=HEAP32[(($current10)>>2)];
      var $18=$old;
      var $cmp11=(($17)|0)!=(($18)|0);
      if ($cmp11) { label = 8; break; } else { label = 12; break; }
    case 8: 
      var $19=$ls_addr;
      var $z13=(($19+44)|0);
      var $20=HEAP32[(($z13)>>2)];
      var $n14=(($20)|0);
      var $21=HEAP32[(($n14)>>2)];
      var $dec15=((($21)-(1))|0);
      HEAP32[(($n14)>>2)]=$dec15;
      var $cmp16=(($21)>>>0) > 0;
      if ($cmp16) { label = 9; break; } else { label = 10; break; }
    case 9: 
      var $22=$ls_addr;
      var $z19=(($22+44)|0);
      var $23=HEAP32[(($z19)>>2)];
      var $p20=(($23+4)|0);
      var $24=HEAP32[(($p20)>>2)];
      var $incdec_ptr21=(($24+1)|0);
      HEAP32[(($p20)>>2)]=$incdec_ptr21;
      var $25=HEAP8[($24)];
      var $conv22=(($25)&255);
      var $cond27 = $conv22;label = 11; break;
    case 10: 
      var $26=$ls_addr;
      var $z24=(($26+44)|0);
      var $27=HEAP32[(($z24)>>2)];
      var $call25=_luaZ_fill($27);
      var $cond27 = $call25;label = 11; break;
    case 11: 
      var $cond27;
      var $28=$ls_addr;
      var $current28=(($28)|0);
      HEAP32[(($current28)>>2)]=$cond27;
      label = 12; break;
    case 12: 
      var $29=$ls_addr;
      var $linenumber=(($29+4)|0);
      var $30=HEAP32[(($linenumber)>>2)];
      var $inc=((($30)+(1))|0);
      HEAP32[(($linenumber)>>2)]=$inc;
      var $cmp29=(($inc)|0) >= 2147483645;
      if ($cmp29) { label = 13; break; } else { label = 14; break; }
    case 13: 
      var $31=$ls_addr;
      _luaX_syntaxerror($31, ((5246192)|0));

    case 14: 

      Module.print(INDENT + 'Exiting: _inclinenumber');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_inclinenumber["X"]=1;

function _read_long_string($ls, $seminfo, $sep) {
  var label = 0;

  Module.print(INDENT + ' Entering: _read_long_string: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $ls_addr;
      var $seminfo_addr;
      var $sep_addr;
      $ls_addr=$ls;
      $seminfo_addr=$seminfo;
      $sep_addr=$sep;
      var $0=$ls_addr;
      var $1=$ls_addr;
      var $current=(($1)|0);
      var $2=HEAP32[(($current)>>2)];
      _save($0, $2);
      var $3=$ls_addr;
      var $z=(($3+44)|0);
      var $4=HEAP32[(($z)>>2)];
      var $n=(($4)|0);
      var $5=HEAP32[(($n)>>2)];
      var $dec=((($5)-(1))|0);
      HEAP32[(($n)>>2)]=$dec;
      var $cmp=(($5)>>>0) > 0;
      if ($cmp) { label = 3; break; } else { label = 4; break; }
    case 3: 
      var $6=$ls_addr;
      var $z1=(($6+44)|0);
      var $7=HEAP32[(($z1)>>2)];
      var $p=(($7+4)|0);
      var $8=HEAP32[(($p)>>2)];
      var $incdec_ptr=(($8+1)|0);
      HEAP32[(($p)>>2)]=$incdec_ptr;
      var $9=HEAP8[($8)];
      var $conv=(($9)&255);
      var $cond = $conv;label = 5; break;
    case 4: 
      var $10=$ls_addr;
      var $z2=(($10+44)|0);
      var $11=HEAP32[(($z2)>>2)];
      var $call=_luaZ_fill($11);
      var $cond = $call;label = 5; break;
    case 5: 
      var $cond;
      var $12=$ls_addr;
      var $current3=(($12)|0);
      HEAP32[(($current3)>>2)]=$cond;
      var $13=$ls_addr;
      var $current4=(($13)|0);
      var $14=HEAP32[(($current4)>>2)];
      var $cmp5=(($14)|0)==10;
      if ($cmp5) { label = 7; break; } else { label = 6; break; }
    case 6: 
      var $15=$ls_addr;
      var $current7=(($15)|0);
      var $16=HEAP32[(($current7)>>2)];
      var $cmp8=(($16)|0)==13;
      if ($cmp8) { label = 7; break; } else { label = 8; break; }
    case 7: 
      var $17=$ls_addr;
      _inclinenumber($17);
      label = 8; break;
    case 8: 
      label = 9; break;
    case 9: 
      var $18=$ls_addr;
      var $current10=(($18)|0);
      var $19=HEAP32[(($current10)>>2)];
      if ((($19)|0)==-1) {
        label = 10; break;
      }
      else if ((($19)|0)==93) {
        label = 11; break;
      }
      else if ((($19)|0)==10 | (($19)|0)==13) {
        label = 17; break;
      }
      else {
      label = 20; break;
      }
      
    case 10: 
      var $20=$ls_addr;
      var $21=$seminfo_addr;
      var $tobool=(($21)|0)!=0;
      var $cond11=$tobool ? (((5246384)|0)) : (((5246308)|0));
      _lexerror($20, $cond11, 286);

    case 11: 
      var $22=$ls_addr;
      var $call13=_skip_sep($22);
      var $23=$sep_addr;
      var $cmp14=(($call13)|0)==(($23)|0);
      if ($cmp14) { label = 12; break; } else { label = 16; break; }
    case 12: 
      var $24=$ls_addr;
      var $25=$ls_addr;
      var $current17=(($25)|0);
      var $26=HEAP32[(($current17)>>2)];
      _save($24, $26);
      var $27=$ls_addr;
      var $z18=(($27+44)|0);
      var $28=HEAP32[(($z18)>>2)];
      var $n19=(($28)|0);
      var $29=HEAP32[(($n19)>>2)];
      var $dec20=((($29)-(1))|0);
      HEAP32[(($n19)>>2)]=$dec20;
      var $cmp21=(($29)>>>0) > 0;
      if ($cmp21) { label = 13; break; } else { label = 14; break; }
    case 13: 
      var $30=$ls_addr;
      var $z24=(($30+44)|0);
      var $31=HEAP32[(($z24)>>2)];
      var $p25=(($31+4)|0);
      var $32=HEAP32[(($p25)>>2)];
      var $incdec_ptr26=(($32+1)|0);
      HEAP32[(($p25)>>2)]=$incdec_ptr26;
      var $33=HEAP8[($32)];
      var $conv27=(($33)&255);
      var $cond32 = $conv27;label = 15; break;
    case 14: 
      var $34=$ls_addr;
      var $z29=(($34+44)|0);
      var $35=HEAP32[(($z29)>>2)];
      var $call30=_luaZ_fill($35);
      var $cond32 = $call30;label = 15; break;
    case 15: 
      var $cond32;
      var $36=$ls_addr;
      var $current33=(($36)|0);
      HEAP32[(($current33)>>2)]=$cond32;
      label = 31; break;
    case 16: 
      label = 30; break;
    case 17: 
      var $37=$ls_addr;
      _save($37, 10);
      var $38=$ls_addr;
      _inclinenumber($38);
      var $39=$seminfo_addr;
      var $tobool36=(($39)|0)!=0;
      if ($tobool36) { label = 19; break; } else { label = 18; break; }
    case 18: 
      var $40=$ls_addr;
      var $buff=(($40+48)|0);
      var $41=HEAP32[(($buff)>>2)];
      var $n38=(($41+4)|0);
      HEAP32[(($n38)>>2)]=0;
      label = 19; break;
    case 19: 
      label = 30; break;
    case 20: 
      var $42=$seminfo_addr;
      var $tobool40=(($42)|0)!=0;
      if ($tobool40) { label = 21; break; } else { label = 25; break; }
    case 21: 
      var $43=$ls_addr;
      var $44=$ls_addr;
      var $current42=(($44)|0);
      var $45=HEAP32[(($current42)>>2)];
      _save($43, $45);
      var $46=$ls_addr;
      var $z43=(($46+44)|0);
      var $47=HEAP32[(($z43)>>2)];
      var $n44=(($47)|0);
      var $48=HEAP32[(($n44)>>2)];
      var $dec45=((($48)-(1))|0);
      HEAP32[(($n44)>>2)]=$dec45;
      var $cmp46=(($48)>>>0) > 0;
      if ($cmp46) { label = 22; break; } else { label = 23; break; }
    case 22: 
      var $49=$ls_addr;
      var $z49=(($49+44)|0);
      var $50=HEAP32[(($z49)>>2)];
      var $p50=(($50+4)|0);
      var $51=HEAP32[(($p50)>>2)];
      var $incdec_ptr51=(($51+1)|0);
      HEAP32[(($p50)>>2)]=$incdec_ptr51;
      var $52=HEAP8[($51)];
      var $conv52=(($52)&255);
      var $cond57 = $conv52;label = 24; break;
    case 23: 
      var $53=$ls_addr;
      var $z54=(($53+44)|0);
      var $54=HEAP32[(($z54)>>2)];
      var $call55=_luaZ_fill($54);
      var $cond57 = $call55;label = 24; break;
    case 24: 
      var $cond57;
      var $55=$ls_addr;
      var $current58=(($55)|0);
      HEAP32[(($current58)>>2)]=$cond57;
      label = 29; break;
    case 25: 
      var $56=$ls_addr;
      var $z59=(($56+44)|0);
      var $57=HEAP32[(($z59)>>2)];
      var $n60=(($57)|0);
      var $58=HEAP32[(($n60)>>2)];
      var $dec61=((($58)-(1))|0);
      HEAP32[(($n60)>>2)]=$dec61;
      var $cmp62=(($58)>>>0) > 0;
      if ($cmp62) { label = 26; break; } else { label = 27; break; }
    case 26: 
      var $59=$ls_addr;
      var $z65=(($59+44)|0);
      var $60=HEAP32[(($z65)>>2)];
      var $p66=(($60+4)|0);
      var $61=HEAP32[(($p66)>>2)];
      var $incdec_ptr67=(($61+1)|0);
      HEAP32[(($p66)>>2)]=$incdec_ptr67;
      var $62=HEAP8[($61)];
      var $conv68=(($62)&255);
      var $cond73 = $conv68;label = 28; break;
    case 27: 
      var $63=$ls_addr;
      var $z70=(($63+44)|0);
      var $64=HEAP32[(($z70)>>2)];
      var $call71=_luaZ_fill($64);
      var $cond73 = $call71;label = 28; break;
    case 28: 
      var $cond73;
      var $65=$ls_addr;
      var $current74=(($65)|0);
      HEAP32[(($current74)>>2)]=$cond73;
      label = 29; break;
    case 29: 
      label = 30; break;
    case 30: 
      label = 9; break;
    case 31: 
      var $66=$seminfo_addr;
      var $tobool76=(($66)|0)!=0;
      if ($tobool76) { label = 32; break; } else { label = 33; break; }
    case 32: 
      var $67=$ls_addr;
      var $68=$ls_addr;
      var $buff78=(($68+48)|0);
      var $69=HEAP32[(($buff78)>>2)];
      var $buffer=(($69)|0);
      var $70=HEAP32[(($buffer)>>2)];
      var $71=$sep_addr;
      var $add=((($71)+(2))|0);
      var $add_ptr=(($70+$add)|0);
      var $72=$ls_addr;
      var $buff79=(($72+48)|0);
      var $73=HEAP32[(($buff79)>>2)];
      var $n80=(($73+4)|0);
      var $74=HEAP32[(($n80)>>2)];
      var $75=$sep_addr;
      var $add81=((($75)+(2))|0);
      var $mul=($add81<<1);
      var $sub=((($74)-($mul))|0);
      var $call82=_luaX_newstring($67, $add_ptr, $sub);
      var $76=$seminfo_addr;
      var $ts=$76;
      HEAP32[(($ts)>>2)]=$call82;
      label = 33; break;
    case 33: 

      Module.print(INDENT + 'Exiting: _read_long_string');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_read_long_string["X"]=1;


function _buffreplace($ls, $from, $to) {
  var label = 0;

  Module.print(INDENT + ' Entering: _buffreplace: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $ls_addr;
      var $from_addr;
      var $to_addr;
      var $n;
      var $p;
      $ls_addr=$ls;
      $from_addr=$from;
      $to_addr=$to;
      var $0=$ls_addr;
      var $buff=(($0+48)|0);
      var $1=HEAP32[(($buff)>>2)];
      var $n1=(($1+4)|0);
      var $2=HEAP32[(($n1)>>2)];
      $n=$2;
      var $3=$ls_addr;
      var $buff2=(($3+48)|0);
      var $4=HEAP32[(($buff2)>>2)];
      var $buffer=(($4)|0);
      var $5=HEAP32[(($buffer)>>2)];
      $p=$5;
      label = 3; break;
    case 3: 
      var $6=$n;
      var $dec=((($6)-(1))|0);
      $n=$dec;
      var $tobool=(($6)|0)!=0;
      if ($tobool) { label = 4; break; } else { label = 7; break; }
    case 4: 
      var $7=$n;
      var $8=$p;
      var $arrayidx=(($8+$7)|0);
      var $9=HEAP8[($arrayidx)];
      var $conv=(($9 << 24) >> 24);
      var $10=$from_addr;
      var $conv3=(($10 << 24) >> 24);
      var $cmp=(($conv)|0)==(($conv3)|0);
      if ($cmp) { label = 5; break; } else { label = 6; break; }
    case 5: 
      var $11=$to_addr;
      var $12=$n;
      var $13=$p;
      var $arrayidx5=(($13+$12)|0);
      HEAP8[($arrayidx5)]=$11;
      label = 6; break;
    case 6: 
      label = 3; break;
    case 7: 

      Module.print(INDENT + 'Exiting: _buffreplace');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _check_next($ls, $set) {
  var label = 0;

  Module.print(INDENT + ' Entering: _check_next: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $retval;
      var $ls_addr;
      var $set_addr;
      $ls_addr=$ls;
      $set_addr=$set;
      var $0=$ls_addr;
      var $current=(($0)|0);
      var $1=HEAP32[(($current)>>2)];
      var $cmp=(($1)|0)==0;
      if ($cmp) { label = 4; break; } else { label = 3; break; }
    case 3: 
      var $2=$set_addr;
      var $3=$ls_addr;
      var $current1=(($3)|0);
      var $4=HEAP32[(($current1)>>2)];
      var $call=_strchr($2, $4);
      var $tobool=(($call)|0)!=0;
      if ($tobool) { label = 5; break; } else { label = 4; break; }
    case 4: 
      $retval=0;
      label = 9; break;
    case 5: 
      var $5=$ls_addr;
      var $6=$ls_addr;
      var $current2=(($6)|0);
      var $7=HEAP32[(($current2)>>2)];
      _save($5, $7);
      var $8=$ls_addr;
      var $z=(($8+44)|0);
      var $9=HEAP32[(($z)>>2)];
      var $n=(($9)|0);
      var $10=HEAP32[(($n)>>2)];
      var $dec=((($10)-(1))|0);
      HEAP32[(($n)>>2)]=$dec;
      var $cmp3=(($10)>>>0) > 0;
      if ($cmp3) { label = 6; break; } else { label = 7; break; }
    case 6: 
      var $11=$ls_addr;
      var $z4=(($11+44)|0);
      var $12=HEAP32[(($z4)>>2)];
      var $p=(($12+4)|0);
      var $13=HEAP32[(($p)>>2)];
      var $incdec_ptr=(($13+1)|0);
      HEAP32[(($p)>>2)]=$incdec_ptr;
      var $14=HEAP8[($13)];
      var $conv=(($14)&255);
      var $cond = $conv;label = 8; break;
    case 7: 
      var $15=$ls_addr;
      var $z5=(($15+44)|0);
      var $16=HEAP32[(($z5)>>2)];
      var $call6=_luaZ_fill($16);
      var $cond = $call6;label = 8; break;
    case 8: 
      var $cond;
      var $17=$ls_addr;
      var $current7=(($17)|0);
      HEAP32[(($current7)>>2)]=$cond;
      $retval=1;
      label = 9; break;
    case 9: 
      var $18=$retval;

      Module.print(INDENT + 'Exiting: _check_next');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return $18;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_check_next["X"]=1;

function _read_numeral($ls, $seminfo) {
  var label = 0;

  Module.print(INDENT + ' Entering: _read_numeral: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $ls_addr;
      var $seminfo_addr;
      var $expo;
      var $first;
      $ls_addr=$ls;
      $seminfo_addr=$seminfo;
      $expo=((5244496)|0);
      var $0=$ls_addr;
      var $current=(($0)|0);
      var $1=HEAP32[(($current)>>2)];
      $first=$1;
      var $2=$ls_addr;
      var $3=$ls_addr;
      var $current1=(($3)|0);
      var $4=HEAP32[(($current1)>>2)];
      _save($2, $4);
      var $5=$ls_addr;
      var $z=(($5+44)|0);
      var $6=HEAP32[(($z)>>2)];
      var $n=(($6)|0);
      var $7=HEAP32[(($n)>>2)];
      var $dec=((($7)-(1))|0);
      HEAP32[(($n)>>2)]=$dec;
      var $cmp=(($7)>>>0) > 0;
      if ($cmp) { label = 3; break; } else { label = 4; break; }
    case 3: 
      var $8=$ls_addr;
      var $z2=(($8+44)|0);
      var $9=HEAP32[(($z2)>>2)];
      var $p=(($9+4)|0);
      var $10=HEAP32[(($p)>>2)];
      var $incdec_ptr=(($10+1)|0);
      HEAP32[(($p)>>2)]=$incdec_ptr;
      var $11=HEAP8[($10)];
      var $conv=(($11)&255);
      var $cond = $conv;label = 5; break;
    case 4: 
      var $12=$ls_addr;
      var $z3=(($12+44)|0);
      var $13=HEAP32[(($z3)>>2)];
      var $call=_luaZ_fill($13);
      var $cond = $call;label = 5; break;
    case 5: 
      var $cond;
      var $14=$ls_addr;
      var $current4=(($14)|0);
      HEAP32[(($current4)>>2)]=$cond;
      var $15=$first;
      var $cmp5=(($15)|0)==48;
      if ($cmp5) { label = 6; break; } else { label = 8; break; }
    case 6: 
      var $16=$ls_addr;
      var $call7=_check_next($16, ((5244352)|0));
      var $tobool=(($call7)|0)!=0;
      if ($tobool) { label = 7; break; } else { label = 8; break; }
    case 7: 
      $expo=((5244204)|0);
      label = 8; break;
    case 8: 
      label = 9; break;
    case 9: 
      var $17=$ls_addr;
      var $18=$expo;
      var $call8=_check_next($17, $18);
      var $tobool9=(($call8)|0)!=0;
      if ($tobool9) { label = 10; break; } else { label = 11; break; }
    case 10: 
      var $19=$ls_addr;
      var $call11=_check_next($19, ((5244104)|0));
      label = 11; break;
    case 11: 
      var $20=$ls_addr;
      var $current13=(($20)|0);
      var $21=HEAP32[(($current13)>>2)];
      var $add=((($21)+(1))|0);
      var $arrayidx=((5242924+$add)|0);
      var $22=HEAP8[($arrayidx)];
      var $conv14=(($22)&255);
      var $and=$conv14 & 16;
      var $tobool15=(($and)|0)!=0;
      if ($tobool15) { label = 13; break; } else { label = 12; break; }
    case 12: 
      var $23=$ls_addr;
      var $current16=(($23)|0);
      var $24=HEAP32[(($current16)>>2)];
      var $cmp17=(($24)|0)==46;
      if ($cmp17) { label = 13; break; } else { label = 17; break; }
    case 13: 
      var $25=$ls_addr;
      var $26=$ls_addr;
      var $current20=(($26)|0);
      var $27=HEAP32[(($current20)>>2)];
      _save($25, $27);
      var $28=$ls_addr;
      var $z21=(($28+44)|0);
      var $29=HEAP32[(($z21)>>2)];
      var $n22=(($29)|0);
      var $30=HEAP32[(($n22)>>2)];
      var $dec23=((($30)-(1))|0);
      HEAP32[(($n22)>>2)]=$dec23;
      var $cmp24=(($30)>>>0) > 0;
      if ($cmp24) { label = 14; break; } else { label = 15; break; }
    case 14: 
      var $31=$ls_addr;
      var $z27=(($31+44)|0);
      var $32=HEAP32[(($z27)>>2)];
      var $p28=(($32+4)|0);
      var $33=HEAP32[(($p28)>>2)];
      var $incdec_ptr29=(($33+1)|0);
      HEAP32[(($p28)>>2)]=$incdec_ptr29;
      var $34=HEAP8[($33)];
      var $conv30=(($34)&255);
      var $cond35 = $conv30;label = 16; break;
    case 15: 
      var $35=$ls_addr;
      var $z32=(($35+44)|0);
      var $36=HEAP32[(($z32)>>2)];
      var $call33=_luaZ_fill($36);
      var $cond35 = $call33;label = 16; break;
    case 16: 
      var $cond35;
      var $37=$ls_addr;
      var $current36=(($37)|0);
      HEAP32[(($current36)>>2)]=$cond35;
      label = 18; break;
    case 17: 
      label = 19; break;
    case 18: 
      label = 9; break;
    case 19: 
      var $38=$ls_addr;
      _save($38, 0);
      var $39=$ls_addr;
      var $40=$ls_addr;
      var $decpoint=(($40+64)|0);
      var $41=HEAP8[($decpoint)];
      _buffreplace($39, 46, $41);
      var $42=$ls_addr;
      var $buff=(($42+48)|0);
      var $43=HEAP32[(($buff)>>2)];
      var $buffer=(($43)|0);
      var $44=HEAP32[(($buffer)>>2)];
      var $45=$ls_addr;
      var $buff38=(($45+48)|0);
      var $46=HEAP32[(($buff38)>>2)];
      var $n39=(($46+4)|0);
      var $47=HEAP32[(($n39)>>2)];
      var $sub=((($47)-(1))|0);
      var $48=$seminfo_addr;
      var $r=$48;
      var $call40=_luaO_str2d($44, $sub, $r);
      var $tobool41=(($call40)|0)!=0;
      if ($tobool41) { label = 21; break; } else { label = 20; break; }
    case 20: 
      var $49=$ls_addr;
      var $50=$seminfo_addr;
      _trydecpoint($49, $50);
      label = 21; break;
    case 21: 

      Module.print(INDENT + 'Exiting: _read_numeral');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_read_numeral["X"]=1;

function _read_string($ls, $del, $seminfo) {
  var label = 0;

  Module.print(INDENT + ' Entering: _read_string: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $ls_addr;
      var $del_addr;
      var $seminfo_addr;
      var $c;
      $ls_addr=$ls;
      $del_addr=$del;
      $seminfo_addr=$seminfo;
      var $0=$ls_addr;
      var $1=$ls_addr;
      var $current=(($1)|0);
      var $2=HEAP32[(($current)>>2)];
      _save($0, $2);
      var $3=$ls_addr;
      var $z=(($3+44)|0);
      var $4=HEAP32[(($z)>>2)];
      var $n=(($4)|0);
      var $5=HEAP32[(($n)>>2)];
      var $dec=((($5)-(1))|0);
      HEAP32[(($n)>>2)]=$dec;
      var $cmp=(($5)>>>0) > 0;
      if ($cmp) { label = 3; break; } else { label = 4; break; }
    case 3: 
      var $6=$ls_addr;
      var $z1=(($6+44)|0);
      var $7=HEAP32[(($z1)>>2)];
      var $p=(($7+4)|0);
      var $8=HEAP32[(($p)>>2)];
      var $incdec_ptr=(($8+1)|0);
      HEAP32[(($p)>>2)]=$incdec_ptr;
      var $9=HEAP8[($8)];
      var $conv=(($9)&255);
      var $cond = $conv;label = 5; break;
    case 4: 
      var $10=$ls_addr;
      var $z2=(($10+44)|0);
      var $11=HEAP32[(($z2)>>2)];
      var $call=_luaZ_fill($11);
      var $cond = $call;label = 5; break;
    case 5: 
      var $cond;
      var $12=$ls_addr;
      var $current3=(($12)|0);
      HEAP32[(($current3)>>2)]=$cond;
      label = 6; break;
    case 6: 
      var $13=$ls_addr;
      var $current4=(($13)|0);
      var $14=HEAP32[(($current4)>>2)];
      var $15=$del_addr;
      var $cmp5=(($14)|0)!=(($15)|0);
      if ($cmp5) { label = 7; break; } else { label = 53; break; }
    case 7: 
      var $16=$ls_addr;
      var $current7=(($16)|0);
      var $17=HEAP32[(($current7)>>2)];
      if ((($17)|0)==-1) {
        label = 8; break;
      }
      else if ((($17)|0)==10 | (($17)|0)==13) {
        label = 9; break;
      }
      else if ((($17)|0)==92) {
        label = 10; break;
      }
      else {
      label = 48; break;
      }
      
    case 8: 
      var $18=$ls_addr;
      _lexerror($18, ((5246776)|0), 286);

    case 9: 
      var $19=$ls_addr;
      _lexerror($19, ((5246776)|0), 289);

    case 10: 
      var $20=$ls_addr;
      var $z10=(($20+44)|0);
      var $21=HEAP32[(($z10)>>2)];
      var $n11=(($21)|0);
      var $22=HEAP32[(($n11)>>2)];
      var $dec12=((($22)-(1))|0);
      HEAP32[(($n11)>>2)]=$dec12;
      var $cmp13=(($22)>>>0) > 0;
      if ($cmp13) { label = 11; break; } else { label = 12; break; }
    case 11: 
      var $23=$ls_addr;
      var $z16=(($23+44)|0);
      var $24=HEAP32[(($z16)>>2)];
      var $p17=(($24+4)|0);
      var $25=HEAP32[(($p17)>>2)];
      var $incdec_ptr18=(($25+1)|0);
      HEAP32[(($p17)>>2)]=$incdec_ptr18;
      var $26=HEAP8[($25)];
      var $conv19=(($26)&255);
      var $cond24 = $conv19;label = 13; break;
    case 12: 
      var $27=$ls_addr;
      var $z21=(($27+44)|0);
      var $28=HEAP32[(($z21)>>2)];
      var $call22=_luaZ_fill($28);
      var $cond24 = $call22;label = 13; break;
    case 13: 
      var $cond24;
      var $29=$ls_addr;
      var $current25=(($29)|0);
      HEAP32[(($current25)>>2)]=$cond24;
      var $30=$ls_addr;
      var $current26=(($30)|0);
      var $31=HEAP32[(($current26)>>2)];
      if ((($31)|0)==97) {
        label = 14; break;
      }
      else if ((($31)|0)==98) {
        label = 15; break;
      }
      else if ((($31)|0)==102) {
        label = 16; break;
      }
      else if ((($31)|0)==110) {
        label = 17; break;
      }
      else if ((($31)|0)==114) {
        label = 18; break;
      }
      else if ((($31)|0)==116) {
        label = 19; break;
      }
      else if ((($31)|0)==118) {
        label = 20; break;
      }
      else if ((($31)|0)==120) {
        label = 21; break;
      }
      else if ((($31)|0)==10 | (($31)|0)==13) {
        label = 22; break;
      }
      else if ((($31)|0)==92 | (($31)|0)==34 | (($31)|0)==39) {
        label = 23; break;
      }
      else if ((($31)|0)==-1) {
        label = 24; break;
      }
      else if ((($31)|0)==122) {
        label = 25; break;
      }
      else {
      label = 39; break;
      }
      
    case 14: 
      $c=7;
      label = 42; break;
    case 15: 
      $c=8;
      label = 42; break;
    case 16: 
      $c=12;
      label = 42; break;
    case 17: 
      $c=10;
      label = 42; break;
    case 18: 
      $c=13;
      label = 42; break;
    case 19: 
      $c=9;
      label = 42; break;
    case 20: 
      $c=11;
      label = 42; break;
    case 21: 
      var $32=$ls_addr;
      var $call35=_readhexaesc($32);
      $c=$call35;
      label = 42; break;
    case 22: 
      var $33=$ls_addr;
      _inclinenumber($33);
      $c=10;
      label = 46; break;
    case 23: 
      var $34=$ls_addr;
      var $current38=(($34)|0);
      var $35=HEAP32[(($current38)>>2)];
      $c=$35;
      label = 42; break;
    case 24: 
      label = 47; break;
    case 25: 
      var $36=$ls_addr;
      var $z41=(($36+44)|0);
      var $37=HEAP32[(($z41)>>2)];
      var $n42=(($37)|0);
      var $38=HEAP32[(($n42)>>2)];
      var $dec43=((($38)-(1))|0);
      HEAP32[(($n42)>>2)]=$dec43;
      var $cmp44=(($38)>>>0) > 0;
      if ($cmp44) { label = 26; break; } else { label = 27; break; }
    case 26: 
      var $39=$ls_addr;
      var $z47=(($39+44)|0);
      var $40=HEAP32[(($z47)>>2)];
      var $p48=(($40+4)|0);
      var $41=HEAP32[(($p48)>>2)];
      var $incdec_ptr49=(($41+1)|0);
      HEAP32[(($p48)>>2)]=$incdec_ptr49;
      var $42=HEAP8[($41)];
      var $conv50=(($42)&255);
      var $cond55 = $conv50;label = 28; break;
    case 27: 
      var $43=$ls_addr;
      var $z52=(($43+44)|0);
      var $44=HEAP32[(($z52)>>2)];
      var $call53=_luaZ_fill($44);
      var $cond55 = $call53;label = 28; break;
    case 28: 
      var $cond55;
      var $45=$ls_addr;
      var $current56=(($45)|0);
      HEAP32[(($current56)>>2)]=$cond55;
      label = 29; break;
    case 29: 
      var $46=$ls_addr;
      var $current58=(($46)|0);
      var $47=HEAP32[(($current58)>>2)];
      var $add=((($47)+(1))|0);
      var $arrayidx=((5242924+$add)|0);
      var $48=HEAP8[($arrayidx)];
      var $conv59=(($48)&255);
      var $and=$conv59 & 8;
      var $tobool=(($and)|0)!=0;
      if ($tobool) { label = 30; break; } else { label = 38; break; }
    case 30: 
      var $49=$ls_addr;
      var $current61=(($49)|0);
      var $50=HEAP32[(($current61)>>2)];
      var $cmp62=(($50)|0)==10;
      if ($cmp62) { label = 32; break; } else { label = 31; break; }
    case 31: 
      var $51=$ls_addr;
      var $current64=(($51)|0);
      var $52=HEAP32[(($current64)>>2)];
      var $cmp65=(($52)|0)==13;
      if ($cmp65) { label = 32; break; } else { label = 33; break; }
    case 32: 
      var $53=$ls_addr;
      _inclinenumber($53);
      label = 37; break;
    case 33: 
      var $54=$ls_addr;
      var $z67=(($54+44)|0);
      var $55=HEAP32[(($z67)>>2)];
      var $n68=(($55)|0);
      var $56=HEAP32[(($n68)>>2)];
      var $dec69=((($56)-(1))|0);
      HEAP32[(($n68)>>2)]=$dec69;
      var $cmp70=(($56)>>>0) > 0;
      if ($cmp70) { label = 34; break; } else { label = 35; break; }
    case 34: 
      var $57=$ls_addr;
      var $z73=(($57+44)|0);
      var $58=HEAP32[(($z73)>>2)];
      var $p74=(($58+4)|0);
      var $59=HEAP32[(($p74)>>2)];
      var $incdec_ptr75=(($59+1)|0);
      HEAP32[(($p74)>>2)]=$incdec_ptr75;
      var $60=HEAP8[($59)];
      var $conv76=(($60)&255);
      var $cond81 = $conv76;label = 36; break;
    case 35: 
      var $61=$ls_addr;
      var $z78=(($61+44)|0);
      var $62=HEAP32[(($z78)>>2)];
      var $call79=_luaZ_fill($62);
      var $cond81 = $call79;label = 36; break;
    case 36: 
      var $cond81;
      var $63=$ls_addr;
      var $current82=(($63)|0);
      HEAP32[(($current82)>>2)]=$cond81;
      label = 37; break;
    case 37: 
      label = 29; break;
    case 38: 
      label = 47; break;
    case 39: 
      var $64=$ls_addr;
      var $current83=(($64)|0);
      var $65=HEAP32[(($current83)>>2)];
      var $add84=((($65)+(1))|0);
      var $arrayidx85=((5242924+$add84)|0);
      var $66=HEAP8[($arrayidx85)];
      var $conv86=(($66)&255);
      var $and87=$conv86 & 2;
      var $tobool88=(($and87)|0)!=0;
      if ($tobool88) { label = 41; break; } else { label = 40; break; }
    case 40: 
      var $67=$ls_addr;
      var $68=$ls_addr;
      var $current90=(($68)|0);
      _escerror($67, $current90, 1, ((5246660)|0));
      label = 41; break;
    case 41: 
      var $69=$ls_addr;
      var $call92=_readdecesc($69);
      $c=$call92;
      label = 46; break;
    case 42: 
      var $70=$ls_addr;
      var $z93=(($70+44)|0);
      var $71=HEAP32[(($z93)>>2)];
      var $n94=(($71)|0);
      var $72=HEAP32[(($n94)>>2)];
      var $dec95=((($72)-(1))|0);
      HEAP32[(($n94)>>2)]=$dec95;
      var $cmp96=(($72)>>>0) > 0;
      if ($cmp96) { label = 43; break; } else { label = 44; break; }
    case 43: 
      var $73=$ls_addr;
      var $z99=(($73+44)|0);
      var $74=HEAP32[(($z99)>>2)];
      var $p100=(($74+4)|0);
      var $75=HEAP32[(($p100)>>2)];
      var $incdec_ptr101=(($75+1)|0);
      HEAP32[(($p100)>>2)]=$incdec_ptr101;
      var $76=HEAP8[($75)];
      var $conv102=(($76)&255);
      var $cond107 = $conv102;label = 45; break;
    case 44: 
      var $77=$ls_addr;
      var $z104=(($77+44)|0);
      var $78=HEAP32[(($z104)>>2)];
      var $call105=_luaZ_fill($78);
      var $cond107 = $call105;label = 45; break;
    case 45: 
      var $cond107;
      var $79=$ls_addr;
      var $current108=(($79)|0);
      HEAP32[(($current108)>>2)]=$cond107;
      label = 46; break;
    case 46: 
      var $80=$ls_addr;
      var $81=$c;
      _save($80, $81);
      label = 47; break;
    case 47: 
      label = 52; break;
    case 48: 
      var $82=$ls_addr;
      var $83=$ls_addr;
      var $current110=(($83)|0);
      var $84=HEAP32[(($current110)>>2)];
      _save($82, $84);
      var $85=$ls_addr;
      var $z111=(($85+44)|0);
      var $86=HEAP32[(($z111)>>2)];
      var $n112=(($86)|0);
      var $87=HEAP32[(($n112)>>2)];
      var $dec113=((($87)-(1))|0);
      HEAP32[(($n112)>>2)]=$dec113;
      var $cmp114=(($87)>>>0) > 0;
      if ($cmp114) { label = 49; break; } else { label = 50; break; }
    case 49: 
      var $88=$ls_addr;
      var $z117=(($88+44)|0);
      var $89=HEAP32[(($z117)>>2)];
      var $p118=(($89+4)|0);
      var $90=HEAP32[(($p118)>>2)];
      var $incdec_ptr119=(($90+1)|0);
      HEAP32[(($p118)>>2)]=$incdec_ptr119;
      var $91=HEAP8[($90)];
      var $conv120=(($91)&255);
      var $cond125 = $conv120;label = 51; break;
    case 50: 
      var $92=$ls_addr;
      var $z122=(($92+44)|0);
      var $93=HEAP32[(($z122)>>2)];
      var $call123=_luaZ_fill($93);
      var $cond125 = $call123;label = 51; break;
    case 51: 
      var $cond125;
      var $94=$ls_addr;
      var $current126=(($94)|0);
      HEAP32[(($current126)>>2)]=$cond125;
      label = 52; break;
    case 52: 
      label = 6; break;
    case 53: 
      var $95=$ls_addr;
      var $96=$ls_addr;
      var $current128=(($96)|0);
      var $97=HEAP32[(($current128)>>2)];
      _save($95, $97);
      var $98=$ls_addr;
      var $z129=(($98+44)|0);
      var $99=HEAP32[(($z129)>>2)];
      var $n130=(($99)|0);
      var $100=HEAP32[(($n130)>>2)];
      var $dec131=((($100)-(1))|0);
      HEAP32[(($n130)>>2)]=$dec131;
      var $cmp132=(($100)>>>0) > 0;
      if ($cmp132) { label = 54; break; } else { label = 55; break; }
    case 54: 
      var $101=$ls_addr;
      var $z135=(($101+44)|0);
      var $102=HEAP32[(($z135)>>2)];
      var $p136=(($102+4)|0);
      var $103=HEAP32[(($p136)>>2)];
      var $incdec_ptr137=(($103+1)|0);
      HEAP32[(($p136)>>2)]=$incdec_ptr137;
      var $104=HEAP8[($103)];
      var $conv138=(($104)&255);
      var $cond143 = $conv138;label = 56; break;
    case 55: 
      var $105=$ls_addr;
      var $z140=(($105+44)|0);
      var $106=HEAP32[(($z140)>>2)];
      var $call141=_luaZ_fill($106);
      var $cond143 = $call141;label = 56; break;
    case 56: 
      var $cond143;
      var $107=$ls_addr;
      var $current144=(($107)|0);
      HEAP32[(($current144)>>2)]=$cond143;
      var $108=$ls_addr;
      var $109=$ls_addr;
      var $buff=(($109+48)|0);
      var $110=HEAP32[(($buff)>>2)];
      var $buffer=(($110)|0);
      var $111=HEAP32[(($buffer)>>2)];
      var $add_ptr=(($111+1)|0);
      var $112=$ls_addr;
      var $buff145=(($112+48)|0);
      var $113=HEAP32[(($buff145)>>2)];
      var $n146=(($113+4)|0);
      var $114=HEAP32[(($n146)>>2)];
      var $sub=((($114)-(2))|0);
      var $call147=_luaX_newstring($108, $add_ptr, $sub);
      var $115=$seminfo_addr;
      var $ts=$115;
      HEAP32[(($ts)>>2)]=$call147;

      Module.print(INDENT + 'Exiting: _read_string');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_read_string["X"]=1;

function _save($ls, $c) {
  var label = 0;

  Module.print(INDENT + ' Entering: _save: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $ls_addr;
      var $c_addr;
      var $b;
      var $newsize;
      $ls_addr=$ls;
      $c_addr=$c;
      var $0=$ls_addr;
      var $buff=(($0+48)|0);
      var $1=HEAP32[(($buff)>>2)];
      $b=$1;
      var $2=$b;
      var $n=(($2+4)|0);
      var $3=HEAP32[(($n)>>2)];
      var $add=((($3)+(1))|0);
      var $4=$b;
      var $buffsize=(($4+8)|0);
      var $5=HEAP32[(($buffsize)>>2)];
      var $cmp=(($add)>>>0) > (($5)>>>0);
      if ($cmp) { label = 3; break; } else { label = 9; break; }
    case 3: 
      var $6=$b;
      var $buffsize1=(($6+8)|0);
      var $7=HEAP32[(($buffsize1)>>2)];
      var $cmp2=(($7)>>>0) >= 2147483646;
      if ($cmp2) { label = 4; break; } else { label = 5; break; }
    case 4: 
      var $8=$ls_addr;
      _lexerror($8, ((5246884)|0), 0);

    case 5: 
      var $9=$b;
      var $buffsize4=(($9+8)|0);
      var $10=HEAP32[(($buffsize4)>>2)];
      var $mul=($10<<1);
      $newsize=$mul;
      var $11=$newsize;
      var $add5=((($11)+(1))|0);
      var $cmp6=(($add5)>>>0) > 4294967293;
      if ($cmp6) { label = 6; break; } else { label = 7; break; }
    case 6: 
      var $12=$ls_addr;
      var $L=(($12+40)|0);
      var $13=HEAP32[(($L)>>2)];
      _luaM_toobig($13);

      label = 8; break;
    case 7: 
      var $15=$ls_addr;
      var $L7=(($15+40)|0);
      var $16=HEAP32[(($L7)>>2)];
      var $17=$b;
      var $buffer=(($17)|0);
      var $18=HEAP32[(($buffer)>>2)];
      var $19=$b;
      var $buffsize8=(($19+8)|0);
      var $20=HEAP32[(($buffsize8)>>2)];
      var $mul9=$20;
      var $21=$newsize;
      var $mul10=$21;
      var $call=_luaM_realloc_($16, $18, $mul9, $mul10);
      var $cond = $call;label = 8; break;
    case 8: 
      var $cond;
      var $22=$b;
      var $buffer11=(($22)|0);
      HEAP32[(($buffer11)>>2)]=$cond;
      var $23=$newsize;
      var $24=$b;
      var $buffsize12=(($24+8)|0);
      HEAP32[(($buffsize12)>>2)]=$23;
      label = 9; break;
    case 9: 
      var $25=$c_addr;
      var $conv=(($25) & 255);
      var $26=$b;
      var $n14=(($26+4)|0);
      var $27=HEAP32[(($n14)>>2)];
      var $inc=((($27)+(1))|0);
      HEAP32[(($n14)>>2)]=$inc;
      var $28=$b;
      var $buffer15=(($28)|0);
      var $29=HEAP32[(($buffer15)>>2)];
      var $arrayidx=(($29+$27)|0);
      HEAP8[($arrayidx)]=$conv;

      Module.print(INDENT + 'Exiting: _save');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_save["X"]=1;

function _trydecpoint($ls, $seminfo) {
  var label = 0;

  Module.print(INDENT + ' Entering: _trydecpoint: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $ls_addr;
      var $seminfo_addr;
      var $old;
      $ls_addr=$ls;
      $seminfo_addr=$seminfo;
      var $0=$ls_addr;
      var $decpoint=(($0+64)|0);
      var $1=HEAP8[($decpoint)];
      $old=$1;
      var $call=_localeconv();
      var $decimal_point=(($call)|0);
      var $2=HEAP32[(($decimal_point)>>2)];
      var $arrayidx=(($2)|0);
      var $3=HEAP8[($arrayidx)];
      var $4=$ls_addr;
      var $decpoint1=(($4+64)|0);
      HEAP8[($decpoint1)]=$3;
      var $5=$ls_addr;
      var $6=$old;
      var $7=$ls_addr;
      var $decpoint2=(($7+64)|0);
      var $8=HEAP8[($decpoint2)];
      _buffreplace($5, $6, $8);
      var $9=$ls_addr;
      var $buff=(($9+48)|0);
      var $10=HEAP32[(($buff)>>2)];
      var $buffer=(($10)|0);
      var $11=HEAP32[(($buffer)>>2)];
      var $12=$ls_addr;
      var $buff3=(($12+48)|0);
      var $13=HEAP32[(($buff3)>>2)];
      var $n=(($13+4)|0);
      var $14=HEAP32[(($n)>>2)];
      var $sub=((($14)-(1))|0);
      var $15=$seminfo_addr;
      var $r=$15;
      var $call4=_luaO_str2d($11, $sub, $r);
      var $tobool=(($call4)|0)!=0;
      if ($tobool) { label = 4; break; } else { label = 3; break; }
    case 3: 
      var $16=$ls_addr;
      var $17=$ls_addr;
      var $decpoint5=(($17+64)|0);
      var $18=HEAP8[($decpoint5)];
      _buffreplace($16, $18, 46);
      var $19=$ls_addr;
      _lexerror($19, ((5247092)|0), 287);

    case 4: 

      Module.print(INDENT + 'Exiting: _trydecpoint');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _luaO_int2fb($x) {
  var label = 0;

  Module.print(INDENT + ' Entering: _luaO_int2fb: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $retval;
      var $x_addr;
      var $e;
      $x_addr=$x;
      $e=0;
      var $0=$x_addr;
      var $cmp=(($0)>>>0) < 8;
      if ($cmp) { label = 3; break; } else { label = 4; break; }
    case 3: 
      var $1=$x_addr;
      $retval=$1;
      label = 8; break;
    case 4: 
      label = 5; break;
    case 5: 
      var $2=$x_addr;
      var $cmp1=(($2)>>>0) >= 16;
      if ($cmp1) { label = 6; break; } else { label = 7; break; }
    case 6: 
      var $3=$x_addr;
      var $add=((($3)+(1))|0);
      var $shr=$add >>> 1;
      $x_addr=$shr;
      var $4=$e;
      var $inc=((($4)+(1))|0);
      $e=$inc;
      label = 5; break;
    case 7: 
      var $5=$e;
      var $add2=((($5)+(1))|0);
      var $shl=$add2 << 3;
      var $6=$x_addr;
      var $sub=((($6)-(8))|0);
      var $or=$shl | $sub;
      $retval=$or;
      label = 8; break;
    case 8: 
      var $7=$retval;

      Module.print(INDENT + 'Exiting: _luaO_int2fb');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return $7;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _luaO_fb2int($x) {
  var label = 0;

  Module.print(INDENT + ' Entering: _luaO_fb2int: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $retval;
      var $x_addr;
      var $e;
      $x_addr=$x;
      var $0=$x_addr;
      var $shr=$0 >> 3;
      var $and=$shr & 31;
      $e=$and;
      var $1=$e;
      var $cmp=(($1)|0)==0;
      if ($cmp) { label = 3; break; } else { label = 4; break; }
    case 3: 
      var $2=$x_addr;
      $retval=$2;
      label = 5; break;
    case 4: 
      var $3=$x_addr;
      var $and1=$3 & 7;
      var $add=((($and1)+(8))|0);
      var $4=$e;
      var $sub=((($4)-(1))|0);
      var $shl=$add << $sub;
      $retval=$shl;
      label = 5; break;
    case 5: 
      var $5=$retval;

      Module.print(INDENT + 'Exiting: _luaO_fb2int');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return $5;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _luaO_ceillog2($x) {
  var label = 0;

  Module.print(INDENT + ' Entering: _luaO_ceillog2: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $x_addr;
      var $l;
      $x_addr=$x;
      $l=0;
      var $0=$x_addr;
      var $dec=((($0)-(1))|0);
      $x_addr=$dec;
      label = 3; break;
    case 3: 
      var $1=$x_addr;
      var $cmp=(($1)>>>0) >= 256;
      if ($cmp) { label = 4; break; } else { label = 5; break; }
    case 4: 
      var $2=$l;
      var $add=((($2)+(8))|0);
      $l=$add;
      var $3=$x_addr;
      var $shr=$3 >>> 8;
      $x_addr=$shr;
      label = 3; break;
    case 5: 
      var $4=$l;
      var $5=$x_addr;
      var $arrayidx=((5243796+$5)|0);
      var $6=HEAP8[($arrayidx)];
      var $conv=(($6)&255);
      var $add1=((($4)+($conv))|0);

      Module.print(INDENT + 'Exiting: _luaO_ceillog2');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return $add1;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _luaO_hexavalue($c) {
  var label = 0;

  Module.print(INDENT + ' Entering: _luaO_hexavalue: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $retval;
      var $c_addr;
      $c_addr=$c;
      var $0=$c_addr;
      var $add=((($0)+(1))|0);
      var $arrayidx=((5242924+$add)|0);
      var $1=HEAP8[($arrayidx)];
      var $conv=(($1)&255);
      var $and=$conv & 2;
      var $tobool=(($and)|0)!=0;
      if ($tobool) { label = 3; break; } else { label = 4; break; }
    case 3: 
      var $2=$c_addr;
      var $sub=((($2)-(48))|0);
      $retval=$sub;
      label = 5; break;
    case 4: 
      var $3=$c_addr;
      var $or=$3 | 32;
      var $sub1=((($or)-(97))|0);
      var $add2=((($sub1)+(10))|0);
      $retval=$add2;
      label = 5; break;
    case 5: 
      var $4=$retval;

      Module.print(INDENT + 'Exiting: _luaO_hexavalue');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return $4;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _readhexaesc($ls) {
  var label = 0;
  var __stackBase__  = STACKTOP; STACKTOP = (STACKTOP + 12)|0; _memset(__stackBase__, 0, 12);
  Module.print(INDENT + ' Entering: _readhexaesc: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $ls_addr;
      var $c=__stackBase__;
      var $i;
      var $r;
      $ls_addr=$ls;
      $r=0;
      var $arrayidx=(($c)|0);
      HEAP32[(($arrayidx)>>2)]=120;
      $i=1;
      label = 3; break;
    case 3: 
      var $0=$i;
      var $cmp=(($0)|0) < 3;
      if ($cmp) { label = 4; break; } else { label = 11; break; }
    case 4: 
      var $1=$ls_addr;
      var $z=(($1+44)|0);
      var $2=HEAP32[(($z)>>2)];
      var $n=(($2)|0);
      var $3=HEAP32[(($n)>>2)];
      var $dec=((($3)-(1))|0);
      HEAP32[(($n)>>2)]=$dec;
      var $cmp1=(($3)>>>0) > 0;
      if ($cmp1) { label = 5; break; } else { label = 6; break; }
    case 5: 
      var $4=$ls_addr;
      var $z2=(($4+44)|0);
      var $5=HEAP32[(($z2)>>2)];
      var $p=(($5+4)|0);
      var $6=HEAP32[(($p)>>2)];
      var $incdec_ptr=(($6+1)|0);
      HEAP32[(($p)>>2)]=$incdec_ptr;
      var $7=HEAP8[($6)];
      var $conv=(($7)&255);
      var $cond = $conv;label = 7; break;
    case 6: 
      var $8=$ls_addr;
      var $z3=(($8+44)|0);
      var $9=HEAP32[(($z3)>>2)];
      var $call=_luaZ_fill($9);
      var $cond = $call;label = 7; break;
    case 7: 
      var $cond;
      var $10=$ls_addr;
      var $current=(($10)|0);
      HEAP32[(($current)>>2)]=$cond;
      var $11=$i;
      var $arrayidx4=(($c+($11<<2))|0);
      HEAP32[(($arrayidx4)>>2)]=$cond;
      var $12=$i;
      var $arrayidx5=(($c+($12<<2))|0);
      var $13=HEAP32[(($arrayidx5)>>2)];
      var $add=((($13)+(1))|0);
      var $arrayidx6=((5242924+$add)|0);
      var $14=HEAP8[($arrayidx6)];
      var $conv7=(($14)&255);
      var $and=$conv7 & 16;
      var $tobool=(($and)|0)!=0;
      if ($tobool) { label = 9; break; } else { label = 8; break; }
    case 8: 
      var $15=$ls_addr;
      var $arraydecay=(($c)|0);
      var $16=$i;
      var $add8=((($16)+(1))|0);
      _escerror($15, $arraydecay, $add8, ((5246528)|0));
      label = 9; break;
    case 9: 
      var $17=$r;
      var $shl=$17 << 4;
      var $18=$i;
      var $arrayidx9=(($c+($18<<2))|0);
      var $19=HEAP32[(($arrayidx9)>>2)];
      var $call10=_luaO_hexavalue($19);
      var $add11=((($shl)+($call10))|0);
      $r=$add11;
      label = 10; break;
    case 10: 
      var $20=$i;
      var $inc=((($20)+(1))|0);
      $i=$inc;
      label = 3; break;
    case 11: 
      var $21=$r;
      STACKTOP = __stackBase__;
      Module.print(INDENT + 'Exiting: _readhexaesc');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return $21;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_readhexaesc["X"]=1;

function _readdecesc($ls) {
  var label = 0;
  var __stackBase__  = STACKTOP; STACKTOP = (STACKTOP + 12)|0; _memset(__stackBase__, 0, 12);
  Module.print(INDENT + ' Entering: _readdecesc: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $ls_addr;
      var $c=__stackBase__;
      var $i;
      var $r;
      $ls_addr=$ls;
      $r=0;
      $i=0;
      label = 3; break;
    case 3: 
      var $0=$i;
      var $cmp=(($0)|0) < 3;
      if ($cmp) { label = 4; break; } else { var $4 = 0;label = 5; break; }
    case 4: 
      var $1=$ls_addr;
      var $current=(($1)|0);
      var $2=HEAP32[(($current)>>2)];
      var $add=((($2)+(1))|0);
      var $arrayidx=((5242924+$add)|0);
      var $3=HEAP8[($arrayidx)];
      var $conv=(($3)&255);
      var $and=$conv & 2;
      var $tobool=(($and)|0)!=0;
      var $4 = $tobool;label = 5; break;
    case 5: 
      var $4;
      if ($4) { label = 6; break; } else { label = 11; break; }
    case 6: 
      var $5=$ls_addr;
      var $current1=(($5)|0);
      var $6=HEAP32[(($current1)>>2)];
      var $7=$i;
      var $arrayidx2=(($c+($7<<2))|0);
      HEAP32[(($arrayidx2)>>2)]=$6;
      var $8=$r;
      var $mul=((($8)*(10))&-1);
      var $9=$i;
      var $arrayidx3=(($c+($9<<2))|0);
      var $10=HEAP32[(($arrayidx3)>>2)];
      var $add4=((($mul)+($10))|0);
      var $sub=((($add4)-(48))|0);
      $r=$sub;
      var $11=$ls_addr;
      var $z=(($11+44)|0);
      var $12=HEAP32[(($z)>>2)];
      var $n=(($12)|0);
      var $13=HEAP32[(($n)>>2)];
      var $dec=((($13)-(1))|0);
      HEAP32[(($n)>>2)]=$dec;
      var $cmp5=(($13)>>>0) > 0;
      if ($cmp5) { label = 7; break; } else { label = 8; break; }
    case 7: 
      var $14=$ls_addr;
      var $z7=(($14+44)|0);
      var $15=HEAP32[(($z7)>>2)];
      var $p=(($15+4)|0);
      var $16=HEAP32[(($p)>>2)];
      var $incdec_ptr=(($16+1)|0);
      HEAP32[(($p)>>2)]=$incdec_ptr;
      var $17=HEAP8[($16)];
      var $conv8=(($17)&255);
      var $cond = $conv8;label = 9; break;
    case 8: 
      var $18=$ls_addr;
      var $z9=(($18+44)|0);
      var $19=HEAP32[(($z9)>>2)];
      var $call=_luaZ_fill($19);
      var $cond = $call;label = 9; break;
    case 9: 
      var $cond;
      var $20=$ls_addr;
      var $current10=(($20)|0);
      HEAP32[(($current10)>>2)]=$cond;
      label = 10; break;
    case 10: 
      var $21=$i;
      var $inc=((($21)+(1))|0);
      $i=$inc;
      label = 3; break;
    case 11: 
      var $22=$r;
      var $cmp11=(($22)|0) > 255;
      if ($cmp11) { label = 12; break; } else { label = 13; break; }
    case 12: 
      var $23=$ls_addr;
      var $arraydecay=(($c)|0);
      var $24=$i;
      _escerror($23, $arraydecay, $24, ((5246592)|0));
      label = 13; break;
    case 13: 
      var $25=$r;
      STACKTOP = __stackBase__;
      Module.print(INDENT + 'Exiting: _readdecesc');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return $25;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_readdecesc["X"]=1;

function _txtToken($ls, $token) {
  var label = 0;
  var __stackBase__  = STACKTOP; _memset(__stackBase__, 0, 0);
  Module.print(INDENT + ' Entering: _txtToken: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $retval;
      var $ls_addr;
      var $token_addr;
      $ls_addr=$ls;
      $token_addr=$token;
      var $0=$token_addr;
      if ((($0)|0)==288 | (($0)|0)==289 | (($0)|0)==287) {
        label = 3; break;
      }
      else {
      label = 4; break;
      }
      
    case 3: 
      var $1=$ls_addr;
      _save($1, 0);
      var $2=$ls_addr;
      var $L=(($2+40)|0);
      var $3=HEAP32[(($L)>>2)];
      var $4=$ls_addr;
      var $buff=(($4+48)|0);
      var $5=HEAP32[(($buff)>>2)];
      var $buffer=(($5)|0);
      var $6=HEAP32[(($buffer)>>2)];
      var $call=_luaO_pushfstring($3, ((5245468)|0), (tempInt=STACKTOP,_memset(STACKTOP, 0, 4),STACKTOP = (STACKTOP + 4)|0,HEAP32[((tempInt)>>2)]=$6,tempInt));
      $retval=$call;
      label = 5; break;
    case 4: 
      var $7=$ls_addr;
      var $8=$token_addr;
      var $call1=_luaX_token2str($7, $8);
      $retval=$call1;
      label = 5; break;
    case 5: 
      var $9=$retval;
      STACKTOP = __stackBase__;
      Module.print(INDENT + 'Exiting: _txtToken');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return $9;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _luaO_arith($op, $v1, $v2) {
  var label = 0;

  Module.print(INDENT + ' Entering: _luaO_arith: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $retval;
      var $op_addr;
      var $v1_addr;
      var $v2_addr;
      $op_addr=$op;
      $v1_addr=$v1;
      $v2_addr=$v2;
      var $0=$op_addr;
      if ((($0)|0)==0) {
        label = 3; break;
      }
      else if ((($0)|0)==1) {
        label = 4; break;
      }
      else if ((($0)|0)==2) {
        label = 5; break;
      }
      else if ((($0)|0)==3) {
        label = 6; break;
      }
      else if ((($0)|0)==4) {
        label = 7; break;
      }
      else if ((($0)|0)==5) {
        label = 8; break;
      }
      else if ((($0)|0)==6) {
        label = 9; break;
      }
      else {
      label = 10; break;
      }
      
    case 3: 
      var $1=$v1_addr;
      var $2=$v2_addr;
      var $add=($1)+($2);
      $retval=$add;
      label = 11; break;
    case 4: 
      var $3=$v1_addr;
      var $4=$v2_addr;
      var $sub=($3)-($4);
      $retval=$sub;
      label = 11; break;
    case 5: 
      var $5=$v1_addr;
      var $6=$v2_addr;
      var $mul=($5)*($6);
      $retval=$mul;
      label = 11; break;
    case 6: 
      var $7=$v1_addr;
      var $8=$v2_addr;
      var $div=($7)/($8);
      $retval=$div;
      label = 11; break;
    case 7: 
      var $9=$v1_addr;
      var $10=$v1_addr;
      var $11=$v2_addr;
      var $div5=($10)/($11);
      var $call=Math.floor($div5);
      var $12=$v2_addr;
      var $mul6=($call)*($12);
      var $sub7=($9)-($mul6);
      $retval=$sub7;
      label = 11; break;
    case 8: 
      var $13=$v1_addr;
      var $14=$v2_addr;
      var $15=Math.pow($13, $14);
      $retval=$15;
      label = 11; break;
    case 9: 
      var $16=$v1_addr;
      var $sub10=(-$16);
      $retval=$sub10;
      label = 11; break;
    case 10: 
      $retval=0;
      label = 11; break;
    case 11: 
      var $17=$retval;

      Module.print(INDENT + 'Exiting: _luaO_arith');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return $17;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_luaO_arith["X"]=1;

function _luaO_str2d($s, $len, $result) {
  var label = 0;
  var __stackBase__  = STACKTOP; STACKTOP = (STACKTOP + 4)|0; _memset(__stackBase__, 0, 4);
  Module.print(INDENT + ' Entering: _luaO_str2d: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $retval;
      var $s_addr;
      var $len_addr;
      var $result_addr;
      var $endptr=__stackBase__;
      $s_addr=$s;
      $len_addr=$len;
      $result_addr=$result;
      var $0=$s_addr;
      var $call=_strpbrk($0, ((5246868)|0));
      var $tobool=(($call)|0)!=0;
      if ($tobool) { label = 3; break; } else { label = 4; break; }
    case 3: 
      $retval=0;
      label = 14; break;
    case 4: 
      var $1=$s_addr;
      var $call1=_strpbrk($1, ((5246984)|0));
      var $tobool2=(($call1)|0)!=0;
      if ($tobool2) { label = 5; break; } else { label = 6; break; }
    case 5: 
      var $2=$s_addr;
      var $call4=_lua_strx2number($2, $endptr);
      var $3=$result_addr;
      (HEAPF64[(tempDoublePtr)>>3]=$call4,HEAP32[(($3)>>2)]=HEAP32[((tempDoublePtr)>>2)],HEAP32[((($3)+(4))>>2)]=HEAP32[(((tempDoublePtr)+(4))>>2)]);
      label = 7; break;
    case 6: 
      var $4=$s_addr;
      var $call6=_strtod($4, $endptr);
      var $5=$result_addr;
      (HEAPF64[(tempDoublePtr)>>3]=$call6,HEAP32[(($5)>>2)]=HEAP32[((tempDoublePtr)>>2)],HEAP32[((($5)+(4))>>2)]=HEAP32[(((tempDoublePtr)+(4))>>2)]);
      label = 7; break;
    case 7: 
      label = 8; break;
    case 8: 
      var $6=HEAP32[(($endptr)>>2)];
      var $7=$s_addr;
      var $cmp=(($6)|0)==(($7)|0);
      if ($cmp) { label = 9; break; } else { label = 10; break; }
    case 9: 
      $retval=0;
      label = 14; break;
    case 10: 
      label = 11; break;
    case 11: 
      var $8=HEAP32[(($endptr)>>2)];
      var $9=HEAP8[($8)];
      var $conv=(($9)&255);
      var $add=((($conv)+(1))|0);
      var $arrayidx=((5242924+$add)|0);
      var $10=HEAP8[($arrayidx)];
      var $conv10=(($10)&255);
      var $and=$conv10 & 8;
      var $tobool11=(($and)|0)!=0;
      if ($tobool11) { label = 12; break; } else { label = 13; break; }
    case 12: 
      var $11=HEAP32[(($endptr)>>2)];
      var $incdec_ptr=(($11+1)|0);
      HEAP32[(($endptr)>>2)]=$incdec_ptr;
      label = 11; break;
    case 13: 
      var $12=HEAP32[(($endptr)>>2)];
      var $13=$s_addr;
      var $14=$len_addr;
      var $add_ptr=(($13+$14)|0);
      var $cmp12=(($12)|0)==(($add_ptr)|0);
      var $conv13=(($cmp12)&1);
      $retval=$conv13;
      label = 14; break;
    case 14: 
      var $15=$retval;
      STACKTOP = __stackBase__;
      Module.print(INDENT + 'Exiting: _luaO_str2d');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return $15;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_luaO_str2d["X"]=1;

function _escerror($ls, $c, $n, $msg) {
  var label = 0;

  Module.print(INDENT + ' Entering: _escerror: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $ls_addr;
      var $c_addr;
      var $n_addr;
      var $msg_addr;
      var $i;
      $ls_addr=$ls;
      $c_addr=$c;
      $n_addr=$n;
      $msg_addr=$msg;
      var $0=$ls_addr;
      var $buff=(($0+48)|0);
      var $1=HEAP32[(($buff)>>2)];
      var $n1=(($1+4)|0);
      HEAP32[(($n1)>>2)]=0;
      var $2=$ls_addr;
      _save($2, 92);
      $i=0;
      label = 3; break;
    case 3: 
      var $3=$i;
      var $4=$n_addr;
      var $cmp=(($3)|0) < (($4)|0);
      if ($cmp) { label = 4; break; } else { var $8 = 0;label = 5; break; }
    case 4: 
      var $5=$i;
      var $6=$c_addr;
      var $arrayidx=(($6+($5<<2))|0);
      var $7=HEAP32[(($arrayidx)>>2)];
      var $cmp2=(($7)|0)!=-1;
      var $8 = $cmp2;label = 5; break;
    case 5: 
      var $8;
      if ($8) { label = 6; break; } else { label = 8; break; }
    case 6: 
      var $9=$ls_addr;
      var $10=$i;
      var $11=$c_addr;
      var $arrayidx3=(($11+($10<<2))|0);
      var $12=HEAP32[(($arrayidx3)>>2)];
      _save($9, $12);
      label = 7; break;
    case 7: 
      var $13=$i;
      var $inc=((($13)+(1))|0);
      $i=$inc;
      label = 3; break;
    case 8: 
      var $14=$ls_addr;
      var $15=$msg_addr;
      _lexerror($14, $15, 289);

    case 9: 

      Module.print(INDENT + 'Exiting: _escerror');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _luaM_growaux_($L, $block, $size, $size_elems, $limit, $what) {
  var label = 0;
  var __stackBase__  = STACKTOP; _memset(__stackBase__, 0, 0);
  Module.print(INDENT + ' Entering: _luaM_growaux_: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $L_addr;
      var $block_addr;
      var $size_addr;
      var $size_elems_addr;
      var $limit_addr;
      var $what_addr;
      var $newblock;
      var $newsize;
      $L_addr=$L;
      $block_addr=$block;
      $size_addr=$size;
      $size_elems_addr=$size_elems;
      $limit_addr=$limit;
      $what_addr=$what;
      var $0=$size_addr;
      var $1=HEAP32[(($0)>>2)];
      var $2=$limit_addr;
      var $div=((((($2)|0))/(2))&-1);
      var $cmp=(($1)|0) >= (($div)|0);
      if ($cmp) { label = 3; break; } else { label = 6; break; }
    case 3: 
      var $3=$size_addr;
      var $4=HEAP32[(($3)>>2)];
      var $5=$limit_addr;
      var $cmp1=(($4)|0) >= (($5)|0);
      if ($cmp1) { label = 4; break; } else { label = 5; break; }
    case 4: 
      var $6=$L_addr;
      var $7=$what_addr;
      var $8=$limit_addr;
      _luaG_runerror($6, ((5247056)|0), (tempInt=STACKTOP,_memset(STACKTOP, 0, 8),STACKTOP = (STACKTOP + 8)|0,HEAP32[((tempInt)>>2)]=$7,HEAP32[(((tempInt)+(4))>>2)]=$8,tempInt));

    case 5: 
      var $9=$limit_addr;
      $newsize=$9;
      label = 9; break;
    case 6: 
      var $10=$size_addr;
      var $11=HEAP32[(($10)>>2)];
      var $mul=($11<<1);
      $newsize=$mul;
      var $12=$newsize;
      var $cmp3=(($12)|0) < 4;
      if ($cmp3) { label = 7; break; } else { label = 8; break; }
    case 7: 
      $newsize=4;
      label = 8; break;
    case 8: 
      label = 9; break;
    case 9: 
      var $13=$newsize;
      var $add=((($13)+(1))|0);
      var $14=$size_elems_addr;
      var $div7=Math.floor((4294967293)/((($14)>>>0)));
      var $cmp8=(($add)>>>0) > (($div7)>>>0);
      if ($cmp8) { label = 10; break; } else { label = 11; break; }
    case 10: 
      var $15=$L_addr;
      _luaM_toobig($15);

      label = 12; break;
    case 11: 
      var $17=$L_addr;
      var $18=$block_addr;
      var $19=$size_addr;
      var $20=HEAP32[(($19)>>2)];
      var $21=$size_elems_addr;
      var $mul9=Math.imul($20,$21);
      var $22=$newsize;
      var $23=$size_elems_addr;
      var $mul10=Math.imul($22,$23);
      var $call=_luaM_realloc_($17, $18, $mul9, $mul10);
      var $cond = $call;label = 12; break;
    case 12: 
      var $cond;
      $newblock=$cond;
      var $24=$newsize;
      var $25=$size_addr;
      HEAP32[(($25)>>2)]=$24;
      var $26=$newblock;
      STACKTOP = __stackBase__;
      Module.print(INDENT + 'Exiting: _luaM_growaux_');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return $26;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_luaM_growaux_["X"]=1;

function _luaM_toobig($L) {
  var label = 0;
  var __stackBase__  = STACKTOP; _memset(__stackBase__, 0, 0);
  Module.print(INDENT + ' Entering: _luaM_toobig: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $L_addr;
      $L_addr=$L;
      var $0=$L_addr;
      _luaG_runerror($0, ((5247016)|0), (tempInt=STACKTOP,_memset(STACKTOP, 0, 1),STACKTOP = (STACKTOP + 1)|0,STACKTOP = ((((STACKTOP)+3)>>2)<<2),HEAP32[((tempInt)>>2)]=0,tempInt));

    case 3: 
      STACKTOP = __stackBase__;
      Module.print(INDENT + 'Exiting: _luaM_toobig');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _luaM_realloc_($L, $block, $osize, $nsize) {
  var label = 0;

  Module.print(INDENT + ' Entering: _luaM_realloc_: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $L_addr;
      var $block_addr;
      var $osize_addr;
      var $nsize_addr;
      var $newblock;
      var $g;
      var $realosize;
      $L_addr=$L;
      $block_addr=$block;
      $osize_addr=$osize;
      $nsize_addr=$nsize;
      var $0=$L_addr;
      var $l_G=(($0+12)|0);
      var $1=HEAP32[(($l_G)>>2)];
      $g=$1;
      var $2=$block_addr;
      var $tobool=(($2)|0)!=0;
      if ($tobool) { label = 3; break; } else { label = 4; break; }
    case 3: 
      var $3=$osize_addr;
      var $cond = $3;label = 5; break;
    case 4: 
      var $cond = 0;label = 5; break;
    case 5: 
      var $cond;
      $realosize=$cond;
      var $4=$g;
      var $frealloc=(($4)|0);
      var $5=HEAP32[(($frealloc)>>2)];
      var $6=$g;
      var $ud=(($6+4)|0);
      var $7=HEAP32[(($ud)>>2)];
      var $8=$block_addr;
      var $9=$osize_addr;
      var $10=$nsize_addr;
      var $call=FUNCTION_TABLE[$5]($7, $8, $9, $10);
      $newblock=$call;
      var $11=$newblock;
      var $cmp=(($11)|0)==0;
      if ($cmp) { label = 6; break; } else { label = 12; break; }
    case 6: 
      var $12=$nsize_addr;
      var $cmp1=(($12)>>>0) > 0;
      if ($cmp1) { label = 7; break; } else { label = 12; break; }
    case 7: 
      var $13=$g;
      var $gcrunning=(($13+55)|0);
      var $14=HEAP8[($gcrunning)];
      var $tobool2=(($14 << 24) >> 24)!=0;
      if ($tobool2) { label = 8; break; } else { label = 9; break; }
    case 8: 
      var $15=$L_addr;
      _luaC_fullgc($15, 1);
      var $16=$g;
      var $frealloc4=(($16)|0);
      var $17=HEAP32[(($frealloc4)>>2)];
      var $18=$g;
      var $ud5=(($18+4)|0);
      var $19=HEAP32[(($ud5)>>2)];
      var $20=$block_addr;
      var $21=$osize_addr;
      var $22=$nsize_addr;
      var $call6=FUNCTION_TABLE[$17]($19, $20, $21, $22);
      $newblock=$call6;
      label = 9; break;
    case 9: 
      var $23=$newblock;
      var $cmp7=(($23)|0)==0;
      if ($cmp7) { label = 10; break; } else { label = 11; break; }
    case 10: 
      var $24=$L_addr;
      _luaD_throw($24, 4);

    case 11: 
      label = 12; break;
    case 12: 
      var $25=$g;
      var $GCdebt=(($25+12)|0);
      var $26=HEAP32[(($GCdebt)>>2)];
      var $27=$nsize_addr;
      var $add=((($26)+($27))|0);
      var $28=$realosize;
      var $sub=((($add)-($28))|0);
      var $29=$g;
      var $GCdebt11=(($29+12)|0);
      HEAP32[(($GCdebt11)>>2)]=$sub;
      var $30=$newblock;

      Module.print(INDENT + 'Exiting: _luaM_realloc_');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return $30;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_luaM_realloc_["X"]=1;

function _isneg($s) {
  var label = 0;

  Module.print(INDENT + ' Entering: _isneg: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $retval;
      var $s_addr;
      $s_addr=$s;
      var $0=$s_addr;
      var $1=HEAP32[(($0)>>2)];
      var $2=HEAP8[($1)];
      var $conv=(($2 << 24) >> 24);
      var $cmp=(($conv)|0)==45;
      if ($cmp) { label = 3; break; } else { label = 4; break; }
    case 3: 
      var $3=$s_addr;
      var $4=HEAP32[(($3)>>2)];
      var $incdec_ptr=(($4+1)|0);
      HEAP32[(($3)>>2)]=$incdec_ptr;
      $retval=1;
      label = 8; break;
    case 4: 
      var $5=$s_addr;
      var $6=HEAP32[(($5)>>2)];
      var $7=HEAP8[($6)];
      var $conv2=(($7 << 24) >> 24);
      var $cmp3=(($conv2)|0)==43;
      if ($cmp3) { label = 5; break; } else { label = 6; break; }
    case 5: 
      var $8=$s_addr;
      var $9=HEAP32[(($8)>>2)];
      var $incdec_ptr6=(($9+1)|0);
      HEAP32[(($8)>>2)]=$incdec_ptr6;
      label = 6; break;
    case 6: 
      label = 7; break;
    case 7: 
      $retval=0;
      label = 8; break;
    case 8: 
      var $10=$retval;

      Module.print(INDENT + 'Exiting: _isneg');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return $10;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _lua_strx2number($s, $endptr) {
  var label = 0;
  var __stackBase__  = STACKTOP; STACKTOP = (STACKTOP + 12)|0; _memset(__stackBase__, 0, 12);
  Module.print(INDENT + ' Entering: _lua_strx2number: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $retval;
      var $s_addr=__stackBase__;
      var $endptr_addr;
      var $r;
      var $e=(__stackBase__)+(4);
      var $i=(__stackBase__)+(8);
      var $neg;
      var $exp1;
      var $neg1;
      HEAP32[(($s_addr)>>2)]=$s;
      $endptr_addr=$endptr;
      $r=0;
      HEAP32[(($e)>>2)]=0;
      HEAP32[(($i)>>2)]=0;
      $neg=0;
      var $0=HEAP32[(($s_addr)>>2)];
      var $1=$endptr_addr;
      HEAP32[(($1)>>2)]=$0;
      label = 3; break;
    case 3: 
      var $2=HEAP32[(($s_addr)>>2)];
      var $3=HEAP8[($2)];
      var $conv=(($3)&255);
      var $add=((($conv)+(1))|0);
      var $arrayidx=((5242924+$add)|0);
      var $4=HEAP8[($arrayidx)];
      var $conv1=(($4)&255);
      var $and=$conv1 & 8;
      var $tobool=(($and)|0)!=0;
      if ($tobool) { label = 4; break; } else { label = 5; break; }
    case 4: 
      var $5=HEAP32[(($s_addr)>>2)];
      var $incdec_ptr=(($5+1)|0);
      HEAP32[(($s_addr)>>2)]=$incdec_ptr;
      label = 3; break;
    case 5: 
      var $call=_isneg($s_addr);
      $neg=$call;
      var $6=HEAP32[(($s_addr)>>2)];
      var $7=HEAP8[($6)];
      var $conv2=(($7 << 24) >> 24);
      var $cmp=(($conv2)|0)==48;
      if ($cmp) { label = 6; break; } else { label = 8; break; }
    case 6: 
      var $8=HEAP32[(($s_addr)>>2)];
      var $add_ptr=(($8+1)|0);
      var $9=HEAP8[($add_ptr)];
      var $conv4=(($9 << 24) >> 24);
      var $cmp5=(($conv4)|0)==120;
      if ($cmp5) { label = 9; break; } else { label = 7; break; }
    case 7: 
      var $10=HEAP32[(($s_addr)>>2)];
      var $add_ptr7=(($10+1)|0);
      var $11=HEAP8[($add_ptr7)];
      var $conv8=(($11 << 24) >> 24);
      var $cmp9=(($conv8)|0)==88;
      if ($cmp9) { label = 9; break; } else { label = 8; break; }
    case 8: 
      $retval=0;
      label = 28; break;
    case 9: 
      var $12=HEAP32[(($s_addr)>>2)];
      var $add_ptr11=(($12+2)|0);
      HEAP32[(($s_addr)>>2)]=$add_ptr11;
      var $13=$r;
      var $call12=_readhexa($s_addr, $13, $i);
      $r=$call12;
      var $14=HEAP32[(($s_addr)>>2)];
      var $15=HEAP8[($14)];
      var $conv13=(($15 << 24) >> 24);
      var $cmp14=(($conv13)|0)==46;
      if ($cmp14) { label = 10; break; } else { label = 11; break; }
    case 10: 
      var $16=HEAP32[(($s_addr)>>2)];
      var $incdec_ptr17=(($16+1)|0);
      HEAP32[(($s_addr)>>2)]=$incdec_ptr17;
      var $17=$r;
      var $call18=_readhexa($s_addr, $17, $e);
      $r=$call18;
      label = 11; break;
    case 11: 
      var $18=HEAP32[(($i)>>2)];
      var $cmp20=(($18)|0)==0;
      if ($cmp20) { label = 12; break; } else { label = 14; break; }
    case 12: 
      var $19=HEAP32[(($e)>>2)];
      var $cmp23=(($19)|0)==0;
      if ($cmp23) { label = 13; break; } else { label = 14; break; }
    case 13: 
      $retval=0;
      label = 28; break;
    case 14: 
      var $20=HEAP32[(($e)>>2)];
      var $mul=((($20)*(-4))&-1);
      HEAP32[(($e)>>2)]=$mul;
      var $21=HEAP32[(($s_addr)>>2)];
      var $22=$endptr_addr;
      HEAP32[(($22)>>2)]=$21;
      var $23=HEAP32[(($s_addr)>>2)];
      var $24=HEAP8[($23)];
      var $conv27=(($24 << 24) >> 24);
      var $cmp28=(($conv27)|0)==112;
      if ($cmp28) { label = 16; break; } else { label = 15; break; }
    case 15: 
      var $25=HEAP32[(($s_addr)>>2)];
      var $26=HEAP8[($25)];
      var $conv31=(($26 << 24) >> 24);
      var $cmp32=(($conv31)|0)==80;
      if ($cmp32) { label = 16; break; } else { label = 24; break; }
    case 16: 
      $exp1=0;
      var $27=HEAP32[(($s_addr)>>2)];
      var $incdec_ptr35=(($27+1)|0);
      HEAP32[(($s_addr)>>2)]=$incdec_ptr35;
      var $call36=_isneg($s_addr);
      $neg1=$call36;
      var $28=HEAP32[(($s_addr)>>2)];
      var $29=HEAP8[($28)];
      var $conv37=(($29)&255);
      var $add38=((($conv37)+(1))|0);
      var $arrayidx39=((5242924+$add38)|0);
      var $30=HEAP8[($arrayidx39)];
      var $conv40=(($30)&255);
      var $and41=$conv40 & 2;
      var $tobool42=(($and41)|0)!=0;
      if ($tobool42) { label = 18; break; } else { label = 17; break; }
    case 17: 
      label = 25; break;
    case 18: 
      label = 19; break;
    case 19: 
      var $31=HEAP32[(($s_addr)>>2)];
      var $32=HEAP8[($31)];
      var $conv46=(($32)&255);
      var $add47=((($conv46)+(1))|0);
      var $arrayidx48=((5242924+$add47)|0);
      var $33=HEAP8[($arrayidx48)];
      var $conv49=(($33)&255);
      var $and50=$conv49 & 2;
      var $tobool51=(($and50)|0)!=0;
      if ($tobool51) { label = 20; break; } else { label = 21; break; }
    case 20: 
      var $34=$exp1;
      var $mul53=((($34)*(10))&-1);
      var $35=HEAP32[(($s_addr)>>2)];
      var $incdec_ptr54=(($35+1)|0);
      HEAP32[(($s_addr)>>2)]=$incdec_ptr54;
      var $36=HEAP8[($35)];
      var $conv55=(($36 << 24) >> 24);
      var $add56=((($mul53)+($conv55))|0);
      var $sub=((($add56)-(48))|0);
      $exp1=$sub;
      label = 19; break;
    case 21: 
      var $37=$neg1;
      var $tobool58=(($37)|0)!=0;
      if ($tobool58) { label = 22; break; } else { label = 23; break; }
    case 22: 
      var $38=$exp1;
      var $sub60=(((-$38))|0);
      $exp1=$sub60;
      label = 23; break;
    case 23: 
      var $39=$exp1;
      var $40=HEAP32[(($e)>>2)];
      var $add62=((($40)+($39))|0);
      HEAP32[(($e)>>2)]=$add62;
      label = 24; break;
    case 24: 
      var $41=HEAP32[(($s_addr)>>2)];
      var $42=$endptr_addr;
      HEAP32[(($42)>>2)]=$41;
      label = 25; break;
    case 25: 
      var $43=$neg;
      var $tobool64=(($43)|0)!=0;
      if ($tobool64) { label = 26; break; } else { label = 27; break; }
    case 26: 
      var $44=$r;
      var $sub66=(-$44);
      $r=$sub66;
      label = 27; break;
    case 27: 
      var $45=$r;
      var $46=HEAP32[(($e)>>2)];
      var $call68=_ldexp($45, $46);
      $retval=$call68;
      label = 28; break;
    case 28: 
      var $47=$retval;
      STACKTOP = __stackBase__;
      Module.print(INDENT + 'Exiting: _lua_strx2number');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return $47;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_lua_strx2number["X"]=1;

function _pushstr($L, $str, $l) {
  var label = 0;

  Module.print(INDENT + ' Entering: _pushstr: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $L_addr;
      var $str_addr;
      var $l_addr;
      var $io;
      var $x_;
      $L_addr=$L;
      $str_addr=$str;
      $l_addr=$l;
      var $0=$L_addr;
      var $top=(($0+8)|0);
      var $1=HEAP32[(($top)>>2)];
      $io=$1;
      var $2=$L_addr;
      var $3=$str_addr;
      var $4=$l_addr;
      var $call=_luaS_newlstr($2, $3, $4);
      $x_=$call;
      var $5=$x_;
      var $6=$5;
      var $7=$io;
      var $value_=(($7)|0);
      var $gc=$value_;
      HEAP32[(($gc)>>2)]=$6;
      var $8=$x_;
      var $tsv=$8;
      var $tt=(($tsv+4)|0);
      var $9=HEAP8[($tt)];
      var $conv=(($9)&255);
      var $or=$conv | 64;
      var $10=$io;
      var $tt_=(($10+8)|0);
      HEAP32[(($tt_)>>2)]=$or;
      var $11=$L_addr;
      var $top1=(($11+8)|0);
      var $12=HEAP32[(($top1)>>2)];
      var $incdec_ptr=(($12+12)|0);
      HEAP32[(($top1)>>2)]=$incdec_ptr;
      var $13=$L_addr;
      var $stack_last=(($13+24)|0);
      var $14=HEAP32[(($stack_last)>>2)];
      var $15=$L_addr;
      var $top2=(($15+8)|0);
      var $16=HEAP32[(($top2)>>2)];
      var $sub_ptr_lhs_cast=$14;
      var $sub_ptr_rhs_cast=$16;
      var $sub_ptr_sub=((($sub_ptr_lhs_cast)-($sub_ptr_rhs_cast))|0);
      var $sub_ptr_div=((((($sub_ptr_sub)|0))/(12))&-1);
      var $cmp=(($sub_ptr_div)|0) <= 0;
      if ($cmp) { label = 3; break; } else { label = 4; break; }
    case 3: 
      var $17=$L_addr;
      _luaD_growstack($17, 0);
      label = 5; break;
    case 4: 
      label = 5; break;
    case 5: 

      Module.print(INDENT + 'Exiting: _pushstr');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_pushstr["X"]=1;

function _luaO_pushfstring($L, $fmt, varrp) {
  var label = 0;
  var __stackBase__  = STACKTOP; STACKTOP = (STACKTOP + 4)|0; _memset(__stackBase__, 0, 4);
  Module.print(INDENT + ' Entering: _luaO_pushfstring: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';

  var $L_addr;
  var $fmt_addr;
  var $msg;
  var $argp=__stackBase__;
  $L_addr=$L;
  $fmt_addr=$fmt;
  var $argp1=$argp;
  HEAP32[(($argp1)>>2)]=varrp;
  var $0=$L_addr;
  var $1=$fmt_addr;
  var $2=HEAP32[(($argp)>>2)];
  var $call=_luaO_pushvfstring($0, $1, $2);
  $msg=$call;
  var $argp2=$argp;

  var $3=$msg;
  STACKTOP = __stackBase__;
  Module.print(INDENT + 'Exiting: _luaO_pushfstring');
  INDENT = INDENT.substr(0, INDENT.length-2);
  return $3;
  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _luaO_chunkid($out, $source, $bufflen) {
  var label = 0;

  Module.print(INDENT + ' Entering: _luaO_chunkid: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $out_addr;
      var $source_addr;
      var $bufflen_addr;
      var $l;
      var $nl;
      $out_addr=$out;
      $source_addr=$source;
      $bufflen_addr=$bufflen;
      var $0=$source_addr;
      var $call=_strlen($0);
      $l=$call;
      var $1=$source_addr;
      var $2=HEAP8[($1)];
      var $conv=(($2 << 24) >> 24);
      var $cmp=(($conv)|0)==61;
      if ($cmp) { label = 3; break; } else { label = 7; break; }
    case 3: 
      var $3=$l;
      var $4=$bufflen_addr;
      var $cmp2=(($3)>>>0) <= (($4)>>>0);
      if ($cmp2) { label = 4; break; } else { label = 5; break; }
    case 4: 
      var $5=$out_addr;
      var $6=$source_addr;
      var $add_ptr=(($6+1)|0);
      var $7=$l;
      var $mul=$7;
      _memcpy($5, $add_ptr, $mul);
      label = 6; break;
    case 5: 
      var $8=$out_addr;
      var $9=$source_addr;
      var $add_ptr5=(($9+1)|0);
      var $10=$bufflen_addr;
      var $sub=((($10)-(1))|0);
      var $mul6=$sub;
      _memcpy($8, $add_ptr5, $mul6);
      var $11=$bufflen_addr;
      var $sub7=((($11)-(1))|0);
      var $12=$out_addr;
      var $add_ptr8=(($12+$sub7)|0);
      $out_addr=$add_ptr8;
      var $13=$out_addr;
      HEAP8[($13)]=0;
      label = 6; break;
    case 6: 
      label = 22; break;
    case 7: 
      var $14=$source_addr;
      var $15=HEAP8[($14)];
      var $conv10=(($15 << 24) >> 24);
      var $cmp11=(($conv10)|0)==64;
      if ($cmp11) { label = 8; break; } else { label = 12; break; }
    case 8: 
      var $16=$l;
      var $17=$bufflen_addr;
      var $cmp14=(($16)>>>0) <= (($17)>>>0);
      if ($cmp14) { label = 9; break; } else { label = 10; break; }
    case 9: 
      var $18=$out_addr;
      var $19=$source_addr;
      var $add_ptr17=(($19+1)|0);
      var $20=$l;
      var $mul18=$20;
      _memcpy($18, $add_ptr17, $mul18);
      label = 11; break;
    case 10: 
      var $21=$out_addr;
      HEAP8[($21)]=HEAP8[((((5244616)|0))|0)];HEAP8[((($21)+(1))|0)]=HEAP8[(((((5244616)|0))+(1))|0)];HEAP8[((($21)+(2))|0)]=HEAP8[(((((5244616)|0))+(2))|0)];
      var $22=$out_addr;
      var $add_ptr20=(($22+3)|0);
      $out_addr=$add_ptr20;
      var $23=$bufflen_addr;
      var $sub21=((($23)-(3))|0);
      $bufflen_addr=$sub21;
      var $24=$out_addr;
      var $25=$source_addr;
      var $add_ptr22=(($25+1)|0);
      var $26=$l;
      var $add_ptr23=(($add_ptr22+$26)|0);
      var $27=$bufflen_addr;
      var $idx_neg=(((-$27))|0);
      var $add_ptr24=(($add_ptr23+$idx_neg)|0);
      var $28=$bufflen_addr;
      var $mul25=$28;
      _memcpy($24, $add_ptr24, $mul25);
      label = 11; break;
    case 11: 
      label = 21; break;
    case 12: 
      var $29=$source_addr;
      var $call28=_strchr($29, 10);
      $nl=$call28;
      var $30=$out_addr;
      for (var $$src = ((5244476)|0), $$dest = $30, $$stop = $$src + 9; $$src < $$stop; $$src++, $$dest++) {
        HEAP8[$$dest] = HEAP8[$$src]
      };
      var $31=$out_addr;
      var $add_ptr29=(($31+9)|0);
      $out_addr=$add_ptr29;
      var $32=$bufflen_addr;
      var $sub30=((($32)-(15))|0);
      $bufflen_addr=$sub30;
      var $33=$l;
      var $34=$bufflen_addr;
      var $cmp31=(($33)>>>0) < (($34)>>>0);
      if ($cmp31) { label = 13; break; } else { label = 15; break; }
    case 13: 
      var $35=$nl;
      var $cmp33=(($35)|0)==0;
      if ($cmp33) { label = 14; break; } else { label = 15; break; }
    case 14: 
      var $36=$out_addr;
      var $37=$source_addr;
      var $38=$l;
      var $mul36=$38;
      _memcpy($36, $37, $mul36);
      var $39=$l;
      var $40=$out_addr;
      var $add_ptr37=(($40+$39)|0);
      $out_addr=$add_ptr37;
      label = 20; break;
    case 15: 
      var $41=$nl;
      var $cmp39=(($41)|0)!=0;
      if ($cmp39) { label = 16; break; } else { label = 17; break; }
    case 16: 
      var $42=$nl;
      var $43=$source_addr;
      var $sub_ptr_lhs_cast=$42;
      var $sub_ptr_rhs_cast=$43;
      var $sub_ptr_sub=((($sub_ptr_lhs_cast)-($sub_ptr_rhs_cast))|0);
      $l=$sub_ptr_sub;
      label = 17; break;
    case 17: 
      var $44=$l;
      var $45=$bufflen_addr;
      var $cmp43=(($44)>>>0) > (($45)>>>0);
      if ($cmp43) { label = 18; break; } else { label = 19; break; }
    case 18: 
      var $46=$bufflen_addr;
      $l=$46;
      label = 19; break;
    case 19: 
      var $47=$out_addr;
      var $48=$source_addr;
      var $49=$l;
      var $mul47=$49;
      _memcpy($47, $48, $mul47);
      var $50=$l;
      var $51=$out_addr;
      var $add_ptr48=(($51+$50)|0);
      $out_addr=$add_ptr48;
      var $52=$out_addr;
      HEAP8[($52)]=HEAP8[((((5244616)|0))|0)];HEAP8[((($52)+(1))|0)]=HEAP8[(((((5244616)|0))+(1))|0)];HEAP8[((($52)+(2))|0)]=HEAP8[(((((5244616)|0))+(2))|0)];
      var $53=$out_addr;
      var $add_ptr49=(($53+3)|0);
      $out_addr=$add_ptr49;
      label = 20; break;
    case 20: 
      var $54=$out_addr;
      HEAP8[($54)]=HEAP8[((((5244332)|0))|0)];HEAP8[((($54)+(1))|0)]=HEAP8[(((((5244332)|0))+(1))|0)];HEAP8[((($54)+(2))|0)]=HEAP8[(((((5244332)|0))+(2))|0)];
      label = 21; break;
    case 21: 
      label = 22; break;
    case 22: 

      Module.print(INDENT + 'Exiting: _luaO_chunkid');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_luaO_chunkid["X"]=1;

function _readhexa($s, $r, $count) {
  var label = 0;

  Module.print(INDENT + ' Entering: _readhexa: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $s_addr;
      var $r_addr;
      var $count_addr;
      $s_addr=$s;
      $r_addr=$r;
      $count_addr=$count;
      label = 3; break;
    case 3: 
      var $0=$s_addr;
      var $1=HEAP32[(($0)>>2)];
      var $2=HEAP8[($1)];
      var $conv=(($2)&255);
      var $add=((($conv)+(1))|0);
      var $arrayidx=((5242924+$add)|0);
      var $3=HEAP8[($arrayidx)];
      var $conv1=(($3)&255);
      var $and=$conv1 & 16;
      var $tobool=(($and)|0)!=0;
      if ($tobool) { label = 4; break; } else { label = 6; break; }
    case 4: 
      var $4=$r_addr;
      var $mul=($4)*(16);
      var $5=$s_addr;
      var $6=HEAP32[(($5)>>2)];
      var $7=HEAP8[($6)];
      var $conv2=(($7)&255);
      var $call=_luaO_hexavalue($conv2);
      var $conv3=(($call)|0);
      var $add4=($mul)+($conv3);
      $r_addr=$add4;
      var $8=$count_addr;
      var $9=HEAP32[(($8)>>2)];
      var $inc=((($9)+(1))|0);
      HEAP32[(($8)>>2)]=$inc;
      label = 5; break;
    case 5: 
      var $10=$s_addr;
      var $11=HEAP32[(($10)>>2)];
      var $incdec_ptr=(($11+1)|0);
      HEAP32[(($10)>>2)]=$incdec_ptr;
      label = 3; break;
    case 6: 
      var $12=$r_addr;

      Module.print(INDENT + 'Exiting: _readhexa');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return $12;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _luaY_parser($L, $z, $buff, $dyd, $name, $firstchar) {
  var label = 0;
  var __stackBase__  = STACKTOP; STACKTOP = (STACKTOP + 120)|0; _memset(__stackBase__, 0, 120);
  Module.print(INDENT + ' Entering: _luaY_parser: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $L_addr;
      var $z_addr;
      var $buff_addr;
      var $dyd_addr;
      var $name_addr;
      var $firstchar_addr;
      var $lexstate=__stackBase__;
      var $funcstate=(__stackBase__)+(68);
      var $cl;
      var $io;
      $L_addr=$L;
      $z_addr=$z;
      $buff_addr=$buff;
      $dyd_addr=$dyd;
      $name_addr=$name;
      $firstchar_addr=$firstchar;
      var $0=$L_addr;
      var $call=_luaF_newLclosure($0, 1);
      $cl=$call;
      var $1=$L_addr;
      var $top=(($1+8)|0);
      var $2=HEAP32[(($top)>>2)];
      $io=$2;
      var $3=$cl;
      var $4=$3;
      var $5=$io;
      var $value_=(($5)|0);
      var $gc=$value_;
      HEAP32[(($gc)>>2)]=$4;
      var $6=$io;
      var $tt_=(($6+8)|0);
      HEAP32[(($tt_)>>2)]=70;
      var $7=$L_addr;
      var $top1=(($7+8)|0);
      var $8=HEAP32[(($top1)>>2)];
      var $incdec_ptr=(($8+12)|0);
      HEAP32[(($top1)>>2)]=$incdec_ptr;
      var $9=$L_addr;
      var $stack_last=(($9+24)|0);
      var $10=HEAP32[(($stack_last)>>2)];
      var $11=$L_addr;
      var $top2=(($11+8)|0);
      var $12=HEAP32[(($top2)>>2)];
      var $sub_ptr_lhs_cast=$10;
      var $sub_ptr_rhs_cast=$12;
      var $sub_ptr_sub=((($sub_ptr_lhs_cast)-($sub_ptr_rhs_cast))|0);
      var $sub_ptr_div=((((($sub_ptr_sub)|0))/(12))&-1);
      var $cmp=(($sub_ptr_div)|0) <= 0;
      if ($cmp) { label = 3; break; } else { label = 4; break; }
    case 3: 
      var $13=$L_addr;
      _luaD_growstack($13, 0);
      label = 5; break;
    case 4: 
      label = 5; break;
    case 5: 
      var $14=$L_addr;
      var $call3=_luaF_newproto($14);
      var $15=$cl;
      var $l=$15;
      var $p=(($l+12)|0);
      HEAP32[(($p)>>2)]=$call3;
      var $f=(($funcstate)|0);
      HEAP32[(($f)>>2)]=$call3;
      var $16=$L_addr;
      var $17=$name_addr;
      var $call4=_luaS_new($16, $17);
      var $f5=(($funcstate)|0);
      var $18=HEAP32[(($f5)>>2)];
      var $source=(($18+36)|0);
      HEAP32[(($source)>>2)]=$call4;
      var $19=$buff_addr;
      var $buff6=(($lexstate+48)|0);
      HEAP32[(($buff6)>>2)]=$19;
      var $20=$dyd_addr;
      var $dyd7=(($lexstate+52)|0);
      HEAP32[(($dyd7)>>2)]=$20;
      var $21=$dyd_addr;
      var $label=(($21+24)|0);
      var $n=(($label+4)|0);
      HEAP32[(($n)>>2)]=0;
      var $22=$dyd_addr;
      var $gt=(($22+12)|0);
      var $n8=(($gt+4)|0);
      HEAP32[(($n8)>>2)]=0;
      var $23=$dyd_addr;
      var $actvar=(($23)|0);
      var $n9=(($actvar+4)|0);
      HEAP32[(($n9)>>2)]=0;
      var $24=$L_addr;
      var $25=$z_addr;
      var $f10=(($funcstate)|0);
      var $26=HEAP32[(($f10)>>2)];
      var $source11=(($26+36)|0);
      var $27=HEAP32[(($source11)>>2)];
      var $28=$firstchar_addr;
      _luaX_setinput($24, $lexstate, $25, $27, $28);
      _mainfunc($lexstate, $funcstate);
      var $29=$cl;
      STACKTOP = __stackBase__;
      Module.print(INDENT + 'Exiting: _luaY_parser');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return $29;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_luaY_parser["X"]=1;

function _luaO_pushvfstring($L, $fmt, $argp) {
  var label = 0;
  var __stackBase__  = STACKTOP; STACKTOP = (STACKTOP + 28)|0; _memset(__stackBase__, 0, 28);
  Module.print(INDENT + ' Entering: _luaO_pushvfstring: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $L_addr;
      var $fmt_addr;
      var $argp_addr;
      var $n;
      var $e;
      var $io;
      var $x_;
      var $s;
      var $buff=__stackBase__;
      var $io22;
      var $io44;
      var $buff65=(__stackBase__)+(4);
      var $l;
      $L_addr=$L;
      $fmt_addr=$fmt;
      $argp_addr=$argp;
      $n=0;
      label = 3; break;
    case 3: 
      var $0=$fmt_addr;
      var $call=_strchr($0, 37);
      $e=$call;
      var $1=$e;
      var $cmp=(($1)|0)==0;
      if ($cmp) { label = 4; break; } else { label = 5; break; }
    case 4: 
      label = 25; break;
    case 5: 
      var $2=$L_addr;
      var $top=(($2+8)|0);
      var $3=HEAP32[(($top)>>2)];
      $io=$3;
      var $4=$L_addr;
      var $5=$fmt_addr;
      var $6=$e;
      var $7=$fmt_addr;
      var $sub_ptr_lhs_cast=$6;
      var $sub_ptr_rhs_cast=$7;
      var $sub_ptr_sub=((($sub_ptr_lhs_cast)-($sub_ptr_rhs_cast))|0);
      var $call1=_luaS_newlstr($4, $5, $sub_ptr_sub);
      $x_=$call1;
      var $8=$x_;
      var $9=$8;
      var $10=$io;
      var $value_=(($10)|0);
      var $gc=$value_;
      HEAP32[(($gc)>>2)]=$9;
      var $11=$x_;
      var $tsv=$11;
      var $tt=(($tsv+4)|0);
      var $12=HEAP8[($tt)];
      var $conv=(($12)&255);
      var $or=$conv | 64;
      var $13=$io;
      var $tt_=(($13+8)|0);
      HEAP32[(($tt_)>>2)]=$or;
      var $14=$L_addr;
      var $top2=(($14+8)|0);
      var $15=HEAP32[(($top2)>>2)];
      var $incdec_ptr=(($15+12)|0);
      HEAP32[(($top2)>>2)]=$incdec_ptr;
      var $16=$L_addr;
      var $stack_last=(($16+24)|0);
      var $17=HEAP32[(($stack_last)>>2)];
      var $18=$L_addr;
      var $top3=(($18+8)|0);
      var $19=HEAP32[(($top3)>>2)];
      var $sub_ptr_lhs_cast4=$17;
      var $sub_ptr_rhs_cast5=$19;
      var $sub_ptr_sub6=((($sub_ptr_lhs_cast4)-($sub_ptr_rhs_cast5))|0);
      var $sub_ptr_div=((((($sub_ptr_sub6)|0))/(12))&-1);
      var $cmp7=(($sub_ptr_div)|0) <= 0;
      if ($cmp7) { label = 6; break; } else { label = 7; break; }
    case 6: 
      var $20=$L_addr;
      _luaD_growstack($20, 0);
      label = 8; break;
    case 7: 
      label = 8; break;
    case 8: 
      var $21=$e;
      var $add_ptr=(($21+1)|0);
      var $22=HEAP8[($add_ptr)];
      var $conv11=(($22 << 24) >> 24);
      if ((($conv11)|0)==115) {
        label = 9; break;
      }
      else if ((($conv11)|0)==99) {
        label = 12; break;
      }
      else if ((($conv11)|0)==100) {
        label = 13; break;
      }
      else if ((($conv11)|0)==102) {
        label = 17; break;
      }
      else if ((($conv11)|0)==112) {
        label = 21; break;
      }
      else if ((($conv11)|0)==37) {
        label = 22; break;
      }
      else {
      label = 23; break;
      }
      
    case 9: 
      var $ap_cur=$argp_addr;
      var $23=$ap_cur;
      var $ap_next=(($ap_cur+4)|0);
      $argp_addr=$ap_next;
      var $24=HEAP32[(($23)>>2)];
      $s=$24;
      var $25=$s;
      var $cmp12=(($25)|0)==0;
      if ($cmp12) { label = 10; break; } else { label = 11; break; }
    case 10: 
      $s=((5245996)|0);
      label = 11; break;
    case 11: 
      var $26=$L_addr;
      var $27=$s;
      var $28=$s;
      var $call16=_strlen($28);
      _pushstr($26, $27, $call16);
      label = 24; break;
    case 12: 
      var $ap_cur18=$argp_addr;
      var $29=$ap_cur18;
      var $ap_next19=(($ap_cur18+4)|0);
      $argp_addr=$ap_next19;
      var $30=HEAP32[(($29)>>2)];
      var $conv20=(($30) & 255);
      HEAP8[($buff)]=$conv20;
      var $31=$L_addr;
      _pushstr($31, $buff, 1);
      label = 24; break;
    case 13: 
      var $32=$L_addr;
      var $top23=(($32+8)|0);
      var $33=HEAP32[(($top23)>>2)];
      $io22=$33;
      var $ap_cur24=$argp_addr;
      var $34=$ap_cur24;
      var $ap_next25=(($ap_cur24+4)|0);
      $argp_addr=$ap_next25;
      var $35=HEAP32[(($34)>>2)];
      var $conv26=(($35)|0);
      var $36=$io22;
      var $value_27=(($36)|0);
      var $n28=$value_27;
      (HEAPF64[(tempDoublePtr)>>3]=$conv26,HEAP32[(($n28)>>2)]=HEAP32[((tempDoublePtr)>>2)],HEAP32[((($n28)+(4))>>2)]=HEAP32[(((tempDoublePtr)+(4))>>2)]);
      var $37=$io22;
      var $tt_29=(($37+8)|0);
      HEAP32[(($tt_29)>>2)]=3;
      var $38=$L_addr;
      var $top30=(($38+8)|0);
      var $39=HEAP32[(($top30)>>2)];
      var $incdec_ptr31=(($39+12)|0);
      HEAP32[(($top30)>>2)]=$incdec_ptr31;
      var $40=$L_addr;
      var $stack_last32=(($40+24)|0);
      var $41=HEAP32[(($stack_last32)>>2)];
      var $42=$L_addr;
      var $top33=(($42+8)|0);
      var $43=HEAP32[(($top33)>>2)];
      var $sub_ptr_lhs_cast34=$41;
      var $sub_ptr_rhs_cast35=$43;
      var $sub_ptr_sub36=((($sub_ptr_lhs_cast34)-($sub_ptr_rhs_cast35))|0);
      var $sub_ptr_div37=((((($sub_ptr_sub36)|0))/(12))&-1);
      var $cmp38=(($sub_ptr_div37)|0) <= 0;
      if ($cmp38) { label = 14; break; } else { label = 15; break; }
    case 14: 
      var $44=$L_addr;
      _luaD_growstack($44, 0);
      label = 16; break;
    case 15: 
      label = 16; break;
    case 16: 
      label = 24; break;
    case 17: 
      var $45=$L_addr;
      var $top45=(($45+8)|0);
      var $46=HEAP32[(($top45)>>2)];
      $io44=$46;
      var $ap_cur46=$argp_addr;
      var $47=$ap_cur46;
      var $ap_next47=(($ap_cur46+8)|0);
      $argp_addr=$ap_next47;
      var $48=(HEAP32[((tempDoublePtr)>>2)]=HEAP32[(($47)>>2)],HEAP32[(((tempDoublePtr)+(4))>>2)]=HEAP32[((($47)+(4))>>2)],HEAPF64[(tempDoublePtr)>>3]);
      var $49=$io44;
      var $value_48=(($49)|0);
      var $n49=$value_48;
      (HEAPF64[(tempDoublePtr)>>3]=$48,HEAP32[(($n49)>>2)]=HEAP32[((tempDoublePtr)>>2)],HEAP32[((($n49)+(4))>>2)]=HEAP32[(((tempDoublePtr)+(4))>>2)]);
      var $50=$io44;
      var $tt_50=(($50+8)|0);
      HEAP32[(($tt_50)>>2)]=3;
      var $51=$L_addr;
      var $top51=(($51+8)|0);
      var $52=HEAP32[(($top51)>>2)];
      var $incdec_ptr52=(($52+12)|0);
      HEAP32[(($top51)>>2)]=$incdec_ptr52;
      var $53=$L_addr;
      var $stack_last53=(($53+24)|0);
      var $54=HEAP32[(($stack_last53)>>2)];
      var $55=$L_addr;
      var $top54=(($55+8)|0);
      var $56=HEAP32[(($top54)>>2)];
      var $sub_ptr_lhs_cast55=$54;
      var $sub_ptr_rhs_cast56=$56;
      var $sub_ptr_sub57=((($sub_ptr_lhs_cast55)-($sub_ptr_rhs_cast56))|0);
      var $sub_ptr_div58=((((($sub_ptr_sub57)|0))/(12))&-1);
      var $cmp59=(($sub_ptr_div58)|0) <= 0;
      if ($cmp59) { label = 18; break; } else { label = 19; break; }
    case 18: 
      var $57=$L_addr;
      _luaD_growstack($57, 0);
      label = 20; break;
    case 19: 
      label = 20; break;
    case 20: 
      label = 24; break;
    case 21: 
      var $arraydecay=(($buff65)|0);
      var $ap_cur66=$argp_addr;
      var $58=$ap_cur66;
      var $ap_next67=(($ap_cur66+4)|0);
      $argp_addr=$ap_next67;
      var $59=HEAP32[(($58)>>2)];
      var $call68=_sprintf($arraydecay, ((5245368)|0), (tempInt=STACKTOP,_memset(STACKTOP, 0, 4),STACKTOP = (STACKTOP + 4)|0,HEAP32[((tempInt)>>2)]=$59,tempInt));
      $l=$call68;
      var $60=$L_addr;
      var $arraydecay69=(($buff65)|0);
      var $61=$l;
      _pushstr($60, $arraydecay69, $61);
      label = 24; break;
    case 22: 
      var $62=$L_addr;
      _pushstr($62, ((5245044)|0), 1);
      label = 24; break;
    case 23: 
      var $63=$L_addr;
      var $64=$e;
      var $add_ptr71=(($64+1)|0);
      var $65=HEAP8[($add_ptr71)];
      var $conv72=(($65 << 24) >> 24);
      _luaG_runerror($63, ((5244736)|0), (tempInt=STACKTOP,_memset(STACKTOP, 0, 4),STACKTOP = (STACKTOP + 4)|0,HEAP32[((tempInt)>>2)]=$conv72,tempInt));

    case 24: 
      var $66=$n;
      var $add=((($66)+(2))|0);
      $n=$add;
      var $67=$e;
      var $add_ptr73=(($67+2)|0);
      $fmt_addr=$add_ptr73;
      label = 3; break;
    case 25: 
      var $68=$L_addr;
      var $69=$fmt_addr;
      var $70=$fmt_addr;
      var $call74=_strlen($70);
      _pushstr($68, $69, $call74);
      var $71=$n;
      var $cmp75=(($71)|0) > 0;
      if ($cmp75) { label = 26; break; } else { label = 27; break; }
    case 26: 
      var $72=$L_addr;
      var $73=$n;
      var $add78=((($73)+(1))|0);
      _luaV_concat($72, $add78);
      label = 27; break;
    case 27: 
      var $74=$L_addr;
      var $top80=(($74+8)|0);
      var $75=HEAP32[(($top80)>>2)];
      var $add_ptr81=((($75)-(12))|0);
      var $value_82=(($add_ptr81)|0);
      var $gc83=$value_82;
      var $76=HEAP32[(($gc83)>>2)];
      var $ts=$76;
      var $add_ptr84=(($ts+16)|0);
      var $77=$add_ptr84;
      STACKTOP = __stackBase__;
      Module.print(INDENT + 'Exiting: _luaO_pushvfstring');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return $77;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_luaO_pushvfstring["X"]=1;

function _init_exp($e, $k, $i) {
  var label = 0;

  Module.print(INDENT + ' Entering: _init_exp: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';

  var $e_addr;
  var $k_addr;
  var $i_addr;
  $e_addr=$e;
  $k_addr=$k;
  $i_addr=$i;
  var $0=$e_addr;
  var $t=(($0+12)|0);
  HEAP32[(($t)>>2)]=-1;
  var $1=$e_addr;
  var $f=(($1+16)|0);
  HEAP32[(($f)>>2)]=-1;
  var $2=$k_addr;
  var $3=$e_addr;
  var $k1=(($3)|0);
  HEAP32[(($k1)>>2)]=$2;
  var $4=$i_addr;
  var $5=$e_addr;
  var $u=(($5+4)|0);
  var $info=$u;
  HEAP32[(($info)>>2)]=$4;

  Module.print(INDENT + 'Exiting: _init_exp');
  INDENT = INDENT.substr(0, INDENT.length-2);
  return;
  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _mainfunc($ls, $fs) {
  var label = 0;
  var __stackBase__  = STACKTOP; STACKTOP = (STACKTOP + 32)|0; _memset(__stackBase__, 0, 32);
  Module.print(INDENT + ' Entering: _mainfunc: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';

  var $ls_addr;
  var $fs_addr;
  var $bl=__stackBase__;
  var $v=(__stackBase__)+(12);
  $ls_addr=$ls;
  $fs_addr=$fs;
  var $0=$ls_addr;
  var $1=$fs_addr;
  _open_func($0, $1, $bl);
  var $2=$fs_addr;
  var $f=(($2)|0);
  var $3=HEAP32[(($f)>>2)];
  var $is_vararg=(($3+77)|0);
  HEAP8[($is_vararg)]=1;
  _init_exp($v, 7, 0);
  var $4=$fs_addr;
  var $5=$ls_addr;
  var $envn=(($5+60)|0);
  var $6=HEAP32[(($envn)>>2)];
  var $call=_newupvalue($4, $6, $v);
  var $7=$ls_addr;
  _luaX_next($7);
  var $8=$ls_addr;
  _statlist($8);
  var $9=$ls_addr;
  _check($9, 286);
  var $10=$ls_addr;
  _close_func($10);
  STACKTOP = __stackBase__;
  Module.print(INDENT + 'Exiting: _mainfunc');
  INDENT = INDENT.substr(0, INDENT.length-2);
  return;
  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _open_func($ls, $fs, $bl) {
  var label = 0;

  Module.print(INDENT + ' Entering: _open_func: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $ls_addr;
      var $fs_addr;
      var $bl_addr;
      var $L;
      var $f;
      var $io;
      $ls_addr=$ls;
      $fs_addr=$fs;
      $bl_addr=$bl;
      var $0=$ls_addr;
      var $L1=(($0+40)|0);
      var $1=HEAP32[(($L1)>>2)];
      $L=$1;
      var $2=$ls_addr;
      var $fs2=(($2+36)|0);
      var $3=HEAP32[(($fs2)>>2)];
      var $4=$fs_addr;
      var $prev=(($4+8)|0);
      HEAP32[(($prev)>>2)]=$3;
      var $5=$ls_addr;
      var $6=$fs_addr;
      var $ls3=(($6+12)|0);
      HEAP32[(($ls3)>>2)]=$5;
      var $7=$fs_addr;
      var $8=$ls_addr;
      var $fs4=(($8+36)|0);
      HEAP32[(($fs4)>>2)]=$7;
      var $9=$fs_addr;
      var $pc=(($9+20)|0);
      HEAP32[(($pc)>>2)]=0;
      var $10=$fs_addr;
      var $lasttarget=(($10+24)|0);
      HEAP32[(($lasttarget)>>2)]=0;
      var $11=$fs_addr;
      var $jpc=(($11+28)|0);
      HEAP32[(($jpc)>>2)]=-1;
      var $12=$fs_addr;
      var $freereg=(($12+48)|0);
      HEAP8[($freereg)]=0;
      var $13=$fs_addr;
      var $nk=(($13+32)|0);
      HEAP32[(($nk)>>2)]=0;
      var $14=$fs_addr;
      var $np=(($14+36)|0);
      HEAP32[(($np)>>2)]=0;
      var $15=$fs_addr;
      var $nups=(($15+47)|0);
      HEAP8[($nups)]=0;
      var $16=$fs_addr;
      var $nlocvars=(($16+44)|0);
      HEAP16[(($nlocvars)>>1)]=0;
      var $17=$fs_addr;
      var $nactvar=(($17+46)|0);
      HEAP8[($nactvar)]=0;
      var $18=$ls_addr;
      var $dyd=(($18+52)|0);
      var $19=HEAP32[(($dyd)>>2)];
      var $actvar=(($19)|0);
      var $n=(($actvar+4)|0);
      var $20=HEAP32[(($n)>>2)];
      var $21=$fs_addr;
      var $firstlocal=(($21+40)|0);
      HEAP32[(($firstlocal)>>2)]=$20;
      var $22=$fs_addr;
      var $bl5=(($22+16)|0);
      HEAP32[(($bl5)>>2)]=0;
      var $23=$fs_addr;
      var $f6=(($23)|0);
      var $24=HEAP32[(($f6)>>2)];
      $f=$24;
      var $25=$ls_addr;
      var $source=(($25+56)|0);
      var $26=HEAP32[(($source)>>2)];
      var $27=$f;
      var $source7=(($27+36)|0);
      HEAP32[(($source7)>>2)]=$26;
      var $28=$f;
      var $maxstacksize=(($28+78)|0);
      HEAP8[($maxstacksize)]=2;
      var $29=$L;
      var $call=_luaH_new($29);
      var $30=$fs_addr;
      var $h=(($30+4)|0);
      HEAP32[(($h)>>2)]=$call;
      var $31=$L;
      var $top=(($31+8)|0);
      var $32=HEAP32[(($top)>>2)];
      $io=$32;
      var $33=$fs_addr;
      var $h8=(($33+4)|0);
      var $34=HEAP32[(($h8)>>2)];
      var $35=$34;
      var $36=$io;
      var $value_=(($36)|0);
      var $gc=$value_;
      HEAP32[(($gc)>>2)]=$35;
      var $37=$io;
      var $tt_=(($37+8)|0);
      HEAP32[(($tt_)>>2)]=69;
      var $38=$L;
      var $top9=(($38+8)|0);
      var $39=HEAP32[(($top9)>>2)];
      var $incdec_ptr=(($39+12)|0);
      HEAP32[(($top9)>>2)]=$incdec_ptr;
      var $40=$L;
      var $stack_last=(($40+24)|0);
      var $41=HEAP32[(($stack_last)>>2)];
      var $42=$L;
      var $top10=(($42+8)|0);
      var $43=HEAP32[(($top10)>>2)];
      var $sub_ptr_lhs_cast=$41;
      var $sub_ptr_rhs_cast=$43;
      var $sub_ptr_sub=((($sub_ptr_lhs_cast)-($sub_ptr_rhs_cast))|0);
      var $sub_ptr_div=((((($sub_ptr_sub)|0))/(12))&-1);
      var $cmp=(($sub_ptr_div)|0) <= 0;
      if ($cmp) { label = 3; break; } else { label = 4; break; }
    case 3: 
      var $44=$L;
      _luaD_growstack($44, 0);
      label = 5; break;
    case 4: 
      label = 5; break;
    case 5: 
      var $45=$fs_addr;
      var $46=$bl_addr;
      _enterblock($45, $46, 0);

      Module.print(INDENT + 'Exiting: _open_func');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_open_func["X"]=1;

function _newupvalue($fs, $name, $v) {
  var label = 0;

  Module.print(INDENT + ' Entering: _newupvalue: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $fs_addr;
      var $name_addr;
      var $v_addr;
      var $f;
      var $oldsize;
      $fs_addr=$fs;
      $name_addr=$name;
      $v_addr=$v;
      var $0=$fs_addr;
      var $f1=(($0)|0);
      var $1=HEAP32[(($f1)>>2)];
      $f=$1;
      var $2=$f;
      var $sizeupvalues=(($2+40)|0);
      var $3=HEAP32[(($sizeupvalues)>>2)];
      $oldsize=$3;
      var $4=$fs_addr;
      var $5=$fs_addr;
      var $nups=(($5+47)|0);
      var $6=HEAP8[($nups)];
      var $conv=(($6)&255);
      var $add=((($conv)+(1))|0);
      _checklimit($4, $add, 255, ((5245448)|0));
      var $7=$fs_addr;
      var $nups2=(($7+47)|0);
      var $8=HEAP8[($nups2)];
      var $conv3=(($8)&255);
      var $add4=((($conv3)+(1))|0);
      var $9=$f;
      var $sizeupvalues5=(($9+40)|0);
      var $10=HEAP32[(($sizeupvalues5)>>2)];
      var $cmp=(($add4)|0) > (($10)|0);
      if ($cmp) { label = 3; break; } else { label = 4; break; }
    case 3: 
      var $11=$fs_addr;
      var $ls=(($11+12)|0);
      var $12=HEAP32[(($ls)>>2)];
      var $L=(($12+40)|0);
      var $13=HEAP32[(($L)>>2)];
      var $14=$f;
      var $upvalues=(($14+28)|0);
      var $15=HEAP32[(($upvalues)>>2)];
      var $16=$15;
      var $17=$f;
      var $sizeupvalues7=(($17+40)|0);
      var $call=_luaM_growaux_($13, $16, $sizeupvalues7, 8, 255, ((5245448)|0));
      var $18=$call;
      var $19=$f;
      var $upvalues8=(($19+28)|0);
      HEAP32[(($upvalues8)>>2)]=$18;
      label = 4; break;
    case 4: 
      label = 5; break;
    case 5: 
      var $20=$oldsize;
      var $21=$f;
      var $sizeupvalues9=(($21+40)|0);
      var $22=HEAP32[(($sizeupvalues9)>>2)];
      var $cmp10=(($20)|0) < (($22)|0);
      if ($cmp10) { label = 6; break; } else { label = 7; break; }
    case 6: 
      var $23=$oldsize;
      var $inc=((($23)+(1))|0);
      $oldsize=$inc;
      var $24=$f;
      var $upvalues12=(($24+28)|0);
      var $25=HEAP32[(($upvalues12)>>2)];
      var $arrayidx=(($25+($23<<3))|0);
      var $name13=(($arrayidx)|0);
      HEAP32[(($name13)>>2)]=0;
      label = 5; break;
    case 7: 
      var $26=$v_addr;
      var $k=(($26)|0);
      var $27=HEAP32[(($k)>>2)];
      var $cmp14=(($27)|0)==7;
      var $conv15=(($cmp14)&1);
      var $conv16=(($conv15) & 255);
      var $28=$fs_addr;
      var $nups17=(($28+47)|0);
      var $29=HEAP8[($nups17)];
      var $idxprom=(($29)&255);
      var $30=$f;
      var $upvalues18=(($30+28)|0);
      var $31=HEAP32[(($upvalues18)>>2)];
      var $arrayidx19=(($31+($idxprom<<3))|0);
      var $instack=(($arrayidx19+4)|0);
      HEAP8[($instack)]=$conv16;
      var $32=$v_addr;
      var $u=(($32+4)|0);
      var $info=$u;
      var $33=HEAP32[(($info)>>2)];
      var $conv20=(($33) & 255);
      var $34=$fs_addr;
      var $nups21=(($34+47)|0);
      var $35=HEAP8[($nups21)];
      var $idxprom22=(($35)&255);
      var $36=$f;
      var $upvalues23=(($36+28)|0);
      var $37=HEAP32[(($upvalues23)>>2)];
      var $arrayidx24=(($37+($idxprom22<<3))|0);
      var $idx=(($arrayidx24+5)|0);
      HEAP8[($idx)]=$conv20;
      var $38=$name_addr;
      var $39=$fs_addr;
      var $nups25=(($39+47)|0);
      var $40=HEAP8[($nups25)];
      var $idxprom26=(($40)&255);
      var $41=$f;
      var $upvalues27=(($41+28)|0);
      var $42=HEAP32[(($upvalues27)>>2)];
      var $arrayidx28=(($42+($idxprom26<<3))|0);
      var $name29=(($arrayidx28)|0);
      HEAP32[(($name29)>>2)]=$38;
      var $43=$name_addr;
      var $44=$43;
      var $gch=$44;
      var $marked=(($gch+5)|0);
      var $45=HEAP8[($marked)];
      var $conv30=(($45)&255);
      var $and=$conv30 & 3;
      var $tobool=(($and)|0)!=0;
      if ($tobool) { label = 8; break; } else { label = 10; break; }
    case 8: 
      var $46=$f;
      var $47=$46;
      var $gch31=$47;
      var $marked32=(($gch31+5)|0);
      var $48=HEAP8[($marked32)];
      var $conv33=(($48)&255);
      var $and34=$conv33 & 4;
      var $tobool35=(($and34)|0)!=0;
      if ($tobool35) { label = 9; break; } else { label = 10; break; }
    case 9: 
      var $49=$fs_addr;
      var $ls37=(($49+12)|0);
      var $50=HEAP32[(($ls37)>>2)];
      var $L38=(($50+40)|0);
      var $51=HEAP32[(($L38)>>2)];
      var $52=$f;
      var $53=$52;
      var $54=$name_addr;
      var $55=$54;
      _luaC_barrier_($51, $53, $55);
      label = 10; break;
    case 10: 
      var $56=$fs_addr;
      var $nups40=(($56+47)|0);
      var $57=HEAP8[($nups40)];
      var $inc41=((($57)+(1))&255);
      HEAP8[($nups40)]=$inc41;
      var $conv42=(($57)&255);

      Module.print(INDENT + 'Exiting: _newupvalue');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return $conv42;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_newupvalue["X"]=1;

function _statlist($ls) {
  var label = 0;

  Module.print(INDENT + ' Entering: _statlist: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $ls_addr;
      $ls_addr=$ls;
      label = 3; break;
    case 3: 
      var $0=$ls_addr;
      var $call=_block_follow($0, 1);
      var $tobool=(($call)|0)!=0;
      var $lnot=$tobool ^ 1;
      if ($lnot) { label = 4; break; } else { label = 7; break; }
    case 4: 
      var $1=$ls_addr;
      var $t=(($1+12)|0);
      var $token=(($t)|0);
      var $2=HEAP32[(($token)>>2)];
      var $cmp=(($2)|0)==274;
      if ($cmp) { label = 5; break; } else { label = 6; break; }
    case 5: 
      var $3=$ls_addr;
      _statement($3);
      label = 7; break;
    case 6: 
      var $4=$ls_addr;
      _statement($4);
      label = 3; break;
    case 7: 

      Module.print(INDENT + 'Exiting: _statlist');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _anchor_token($ls) {
  var label = 0;

  Module.print(INDENT + ' Entering: _anchor_token: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $ls_addr;
      var $ts;
      $ls_addr=$ls;
      var $0=$ls_addr;
      var $t=(($0+12)|0);
      var $token=(($t)|0);
      var $1=HEAP32[(($token)>>2)];
      var $cmp=(($1)|0)==288;
      if ($cmp) { label = 4; break; } else { label = 3; break; }
    case 3: 
      var $2=$ls_addr;
      var $t1=(($2+12)|0);
      var $token2=(($t1)|0);
      var $3=HEAP32[(($token2)>>2)];
      var $cmp3=(($3)|0)==289;
      if ($cmp3) { label = 4; break; } else { label = 5; break; }
    case 4: 
      var $4=$ls_addr;
      var $t4=(($4+12)|0);
      var $seminfo=(($t4+4)|0);
      var $ts5=$seminfo;
      var $5=HEAP32[(($ts5)>>2)];
      $ts=$5;
      var $6=$ls_addr;
      var $7=$ts;
      var $add_ptr=(($7+16)|0);
      var $8=$add_ptr;
      var $9=$ts;
      var $tsv=$9;
      var $len=(($tsv+12)|0);
      var $10=HEAP32[(($len)>>2)];
      var $call=_luaX_newstring($6, $8, $10);
      label = 5; break;
    case 5: 

      Module.print(INDENT + 'Exiting: _anchor_token');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _breaklabel($ls) {
  var label = 0;

  Module.print(INDENT + ' Entering: _breaklabel: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';

  var $ls_addr;
  var $n;
  var $l;
  $ls_addr=$ls;
  var $0=$ls_addr;
  var $L=(($0+40)|0);
  var $1=HEAP32[(($L)>>2)];
  var $call=_luaS_new($1, ((5245348)|0));
  $n=$call;
  var $2=$ls_addr;
  var $3=$ls_addr;
  var $dyd=(($3+52)|0);
  var $4=HEAP32[(($dyd)>>2)];
  var $label=(($4+24)|0);
  var $5=$n;
  var $6=$ls_addr;
  var $fs=(($6+36)|0);
  var $7=HEAP32[(($fs)>>2)];
  var $pc=(($7+20)|0);
  var $8=HEAP32[(($pc)>>2)];
  var $call1=_newlabelentry($2, $label, $5, 0, $8);
  $l=$call1;
  var $9=$ls_addr;
  var $10=$l;
  var $11=$ls_addr;
  var $dyd2=(($11+52)|0);
  var $12=HEAP32[(($dyd2)>>2)];
  var $label3=(($12+24)|0);
  var $arr=(($label3)|0);
  var $13=HEAP32[(($arr)>>2)];
  var $arrayidx=(($13+($10<<4))|0);
  _findgotos($9, $arrayidx);

  Module.print(INDENT + 'Exiting: _breaklabel');
  INDENT = INDENT.substr(0, INDENT.length-2);
  return;
  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _removevars($fs, $tolevel) {
  var label = 0;

  Module.print(INDENT + ' Entering: _removevars: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $fs_addr;
      var $tolevel_addr;
      $fs_addr=$fs;
      $tolevel_addr=$tolevel;
      var $0=$fs_addr;
      var $nactvar=(($0+46)|0);
      var $1=HEAP8[($nactvar)];
      var $conv=(($1)&255);
      var $2=$tolevel_addr;
      var $sub=((($conv)-($2))|0);
      var $3=$fs_addr;
      var $ls=(($3+12)|0);
      var $4=HEAP32[(($ls)>>2)];
      var $dyd=(($4+52)|0);
      var $5=HEAP32[(($dyd)>>2)];
      var $actvar=(($5)|0);
      var $n=(($actvar+4)|0);
      var $6=HEAP32[(($n)>>2)];
      var $sub1=((($6)-($sub))|0);
      HEAP32[(($n)>>2)]=$sub1;
      label = 3; break;
    case 3: 
      var $7=$fs_addr;
      var $nactvar2=(($7+46)|0);
      var $8=HEAP8[($nactvar2)];
      var $conv3=(($8)&255);
      var $9=$tolevel_addr;
      var $cmp=(($conv3)|0) > (($9)|0);
      if ($cmp) { label = 4; break; } else { label = 5; break; }
    case 4: 
      var $10=$fs_addr;
      var $pc=(($10+20)|0);
      var $11=HEAP32[(($pc)>>2)];
      var $12=$fs_addr;
      var $13=$fs_addr;
      var $nactvar5=(($13+46)|0);
      var $14=HEAP8[($nactvar5)];
      var $dec=((($14)-(1))&255);
      HEAP8[($nactvar5)]=$dec;
      var $conv6=(($dec)&255);
      var $call=_getlocvar($12, $conv6);
      var $endpc=(($call+8)|0);
      HEAP32[(($endpc)>>2)]=$11;
      label = 3; break;
    case 5: 

      Module.print(INDENT + 'Exiting: _removevars');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _check($ls, $c) {
  var label = 0;

  Module.print(INDENT + ' Entering: _check: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $ls_addr;
      var $c_addr;
      $ls_addr=$ls;
      $c_addr=$c;
      var $0=$ls_addr;
      var $t=(($0+12)|0);
      var $token=(($t)|0);
      var $1=HEAP32[(($token)>>2)];
      var $2=$c_addr;
      var $cmp=(($1)|0)!=(($2)|0);
      if ($cmp) { label = 3; break; } else { label = 4; break; }
    case 3: 
      var $3=$ls_addr;
      var $4=$c_addr;
      _error_expected($3, $4);

    case 4: 

      Module.print(INDENT + 'Exiting: _check');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _close_func($ls) {
  var label = 0;

  Module.print(INDENT + ' Entering: _close_func: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $ls_addr;
      var $L;
      var $fs;
      var $f;
      $ls_addr=$ls;
      var $0=$ls_addr;
      var $L1=(($0+40)|0);
      var $1=HEAP32[(($L1)>>2)];
      $L=$1;
      var $2=$ls_addr;
      var $fs2=(($2+36)|0);
      var $3=HEAP32[(($fs2)>>2)];
      $fs=$3;
      var $4=$fs;
      var $f3=(($4)|0);
      var $5=HEAP32[(($f3)>>2)];
      $f=$5;
      var $6=$fs;
      _luaK_ret($6, 0, 0);
      var $7=$fs;
      _leaveblock($7);
      var $8=$fs;
      var $pc=(($8+20)|0);
      var $9=HEAP32[(($pc)>>2)];
      var $add=((($9)+(1))|0);
      var $cmp=(($add)>>>0) > 1073741823;
      if ($cmp) { label = 3; break; } else { label = 4; break; }
    case 3: 
      var $10=$L;
      _luaM_toobig($10);

      label = 5; break;
    case 4: 
      var $12=$L;
      var $13=$f;
      var $code=(($13+12)|0);
      var $14=HEAP32[(($code)>>2)];
      var $15=$14;
      var $16=$f;
      var $sizecode=(($16+48)|0);
      var $17=HEAP32[(($sizecode)>>2)];
      var $mul=($17<<2);
      var $18=$fs;
      var $pc4=(($18+20)|0);
      var $19=HEAP32[(($pc4)>>2)];
      var $mul5=($19<<2);
      var $call=_luaM_realloc_($12, $15, $mul, $mul5);
      var $cond = $call;label = 5; break;
    case 5: 
      var $cond;
      var $20=$cond;
      var $21=$f;
      var $code6=(($21+12)|0);
      HEAP32[(($code6)>>2)]=$20;
      var $22=$fs;
      var $pc7=(($22+20)|0);
      var $23=HEAP32[(($pc7)>>2)];
      var $24=$f;
      var $sizecode8=(($24+48)|0);
      HEAP32[(($sizecode8)>>2)]=$23;
      var $25=$fs;
      var $pc9=(($25+20)|0);
      var $26=HEAP32[(($pc9)>>2)];
      var $add10=((($26)+(1))|0);
      var $cmp11=(($add10)>>>0) > 1073741823;
      if ($cmp11) { label = 6; break; } else { label = 7; break; }
    case 6: 
      var $27=$L;
      _luaM_toobig($27);

      label = 8; break;
    case 7: 
      var $29=$L;
      var $30=$f;
      var $lineinfo=(($30+20)|0);
      var $31=HEAP32[(($lineinfo)>>2)];
      var $32=$31;
      var $33=$f;
      var $sizelineinfo=(($33+52)|0);
      var $34=HEAP32[(($sizelineinfo)>>2)];
      var $mul14=($34<<2);
      var $35=$fs;
      var $pc15=(($35+20)|0);
      var $36=HEAP32[(($pc15)>>2)];
      var $mul16=($36<<2);
      var $call17=_luaM_realloc_($29, $32, $mul14, $mul16);
      var $cond19 = $call17;label = 8; break;
    case 8: 
      var $cond19;
      var $37=$cond19;
      var $38=$f;
      var $lineinfo20=(($38+20)|0);
      HEAP32[(($lineinfo20)>>2)]=$37;
      var $39=$fs;
      var $pc21=(($39+20)|0);
      var $40=HEAP32[(($pc21)>>2)];
      var $41=$f;
      var $sizelineinfo22=(($41+52)|0);
      HEAP32[(($sizelineinfo22)>>2)]=$40;
      var $42=$fs;
      var $nk=(($42+32)|0);
      var $43=HEAP32[(($nk)>>2)];
      var $add23=((($43)+(1))|0);
      var $cmp24=(($add23)>>>0) > 357913941;
      if ($cmp24) { label = 9; break; } else { label = 10; break; }
    case 9: 
      var $44=$L;
      _luaM_toobig($44);

      label = 11; break;
    case 10: 
      var $46=$L;
      var $47=$f;
      var $k=(($47+8)|0);
      var $48=HEAP32[(($k)>>2)];
      var $49=$48;
      var $50=$f;
      var $sizek=(($50+44)|0);
      var $51=HEAP32[(($sizek)>>2)];
      var $mul27=((($51)*(12))&-1);
      var $52=$fs;
      var $nk28=(($52+32)|0);
      var $53=HEAP32[(($nk28)>>2)];
      var $mul29=((($53)*(12))&-1);
      var $call30=_luaM_realloc_($46, $49, $mul27, $mul29);
      var $cond32 = $call30;label = 11; break;
    case 11: 
      var $cond32;
      var $54=$cond32;
      var $55=$f;
      var $k33=(($55+8)|0);
      HEAP32[(($k33)>>2)]=$54;
      var $56=$fs;
      var $nk34=(($56+32)|0);
      var $57=HEAP32[(($nk34)>>2)];
      var $58=$f;
      var $sizek35=(($58+44)|0);
      HEAP32[(($sizek35)>>2)]=$57;
      var $59=$fs;
      var $np=(($59+36)|0);
      var $60=HEAP32[(($np)>>2)];
      var $add36=((($60)+(1))|0);
      var $cmp37=(($add36)>>>0) > 1073741823;
      if ($cmp37) { label = 12; break; } else { label = 13; break; }
    case 12: 
      var $61=$L;
      _luaM_toobig($61);

      label = 14; break;
    case 13: 
      var $63=$L;
      var $64=$f;
      var $p=(($64+16)|0);
      var $65=HEAP32[(($p)>>2)];
      var $66=$65;
      var $67=$f;
      var $sizep=(($67+56)|0);
      var $68=HEAP32[(($sizep)>>2)];
      var $mul40=($68<<2);
      var $69=$fs;
      var $np41=(($69+36)|0);
      var $70=HEAP32[(($np41)>>2)];
      var $mul42=($70<<2);
      var $call43=_luaM_realloc_($63, $66, $mul40, $mul42);
      var $cond45 = $call43;label = 14; break;
    case 14: 
      var $cond45;
      var $71=$cond45;
      var $72=$f;
      var $p46=(($72+16)|0);
      HEAP32[(($p46)>>2)]=$71;
      var $73=$fs;
      var $np47=(($73+36)|0);
      var $74=HEAP32[(($np47)>>2)];
      var $75=$f;
      var $sizep48=(($75+56)|0);
      HEAP32[(($sizep48)>>2)]=$74;
      var $76=$fs;
      var $nlocvars=(($76+44)|0);
      var $77=HEAP16[(($nlocvars)>>1)];
      var $conv=(($77 << 16) >> 16);
      var $add49=((($conv)+(1))|0);
      var $cmp50=(($add49)>>>0) > 357913941;
      if ($cmp50) { label = 15; break; } else { label = 16; break; }
    case 15: 
      var $78=$L;
      _luaM_toobig($78);

      label = 17; break;
    case 16: 
      var $80=$L;
      var $81=$f;
      var $locvars=(($81+24)|0);
      var $82=HEAP32[(($locvars)>>2)];
      var $83=$82;
      var $84=$f;
      var $sizelocvars=(($84+60)|0);
      var $85=HEAP32[(($sizelocvars)>>2)];
      var $mul54=((($85)*(12))&-1);
      var $86=$fs;
      var $nlocvars55=(($86+44)|0);
      var $87=HEAP16[(($nlocvars55)>>1)];
      var $conv56=(($87 << 16) >> 16);
      var $mul57=((($conv56)*(12))&-1);
      var $call58=_luaM_realloc_($80, $83, $mul54, $mul57);
      var $cond60 = $call58;label = 17; break;
    case 17: 
      var $cond60;
      var $88=$cond60;
      var $89=$f;
      var $locvars61=(($89+24)|0);
      HEAP32[(($locvars61)>>2)]=$88;
      var $90=$fs;
      var $nlocvars62=(($90+44)|0);
      var $91=HEAP16[(($nlocvars62)>>1)];
      var $conv63=(($91 << 16) >> 16);
      var $92=$f;
      var $sizelocvars64=(($92+60)|0);
      HEAP32[(($sizelocvars64)>>2)]=$conv63;
      var $93=$fs;
      var $nups=(($93+47)|0);
      var $94=HEAP8[($nups)];
      var $conv65=(($94)&255);
      var $add66=((($conv65)+(1))|0);
      var $cmp67=(($add66)>>>0) > 536870911;
      if ($cmp67) { label = 18; break; } else { label = 19; break; }
    case 18: 
      var $95=$L;
      _luaM_toobig($95);

      label = 20; break;
    case 19: 
      var $97=$L;
      var $98=$f;
      var $upvalues=(($98+28)|0);
      var $99=HEAP32[(($upvalues)>>2)];
      var $100=$99;
      var $101=$f;
      var $sizeupvalues=(($101+40)|0);
      var $102=HEAP32[(($sizeupvalues)>>2)];
      var $mul71=($102<<3);
      var $103=$fs;
      var $nups72=(($103+47)|0);
      var $104=HEAP8[($nups72)];
      var $conv73=(($104)&255);
      var $mul74=($conv73<<3);
      var $call75=_luaM_realloc_($97, $100, $mul71, $mul74);
      var $cond77 = $call75;label = 20; break;
    case 20: 
      var $cond77;
      var $105=$cond77;
      var $106=$f;
      var $upvalues78=(($106+28)|0);
      HEAP32[(($upvalues78)>>2)]=$105;
      var $107=$fs;
      var $nups79=(($107+47)|0);
      var $108=HEAP8[($nups79)];
      var $conv80=(($108)&255);
      var $109=$f;
      var $sizeupvalues81=(($109+40)|0);
      HEAP32[(($sizeupvalues81)>>2)]=$conv80;
      var $110=$fs;
      var $prev=(($110+8)|0);
      var $111=HEAP32[(($prev)>>2)];
      var $112=$ls_addr;
      var $fs82=(($112+36)|0);
      HEAP32[(($fs82)>>2)]=$111;
      var $113=$ls_addr;
      _anchor_token($113);
      var $114=$L;
      var $top=(($114+8)|0);
      var $115=HEAP32[(($top)>>2)];
      var $incdec_ptr=((($115)-(12))|0);
      HEAP32[(($top)>>2)]=$incdec_ptr;
      var $116=$L;
      var $l_G=(($116+12)|0);
      var $117=HEAP32[(($l_G)>>2)];
      var $GCdebt=(($117+12)|0);
      var $118=HEAP32[(($GCdebt)>>2)];
      var $cmp83=(($118)|0) > 0;
      if ($cmp83) { label = 21; break; } else { label = 22; break; }
    case 21: 
      var $119=$L;
      _luaC_step($119);
      label = 22; break;
    case 22: 

      Module.print(INDENT + 'Exiting: _close_func');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_close_func["X"]=1;

function _leaveblock($fs) {
  var label = 0;

  Module.print(INDENT + ' Entering: _leaveblock: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $fs_addr;
      var $bl;
      var $ls;
      var $j;
      $fs_addr=$fs;
      var $0=$fs_addr;
      var $bl1=(($0+16)|0);
      var $1=HEAP32[(($bl1)>>2)];
      $bl=$1;
      var $2=$fs_addr;
      var $ls2=(($2+12)|0);
      var $3=HEAP32[(($ls2)>>2)];
      $ls=$3;
      var $4=$bl;
      var $previous=(($4)|0);
      var $5=HEAP32[(($previous)>>2)];
      var $tobool=(($5)|0)!=0;
      if ($tobool) { label = 3; break; } else { label = 5; break; }
    case 3: 
      var $6=$bl;
      var $upval=(($6+9)|0);
      var $7=HEAP8[($upval)];
      var $conv=(($7)&255);
      var $tobool3=(($conv)|0)!=0;
      if ($tobool3) { label = 4; break; } else { label = 5; break; }
    case 4: 
      var $8=$fs_addr;
      var $call=_luaK_jump($8);
      $j=$call;
      var $9=$fs_addr;
      var $10=$j;
      var $11=$bl;
      var $nactvar=(($11+8)|0);
      var $12=HEAP8[($nactvar)];
      var $conv4=(($12)&255);
      _luaK_patchclose($9, $10, $conv4);
      var $13=$fs_addr;
      var $14=$j;
      _luaK_patchtohere($13, $14);
      label = 5; break;
    case 5: 
      var $15=$bl;
      var $isloop=(($15+10)|0);
      var $16=HEAP8[($isloop)];
      var $tobool5=(($16 << 24) >> 24)!=0;
      if ($tobool5) { label = 6; break; } else { label = 7; break; }
    case 6: 
      var $17=$ls;
      _breaklabel($17);
      label = 7; break;
    case 7: 
      var $18=$bl;
      var $previous8=(($18)|0);
      var $19=HEAP32[(($previous8)>>2)];
      var $20=$fs_addr;
      var $bl9=(($20+16)|0);
      HEAP32[(($bl9)>>2)]=$19;
      var $21=$fs_addr;
      var $22=$bl;
      var $nactvar10=(($22+8)|0);
      var $23=HEAP8[($nactvar10)];
      var $conv11=(($23)&255);
      _removevars($21, $conv11);
      var $24=$fs_addr;
      var $nactvar12=(($24+46)|0);
      var $25=HEAP8[($nactvar12)];
      var $26=$fs_addr;
      var $freereg=(($26+48)|0);
      HEAP8[($freereg)]=$25;
      var $27=$bl;
      var $firstlabel=(($27+4)|0);
      var $28=HEAP16[(($firstlabel)>>1)];
      var $conv13=(($28 << 16) >> 16);
      var $29=$ls;
      var $dyd=(($29+52)|0);
      var $30=HEAP32[(($dyd)>>2)];
      var $label=(($30+24)|0);
      var $n=(($label+4)|0);
      HEAP32[(($n)>>2)]=$conv13;
      var $31=$bl;
      var $previous14=(($31)|0);
      var $32=HEAP32[(($previous14)>>2)];
      var $tobool15=(($32)|0)!=0;
      if ($tobool15) { label = 8; break; } else { label = 9; break; }
    case 8: 
      var $33=$fs_addr;
      var $34=$bl;
      _movegotosout($33, $34);
      label = 12; break;
    case 9: 
      var $35=$bl;
      var $firstgoto=(($35+6)|0);
      var $36=HEAP16[(($firstgoto)>>1)];
      var $conv17=(($36 << 16) >> 16);
      var $37=$ls;
      var $dyd18=(($37+52)|0);
      var $38=HEAP32[(($dyd18)>>2)];
      var $gt=(($38+12)|0);
      var $n19=(($gt+4)|0);
      var $39=HEAP32[(($n19)>>2)];
      var $cmp=(($conv17)|0) < (($39)|0);
      if ($cmp) { label = 10; break; } else { label = 11; break; }
    case 10: 
      var $40=$ls;
      var $41=$bl;
      var $firstgoto22=(($41+6)|0);
      var $42=HEAP16[(($firstgoto22)>>1)];
      var $idxprom=(($42 << 16) >> 16);
      var $43=$ls;
      var $dyd23=(($43+52)|0);
      var $44=HEAP32[(($dyd23)>>2)];
      var $gt24=(($44+12)|0);
      var $arr=(($gt24)|0);
      var $45=HEAP32[(($arr)>>2)];
      var $arrayidx=(($45+($idxprom<<4))|0);
      _undefgoto($40, $arrayidx);

    case 11: 
      label = 12; break;
    case 12: 

      Module.print(INDENT + 'Exiting: _leaveblock');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_leaveblock["X"]=1;

function _getlocvar($fs, $i) {
  var label = 0;

  Module.print(INDENT + ' Entering: _getlocvar: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';

  var $fs_addr;
  var $i_addr;
  var $idx;
  $fs_addr=$fs;
  $i_addr=$i;
  var $0=$fs_addr;
  var $firstlocal=(($0+40)|0);
  var $1=HEAP32[(($firstlocal)>>2)];
  var $2=$i_addr;
  var $add=((($1)+($2))|0);
  var $3=$fs_addr;
  var $ls=(($3+12)|0);
  var $4=HEAP32[(($ls)>>2)];
  var $dyd=(($4+52)|0);
  var $5=HEAP32[(($dyd)>>2)];
  var $actvar=(($5)|0);
  var $arr=(($actvar)|0);
  var $6=HEAP32[(($arr)>>2)];
  var $arrayidx=(($6+($add<<1))|0);
  var $idx1=(($arrayidx)|0);
  var $7=HEAP16[(($idx1)>>1)];
  var $conv=(($7 << 16) >> 16);
  $idx=$conv;
  var $8=$idx;
  var $9=$fs_addr;
  var $f=(($9)|0);
  var $10=HEAP32[(($f)>>2)];
  var $locvars=(($10+24)|0);
  var $11=HEAP32[(($locvars)>>2)];
  var $arrayidx2=(($11+((($8)*(12))&-1))|0);

  Module.print(INDENT + 'Exiting: _getlocvar');
  INDENT = INDENT.substr(0, INDENT.length-2);
  return $arrayidx2;
  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _block_follow($ls, $withuntil) {
  var label = 0;

  Module.print(INDENT + ' Entering: _block_follow: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $retval;
      var $ls_addr;
      var $withuntil_addr;
      $ls_addr=$ls;
      $withuntil_addr=$withuntil;
      var $0=$ls_addr;
      var $t=(($0+12)|0);
      var $token=(($t)|0);
      var $1=HEAP32[(($token)>>2)];
      if ((($1)|0)==260 | (($1)|0)==261 | (($1)|0)==262 | (($1)|0)==286) {
        label = 3; break;
      }
      else if ((($1)|0)==277) {
        label = 4; break;
      }
      else {
      label = 5; break;
      }
      
    case 3: 
      $retval=1;
      label = 6; break;
    case 4: 
      var $2=$withuntil_addr;
      $retval=$2;
      label = 6; break;
    case 5: 
      $retval=0;
      label = 6; break;
    case 6: 
      var $3=$retval;

      Module.print(INDENT + 'Exiting: _block_follow');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return $3;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _movegotosout($fs, $bl) {
  var label = 0;

  Module.print(INDENT + ' Entering: _movegotosout: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $fs_addr;
      var $bl_addr;
      var $i;
      var $gl;
      var $gt2;
      $fs_addr=$fs;
      $bl_addr=$bl;
      var $0=$bl_addr;
      var $firstgoto=(($0+6)|0);
      var $1=HEAP16[(($firstgoto)>>1)];
      var $conv=(($1 << 16) >> 16);
      $i=$conv;
      var $2=$fs_addr;
      var $ls=(($2+12)|0);
      var $3=HEAP32[(($ls)>>2)];
      var $dyd=(($3+52)|0);
      var $4=HEAP32[(($dyd)>>2)];
      var $gt=(($4+12)|0);
      $gl=$gt;
      label = 3; break;
    case 3: 
      var $5=$i;
      var $6=$gl;
      var $n=(($6+4)|0);
      var $7=HEAP32[(($n)>>2)];
      var $cmp=(($5)|0) < (($7)|0);
      if ($cmp) { label = 4; break; } else { label = 11; break; }
    case 4: 
      var $8=$i;
      var $9=$gl;
      var $arr=(($9)|0);
      var $10=HEAP32[(($arr)>>2)];
      var $arrayidx=(($10+($8<<4))|0);
      $gt2=$arrayidx;
      var $11=$gt2;
      var $nactvar=(($11+12)|0);
      var $12=HEAP8[($nactvar)];
      var $conv3=(($12)&255);
      var $13=$bl_addr;
      var $nactvar4=(($13+8)|0);
      var $14=HEAP8[($nactvar4)];
      var $conv5=(($14)&255);
      var $cmp6=(($conv3)|0) > (($conv5)|0);
      if ($cmp6) { label = 5; break; } else { label = 8; break; }
    case 5: 
      var $15=$bl_addr;
      var $upval=(($15+9)|0);
      var $16=HEAP8[($upval)];
      var $tobool=(($16 << 24) >> 24)!=0;
      if ($tobool) { label = 6; break; } else { label = 7; break; }
    case 6: 
      var $17=$fs_addr;
      var $18=$gt2;
      var $pc=(($18+4)|0);
      var $19=HEAP32[(($pc)>>2)];
      var $20=$bl_addr;
      var $nactvar9=(($20+8)|0);
      var $21=HEAP8[($nactvar9)];
      var $conv10=(($21)&255);
      _luaK_patchclose($17, $19, $conv10);
      label = 7; break;
    case 7: 
      var $22=$bl_addr;
      var $nactvar11=(($22+8)|0);
      var $23=HEAP8[($nactvar11)];
      var $24=$gt2;
      var $nactvar12=(($24+12)|0);
      HEAP8[($nactvar12)]=$23;
      label = 8; break;
    case 8: 
      var $25=$fs_addr;
      var $ls14=(($25+12)|0);
      var $26=HEAP32[(($ls14)>>2)];
      var $27=$i;
      var $call=_findlabel($26, $27);
      var $tobool15=(($call)|0)!=0;
      if ($tobool15) { label = 10; break; } else { label = 9; break; }
    case 9: 
      var $28=$i;
      var $inc=((($28)+(1))|0);
      $i=$inc;
      label = 10; break;
    case 10: 
      label = 3; break;
    case 11: 

      Module.print(INDENT + 'Exiting: _movegotosout');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_movegotosout["X"]=1;

function _findlabel($ls, $g) {
  var label = 0;

  Module.print(INDENT + ' Entering: _findlabel: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $retval;
      var $ls_addr;
      var $g_addr;
      var $i;
      var $bl;
      var $dyd;
      var $gt;
      var $lb;
      $ls_addr=$ls;
      $g_addr=$g;
      var $0=$ls_addr;
      var $fs=(($0+36)|0);
      var $1=HEAP32[(($fs)>>2)];
      var $bl1=(($1+16)|0);
      var $2=HEAP32[(($bl1)>>2)];
      $bl=$2;
      var $3=$ls_addr;
      var $dyd2=(($3+52)|0);
      var $4=HEAP32[(($dyd2)>>2)];
      $dyd=$4;
      var $5=$g_addr;
      var $6=$dyd;
      var $gt3=(($6+12)|0);
      var $arr=(($gt3)|0);
      var $7=HEAP32[(($arr)>>2)];
      var $arrayidx=(($7+($5<<4))|0);
      $gt=$arrayidx;
      var $8=$bl;
      var $firstlabel=(($8+4)|0);
      var $9=HEAP16[(($firstlabel)>>1)];
      var $conv=(($9 << 16) >> 16);
      $i=$conv;
      label = 3; break;
    case 3: 
      var $10=$i;
      var $11=$dyd;
      var $label=(($11+24)|0);
      var $n=(($label+4)|0);
      var $12=HEAP32[(($n)>>2)];
      var $cmp=(($10)|0) < (($12)|0);
      if ($cmp) { label = 4; break; } else { label = 12; break; }
    case 4: 
      var $13=$i;
      var $14=$dyd;
      var $label5=(($14+24)|0);
      var $arr6=(($label5)|0);
      var $15=HEAP32[(($arr6)>>2)];
      var $arrayidx7=(($15+($13<<4))|0);
      $lb=$arrayidx7;
      var $16=$lb;
      var $name=(($16)|0);
      var $17=HEAP32[(($name)>>2)];
      var $18=$gt;
      var $name8=(($18)|0);
      var $19=HEAP32[(($name8)>>2)];
      var $call=_luaS_eqstr($17, $19);
      var $tobool=(($call)|0)!=0;
      if ($tobool) { label = 5; break; } else { label = 10; break; }
    case 5: 
      var $20=$gt;
      var $nactvar=(($20+12)|0);
      var $21=HEAP8[($nactvar)];
      var $conv9=(($21)&255);
      var $22=$lb;
      var $nactvar10=(($22+12)|0);
      var $23=HEAP8[($nactvar10)];
      var $conv11=(($23)&255);
      var $cmp12=(($conv9)|0) > (($conv11)|0);
      if ($cmp12) { label = 6; break; } else { label = 9; break; }
    case 6: 
      var $24=$bl;
      var $upval=(($24+9)|0);
      var $25=HEAP8[($upval)];
      var $conv14=(($25)&255);
      var $tobool15=(($conv14)|0)!=0;
      if ($tobool15) { label = 8; break; } else { label = 7; break; }
    case 7: 
      var $26=$dyd;
      var $label16=(($26+24)|0);
      var $n17=(($label16+4)|0);
      var $27=HEAP32[(($n17)>>2)];
      var $28=$bl;
      var $firstlabel18=(($28+4)|0);
      var $29=HEAP16[(($firstlabel18)>>1)];
      var $conv19=(($29 << 16) >> 16);
      var $cmp20=(($27)|0) > (($conv19)|0);
      if ($cmp20) { label = 8; break; } else { label = 9; break; }
    case 8: 
      var $30=$ls_addr;
      var $fs23=(($30+36)|0);
      var $31=HEAP32[(($fs23)>>2)];
      var $32=$gt;
      var $pc=(($32+4)|0);
      var $33=HEAP32[(($pc)>>2)];
      var $34=$lb;
      var $nactvar24=(($34+12)|0);
      var $35=HEAP8[($nactvar24)];
      var $conv25=(($35)&255);
      _luaK_patchclose($31, $33, $conv25);
      label = 9; break;
    case 9: 
      var $36=$ls_addr;
      var $37=$g_addr;
      var $38=$lb;
      _closegoto($36, $37, $38);
      $retval=1;
      label = 13; break;
    case 10: 
      label = 11; break;
    case 11: 
      var $39=$i;
      var $inc=((($39)+(1))|0);
      $i=$inc;
      label = 3; break;
    case 12: 
      $retval=0;
      label = 13; break;
    case 13: 
      var $40=$retval;

      Module.print(INDENT + 'Exiting: _findlabel');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return $40;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_findlabel["X"]=1;

function _newlabelentry($ls, $l, $name, $line, $pc) {
  var label = 0;

  Module.print(INDENT + ' Entering: _newlabelentry: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $ls_addr;
      var $l_addr;
      var $name_addr;
      var $line_addr;
      var $pc_addr;
      var $n;
      $ls_addr=$ls;
      $l_addr=$l;
      $name_addr=$name;
      $line_addr=$line;
      $pc_addr=$pc;
      var $0=$l_addr;
      var $n1=(($0+4)|0);
      var $1=HEAP32[(($n1)>>2)];
      $n=$1;
      var $2=$n;
      var $add=((($2)+(1))|0);
      var $3=$l_addr;
      var $size=(($3+8)|0);
      var $4=HEAP32[(($size)>>2)];
      var $cmp=(($add)|0) > (($4)|0);
      if ($cmp) { label = 3; break; } else { label = 4; break; }
    case 3: 
      var $5=$ls_addr;
      var $L=(($5+40)|0);
      var $6=HEAP32[(($L)>>2)];
      var $7=$l_addr;
      var $arr=(($7)|0);
      var $8=HEAP32[(($arr)>>2)];
      var $9=$8;
      var $10=$l_addr;
      var $size2=(($10+8)|0);
      var $call=_luaM_growaux_($6, $9, $size2, 16, 32767, ((5245020)|0));
      var $11=$call;
      var $12=$l_addr;
      var $arr3=(($12)|0);
      HEAP32[(($arr3)>>2)]=$11;
      label = 4; break;
    case 4: 
      var $13=$name_addr;
      var $14=$n;
      var $15=$l_addr;
      var $arr4=(($15)|0);
      var $16=HEAP32[(($arr4)>>2)];
      var $arrayidx=(($16+($14<<4))|0);
      var $name5=(($arrayidx)|0);
      HEAP32[(($name5)>>2)]=$13;
      var $17=$line_addr;
      var $18=$n;
      var $19=$l_addr;
      var $arr6=(($19)|0);
      var $20=HEAP32[(($arr6)>>2)];
      var $arrayidx7=(($20+($18<<4))|0);
      var $line8=(($arrayidx7+8)|0);
      HEAP32[(($line8)>>2)]=$17;
      var $21=$ls_addr;
      var $fs=(($21+36)|0);
      var $22=HEAP32[(($fs)>>2)];
      var $nactvar=(($22+46)|0);
      var $23=HEAP8[($nactvar)];
      var $24=$n;
      var $25=$l_addr;
      var $arr9=(($25)|0);
      var $26=HEAP32[(($arr9)>>2)];
      var $arrayidx10=(($26+($24<<4))|0);
      var $nactvar11=(($arrayidx10+12)|0);
      HEAP8[($nactvar11)]=$23;
      var $27=$pc_addr;
      var $28=$n;
      var $29=$l_addr;
      var $arr12=(($29)|0);
      var $30=HEAP32[(($arr12)>>2)];
      var $arrayidx13=(($30+($28<<4))|0);
      var $pc14=(($arrayidx13+4)|0);
      HEAP32[(($pc14)>>2)]=$27;
      var $31=$l_addr;
      var $n15=(($31+4)|0);
      var $32=HEAP32[(($n15)>>2)];
      var $inc=((($32)+(1))|0);
      HEAP32[(($n15)>>2)]=$inc;
      var $33=$n;

      Module.print(INDENT + 'Exiting: _newlabelentry');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return $33;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_newlabelentry["X"]=1;

function _findgotos($ls, $lb) {
  var label = 0;

  Module.print(INDENT + ' Entering: _findgotos: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $ls_addr;
      var $lb_addr;
      var $gl;
      var $i;
      $ls_addr=$ls;
      $lb_addr=$lb;
      var $0=$ls_addr;
      var $dyd=(($0+52)|0);
      var $1=HEAP32[(($dyd)>>2)];
      var $gt=(($1+12)|0);
      $gl=$gt;
      var $2=$ls_addr;
      var $fs=(($2+36)|0);
      var $3=HEAP32[(($fs)>>2)];
      var $bl=(($3+16)|0);
      var $4=HEAP32[(($bl)>>2)];
      var $firstgoto=(($4+6)|0);
      var $5=HEAP16[(($firstgoto)>>1)];
      var $conv=(($5 << 16) >> 16);
      $i=$conv;
      label = 3; break;
    case 3: 
      var $6=$i;
      var $7=$gl;
      var $n=(($7+4)|0);
      var $8=HEAP32[(($n)>>2)];
      var $cmp=(($6)|0) < (($8)|0);
      if ($cmp) { label = 4; break; } else { label = 8; break; }
    case 4: 
      var $9=$i;
      var $10=$gl;
      var $arr=(($10)|0);
      var $11=HEAP32[(($arr)>>2)];
      var $arrayidx=(($11+($9<<4))|0);
      var $name=(($arrayidx)|0);
      var $12=HEAP32[(($name)>>2)];
      var $13=$lb_addr;
      var $name2=(($13)|0);
      var $14=HEAP32[(($name2)>>2)];
      var $call=_luaS_eqstr($12, $14);
      var $tobool=(($call)|0)!=0;
      if ($tobool) { label = 5; break; } else { label = 6; break; }
    case 5: 
      var $15=$ls_addr;
      var $16=$i;
      var $17=$lb_addr;
      _closegoto($15, $16, $17);
      label = 7; break;
    case 6: 
      var $18=$i;
      var $inc=((($18)+(1))|0);
      $i=$inc;
      label = 7; break;
    case 7: 
      label = 3; break;
    case 8: 

      Module.print(INDENT + 'Exiting: _findgotos');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_findgotos["X"]=1;

function _statement($ls) {
  var label = 0;

  Module.print(INDENT + ' Entering: _statement: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $ls_addr;
      var $line;
      $ls_addr=$ls;
      var $0=$ls_addr;
      var $linenumber=(($0+4)|0);
      var $1=HEAP32[(($linenumber)>>2)];
      $line=$1;
      var $2=$ls_addr;
      _enterlevel($2);
      var $3=$ls_addr;
      var $t=(($3+12)|0);
      var $token=(($t)|0);
      var $4=HEAP32[(($token)>>2)];
      if ((($4)|0)==59) {
        label = 3; break;
      }
      else if ((($4)|0)==267) {
        label = 4; break;
      }
      else if ((($4)|0)==278) {
        label = 5; break;
      }
      else if ((($4)|0)==259) {
        label = 6; break;
      }
      else if ((($4)|0)==264) {
        label = 7; break;
      }
      else if ((($4)|0)==273) {
        label = 8; break;
      }
      else if ((($4)|0)==265) {
        label = 9; break;
      }
      else if ((($4)|0)==269) {
        label = 10; break;
      }
      else if ((($4)|0)==285) {
        label = 14; break;
      }
      else if ((($4)|0)==274) {
        label = 15; break;
      }
      else if ((($4)|0)==258 | (($4)|0)==266) {
        label = 16; break;
      }
      else {
      label = 17; break;
      }
      
    case 3: 
      var $5=$ls_addr;
      _luaX_next($5);
      label = 18; break;
    case 4: 
      var $6=$ls_addr;
      var $7=$line;
      _ifstat($6, $7);
      label = 18; break;
    case 5: 
      var $8=$ls_addr;
      var $9=$line;
      _whilestat($8, $9);
      label = 18; break;
    case 6: 
      var $10=$ls_addr;
      _luaX_next($10);
      var $11=$ls_addr;
      _block($11);
      var $12=$ls_addr;
      var $13=$line;
      _check_match($12, 262, 259, $13);
      label = 18; break;
    case 7: 
      var $14=$ls_addr;
      var $15=$line;
      _forstat($14, $15);
      label = 18; break;
    case 8: 
      var $16=$ls_addr;
      var $17=$line;
      _repeatstat($16, $17);
      label = 18; break;
    case 9: 
      var $18=$ls_addr;
      var $19=$line;
      _funcstat($18, $19);
      label = 18; break;
    case 10: 
      var $20=$ls_addr;
      _luaX_next($20);
      var $21=$ls_addr;
      var $call=_testnext($21, 265);
      var $tobool=(($call)|0)!=0;
      if ($tobool) { label = 11; break; } else { label = 12; break; }
    case 11: 
      var $22=$ls_addr;
      _localfunc($22);
      label = 13; break;
    case 12: 
      var $23=$ls_addr;
      _localstat($23);
      label = 13; break;
    case 13: 
      label = 18; break;
    case 14: 
      var $24=$ls_addr;
      _luaX_next($24);
      var $25=$ls_addr;
      var $26=$ls_addr;
      var $call9=_str_checkname($26);
      var $27=$line;
      _labelstat($25, $call9, $27);
      label = 18; break;
    case 15: 
      var $28=$ls_addr;
      _luaX_next($28);
      var $29=$ls_addr;
      _retstat($29);
      label = 18; break;
    case 16: 
      var $30=$ls_addr;
      var $31=$ls_addr;
      var $fs=(($31+36)|0);
      var $32=HEAP32[(($fs)>>2)];
      var $call12=_luaK_jump($32);
      _gotostat($30, $call12);
      label = 18; break;
    case 17: 
      var $33=$ls_addr;
      _exprstat($33);
      label = 18; break;
    case 18: 
      var $34=$ls_addr;
      var $fs13=(($34+36)|0);
      var $35=HEAP32[(($fs13)>>2)];
      var $nactvar=(($35+46)|0);
      var $36=HEAP8[($nactvar)];
      var $37=$ls_addr;
      var $fs14=(($37+36)|0);
      var $38=HEAP32[(($fs14)>>2)];
      var $freereg=(($38+48)|0);
      HEAP8[($freereg)]=$36;
      var $39=$ls_addr;
      var $L=(($39+40)|0);
      var $40=HEAP32[(($L)>>2)];
      var $nCcalls=(($40+38)|0);
      var $41=HEAP16[(($nCcalls)>>1)];
      var $dec=((($41)-(1))&65535);
      HEAP16[(($nCcalls)>>1)]=$dec;

      Module.print(INDENT + 'Exiting: _statement');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_statement["X"]=1;

function _enterlevel($ls) {
  var label = 0;

  Module.print(INDENT + ' Entering: _enterlevel: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';

  var $ls_addr;
  var $L;
  $ls_addr=$ls;
  var $0=$ls_addr;
  var $L1=(($0+40)|0);
  var $1=HEAP32[(($L1)>>2)];
  $L=$1;
  var $2=$L;
  var $nCcalls=(($2+38)|0);
  var $3=HEAP16[(($nCcalls)>>1)];
  var $inc=((($3)+(1))&65535);
  HEAP16[(($nCcalls)>>1)]=$inc;
  var $4=$ls_addr;
  var $fs=(($4+36)|0);
  var $5=HEAP32[(($fs)>>2)];
  var $6=$L;
  var $nCcalls2=(($6+38)|0);
  var $7=HEAP16[(($nCcalls2)>>1)];
  var $conv=(($7)&65535);
  _checklimit($5, $conv, 200, ((5244452)|0));

  Module.print(INDENT + 'Exiting: _enterlevel');
  INDENT = INDENT.substr(0, INDENT.length-2);
  return;
  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _ifstat($ls, $line) {
  var label = 0;
  var __stackBase__  = STACKTOP; STACKTOP = (STACKTOP + 4)|0; _memset(__stackBase__, 0, 4);
  Module.print(INDENT + ' Entering: _ifstat: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $ls_addr;
      var $line_addr;
      var $fs;
      var $escapelist=__stackBase__;
      $ls_addr=$ls;
      $line_addr=$line;
      var $0=$ls_addr;
      var $fs1=(($0+36)|0);
      var $1=HEAP32[(($fs1)>>2)];
      $fs=$1;
      HEAP32[(($escapelist)>>2)]=-1;
      var $2=$ls_addr;
      _test_then_block($2, $escapelist);
      label = 3; break;
    case 3: 
      var $3=$ls_addr;
      var $t=(($3+12)|0);
      var $token=(($t)|0);
      var $4=HEAP32[(($token)>>2)];
      var $cmp=(($4)|0)==261;
      if ($cmp) { label = 4; break; } else { label = 5; break; }
    case 4: 
      var $5=$ls_addr;
      _test_then_block($5, $escapelist);
      label = 3; break;
    case 5: 
      var $6=$ls_addr;
      var $call=_testnext($6, 260);
      var $tobool=(($call)|0)!=0;
      if ($tobool) { label = 6; break; } else { label = 7; break; }
    case 6: 
      var $7=$ls_addr;
      _block($7);
      label = 7; break;
    case 7: 
      var $8=$ls_addr;
      var $9=$line_addr;
      _check_match($8, 262, 267, $9);
      var $10=$fs;
      var $11=HEAP32[(($escapelist)>>2)];
      _luaK_patchtohere($10, $11);
      STACKTOP = __stackBase__;
      Module.print(INDENT + 'Exiting: _ifstat');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _whilestat($ls, $line) {
  var label = 0;
  var __stackBase__  = STACKTOP; STACKTOP = (STACKTOP + 12)|0; _memset(__stackBase__, 0, 12);
  Module.print(INDENT + ' Entering: _whilestat: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';

  var $ls_addr;
  var $line_addr;
  var $fs;
  var $whileinit;
  var $condexit;
  var $bl=__stackBase__;
  $ls_addr=$ls;
  $line_addr=$line;
  var $0=$ls_addr;
  var $fs1=(($0+36)|0);
  var $1=HEAP32[(($fs1)>>2)];
  $fs=$1;
  var $2=$ls_addr;
  _luaX_next($2);
  var $3=$fs;
  var $call=_luaK_getlabel($3);
  $whileinit=$call;
  var $4=$ls_addr;
  var $call2=_cond($4);
  $condexit=$call2;
  var $5=$fs;
  _enterblock($5, $bl, 1);
  var $6=$ls_addr;
  _checknext($6, 259);
  var $7=$ls_addr;
  _block($7);
  var $8=$fs;
  var $9=$fs;
  var $call3=_luaK_jump($9);
  var $10=$whileinit;
  _luaK_patchlist($8, $call3, $10);
  var $11=$ls_addr;
  var $12=$line_addr;
  _check_match($11, 262, 278, $12);
  var $13=$fs;
  _leaveblock($13);
  var $14=$fs;
  var $15=$condexit;
  _luaK_patchtohere($14, $15);
  STACKTOP = __stackBase__;
  Module.print(INDENT + 'Exiting: _whilestat');
  INDENT = INDENT.substr(0, INDENT.length-2);
  return;
  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _block($ls) {
  var label = 0;
  var __stackBase__  = STACKTOP; STACKTOP = (STACKTOP + 12)|0; _memset(__stackBase__, 0, 12);
  Module.print(INDENT + ' Entering: _block: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';

  var $ls_addr;
  var $fs;
  var $bl=__stackBase__;
  $ls_addr=$ls;
  var $0=$ls_addr;
  var $fs1=(($0+36)|0);
  var $1=HEAP32[(($fs1)>>2)];
  $fs=$1;
  var $2=$fs;
  _enterblock($2, $bl, 0);
  var $3=$ls_addr;
  _statlist($3);
  var $4=$fs;
  _leaveblock($4);
  STACKTOP = __stackBase__;
  Module.print(INDENT + 'Exiting: _block');
  INDENT = INDENT.substr(0, INDENT.length-2);
  return;
  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _undefgoto($ls, $gt) {
  var label = 0;
  var __stackBase__  = STACKTOP; _memset(__stackBase__, 0, 0);
  Module.print(INDENT + ' Entering: _undefgoto: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $ls_addr;
      var $gt_addr;
      var $msg;
      $ls_addr=$ls;
      $gt_addr=$gt;
      var $0=$gt_addr;
      var $name=(($0)|0);
      var $1=HEAP32[(($name)>>2)];
      var $tsv=$1;
      var $tt=(($tsv+4)|0);
      var $2=HEAP8[($tt)];
      var $conv=(($2)&255);
      var $cmp=(($conv)|0)==4;
      if ($cmp) { label = 3; break; } else { var $6 = 0;label = 4; break; }
    case 3: 
      var $3=$gt_addr;
      var $name2=(($3)|0);
      var $4=HEAP32[(($name2)>>2)];
      var $tsv3=$4;
      var $extra=(($tsv3+6)|0);
      var $5=HEAP8[($extra)];
      var $conv4=(($5)&255);
      var $cmp5=(($conv4)|0) > 0;
      var $6 = $cmp5;label = 4; break;
    case 4: 
      var $6;
      var $cond=$6 ? (((5246220)|0)) : (((5246912)|0));
      $msg=$cond;
      var $7=$ls_addr;
      var $L=(($7+40)|0);
      var $8=HEAP32[(($L)>>2)];
      var $9=$msg;
      var $10=$gt_addr;
      var $name7=(($10)|0);
      var $11=HEAP32[(($name7)>>2)];
      var $add_ptr=(($11+16)|0);
      var $12=$add_ptr;
      var $13=$gt_addr;
      var $line=(($13+8)|0);
      var $14=HEAP32[(($line)>>2)];
      var $call=_luaO_pushfstring($8, $9, (tempInt=STACKTOP,_memset(STACKTOP, 0, 8),STACKTOP = (STACKTOP + 8)|0,HEAP32[((tempInt)>>2)]=$12,HEAP32[(((tempInt)+(4))>>2)]=$14,tempInt));
      $msg=$call;
      var $15=$ls_addr;
      var $16=$msg;
      _semerror($15, $16);

    case 5: 
      STACKTOP = __stackBase__;
      Module.print(INDENT + 'Exiting: _undefgoto');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _semerror($ls, $msg) {
  var label = 0;

  Module.print(INDENT + ' Entering: _semerror: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $ls_addr;
      var $msg_addr;
      $ls_addr=$ls;
      $msg_addr=$msg;
      var $0=$ls_addr;
      var $t=(($0+12)|0);
      var $token=(($t)|0);
      HEAP32[(($token)>>2)]=0;
      var $1=$ls_addr;
      var $2=$msg_addr;
      _luaX_syntaxerror($1, $2);

    case 3: 

      Module.print(INDENT + 'Exiting: _semerror');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _closegoto($ls, $g, $label) {
  var label = 0;
  var __stackBase__  = STACKTOP; _memset(__stackBase__, 0, 0);
  Module.print(INDENT + ' Entering: _closegoto: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $ls_addr;
      var $g_addr;
      var $label_addr;
      var $i;
      var $fs;
      var $gl;
      var $gt2;
      var $vname;
      var $msg;
      $ls_addr=$ls;
      $g_addr=$g;
      $label_addr=$label;
      var $0=$ls_addr;
      var $fs1=(($0+36)|0);
      var $1=HEAP32[(($fs1)>>2)];
      $fs=$1;
      var $2=$ls_addr;
      var $dyd=(($2+52)|0);
      var $3=HEAP32[(($dyd)>>2)];
      var $gt=(($3+12)|0);
      $gl=$gt;
      var $4=$g_addr;
      var $5=$gl;
      var $arr=(($5)|0);
      var $6=HEAP32[(($arr)>>2)];
      var $arrayidx=(($6+($4<<4))|0);
      $gt2=$arrayidx;
      var $7=$gt2;
      var $nactvar=(($7+12)|0);
      var $8=HEAP8[($nactvar)];
      var $conv=(($8)&255);
      var $9=$label_addr;
      var $nactvar3=(($9+12)|0);
      var $10=HEAP8[($nactvar3)];
      var $conv4=(($10)&255);
      var $cmp=(($conv)|0) < (($conv4)|0);
      if ($cmp) { label = 3; break; } else { label = 4; break; }
    case 3: 
      var $11=$fs;
      var $12=$gt2;
      var $nactvar6=(($12+12)|0);
      var $13=HEAP8[($nactvar6)];
      var $conv7=(($13)&255);
      var $call=_getlocvar($11, $conv7);
      var $varname=(($call)|0);
      var $14=HEAP32[(($varname)>>2)];
      $vname=$14;
      var $15=$ls_addr;
      var $L=(($15+40)|0);
      var $16=HEAP32[(($L)>>2)];
      var $17=$gt2;
      var $name=(($17)|0);
      var $18=HEAP32[(($name)>>2)];
      var $add_ptr=(($18+16)|0);
      var $19=$add_ptr;
      var $20=$gt2;
      var $line=(($20+8)|0);
      var $21=HEAP32[(($line)>>2)];
      var $22=$vname;
      var $add_ptr8=(($22+16)|0);
      var $23=$add_ptr8;
      var $call9=_luaO_pushfstring($16, ((5245904)|0), (tempInt=STACKTOP,_memset(STACKTOP, 0, 12),STACKTOP = (STACKTOP + 12)|0,HEAP32[((tempInt)>>2)]=$19,HEAP32[(((tempInt)+(4))>>2)]=$21,HEAP32[(((tempInt)+(8))>>2)]=$23,tempInt));
      $msg=$call9;
      var $24=$ls_addr;
      var $25=$msg;
      _semerror($24, $25);

    case 4: 
      var $26=$fs;
      var $27=$gt2;
      var $pc=(($27+4)|0);
      var $28=HEAP32[(($pc)>>2)];
      var $29=$label_addr;
      var $pc10=(($29+4)|0);
      var $30=HEAP32[(($pc10)>>2)];
      _luaK_patchlist($26, $28, $30);
      var $31=$g_addr;
      $i=$31;
      label = 5; break;
    case 5: 
      var $32=$i;
      var $33=$gl;
      var $n=(($33+4)|0);
      var $34=HEAP32[(($n)>>2)];
      var $sub=((($34)-(1))|0);
      var $cmp11=(($32)|0) < (($sub)|0);
      if ($cmp11) { label = 6; break; } else { label = 8; break; }
    case 6: 
      var $35=$i;
      var $36=$gl;
      var $arr13=(($36)|0);
      var $37=HEAP32[(($arr13)>>2)];
      var $arrayidx14=(($37+($35<<4))|0);
      var $38=$i;
      var $add=((($38)+(1))|0);
      var $39=$gl;
      var $arr15=(($39)|0);
      var $40=HEAP32[(($arr15)>>2)];
      var $arrayidx16=(($40+($add<<4))|0);
      var $41=$arrayidx14;
      var $42=$arrayidx16;
      HEAP32[(($41)>>2)]=HEAP32[(($42)>>2)];HEAP32[((($41)+(4))>>2)]=HEAP32[((($42)+(4))>>2)];HEAP32[((($41)+(8))>>2)]=HEAP32[((($42)+(8))>>2)];HEAP32[((($41)+(12))>>2)]=HEAP32[((($42)+(12))>>2)];
      label = 7; break;
    case 7: 
      var $43=$i;
      var $inc=((($43)+(1))|0);
      $i=$inc;
      label = 5; break;
    case 8: 
      var $44=$gl;
      var $n17=(($44+4)|0);
      var $45=HEAP32[(($n17)>>2)];
      var $dec=((($45)-(1))|0);
      HEAP32[(($n17)>>2)]=$dec;
      STACKTOP = __stackBase__;
      Module.print(INDENT + 'Exiting: _closegoto');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_closegoto["X"]=1;

function _error_expected($ls, $token) {
  var label = 0;
  var __stackBase__  = STACKTOP; _memset(__stackBase__, 0, 0);
  Module.print(INDENT + ' Entering: _error_expected: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $ls_addr;
      var $token_addr;
      $ls_addr=$ls;
      $token_addr=$token;
      var $0=$ls_addr;
      var $1=$ls_addr;
      var $L=(($1+40)|0);
      var $2=HEAP32[(($L)>>2)];
      var $3=$ls_addr;
      var $4=$token_addr;
      var $call=_luaX_token2str($3, $4);
      var $call1=_luaO_pushfstring($2, ((5244712)|0), (tempInt=STACKTOP,_memset(STACKTOP, 0, 4),STACKTOP = (STACKTOP + 4)|0,HEAP32[((tempInt)>>2)]=$call,tempInt));
      _luaX_syntaxerror($0, $call1);

    case 3: 
      STACKTOP = __stackBase__;
      Module.print(INDENT + 'Exiting: _error_expected');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _repeatstat($ls, $line) {
  var label = 0;
  var __stackBase__  = STACKTOP; STACKTOP = (STACKTOP + 24)|0; _memset(__stackBase__, 0, 24);
  Module.print(INDENT + ' Entering: _repeatstat: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $ls_addr;
      var $line_addr;
      var $condexit;
      var $fs;
      var $repeat_init;
      var $bl1=__stackBase__;
      var $bl2=(__stackBase__)+(12);
      $ls_addr=$ls;
      $line_addr=$line;
      var $0=$ls_addr;
      var $fs1=(($0+36)|0);
      var $1=HEAP32[(($fs1)>>2)];
      $fs=$1;
      var $2=$fs;
      var $call=_luaK_getlabel($2);
      $repeat_init=$call;
      var $3=$fs;
      _enterblock($3, $bl1, 1);
      var $4=$fs;
      _enterblock($4, $bl2, 0);
      var $5=$ls_addr;
      _luaX_next($5);
      var $6=$ls_addr;
      _statlist($6);
      var $7=$ls_addr;
      var $8=$line_addr;
      _check_match($7, 277, 273, $8);
      var $9=$ls_addr;
      var $call2=_cond($9);
      $condexit=$call2;
      var $upval=(($bl2+9)|0);
      var $10=HEAP8[($upval)];
      var $tobool=(($10 << 24) >> 24)!=0;
      if ($tobool) { label = 3; break; } else { label = 4; break; }
    case 3: 
      var $11=$fs;
      var $12=$condexit;
      var $nactvar=(($bl2+8)|0);
      var $13=HEAP8[($nactvar)];
      var $conv=(($13)&255);
      _luaK_patchclose($11, $12, $conv);
      label = 4; break;
    case 4: 
      var $14=$fs;
      _leaveblock($14);
      var $15=$fs;
      var $16=$condexit;
      var $17=$repeat_init;
      _luaK_patchlist($15, $16, $17);
      var $18=$fs;
      _leaveblock($18);
      STACKTOP = __stackBase__;
      Module.print(INDENT + 'Exiting: _repeatstat');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_repeatstat["X"]=1;

function _funcstat($ls, $line) {
  var label = 0;
  var __stackBase__  = STACKTOP; STACKTOP = (STACKTOP + 40)|0; _memset(__stackBase__, 0, 40);
  Module.print(INDENT + ' Entering: _funcstat: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';

  var $ls_addr;
  var $line_addr;
  var $ismethod;
  var $v=__stackBase__;
  var $b=(__stackBase__)+(20);
  $ls_addr=$ls;
  $line_addr=$line;
  var $0=$ls_addr;
  _luaX_next($0);
  var $1=$ls_addr;
  var $call=_funcname($1, $v);
  $ismethod=$call;
  var $2=$ls_addr;
  var $3=$ismethod;
  var $4=$line_addr;
  _body($2, $b, $3, $4);
  var $5=$ls_addr;
  var $fs=(($5+36)|0);
  var $6=HEAP32[(($fs)>>2)];
  _luaK_storevar($6, $v, $b);
  var $7=$ls_addr;
  var $fs1=(($7+36)|0);
  var $8=HEAP32[(($fs1)>>2)];
  var $9=$line_addr;
  _luaK_fixline($8, $9);
  STACKTOP = __stackBase__;
  Module.print(INDENT + 'Exiting: _funcstat');
  INDENT = INDENT.substr(0, INDENT.length-2);
  return;
  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _testnext($ls, $c) {
  var label = 0;

  Module.print(INDENT + ' Entering: _testnext: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $retval;
      var $ls_addr;
      var $c_addr;
      $ls_addr=$ls;
      $c_addr=$c;
      var $0=$ls_addr;
      var $t=(($0+12)|0);
      var $token=(($t)|0);
      var $1=HEAP32[(($token)>>2)];
      var $2=$c_addr;
      var $cmp=(($1)|0)==(($2)|0);
      if ($cmp) { label = 3; break; } else { label = 4; break; }
    case 3: 
      var $3=$ls_addr;
      _luaX_next($3);
      $retval=1;
      label = 5; break;
    case 4: 
      $retval=0;
      label = 5; break;
    case 5: 
      var $4=$retval;

      Module.print(INDENT + 'Exiting: _testnext');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return $4;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _localfunc($ls) {
  var label = 0;
  var __stackBase__  = STACKTOP; STACKTOP = (STACKTOP + 20)|0; _memset(__stackBase__, 0, 20);
  Module.print(INDENT + ' Entering: _localfunc: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';

  var $ls_addr;
  var $b=__stackBase__;
  var $fs;
  $ls_addr=$ls;
  var $0=$ls_addr;
  var $fs1=(($0+36)|0);
  var $1=HEAP32[(($fs1)>>2)];
  $fs=$1;
  var $2=$ls_addr;
  var $3=$ls_addr;
  var $call=_str_checkname($3);
  _new_localvar($2, $call);
  var $4=$ls_addr;
  _adjustlocalvars($4, 1);
  var $5=$ls_addr;
  var $6=$ls_addr;
  var $linenumber=(($6+4)|0);
  var $7=HEAP32[(($linenumber)>>2)];
  _body($5, $b, 0, $7);
  var $8=$fs;
  var $pc=(($8+20)|0);
  var $9=HEAP32[(($pc)>>2)];
  var $10=$fs;
  var $u=(($b+4)|0);
  var $info=$u;
  var $11=HEAP32[(($info)>>2)];
  var $call2=_getlocvar($10, $11);
  var $startpc=(($call2+4)|0);
  HEAP32[(($startpc)>>2)]=$9;
  STACKTOP = __stackBase__;
  Module.print(INDENT + 'Exiting: _localfunc');
  INDENT = INDENT.substr(0, INDENT.length-2);
  return;
  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _localstat($ls) {
  var label = 0;
  var __stackBase__  = STACKTOP; STACKTOP = (STACKTOP + 20)|0; _memset(__stackBase__, 0, 20);
  Module.print(INDENT + ' Entering: _localstat: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $ls_addr;
      var $nvars;
      var $nexps;
      var $e=__stackBase__;
      $ls_addr=$ls;
      $nvars=0;
      label = 3; break;
    case 3: 
      var $0=$ls_addr;
      var $1=$ls_addr;
      var $call=_str_checkname($1);
      _new_localvar($0, $call);
      var $2=$nvars;
      var $inc=((($2)+(1))|0);
      $nvars=$inc;
      label = 4; break;
    case 4: 
      var $3=$ls_addr;
      var $call1=_testnext($3, 44);
      var $tobool=(($call1)|0)!=0;
      if ($tobool) { label = 3; break; } else { label = 5; break; }
    case 5: 
      var $4=$ls_addr;
      var $call2=_testnext($4, 61);
      var $tobool3=(($call2)|0)!=0;
      if ($tobool3) { label = 6; break; } else { label = 7; break; }
    case 6: 
      var $5=$ls_addr;
      var $call4=_explist($5, $e);
      $nexps=$call4;
      label = 8; break;
    case 7: 
      var $k=(($e)|0);
      HEAP32[(($k)>>2)]=0;
      $nexps=0;
      label = 8; break;
    case 8: 
      var $6=$ls_addr;
      var $7=$nvars;
      var $8=$nexps;
      _adjust_assign($6, $7, $8, $e);
      var $9=$ls_addr;
      var $10=$nvars;
      _adjustlocalvars($9, $10);
      STACKTOP = __stackBase__;
      Module.print(INDENT + 'Exiting: _localstat');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _labelstat($ls, $label, $line) {
  var label = 0;

  Module.print(INDENT + ' Entering: _labelstat: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $ls_addr;
      var $label_addr;
      var $line_addr;
      var $fs;
      var $ll;
      var $l;
      $ls_addr=$ls;
      $label_addr=$label;
      $line_addr=$line;
      var $0=$ls_addr;
      var $fs1=(($0+36)|0);
      var $1=HEAP32[(($fs1)>>2)];
      $fs=$1;
      var $2=$ls_addr;
      var $dyd=(($2+52)|0);
      var $3=HEAP32[(($dyd)>>2)];
      var $label2=(($3+24)|0);
      $ll=$label2;
      var $4=$fs;
      var $5=$ll;
      var $6=$label_addr;
      _checkrepeated($4, $5, $6);
      var $7=$ls_addr;
      _checknext($7, 285);
      var $8=$ls_addr;
      var $9=$ll;
      var $10=$label_addr;
      var $11=$line_addr;
      var $12=$fs;
      var $pc=(($12+20)|0);
      var $13=HEAP32[(($pc)>>2)];
      var $call=_newlabelentry($8, $9, $10, $11, $13);
      $l=$call;
      var $14=$ls_addr;
      _skipnoopstat($14);
      var $15=$ls_addr;
      var $call3=_block_follow($15, 0);
      var $tobool=(($call3)|0)!=0;
      if ($tobool) { label = 3; break; } else { label = 4; break; }
    case 3: 
      var $16=$fs;
      var $bl=(($16+16)|0);
      var $17=HEAP32[(($bl)>>2)];
      var $nactvar=(($17+8)|0);
      var $18=HEAP8[($nactvar)];
      var $19=$l;
      var $20=$ll;
      var $arr=(($20)|0);
      var $21=HEAP32[(($arr)>>2)];
      var $arrayidx=(($21+($19<<4))|0);
      var $nactvar4=(($arrayidx+12)|0);
      HEAP8[($nactvar4)]=$18;
      label = 4; break;
    case 4: 
      var $22=$ls_addr;
      var $23=$l;
      var $24=$ll;
      var $arr5=(($24)|0);
      var $25=HEAP32[(($arr5)>>2)];
      var $arrayidx6=(($25+($23<<4))|0);
      _findgotos($22, $arrayidx6);

      Module.print(INDENT + 'Exiting: _labelstat');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_labelstat["X"]=1;

function _str_checkname($ls) {
  var label = 0;

  Module.print(INDENT + ' Entering: _str_checkname: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';

  var $ls_addr;
  var $ts;
  $ls_addr=$ls;
  var $0=$ls_addr;
  _check($0, 288);
  var $1=$ls_addr;
  var $t=(($1+12)|0);
  var $seminfo=(($t+4)|0);
  var $ts1=$seminfo;
  var $2=HEAP32[(($ts1)>>2)];
  $ts=$2;
  var $3=$ls_addr;
  _luaX_next($3);
  var $4=$ts;

  Module.print(INDENT + 'Exiting: _str_checkname');
  INDENT = INDENT.substr(0, INDENT.length-2);
  return $4;
  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _retstat($ls) {
  var label = 0;
  var __stackBase__  = STACKTOP; STACKTOP = (STACKTOP + 20)|0; _memset(__stackBase__, 0, 20);
  Module.print(INDENT + ' Entering: _retstat: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $ls_addr;
      var $fs;
      var $e=__stackBase__;
      var $first;
      var $nret;
      $ls_addr=$ls;
      var $0=$ls_addr;
      var $fs1=(($0+36)|0);
      var $1=HEAP32[(($fs1)>>2)];
      $fs=$1;
      var $2=$ls_addr;
      var $call=_block_follow($2, 1);
      var $tobool=(($call)|0)!=0;
      if ($tobool) { label = 4; break; } else { label = 3; break; }
    case 3: 
      var $3=$ls_addr;
      var $t=(($3+12)|0);
      var $token=(($t)|0);
      var $4=HEAP32[(($token)>>2)];
      var $cmp=(($4)|0)==59;
      if ($cmp) { label = 4; break; } else { label = 5; break; }
    case 4: 
      $nret=0;
      $first=0;
      label = 16; break;
    case 5: 
      var $5=$ls_addr;
      var $call2=_explist($5, $e);
      $nret=$call2;
      var $k=(($e)|0);
      var $6=HEAP32[(($k)>>2)];
      var $cmp3=(($6)|0)==12;
      if ($cmp3) { label = 7; break; } else { label = 6; break; }
    case 6: 
      var $k5=(($e)|0);
      var $7=HEAP32[(($k5)>>2)];
      var $cmp6=(($7)|0)==13;
      if ($cmp6) { label = 7; break; } else { label = 11; break; }
    case 7: 
      var $8=$fs;
      _luaK_setreturns($8, $e, -1);
      var $k8=(($e)|0);
      var $9=HEAP32[(($k8)>>2)];
      var $cmp9=(($9)|0)==12;
      if ($cmp9) { label = 8; break; } else { label = 10; break; }
    case 8: 
      var $10=$nret;
      var $cmp10=(($10)|0)==1;
      if ($cmp10) { label = 9; break; } else { label = 10; break; }
    case 9: 
      var $u=(($e+4)|0);
      var $info=$u;
      var $11=HEAP32[(($info)>>2)];
      var $12=$fs;
      var $f=(($12)|0);
      var $13=HEAP32[(($f)>>2)];
      var $code=(($13+12)|0);
      var $14=HEAP32[(($code)>>2)];
      var $arrayidx=(($14+($11<<2))|0);
      var $15=HEAP32[(($arrayidx)>>2)];
      var $and=$15 & -64;
      var $or=$and | 30;
      var $u12=(($e+4)|0);
      var $info13=$u12;
      var $16=HEAP32[(($info13)>>2)];
      var $17=$fs;
      var $f14=(($17)|0);
      var $18=HEAP32[(($f14)>>2)];
      var $code15=(($18+12)|0);
      var $19=HEAP32[(($code15)>>2)];
      var $arrayidx16=(($19+($16<<2))|0);
      HEAP32[(($arrayidx16)>>2)]=$or;
      label = 10; break;
    case 10: 
      var $20=$fs;
      var $nactvar=(($20+46)|0);
      var $21=HEAP8[($nactvar)];
      var $conv=(($21)&255);
      $first=$conv;
      $nret=-1;
      label = 15; break;
    case 11: 
      var $22=$nret;
      var $cmp18=(($22)|0)==1;
      if ($cmp18) { label = 12; break; } else { label = 13; break; }
    case 12: 
      var $23=$fs;
      var $call21=_luaK_exp2anyreg($23, $e);
      $first=$call21;
      label = 14; break;
    case 13: 
      var $24=$fs;
      _luaK_exp2nextreg($24, $e);
      var $25=$fs;
      var $nactvar23=(($25+46)|0);
      var $26=HEAP8[($nactvar23)];
      var $conv24=(($26)&255);
      $first=$conv24;
      label = 14; break;
    case 14: 
      label = 15; break;
    case 15: 
      label = 16; break;
    case 16: 
      var $27=$fs;
      var $28=$first;
      var $29=$nret;
      _luaK_ret($27, $28, $29);
      var $30=$ls_addr;
      var $call28=_testnext($30, 59);
      STACKTOP = __stackBase__;
      Module.print(INDENT + 'Exiting: _retstat');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_retstat["X"]=1;

function _gotostat($ls, $pc) {
  var label = 0;

  Module.print(INDENT + ' Entering: _gotostat: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $ls_addr;
      var $pc_addr;
      var $line;
      var $label;
      var $g;
      $ls_addr=$ls;
      $pc_addr=$pc;
      var $0=$ls_addr;
      var $linenumber=(($0+4)|0);
      var $1=HEAP32[(($linenumber)>>2)];
      $line=$1;
      var $2=$ls_addr;
      var $call=_testnext($2, 266);
      var $tobool=(($call)|0)!=0;
      if ($tobool) { label = 3; break; } else { label = 4; break; }
    case 3: 
      var $3=$ls_addr;
      var $call1=_str_checkname($3);
      $label=$call1;
      label = 5; break;
    case 4: 
      var $4=$ls_addr;
      _luaX_next($4);
      var $5=$ls_addr;
      var $L=(($5+40)|0);
      var $6=HEAP32[(($L)>>2)];
      var $call2=_luaS_new($6, ((5245348)|0));
      $label=$call2;
      label = 5; break;
    case 5: 
      var $7=$ls_addr;
      var $8=$ls_addr;
      var $dyd=(($8+52)|0);
      var $9=HEAP32[(($dyd)>>2)];
      var $gt=(($9+12)|0);
      var $10=$label;
      var $11=$line;
      var $12=$pc_addr;
      var $call3=_newlabelentry($7, $gt, $10, $11, $12);
      $g=$call3;
      var $13=$ls_addr;
      var $14=$g;
      var $call4=_findlabel($13, $14);

      Module.print(INDENT + 'Exiting: _gotostat');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _suffixedexp($ls, $v) {
  var label = 0;
  var __stackBase__  = STACKTOP; STACKTOP = (STACKTOP + 40)|0; _memset(__stackBase__, 0, 40);
  Module.print(INDENT + ' Entering: _suffixedexp: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $ls_addr;
      var $v_addr;
      var $fs;
      var $line;
      var $key=__stackBase__;
      var $key4=(__stackBase__)+(20);
      $ls_addr=$ls;
      $v_addr=$v;
      var $0=$ls_addr;
      var $fs1=(($0+36)|0);
      var $1=HEAP32[(($fs1)>>2)];
      $fs=$1;
      var $2=$ls_addr;
      var $linenumber=(($2+4)|0);
      var $3=HEAP32[(($linenumber)>>2)];
      $line=$3;
      var $4=$ls_addr;
      var $5=$v_addr;
      _primaryexp($4, $5);
      label = 3; break;
    case 3: 
      var $6=$ls_addr;
      var $t=(($6+12)|0);
      var $token=(($t)|0);
      var $7=HEAP32[(($token)>>2)];
      if ((($7)|0)==46) {
        label = 4; break;
      }
      else if ((($7)|0)==91) {
        label = 5; break;
      }
      else if ((($7)|0)==58) {
        label = 6; break;
      }
      else if ((($7)|0)==40 | (($7)|0)==289 | (($7)|0)==123) {
        label = 7; break;
      }
      else {
      label = 8; break;
      }
      
    case 4: 
      var $8=$ls_addr;
      var $9=$v_addr;
      _fieldsel($8, $9);
      label = 9; break;
    case 5: 
      var $10=$fs;
      var $11=$v_addr;
      _luaK_exp2anyregup($10, $11);
      var $12=$ls_addr;
      _yindex($12, $key);
      var $13=$fs;
      var $14=$v_addr;
      _luaK_indexed($13, $14, $key);
      label = 9; break;
    case 6: 
      var $15=$ls_addr;
      _luaX_next($15);
      var $16=$ls_addr;
      _checkname($16, $key4);
      var $17=$fs;
      var $18=$v_addr;
      _luaK_self($17, $18, $key4);
      var $19=$ls_addr;
      var $20=$v_addr;
      var $21=$line;
      _funcargs($19, $20, $21);
      label = 9; break;
    case 7: 
      var $22=$fs;
      var $23=$v_addr;
      _luaK_exp2nextreg($22, $23);
      var $24=$ls_addr;
      var $25=$v_addr;
      var $26=$line;
      _funcargs($24, $25, $26);
      label = 9; break;
    case 8: 
      STACKTOP = __stackBase__;
      Module.print(INDENT + 'Exiting: _suffixedexp');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return;
    case 9: 
      label = 3; break;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_suffixedexp["X"]=1;

function _check_match($ls, $what, $who, $where) {
  var label = 0;
  var __stackBase__  = STACKTOP; _memset(__stackBase__, 0, 0);
  Module.print(INDENT + ' Entering: _check_match: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $ls_addr;
      var $what_addr;
      var $who_addr;
      var $where_addr;
      $ls_addr=$ls;
      $what_addr=$what;
      $who_addr=$who;
      $where_addr=$where;
      var $0=$ls_addr;
      var $1=$what_addr;
      var $call=_testnext($0, $1);
      var $tobool=(($call)|0)!=0;
      if ($tobool) { label = 6; break; } else { label = 3; break; }
    case 3: 
      var $2=$where_addr;
      var $3=$ls_addr;
      var $linenumber=(($3+4)|0);
      var $4=HEAP32[(($linenumber)>>2)];
      var $cmp=(($2)|0)==(($4)|0);
      if ($cmp) { label = 4; break; } else { label = 5; break; }
    case 4: 
      var $5=$ls_addr;
      var $6=$what_addr;
      _error_expected($5, $6);

    case 5: 
      var $7=$ls_addr;
      var $8=$ls_addr;
      var $L=(($8+40)|0);
      var $9=HEAP32[(($L)>>2)];
      var $10=$ls_addr;
      var $11=$what_addr;
      var $call2=_luaX_token2str($10, $11);
      var $12=$ls_addr;
      var $13=$who_addr;
      var $call3=_luaX_token2str($12, $13);
      var $14=$where_addr;
      var $call4=_luaO_pushfstring($9, ((5245480)|0), (tempInt=STACKTOP,_memset(STACKTOP, 0, 12),STACKTOP = (STACKTOP + 12)|0,HEAP32[((tempInt)>>2)]=$call2,HEAP32[(((tempInt)+(4))>>2)]=$call3,HEAP32[(((tempInt)+(8))>>2)]=$14,tempInt));
      _luaX_syntaxerror($7, $call4);

    case 6: 
      STACKTOP = __stackBase__;
      Module.print(INDENT + 'Exiting: _check_match');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _forstat($ls, $line) {
  var label = 0;
  var __stackBase__  = STACKTOP; STACKTOP = (STACKTOP + 12)|0; _memset(__stackBase__, 0, 12);
  Module.print(INDENT + ' Entering: _forstat: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $ls_addr;
      var $line_addr;
      var $fs;
      var $varname;
      var $bl=__stackBase__;
      $ls_addr=$ls;
      $line_addr=$line;
      var $0=$ls_addr;
      var $fs1=(($0+36)|0);
      var $1=HEAP32[(($fs1)>>2)];
      $fs=$1;
      var $2=$fs;
      _enterblock($2, $bl, 1);
      var $3=$ls_addr;
      _luaX_next($3);
      var $4=$ls_addr;
      var $call=_str_checkname($4);
      $varname=$call;
      var $5=$ls_addr;
      var $t=(($5+12)|0);
      var $token=(($t)|0);
      var $6=HEAP32[(($token)>>2)];
      if ((($6)|0)==61) {
        label = 3; break;
      }
      else if ((($6)|0)==44 | (($6)|0)==268) {
        label = 4; break;
      }
      else {
      label = 5; break;
      }
      
    case 3: 
      var $7=$ls_addr;
      var $8=$varname;
      var $9=$line_addr;
      _fornum($7, $8, $9);
      label = 6; break;
    case 4: 
      var $10=$ls_addr;
      var $11=$varname;
      _forlist($10, $11);
      label = 6; break;
    case 5: 
      var $12=$ls_addr;
      _luaX_syntaxerror($12, ((5246056)|0));

    case 6: 
      var $13=$ls_addr;
      var $14=$line_addr;
      _check_match($13, 262, 264, $14);
      var $15=$fs;
      _leaveblock($15);
      STACKTOP = __stackBase__;
      Module.print(INDENT + 'Exiting: _forstat');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _exprstat($ls) {
  var label = 0;
  var __stackBase__  = STACKTOP; STACKTOP = (STACKTOP + 24)|0; _memset(__stackBase__, 0, 24);
  Module.print(INDENT + ' Entering: _exprstat: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $ls_addr;
      var $fs;
      var $v=__stackBase__;
      $ls_addr=$ls;
      var $0=$ls_addr;
      var $fs1=(($0+36)|0);
      var $1=HEAP32[(($fs1)>>2)];
      $fs=$1;
      var $2=$ls_addr;
      var $v2=(($v+4)|0);
      _suffixedexp($2, $v2);
      var $3=$ls_addr;
      var $t=(($3+12)|0);
      var $token=(($t)|0);
      var $4=HEAP32[(($token)>>2)];
      var $cmp=(($4)|0)==61;
      if ($cmp) { label = 4; break; } else { label = 3; break; }
    case 3: 
      var $5=$ls_addr;
      var $t3=(($5+12)|0);
      var $token4=(($t3)|0);
      var $6=HEAP32[(($token4)>>2)];
      var $cmp5=(($6)|0)==44;
      if ($cmp5) { label = 4; break; } else { label = 5; break; }
    case 4: 
      var $prev=(($v)|0);
      HEAP32[(($prev)>>2)]=0;
      var $7=$ls_addr;
      _assignment($7, $v, 1);
      label = 8; break;
    case 5: 
      var $v6=(($v+4)|0);
      var $k=(($v6)|0);
      var $8=HEAP32[(($k)>>2)];
      var $cmp7=(($8)|0)==12;
      if ($cmp7) { label = 7; break; } else { label = 6; break; }
    case 6: 
      var $9=$ls_addr;
      _luaX_syntaxerror($9, ((5244588)|0));

    case 7: 
      var $v9=(($v+4)|0);
      var $u=(($v9+4)|0);
      var $info=$u;
      var $10=HEAP32[(($info)>>2)];
      var $11=$fs;
      var $f=(($11)|0);
      var $12=HEAP32[(($f)>>2)];
      var $code=(($12+12)|0);
      var $13=HEAP32[(($code)>>2)];
      var $arrayidx=(($13+($10<<2))|0);
      var $14=HEAP32[(($arrayidx)>>2)];
      var $and=$14 & -8372225;
      var $or=$and | 16384;
      var $v10=(($v+4)|0);
      var $u11=(($v10+4)|0);
      var $info12=$u11;
      var $15=HEAP32[(($info12)>>2)];
      var $16=$fs;
      var $f13=(($16)|0);
      var $17=HEAP32[(($f13)>>2)];
      var $code14=(($17+12)|0);
      var $18=HEAP32[(($code14)>>2)];
      var $arrayidx15=(($18+($15<<2))|0);
      HEAP32[(($arrayidx15)>>2)]=$or;
      label = 8; break;
    case 8: 
      STACKTOP = __stackBase__;
      Module.print(INDENT + 'Exiting: _exprstat');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_exprstat["X"]=1;

function _assignment($ls, $lh, $nvars) {
  var label = 0;
  var __stackBase__  = STACKTOP; STACKTOP = (STACKTOP + 44)|0; _memset(__stackBase__, 0, 44);
  Module.print(INDENT + ' Entering: _assignment: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $ls_addr;
      var $lh_addr;
      var $nvars_addr;
      var $e=__stackBase__;
      var $nv=(__stackBase__)+(20);
      var $nexps;
      $ls_addr=$ls;
      $lh_addr=$lh;
      $nvars_addr=$nvars;
      var $0=$lh_addr;
      var $v=(($0+4)|0);
      var $k=(($v)|0);
      var $1=HEAP32[(($k)>>2)];
      var $cmp=7 <= (($1)>>>0);
      if ($cmp) { label = 3; break; } else { label = 4; break; }
    case 3: 
      var $2=$lh_addr;
      var $v1=(($2+4)|0);
      var $k2=(($v1)|0);
      var $3=HEAP32[(($k2)>>2)];
      var $cmp3=(($3)>>>0) <= 9;
      if ($cmp3) { label = 5; break; } else { label = 4; break; }
    case 4: 
      var $4=$ls_addr;
      _luaX_syntaxerror($4, ((5244588)|0));

    case 5: 
      var $5=$ls_addr;
      var $call=_testnext($5, 44);
      var $tobool=(($call)|0)!=0;
      if ($tobool) { label = 6; break; } else { label = 9; break; }
    case 6: 
      var $6=$lh_addr;
      var $prev=(($nv)|0);
      HEAP32[(($prev)>>2)]=$6;
      var $7=$ls_addr;
      var $v5=(($nv+4)|0);
      _suffixedexp($7, $v5);
      var $v6=(($nv+4)|0);
      var $k7=(($v6)|0);
      var $8=HEAP32[(($k7)>>2)];
      var $cmp8=(($8)|0)!=9;
      if ($cmp8) { label = 7; break; } else { label = 8; break; }
    case 7: 
      var $9=$ls_addr;
      var $10=$lh_addr;
      var $v10=(($nv+4)|0);
      _check_conflict($9, $10, $v10);
      label = 8; break;
    case 8: 
      var $11=$ls_addr;
      var $fs=(($11+36)|0);
      var $12=HEAP32[(($fs)>>2)];
      var $13=$nvars_addr;
      var $14=$ls_addr;
      var $L=(($14+40)|0);
      var $15=HEAP32[(($L)>>2)];
      var $nCcalls=(($15+38)|0);
      var $16=HEAP16[(($nCcalls)>>1)];
      var $conv=(($16)&65535);
      var $add=((($13)+($conv))|0);
      _checklimit($12, $add, 200, ((5244452)|0));
      var $17=$ls_addr;
      var $18=$nvars_addr;
      var $add12=((($18)+(1))|0);
      _assignment($17, $nv, $add12);
      label = 15; break;
    case 9: 
      var $19=$ls_addr;
      _checknext($19, 61);
      var $20=$ls_addr;
      var $call13=_explist($20, $e);
      $nexps=$call13;
      var $21=$nexps;
      var $22=$nvars_addr;
      var $cmp14=(($21)|0)!=(($22)|0);
      if ($cmp14) { label = 10; break; } else { label = 13; break; }
    case 10: 
      var $23=$ls_addr;
      var $24=$nvars_addr;
      var $25=$nexps;
      _adjust_assign($23, $24, $25, $e);
      var $26=$nexps;
      var $27=$nvars_addr;
      var $cmp17=(($26)|0) > (($27)|0);
      if ($cmp17) { label = 11; break; } else { label = 12; break; }
    case 11: 
      var $28=$nexps;
      var $29=$nvars_addr;
      var $sub=((($28)-($29))|0);
      var $30=$ls_addr;
      var $fs20=(($30+36)|0);
      var $31=HEAP32[(($fs20)>>2)];
      var $freereg=(($31+48)|0);
      var $32=HEAP8[($freereg)];
      var $conv21=(($32)&255);
      var $sub22=((($conv21)-($sub))|0);
      var $conv23=(($sub22) & 255);
      HEAP8[($freereg)]=$conv23;
      label = 12; break;
    case 12: 
      label = 14; break;
    case 13: 
      var $33=$ls_addr;
      var $fs26=(($33+36)|0);
      var $34=HEAP32[(($fs26)>>2)];
      _luaK_setoneret($34, $e);
      var $35=$ls_addr;
      var $fs27=(($35+36)|0);
      var $36=HEAP32[(($fs27)>>2)];
      var $37=$lh_addr;
      var $v28=(($37+4)|0);
      _luaK_storevar($36, $v28, $e);
      label = 16; break;
    case 14: 
      label = 15; break;
    case 15: 
      var $38=$ls_addr;
      var $fs31=(($38+36)|0);
      var $39=HEAP32[(($fs31)>>2)];
      var $freereg32=(($39+48)|0);
      var $40=HEAP8[($freereg32)];
      var $conv33=(($40)&255);
      var $sub34=((($conv33)-(1))|0);
      _init_exp($e, 6, $sub34);
      var $41=$ls_addr;
      var $fs35=(($41+36)|0);
      var $42=HEAP32[(($fs35)>>2)];
      var $43=$lh_addr;
      var $v36=(($43+4)|0);
      _luaK_storevar($42, $v36, $e);
      label = 16; break;
    case 16: 
      STACKTOP = __stackBase__;
      Module.print(INDENT + 'Exiting: _assignment');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_assignment["X"]=1;

function _getunopr($op) {
  var label = 0;

  Module.print(INDENT + ' Entering: _getunopr: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $retval;
      var $op_addr;
      $op_addr=$op;
      var $0=$op_addr;
      if ((($0)|0)==271) {
        label = 3; break;
      }
      else if ((($0)|0)==45) {
        label = 4; break;
      }
      else if ((($0)|0)==35) {
        label = 5; break;
      }
      else {
      label = 6; break;
      }
      
    case 3: 
      $retval=1;
      label = 7; break;
    case 4: 
      $retval=0;
      label = 7; break;
    case 5: 
      $retval=2;
      label = 7; break;
    case 6: 
      $retval=3;
      label = 7; break;
    case 7: 
      var $1=$retval;

      Module.print(INDENT + 'Exiting: _getunopr');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return $1;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _getbinopr($op) {
  var label = 0;

  Module.print(INDENT + ' Entering: _getbinopr: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $retval;
      var $op_addr;
      $op_addr=$op;
      var $0=$op_addr;
      if ((($0)|0)==43) {
        label = 3; break;
      }
      else if ((($0)|0)==45) {
        label = 4; break;
      }
      else if ((($0)|0)==42) {
        label = 5; break;
      }
      else if ((($0)|0)==47) {
        label = 6; break;
      }
      else if ((($0)|0)==37) {
        label = 7; break;
      }
      else if ((($0)|0)==94) {
        label = 8; break;
      }
      else if ((($0)|0)==279) {
        label = 9; break;
      }
      else if ((($0)|0)==284) {
        label = 10; break;
      }
      else if ((($0)|0)==281) {
        label = 11; break;
      }
      else if ((($0)|0)==60) {
        label = 12; break;
      }
      else if ((($0)|0)==283) {
        label = 13; break;
      }
      else if ((($0)|0)==62) {
        label = 14; break;
      }
      else if ((($0)|0)==282) {
        label = 15; break;
      }
      else if ((($0)|0)==257) {
        label = 16; break;
      }
      else if ((($0)|0)==272) {
        label = 17; break;
      }
      else {
      label = 18; break;
      }
      
    case 3: 
      $retval=0;
      label = 19; break;
    case 4: 
      $retval=1;
      label = 19; break;
    case 5: 
      $retval=2;
      label = 19; break;
    case 6: 
      $retval=3;
      label = 19; break;
    case 7: 
      $retval=4;
      label = 19; break;
    case 8: 
      $retval=5;
      label = 19; break;
    case 9: 
      $retval=6;
      label = 19; break;
    case 10: 
      $retval=10;
      label = 19; break;
    case 11: 
      $retval=7;
      label = 19; break;
    case 12: 
      $retval=8;
      label = 19; break;
    case 13: 
      $retval=9;
      label = 19; break;
    case 14: 
      $retval=11;
      label = 19; break;
    case 15: 
      $retval=12;
      label = 19; break;
    case 16: 
      $retval=13;
      label = 19; break;
    case 17: 
      $retval=14;
      label = 19; break;
    case 18: 
      $retval=15;
      label = 19; break;
    case 19: 
      var $1=$retval;

      Module.print(INDENT + 'Exiting: _getbinopr');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return $1;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _check_conflict($ls, $lh, $v) {
  var label = 0;

  Module.print(INDENT + ' Entering: _check_conflict: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $ls_addr;
      var $lh_addr;
      var $v_addr;
      var $fs;
      var $extra;
      var $conflict;
      var $op;
      $ls_addr=$ls;
      $lh_addr=$lh;
      $v_addr=$v;
      var $0=$ls_addr;
      var $fs1=(($0+36)|0);
      var $1=HEAP32[(($fs1)>>2)];
      $fs=$1;
      var $2=$fs;
      var $freereg=(($2+48)|0);
      var $3=HEAP8[($freereg)];
      var $conv=(($3)&255);
      $extra=$conv;
      $conflict=0;
      label = 3; break;
    case 3: 
      var $4=$lh_addr;
      var $tobool=(($4)|0)!=0;
      if ($tobool) { label = 4; break; } else { label = 14; break; }
    case 4: 
      var $5=$lh_addr;
      var $v2=(($5+4)|0);
      var $k=(($v2)|0);
      var $6=HEAP32[(($k)>>2)];
      var $cmp=(($6)|0)==9;
      if ($cmp) { label = 5; break; } else { label = 12; break; }
    case 5: 
      var $7=$lh_addr;
      var $v4=(($7+4)|0);
      var $u=(($v4+4)|0);
      var $ind=$u;
      var $vt=(($ind+3)|0);
      var $8=HEAP8[($vt)];
      var $conv5=(($8)&255);
      var $9=$v_addr;
      var $k6=(($9)|0);
      var $10=HEAP32[(($k6)>>2)];
      var $cmp7=(($conv5)|0)==(($10)|0);
      if ($cmp7) { label = 6; break; } else { label = 8; break; }
    case 6: 
      var $11=$lh_addr;
      var $v9=(($11+4)|0);
      var $u10=(($v9+4)|0);
      var $ind11=$u10;
      var $t=(($ind11+2)|0);
      var $12=HEAP8[($t)];
      var $conv12=(($12)&255);
      var $13=$v_addr;
      var $u13=(($13+4)|0);
      var $info=$u13;
      var $14=HEAP32[(($info)>>2)];
      var $cmp14=(($conv12)|0)==(($14)|0);
      if ($cmp14) { label = 7; break; } else { label = 8; break; }
    case 7: 
      $conflict=1;
      var $15=$lh_addr;
      var $v17=(($15+4)|0);
      var $u18=(($v17+4)|0);
      var $ind19=$u18;
      var $vt20=(($ind19+3)|0);
      HEAP8[($vt20)]=7;
      var $16=$extra;
      var $conv21=(($16) & 255);
      var $17=$lh_addr;
      var $v22=(($17+4)|0);
      var $u23=(($v22+4)|0);
      var $ind24=$u23;
      var $t25=(($ind24+2)|0);
      HEAP8[($t25)]=$conv21;
      label = 8; break;
    case 8: 
      var $18=$v_addr;
      var $k26=(($18)|0);
      var $19=HEAP32[(($k26)>>2)];
      var $cmp27=(($19)|0)==7;
      if ($cmp27) { label = 9; break; } else { label = 11; break; }
    case 9: 
      var $20=$lh_addr;
      var $v30=(($20+4)|0);
      var $u31=(($v30+4)|0);
      var $ind32=$u31;
      var $idx=(($ind32)|0);
      var $21=HEAP16[(($idx)>>1)];
      var $conv33=(($21 << 16) >> 16);
      var $22=$v_addr;
      var $u34=(($22+4)|0);
      var $info35=$u34;
      var $23=HEAP32[(($info35)>>2)];
      var $cmp36=(($conv33)|0)==(($23)|0);
      if ($cmp36) { label = 10; break; } else { label = 11; break; }
    case 10: 
      $conflict=1;
      var $24=$extra;
      var $conv39=(($24) & 65535);
      var $25=$lh_addr;
      var $v40=(($25+4)|0);
      var $u41=(($v40+4)|0);
      var $ind42=$u41;
      var $idx43=(($ind42)|0);
      HEAP16[(($idx43)>>1)]=$conv39;
      label = 11; break;
    case 11: 
      label = 12; break;
    case 12: 
      label = 13; break;
    case 13: 
      var $26=$lh_addr;
      var $prev=(($26)|0);
      var $27=HEAP32[(($prev)>>2)];
      $lh_addr=$27;
      label = 3; break;
    case 14: 
      var $28=$conflict;
      var $tobool46=(($28)|0)!=0;
      if ($tobool46) { label = 15; break; } else { label = 16; break; }
    case 15: 
      var $29=$v_addr;
      var $k48=(($29)|0);
      var $30=HEAP32[(($k48)>>2)];
      var $cmp49=(($30)|0)==7;
      var $cond=$cmp49 ? 0 : 5;
      $op=$cond;
      var $31=$fs;
      var $32=$op;
      var $33=$extra;
      var $34=$v_addr;
      var $u51=(($34+4)|0);
      var $info52=$u51;
      var $35=HEAP32[(($info52)>>2)];
      var $call=_luaK_codeABC($31, $32, $33, $35, 0);
      var $36=$fs;
      _luaK_reserveregs($36, 1);
      label = 16; break;
    case 16: 

      Module.print(INDENT + 'Exiting: _check_conflict');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_check_conflict["X"]=1;

function _checknext($ls, $c) {
  var label = 0;

  Module.print(INDENT + ' Entering: _checknext: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';

  var $ls_addr;
  var $c_addr;
  $ls_addr=$ls;
  $c_addr=$c;
  var $0=$ls_addr;
  var $1=$c_addr;
  _check($0, $1);
  var $2=$ls_addr;
  _luaX_next($2);

  Module.print(INDENT + 'Exiting: _checknext');
  INDENT = INDENT.substr(0, INDENT.length-2);
  return;
  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _explist($ls, $v) {
  var label = 0;

  Module.print(INDENT + ' Entering: _explist: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $ls_addr;
      var $v_addr;
      var $n;
      $ls_addr=$ls;
      $v_addr=$v;
      $n=1;
      var $0=$ls_addr;
      var $1=$v_addr;
      _expr($0, $1);
      label = 3; break;
    case 3: 
      var $2=$ls_addr;
      var $call=_testnext($2, 44);
      var $tobool=(($call)|0)!=0;
      if ($tobool) { label = 4; break; } else { label = 5; break; }
    case 4: 
      var $3=$ls_addr;
      var $fs=(($3+36)|0);
      var $4=HEAP32[(($fs)>>2)];
      var $5=$v_addr;
      _luaK_exp2nextreg($4, $5);
      var $6=$ls_addr;
      var $7=$v_addr;
      _expr($6, $7);
      var $8=$n;
      var $inc=((($8)+(1))|0);
      $n=$inc;
      label = 3; break;
    case 5: 
      var $9=$n;

      Module.print(INDENT + 'Exiting: _explist');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return $9;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _adjust_assign($ls, $nvars, $nexps, $e) {
  var label = 0;

  Module.print(INDENT + ' Entering: _adjust_assign: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $ls_addr;
      var $nvars_addr;
      var $nexps_addr;
      var $e_addr;
      var $fs;
      var $extra;
      var $reg;
      $ls_addr=$ls;
      $nvars_addr=$nvars;
      $nexps_addr=$nexps;
      $e_addr=$e;
      var $0=$ls_addr;
      var $fs1=(($0+36)|0);
      var $1=HEAP32[(($fs1)>>2)];
      $fs=$1;
      var $2=$nvars_addr;
      var $3=$nexps_addr;
      var $sub=((($2)-($3))|0);
      $extra=$sub;
      var $4=$e_addr;
      var $k=(($4)|0);
      var $5=HEAP32[(($k)>>2)];
      var $cmp=(($5)|0)==12;
      if ($cmp) { label = 4; break; } else { label = 3; break; }
    case 3: 
      var $6=$e_addr;
      var $k2=(($6)|0);
      var $7=HEAP32[(($k2)>>2)];
      var $cmp3=(($7)|0)==13;
      if ($cmp3) { label = 4; break; } else { label = 9; break; }
    case 4: 
      var $8=$extra;
      var $inc=((($8)+(1))|0);
      $extra=$inc;
      var $9=$extra;
      var $cmp4=(($9)|0) < 0;
      if ($cmp4) { label = 5; break; } else { label = 6; break; }
    case 5: 
      $extra=0;
      label = 6; break;
    case 6: 
      var $10=$fs;
      var $11=$e_addr;
      var $12=$extra;
      _luaK_setreturns($10, $11, $12);
      var $13=$extra;
      var $cmp6=(($13)|0) > 1;
      if ($cmp6) { label = 7; break; } else { label = 8; break; }
    case 7: 
      var $14=$fs;
      var $15=$extra;
      var $sub8=((($15)-(1))|0);
      _luaK_reserveregs($14, $sub8);
      label = 8; break;
    case 8: 
      label = 14; break;
    case 9: 
      var $16=$e_addr;
      var $k10=(($16)|0);
      var $17=HEAP32[(($k10)>>2)];
      var $cmp11=(($17)|0)!=0;
      if ($cmp11) { label = 10; break; } else { label = 11; break; }
    case 10: 
      var $18=$fs;
      var $19=$e_addr;
      _luaK_exp2nextreg($18, $19);
      label = 11; break;
    case 11: 
      var $20=$extra;
      var $cmp14=(($20)|0) > 0;
      if ($cmp14) { label = 12; break; } else { label = 13; break; }
    case 12: 
      var $21=$fs;
      var $freereg=(($21+48)|0);
      var $22=HEAP8[($freereg)];
      var $conv=(($22)&255);
      $reg=$conv;
      var $23=$fs;
      var $24=$extra;
      _luaK_reserveregs($23, $24);
      var $25=$fs;
      var $26=$reg;
      var $27=$extra;
      _luaK_nil($25, $26, $27);
      label = 13; break;
    case 13: 
      label = 14; break;
    case 14: 

      Module.print(INDENT + 'Exiting: _adjust_assign');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_adjust_assign["X"]=1;

function _expr($ls, $v) {
  var label = 0;

  Module.print(INDENT + ' Entering: _expr: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';

  var $ls_addr;
  var $v_addr;
  $ls_addr=$ls;
  $v_addr=$v;
  var $0=$ls_addr;
  var $1=$v_addr;
  var $call=_subexpr($0, $1, 0);

  Module.print(INDENT + 'Exiting: _expr');
  INDENT = INDENT.substr(0, INDENT.length-2);
  return;
  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _subexpr($ls, $v, $limit) {
  var label = 0;
  var __stackBase__  = STACKTOP; STACKTOP = (STACKTOP + 20)|0; _memset(__stackBase__, 0, 20);
  Module.print(INDENT + ' Entering: _subexpr: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $ls_addr;
      var $v_addr;
      var $limit_addr;
      var $op;
      var $uop;
      var $line;
      var $v2=__stackBase__;
      var $nextop;
      var $line8;
      $ls_addr=$ls;
      $v_addr=$v;
      $limit_addr=$limit;
      var $0=$ls_addr;
      _enterlevel($0);
      var $1=$ls_addr;
      var $t=(($1+12)|0);
      var $token=(($t)|0);
      var $2=HEAP32[(($token)>>2)];
      var $call=_getunopr($2);
      $uop=$call;
      var $3=$uop;
      var $cmp=(($3)|0)!=3;
      if ($cmp) { label = 3; break; } else { label = 4; break; }
    case 3: 
      var $4=$ls_addr;
      var $linenumber=(($4+4)|0);
      var $5=HEAP32[(($linenumber)>>2)];
      $line=$5;
      var $6=$ls_addr;
      _luaX_next($6);
      var $7=$ls_addr;
      var $8=$v_addr;
      var $call1=_subexpr($7, $8, 8);
      var $9=$ls_addr;
      var $fs=(($9+36)|0);
      var $10=HEAP32[(($fs)>>2)];
      var $11=$uop;
      var $12=$v_addr;
      var $13=$line;
      _luaK_prefix($10, $11, $12, $13);
      label = 5; break;
    case 4: 
      var $14=$ls_addr;
      var $15=$v_addr;
      _simpleexp($14, $15);
      label = 5; break;
    case 5: 
      var $16=$ls_addr;
      var $t2=(($16+12)|0);
      var $token3=(($t2)|0);
      var $17=HEAP32[(($token3)>>2)];
      var $call4=_getbinopr($17);
      $op=$call4;
      label = 6; break;
    case 6: 
      var $18=$op;
      var $cmp5=(($18)|0)!=15;
      if ($cmp5) { label = 7; break; } else { var $22 = 0;label = 8; break; }
    case 7: 
      var $19=$op;
      var $arrayidx=((5242892+($19<<1))|0);
      var $left=(($arrayidx)|0);
      var $20=HEAP8[($left)];
      var $conv=(($20)&255);
      var $21=$limit_addr;
      var $cmp6=(($conv)|0) > (($21)|0);
      var $22 = $cmp6;label = 8; break;
    case 8: 
      var $22;
      if ($22) { label = 9; break; } else { label = 10; break; }
    case 9: 
      var $23=$ls_addr;
      var $linenumber9=(($23+4)|0);
      var $24=HEAP32[(($linenumber9)>>2)];
      $line8=$24;
      var $25=$ls_addr;
      _luaX_next($25);
      var $26=$ls_addr;
      var $fs10=(($26+36)|0);
      var $27=HEAP32[(($fs10)>>2)];
      var $28=$op;
      var $29=$v_addr;
      _luaK_infix($27, $28, $29);
      var $30=$ls_addr;
      var $31=$op;
      var $arrayidx11=((5242892+($31<<1))|0);
      var $right=(($arrayidx11+1)|0);
      var $32=HEAP8[($right)];
      var $conv12=(($32)&255);
      var $call13=_subexpr($30, $v2, $conv12);
      $nextop=$call13;
      var $33=$ls_addr;
      var $fs14=(($33+36)|0);
      var $34=HEAP32[(($fs14)>>2)];
      var $35=$op;
      var $36=$v_addr;
      var $37=$line8;
      _luaK_posfix($34, $35, $36, $v2, $37);
      var $38=$nextop;
      $op=$38;
      label = 6; break;
    case 10: 
      var $39=$ls_addr;
      var $L=(($39+40)|0);
      var $40=HEAP32[(($L)>>2)];
      var $nCcalls=(($40+38)|0);
      var $41=HEAP16[(($nCcalls)>>1)];
      var $dec=((($41)-(1))&65535);
      HEAP16[(($nCcalls)>>1)]=$dec;
      var $42=$op;
      STACKTOP = __stackBase__;
      Module.print(INDENT + 'Exiting: _subexpr');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return $42;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_subexpr["X"]=1;

function _codestring($ls, $e, $s) {
  var label = 0;

  Module.print(INDENT + ' Entering: _codestring: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';

  var $ls_addr;
  var $e_addr;
  var $s_addr;
  $ls_addr=$ls;
  $e_addr=$e;
  $s_addr=$s;
  var $0=$e_addr;
  var $1=$ls_addr;
  var $fs=(($1+36)|0);
  var $2=HEAP32[(($fs)>>2)];
  var $3=$s_addr;
  var $call=_luaK_stringK($2, $3);
  _init_exp($0, 4, $call);

  Module.print(INDENT + 'Exiting: _codestring');
  INDENT = INDENT.substr(0, INDENT.length-2);
  return;
  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _constructor($ls, $t) {
  var label = 0;
  var __stackBase__  = STACKTOP; STACKTOP = (STACKTOP + 36)|0; _memset(__stackBase__, 0, 36);
  Module.print(INDENT + ' Entering: _constructor: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $ls_addr;
      var $t_addr;
      var $fs;
      var $line;
      var $pc;
      var $cc=__stackBase__;
      $ls_addr=$ls;
      $t_addr=$t;
      var $0=$ls_addr;
      var $fs1=(($0+36)|0);
      var $1=HEAP32[(($fs1)>>2)];
      $fs=$1;
      var $2=$ls_addr;
      var $linenumber=(($2+4)|0);
      var $3=HEAP32[(($linenumber)>>2)];
      $line=$3;
      var $4=$fs;
      var $call=_luaK_codeABC($4, 11, 0, 0, 0);
      $pc=$call;
      var $tostore=(($cc+32)|0);
      HEAP32[(($tostore)>>2)]=0;
      var $nh=(($cc+24)|0);
      HEAP32[(($nh)>>2)]=0;
      var $na=(($cc+28)|0);
      HEAP32[(($na)>>2)]=0;
      var $5=$t_addr;
      var $t2=(($cc+20)|0);
      HEAP32[(($t2)>>2)]=$5;
      var $6=$t_addr;
      var $7=$pc;
      _init_exp($6, 11, $7);
      var $v=(($cc)|0);
      _init_exp($v, 0, 0);
      var $8=$ls_addr;
      var $fs3=(($8+36)|0);
      var $9=HEAP32[(($fs3)>>2)];
      var $10=$t_addr;
      _luaK_exp2nextreg($9, $10);
      var $11=$ls_addr;
      _checknext($11, 123);
      label = 3; break;
    case 3: 
      var $12=$ls_addr;
      var $t4=(($12+12)|0);
      var $token=(($t4)|0);
      var $13=HEAP32[(($token)>>2)];
      var $cmp=(($13)|0)==125;
      if ($cmp) { label = 4; break; } else { label = 5; break; }
    case 4: 
      label = 9; break;
    case 5: 
      var $14=$fs;
      _closelistfield($14, $cc);
      var $15=$ls_addr;
      _field($15, $cc);
      label = 6; break;
    case 6: 
      var $16=$ls_addr;
      var $call5=_testnext($16, 44);
      var $tobool=(($call5)|0)!=0;
      if ($tobool) { var $18 = 1;label = 8; break; } else { label = 7; break; }
    case 7: 
      var $17=$ls_addr;
      var $call6=_testnext($17, 59);
      var $tobool7=(($call6)|0)!=0;
      var $18 = $tobool7;label = 8; break;
    case 8: 
      var $18;
      if ($18) { label = 3; break; } else { label = 9; break; }
    case 9: 
      var $19=$ls_addr;
      var $20=$line;
      _check_match($19, 125, 123, $20);
      var $21=$fs;
      _lastlistfield($21, $cc);
      var $22=$pc;
      var $23=$fs;
      var $f=(($23)|0);
      var $24=HEAP32[(($f)>>2)];
      var $code=(($24+12)|0);
      var $25=HEAP32[(($code)>>2)];
      var $arrayidx=(($25+($22<<2))|0);
      var $26=HEAP32[(($arrayidx)>>2)];
      var $and=$26 & 8388607;
      var $na8=(($cc+28)|0);
      var $27=HEAP32[(($na8)>>2)];
      var $call9=_luaO_int2fb($27);
      var $shl=$call9 << 23;
      var $and10=$shl & -8388608;
      var $or=$and | $and10;
      var $28=$pc;
      var $29=$fs;
      var $f11=(($29)|0);
      var $30=HEAP32[(($f11)>>2)];
      var $code12=(($30+12)|0);
      var $31=HEAP32[(($code12)>>2)];
      var $arrayidx13=(($31+($28<<2))|0);
      HEAP32[(($arrayidx13)>>2)]=$or;
      var $32=$pc;
      var $33=$fs;
      var $f14=(($33)|0);
      var $34=HEAP32[(($f14)>>2)];
      var $code15=(($34+12)|0);
      var $35=HEAP32[(($code15)>>2)];
      var $arrayidx16=(($35+($32<<2))|0);
      var $36=HEAP32[(($arrayidx16)>>2)];
      var $and17=$36 & -8372225;
      var $nh18=(($cc+24)|0);
      var $37=HEAP32[(($nh18)>>2)];
      var $call19=_luaO_int2fb($37);
      var $shl20=$call19 << 14;
      var $and21=$shl20 & 8372224;
      var $or22=$and17 | $and21;
      var $38=$pc;
      var $39=$fs;
      var $f23=(($39)|0);
      var $40=HEAP32[(($f23)>>2)];
      var $code24=(($40+12)|0);
      var $41=HEAP32[(($code24)>>2)];
      var $arrayidx25=(($41+($38<<2))|0);
      HEAP32[(($arrayidx25)>>2)]=$or22;
      STACKTOP = __stackBase__;
      Module.print(INDENT + 'Exiting: _constructor');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_constructor["X"]=1;

function _body($ls, $e, $ismethod, $line) {
  var label = 0;
  var __stackBase__  = STACKTOP; STACKTOP = (STACKTOP + 64)|0; _memset(__stackBase__, 0, 64);
  Module.print(INDENT + ' Entering: _body: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $ls_addr;
      var $e_addr;
      var $ismethod_addr;
      var $line_addr;
      var $new_fs=__stackBase__;
      var $bl=(__stackBase__)+(52);
      $ls_addr=$ls;
      $e_addr=$e;
      $ismethod_addr=$ismethod;
      $line_addr=$line;
      var $0=$ls_addr;
      var $call=_addprototype($0);
      var $f=(($new_fs)|0);
      HEAP32[(($f)>>2)]=$call;
      var $1=$line_addr;
      var $f1=(($new_fs)|0);
      var $2=HEAP32[(($f1)>>2)];
      var $linedefined=(($2+64)|0);
      HEAP32[(($linedefined)>>2)]=$1;
      var $3=$ls_addr;
      _open_func($3, $new_fs, $bl);
      var $4=$ls_addr;
      _checknext($4, 40);
      var $5=$ismethod_addr;
      var $tobool=(($5)|0)!=0;
      if ($tobool) { label = 3; break; } else { label = 4; break; }
    case 3: 
      var $6=$ls_addr;
      _new_localvarliteral_($6, ((5244176)|0), 4);
      var $7=$ls_addr;
      _adjustlocalvars($7, 1);
      label = 4; break;
    case 4: 
      var $8=$ls_addr;
      _parlist($8);
      var $9=$ls_addr;
      _checknext($9, 41);
      var $10=$ls_addr;
      _statlist($10);
      var $11=$ls_addr;
      var $linenumber=(($11+4)|0);
      var $12=HEAP32[(($linenumber)>>2)];
      var $f2=(($new_fs)|0);
      var $13=HEAP32[(($f2)>>2)];
      var $lastlinedefined=(($13+68)|0);
      HEAP32[(($lastlinedefined)>>2)]=$12;
      var $14=$ls_addr;
      var $15=$line_addr;
      _check_match($14, 262, 265, $15);
      var $16=$ls_addr;
      var $17=$e_addr;
      _codeclosure($16, $17);
      var $18=$ls_addr;
      _close_func($18);
      STACKTOP = __stackBase__;
      Module.print(INDENT + 'Exiting: _body');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_body["X"]=1;

function _checklimit($fs, $v, $l, $what) {
  var label = 0;

  Module.print(INDENT + ' Entering: _checklimit: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $fs_addr;
      var $v_addr;
      var $l_addr;
      var $what_addr;
      $fs_addr=$fs;
      $v_addr=$v;
      $l_addr=$l;
      $what_addr=$what;
      var $0=$v_addr;
      var $1=$l_addr;
      var $cmp=(($0)|0) > (($1)|0);
      if ($cmp) { label = 3; break; } else { label = 4; break; }
    case 3: 
      var $2=$fs_addr;
      var $3=$l_addr;
      var $4=$what_addr;
      _errorlimit($2, $3, $4);

    case 4: 

      Module.print(INDENT + 'Exiting: _checklimit');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _simpleexp($ls, $v) {
  var label = 0;

  Module.print(INDENT + ' Entering: _simpleexp: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $ls_addr;
      var $v_addr;
      var $fs;
      $ls_addr=$ls;
      $v_addr=$v;
      var $0=$ls_addr;
      var $t=(($0+12)|0);
      var $token=(($t)|0);
      var $1=HEAP32[(($token)>>2)];
      if ((($1)|0)==287) {
        label = 3; break;
      }
      else if ((($1)|0)==289) {
        label = 4; break;
      }
      else if ((($1)|0)==270) {
        label = 5; break;
      }
      else if ((($1)|0)==276) {
        label = 6; break;
      }
      else if ((($1)|0)==263) {
        label = 7; break;
      }
      else if ((($1)|0)==280) {
        label = 8; break;
      }
      else if ((($1)|0)==123) {
        label = 11; break;
      }
      else if ((($1)|0)==265) {
        label = 12; break;
      }
      else {
      label = 13; break;
      }
      
    case 3: 
      var $2=$v_addr;
      _init_exp($2, 5, 0);
      var $3=$ls_addr;
      var $t1=(($3+12)|0);
      var $seminfo=(($t1+4)|0);
      var $r=$seminfo;
      var $4=(HEAP32[((tempDoublePtr)>>2)]=HEAP32[(($r)>>2)],HEAP32[(((tempDoublePtr)+(4))>>2)]=HEAP32[((($r)+(4))>>2)],HEAPF64[(tempDoublePtr)>>3]);
      var $5=$v_addr;
      var $u=(($5+4)|0);
      var $nval=$u;
      (HEAPF64[(tempDoublePtr)>>3]=$4,HEAP32[(($nval)>>2)]=HEAP32[((tempDoublePtr)>>2)],HEAP32[((($nval)+(4))>>2)]=HEAP32[(((tempDoublePtr)+(4))>>2)]);
      label = 14; break;
    case 4: 
      var $6=$ls_addr;
      var $7=$v_addr;
      var $8=$ls_addr;
      var $t3=(($8+12)|0);
      var $seminfo4=(($t3+4)|0);
      var $ts=$seminfo4;
      var $9=HEAP32[(($ts)>>2)];
      _codestring($6, $7, $9);
      label = 14; break;
    case 5: 
      var $10=$v_addr;
      _init_exp($10, 1, 0);
      label = 14; break;
    case 6: 
      var $11=$v_addr;
      _init_exp($11, 2, 0);
      label = 14; break;
    case 7: 
      var $12=$v_addr;
      _init_exp($12, 3, 0);
      label = 14; break;
    case 8: 
      var $13=$ls_addr;
      var $fs9=(($13+36)|0);
      var $14=HEAP32[(($fs9)>>2)];
      $fs=$14;
      var $15=$fs;
      var $f=(($15)|0);
      var $16=HEAP32[(($f)>>2)];
      var $is_vararg=(($16+77)|0);
      var $17=HEAP8[($is_vararg)];
      var $tobool=(($17 << 24) >> 24)!=0;
      if ($tobool) { label = 10; break; } else { label = 9; break; }
    case 9: 
      var $18=$ls_addr;
      _luaX_syntaxerror($18, ((5244276)|0));

    case 10: 
      var $19=$v_addr;
      var $20=$fs;
      var $call=_luaK_codeABC($20, 38, 0, 1, 0);
      _init_exp($19, 13, $call);
      label = 14; break;
    case 11: 
      var $21=$ls_addr;
      var $22=$v_addr;
      _constructor($21, $22);
      label = 15; break;
    case 12: 
      var $23=$ls_addr;
      _luaX_next($23);
      var $24=$ls_addr;
      var $25=$v_addr;
      var $26=$ls_addr;
      var $linenumber=(($26+4)|0);
      var $27=HEAP32[(($linenumber)>>2)];
      _body($24, $25, 0, $27);
      label = 15; break;
    case 13: 
      var $28=$ls_addr;
      var $29=$v_addr;
      _suffixedexp($28, $29);
      label = 15; break;
    case 14: 
      var $30=$ls_addr;
      _luaX_next($30);
      label = 15; break;
    case 15: 

      Module.print(INDENT + 'Exiting: _simpleexp');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_simpleexp["X"]=1;

function _addprototype($ls) {
  var label = 0;

  Module.print(INDENT + ' Entering: _addprototype: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $ls_addr;
      var $clp;
      var $L;
      var $fs;
      var $f;
      var $oldsize;
      $ls_addr=$ls;
      var $0=$ls_addr;
      var $L1=(($0+40)|0);
      var $1=HEAP32[(($L1)>>2)];
      $L=$1;
      var $2=$ls_addr;
      var $fs2=(($2+36)|0);
      var $3=HEAP32[(($fs2)>>2)];
      $fs=$3;
      var $4=$fs;
      var $f3=(($4)|0);
      var $5=HEAP32[(($f3)>>2)];
      $f=$5;
      var $6=$fs;
      var $np=(($6+36)|0);
      var $7=HEAP32[(($np)>>2)];
      var $8=$f;
      var $sizep=(($8+56)|0);
      var $9=HEAP32[(($sizep)>>2)];
      var $cmp=(($7)|0) >= (($9)|0);
      if ($cmp) { label = 3; break; } else { label = 9; break; }
    case 3: 
      var $10=$f;
      var $sizep4=(($10+56)|0);
      var $11=HEAP32[(($sizep4)>>2)];
      $oldsize=$11;
      var $12=$fs;
      var $np5=(($12+36)|0);
      var $13=HEAP32[(($np5)>>2)];
      var $add=((($13)+(1))|0);
      var $14=$f;
      var $sizep6=(($14+56)|0);
      var $15=HEAP32[(($sizep6)>>2)];
      var $cmp7=(($add)|0) > (($15)|0);
      if ($cmp7) { label = 4; break; } else { label = 5; break; }
    case 4: 
      var $16=$L;
      var $17=$f;
      var $p=(($17+16)|0);
      var $18=HEAP32[(($p)>>2)];
      var $19=$18;
      var $20=$f;
      var $sizep9=(($20+56)|0);
      var $call=_luaM_growaux_($16, $19, $sizep9, 4, 262143, ((5246848)|0));
      var $21=$call;
      var $22=$f;
      var $p10=(($22+16)|0);
      HEAP32[(($p10)>>2)]=$21;
      label = 5; break;
    case 5: 
      label = 6; break;
    case 6: 
      var $23=$oldsize;
      var $24=$f;
      var $sizep11=(($24+56)|0);
      var $25=HEAP32[(($sizep11)>>2)];
      var $cmp12=(($23)|0) < (($25)|0);
      if ($cmp12) { label = 7; break; } else { label = 8; break; }
    case 7: 
      var $26=$oldsize;
      var $inc=((($26)+(1))|0);
      $oldsize=$inc;
      var $27=$f;
      var $p13=(($27+16)|0);
      var $28=HEAP32[(($p13)>>2)];
      var $arrayidx=(($28+($26<<2))|0);
      HEAP32[(($arrayidx)>>2)]=0;
      label = 6; break;
    case 8: 
      label = 9; break;
    case 9: 
      var $29=$L;
      var $call15=_luaF_newproto($29);
      $clp=$call15;
      var $30=$fs;
      var $np16=(($30+36)|0);
      var $31=HEAP32[(($np16)>>2)];
      var $inc17=((($31)+(1))|0);
      HEAP32[(($np16)>>2)]=$inc17;
      var $32=$f;
      var $p18=(($32+16)|0);
      var $33=HEAP32[(($p18)>>2)];
      var $arrayidx19=(($33+($31<<2))|0);
      HEAP32[(($arrayidx19)>>2)]=$call15;
      var $34=$clp;
      var $35=$34;
      var $gch=$35;
      var $marked=(($gch+5)|0);
      var $36=HEAP8[($marked)];
      var $conv=(($36)&255);
      var $and=$conv & 3;
      var $tobool=(($and)|0)!=0;
      if ($tobool) { label = 10; break; } else { label = 12; break; }
    case 10: 
      var $37=$f;
      var $38=$37;
      var $gch20=$38;
      var $marked21=(($gch20+5)|0);
      var $39=HEAP8[($marked21)];
      var $conv22=(($39)&255);
      var $and23=$conv22 & 4;
      var $tobool24=(($and23)|0)!=0;
      if ($tobool24) { label = 11; break; } else { label = 12; break; }
    case 11: 
      var $40=$L;
      var $41=$f;
      var $42=$41;
      var $43=$clp;
      var $44=$43;
      _luaC_barrier_($40, $42, $44);
      label = 12; break;
    case 12: 
      var $45=$clp;

      Module.print(INDENT + 'Exiting: _addprototype');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return $45;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_addprototype["X"]=1;

function _new_localvarliteral_($ls, $name, $sz) {
  var label = 0;

  Module.print(INDENT + ' Entering: _new_localvarliteral_: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';

  var $ls_addr;
  var $name_addr;
  var $sz_addr;
  $ls_addr=$ls;
  $name_addr=$name;
  $sz_addr=$sz;
  var $0=$ls_addr;
  var $1=$ls_addr;
  var $2=$name_addr;
  var $3=$sz_addr;
  var $call=_luaX_newstring($1, $2, $3);
  _new_localvar($0, $call);

  Module.print(INDENT + 'Exiting: _new_localvarliteral_');
  INDENT = INDENT.substr(0, INDENT.length-2);
  return;
  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _adjustlocalvars($ls, $nvars) {
  var label = 0;

  Module.print(INDENT + ' Entering: _adjustlocalvars: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $ls_addr;
      var $nvars_addr;
      var $fs;
      $ls_addr=$ls;
      $nvars_addr=$nvars;
      var $0=$ls_addr;
      var $fs1=(($0+36)|0);
      var $1=HEAP32[(($fs1)>>2)];
      $fs=$1;
      var $2=$fs;
      var $nactvar=(($2+46)|0);
      var $3=HEAP8[($nactvar)];
      var $conv=(($3)&255);
      var $4=$nvars_addr;
      var $add=((($conv)+($4))|0);
      var $conv2=(($add) & 255);
      var $5=$fs;
      var $nactvar3=(($5+46)|0);
      HEAP8[($nactvar3)]=$conv2;
      label = 3; break;
    case 3: 
      var $6=$nvars_addr;
      var $tobool=(($6)|0)!=0;
      if ($tobool) { label = 4; break; } else { label = 6; break; }
    case 4: 
      var $7=$fs;
      var $pc=(($7+20)|0);
      var $8=HEAP32[(($pc)>>2)];
      var $9=$fs;
      var $10=$fs;
      var $nactvar4=(($10+46)|0);
      var $11=HEAP8[($nactvar4)];
      var $conv5=(($11)&255);
      var $12=$nvars_addr;
      var $sub=((($conv5)-($12))|0);
      var $call=_getlocvar($9, $sub);
      var $startpc=(($call+4)|0);
      HEAP32[(($startpc)>>2)]=$8;
      label = 5; break;
    case 5: 
      var $13=$nvars_addr;
      var $dec=((($13)-(1))|0);
      $nvars_addr=$dec;
      label = 3; break;
    case 6: 

      Module.print(INDENT + 'Exiting: _adjustlocalvars');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _codeclosure($ls, $v) {
  var label = 0;

  Module.print(INDENT + ' Entering: _codeclosure: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';

  var $ls_addr;
  var $v_addr;
  var $fs;
  $ls_addr=$ls;
  $v_addr=$v;
  var $0=$ls_addr;
  var $fs1=(($0+36)|0);
  var $1=HEAP32[(($fs1)>>2)];
  var $prev=(($1+8)|0);
  var $2=HEAP32[(($prev)>>2)];
  $fs=$2;
  var $3=$v_addr;
  var $4=$fs;
  var $5=$fs;
  var $np=(($5+36)|0);
  var $6=HEAP32[(($np)>>2)];
  var $sub=((($6)-(1))|0);
  var $call=_luaK_codeABx($4, 37, 0, $sub);
  _init_exp($3, 11, $call);
  var $7=$fs;
  var $8=$v_addr;
  _luaK_exp2nextreg($7, $8);

  Module.print(INDENT + 'Exiting: _codeclosure');
  INDENT = INDENT.substr(0, INDENT.length-2);
  return;
  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _new_localvar($ls, $name) {
  var label = 0;

  Module.print(INDENT + ' Entering: _new_localvar: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $ls_addr;
      var $name_addr;
      var $fs;
      var $dyd;
      var $reg;
      $ls_addr=$ls;
      $name_addr=$name;
      var $0=$ls_addr;
      var $fs1=(($0+36)|0);
      var $1=HEAP32[(($fs1)>>2)];
      $fs=$1;
      var $2=$ls_addr;
      var $dyd2=(($2+52)|0);
      var $3=HEAP32[(($dyd2)>>2)];
      $dyd=$3;
      var $4=$ls_addr;
      var $5=$name_addr;
      var $call=_registerlocalvar($4, $5);
      $reg=$call;
      var $6=$fs;
      var $7=$dyd;
      var $actvar=(($7)|0);
      var $n=(($actvar+4)|0);
      var $8=HEAP32[(($n)>>2)];
      var $add=((($8)+(1))|0);
      var $9=$fs;
      var $firstlocal=(($9+40)|0);
      var $10=HEAP32[(($firstlocal)>>2)];
      var $sub=((($add)-($10))|0);
      _checklimit($6, $sub, 200, ((5246988)|0));
      var $11=$dyd;
      var $actvar3=(($11)|0);
      var $n4=(($actvar3+4)|0);
      var $12=HEAP32[(($n4)>>2)];
      var $add5=((($12)+(1))|0);
      var $add6=((($add5)+(1))|0);
      var $13=$dyd;
      var $actvar7=(($13)|0);
      var $size=(($actvar7+8)|0);
      var $14=HEAP32[(($size)>>2)];
      var $cmp=(($add6)|0) > (($14)|0);
      if ($cmp) { label = 3; break; } else { label = 4; break; }
    case 3: 
      var $15=$ls_addr;
      var $L=(($15+40)|0);
      var $16=HEAP32[(($L)>>2)];
      var $17=$dyd;
      var $actvar8=(($17)|0);
      var $arr=(($actvar8)|0);
      var $18=HEAP32[(($arr)>>2)];
      var $19=$18;
      var $20=$dyd;
      var $actvar9=(($20)|0);
      var $size10=(($actvar9+8)|0);
      var $call11=_luaM_growaux_($16, $19, $size10, 2, 2147483645, ((5246988)|0));
      var $21=$call11;
      var $22=$dyd;
      var $actvar12=(($22)|0);
      var $arr13=(($actvar12)|0);
      HEAP32[(($arr13)>>2)]=$21;
      label = 4; break;
    case 4: 
      var $23=$reg;
      var $conv=(($23) & 65535);
      var $24=$dyd;
      var $actvar14=(($24)|0);
      var $n15=(($actvar14+4)|0);
      var $25=HEAP32[(($n15)>>2)];
      var $inc=((($25)+(1))|0);
      HEAP32[(($n15)>>2)]=$inc;
      var $26=$dyd;
      var $actvar16=(($26)|0);
      var $arr17=(($actvar16)|0);
      var $27=HEAP32[(($arr17)>>2)];
      var $arrayidx=(($27+($25<<1))|0);
      var $idx=(($arrayidx)|0);
      HEAP16[(($idx)>>1)]=$conv;

      Module.print(INDENT + 'Exiting: _new_localvar');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_new_localvar["X"]=1;

function _registerlocalvar($ls, $varname) {
  var label = 0;

  Module.print(INDENT + ' Entering: _registerlocalvar: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $ls_addr;
      var $varname_addr;
      var $fs;
      var $f;
      var $oldsize;
      $ls_addr=$ls;
      $varname_addr=$varname;
      var $0=$ls_addr;
      var $fs1=(($0+36)|0);
      var $1=HEAP32[(($fs1)>>2)];
      $fs=$1;
      var $2=$fs;
      var $f2=(($2)|0);
      var $3=HEAP32[(($f2)>>2)];
      $f=$3;
      var $4=$f;
      var $sizelocvars=(($4+60)|0);
      var $5=HEAP32[(($sizelocvars)>>2)];
      $oldsize=$5;
      var $6=$fs;
      var $nlocvars=(($6+44)|0);
      var $7=HEAP16[(($nlocvars)>>1)];
      var $conv=(($7 << 16) >> 16);
      var $add=((($conv)+(1))|0);
      var $8=$f;
      var $sizelocvars3=(($8+60)|0);
      var $9=HEAP32[(($sizelocvars3)>>2)];
      var $cmp=(($add)|0) > (($9)|0);
      if ($cmp) { label = 3; break; } else { label = 4; break; }
    case 3: 
      var $10=$ls_addr;
      var $L=(($10+40)|0);
      var $11=HEAP32[(($L)>>2)];
      var $12=$f;
      var $locvars=(($12+24)|0);
      var $13=HEAP32[(($locvars)>>2)];
      var $14=$13;
      var $15=$f;
      var $sizelocvars5=(($15+60)|0);
      var $call=_luaM_growaux_($11, $14, $sizelocvars5, 12, 32767, ((5246988)|0));
      var $16=$call;
      var $17=$f;
      var $locvars6=(($17+24)|0);
      HEAP32[(($locvars6)>>2)]=$16;
      label = 4; break;
    case 4: 
      label = 5; break;
    case 5: 
      var $18=$oldsize;
      var $19=$f;
      var $sizelocvars7=(($19+60)|0);
      var $20=HEAP32[(($sizelocvars7)>>2)];
      var $cmp8=(($18)|0) < (($20)|0);
      if ($cmp8) { label = 6; break; } else { label = 7; break; }
    case 6: 
      var $21=$oldsize;
      var $inc=((($21)+(1))|0);
      $oldsize=$inc;
      var $22=$f;
      var $locvars10=(($22+24)|0);
      var $23=HEAP32[(($locvars10)>>2)];
      var $arrayidx=(($23+((($21)*(12))&-1))|0);
      var $varname11=(($arrayidx)|0);
      HEAP32[(($varname11)>>2)]=0;
      label = 5; break;
    case 7: 
      var $24=$varname_addr;
      var $25=$fs;
      var $nlocvars12=(($25+44)|0);
      var $26=HEAP16[(($nlocvars12)>>1)];
      var $idxprom=(($26 << 16) >> 16);
      var $27=$f;
      var $locvars13=(($27+24)|0);
      var $28=HEAP32[(($locvars13)>>2)];
      var $arrayidx14=(($28+((($idxprom)*(12))&-1))|0);
      var $varname15=(($arrayidx14)|0);
      HEAP32[(($varname15)>>2)]=$24;
      var $29=$varname_addr;
      var $30=$29;
      var $gch=$30;
      var $marked=(($gch+5)|0);
      var $31=HEAP8[($marked)];
      var $conv16=(($31)&255);
      var $and=$conv16 & 3;
      var $tobool=(($and)|0)!=0;
      if ($tobool) { label = 8; break; } else { label = 10; break; }
    case 8: 
      var $32=$f;
      var $33=$32;
      var $gch17=$33;
      var $marked18=(($gch17+5)|0);
      var $34=HEAP8[($marked18)];
      var $conv19=(($34)&255);
      var $and20=$conv19 & 4;
      var $tobool21=(($and20)|0)!=0;
      if ($tobool21) { label = 9; break; } else { label = 10; break; }
    case 9: 
      var $35=$ls_addr;
      var $L23=(($35+40)|0);
      var $36=HEAP32[(($L23)>>2)];
      var $37=$f;
      var $38=$37;
      var $39=$varname_addr;
      var $40=$39;
      _luaC_barrier_($36, $38, $40);
      label = 10; break;
    case 10: 
      var $41=$fs;
      var $nlocvars25=(($41+44)|0);
      var $42=HEAP16[(($nlocvars25)>>1)];
      var $inc26=((($42)+(1))&65535);
      HEAP16[(($nlocvars25)>>1)]=$inc26;
      var $conv27=(($42 << 16) >> 16);

      Module.print(INDENT + 'Exiting: _registerlocalvar');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return $conv27;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_registerlocalvar["X"]=1;

function _closelistfield($fs, $cc) {
  var label = 0;

  Module.print(INDENT + ' Entering: _closelistfield: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $fs_addr;
      var $cc_addr;
      $fs_addr=$fs;
      $cc_addr=$cc;
      var $0=$cc_addr;
      var $v=(($0)|0);
      var $k=(($v)|0);
      var $1=HEAP32[(($k)>>2)];
      var $cmp=(($1)|0)==0;
      if ($cmp) { label = 3; break; } else { label = 4; break; }
    case 3: 
      label = 6; break;
    case 4: 
      var $2=$fs_addr;
      var $3=$cc_addr;
      var $v1=(($3)|0);
      _luaK_exp2nextreg($2, $v1);
      var $4=$cc_addr;
      var $v2=(($4)|0);
      var $k3=(($v2)|0);
      HEAP32[(($k3)>>2)]=0;
      var $5=$cc_addr;
      var $tostore=(($5+32)|0);
      var $6=HEAP32[(($tostore)>>2)];
      var $cmp4=(($6)|0)==50;
      if ($cmp4) { label = 5; break; } else { label = 6; break; }
    case 5: 
      var $7=$fs_addr;
      var $8=$cc_addr;
      var $t=(($8+20)|0);
      var $9=HEAP32[(($t)>>2)];
      var $u=(($9+4)|0);
      var $info=$u;
      var $10=HEAP32[(($info)>>2)];
      var $11=$cc_addr;
      var $na=(($11+28)|0);
      var $12=HEAP32[(($na)>>2)];
      var $13=$cc_addr;
      var $tostore6=(($13+32)|0);
      var $14=HEAP32[(($tostore6)>>2)];
      _luaK_setlist($7, $10, $12, $14);
      var $15=$cc_addr;
      var $tostore7=(($15+32)|0);
      HEAP32[(($tostore7)>>2)]=0;
      label = 6; break;
    case 6: 

      Module.print(INDENT + 'Exiting: _closelistfield');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _field($ls, $cc) {
  var label = 0;

  Module.print(INDENT + ' Entering: _field: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $ls_addr;
      var $cc_addr;
      $ls_addr=$ls;
      $cc_addr=$cc;
      var $0=$ls_addr;
      var $t=(($0+12)|0);
      var $token=(($t)|0);
      var $1=HEAP32[(($token)>>2)];
      if ((($1)|0)==288) {
        label = 3; break;
      }
      else if ((($1)|0)==91) {
        label = 7; break;
      }
      else {
      label = 8; break;
      }
      
    case 3: 
      var $2=$ls_addr;
      var $call=_luaX_lookahead($2);
      var $cmp=(($call)|0)!=61;
      if ($cmp) { label = 4; break; } else { label = 5; break; }
    case 4: 
      var $3=$ls_addr;
      var $4=$cc_addr;
      _listfield($3, $4);
      label = 6; break;
    case 5: 
      var $5=$ls_addr;
      var $6=$cc_addr;
      _recfield($5, $6);
      label = 6; break;
    case 6: 
      label = 9; break;
    case 7: 
      var $7=$ls_addr;
      var $8=$cc_addr;
      _recfield($7, $8);
      label = 9; break;
    case 8: 
      var $9=$ls_addr;
      var $10=$cc_addr;
      _listfield($9, $10);
      label = 9; break;
    case 9: 

      Module.print(INDENT + 'Exiting: _field');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _lastlistfield($fs, $cc) {
  var label = 0;

  Module.print(INDENT + ' Entering: _lastlistfield: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $fs_addr;
      var $cc_addr;
      $fs_addr=$fs;
      $cc_addr=$cc;
      var $0=$cc_addr;
      var $tostore=(($0+32)|0);
      var $1=HEAP32[(($tostore)>>2)];
      var $cmp=(($1)|0)==0;
      if ($cmp) { label = 3; break; } else { label = 4; break; }
    case 3: 
      label = 10; break;
    case 4: 
      var $2=$cc_addr;
      var $v=(($2)|0);
      var $k=(($v)|0);
      var $3=HEAP32[(($k)>>2)];
      var $cmp1=(($3)|0)==12;
      if ($cmp1) { label = 6; break; } else { label = 5; break; }
    case 5: 
      var $4=$cc_addr;
      var $v2=(($4)|0);
      var $k3=(($v2)|0);
      var $5=HEAP32[(($k3)>>2)];
      var $cmp4=(($5)|0)==13;
      if ($cmp4) { label = 6; break; } else { label = 7; break; }
    case 6: 
      var $6=$fs_addr;
      var $7=$cc_addr;
      var $v6=(($7)|0);
      _luaK_setreturns($6, $v6, -1);
      var $8=$fs_addr;
      var $9=$cc_addr;
      var $t=(($9+20)|0);
      var $10=HEAP32[(($t)>>2)];
      var $u=(($10+4)|0);
      var $info=$u;
      var $11=HEAP32[(($info)>>2)];
      var $12=$cc_addr;
      var $na=(($12+28)|0);
      var $13=HEAP32[(($na)>>2)];
      _luaK_setlist($8, $11, $13, -1);
      var $14=$cc_addr;
      var $na7=(($14+28)|0);
      var $15=HEAP32[(($na7)>>2)];
      var $dec=((($15)-(1))|0);
      HEAP32[(($na7)>>2)]=$dec;
      label = 10; break;
    case 7: 
      var $16=$cc_addr;
      var $v8=(($16)|0);
      var $k9=(($v8)|0);
      var $17=HEAP32[(($k9)>>2)];
      var $cmp10=(($17)|0)!=0;
      if ($cmp10) { label = 8; break; } else { label = 9; break; }
    case 8: 
      var $18=$fs_addr;
      var $19=$cc_addr;
      var $v12=(($19)|0);
      _luaK_exp2nextreg($18, $v12);
      label = 9; break;
    case 9: 
      var $20=$fs_addr;
      var $21=$cc_addr;
      var $t14=(($21+20)|0);
      var $22=HEAP32[(($t14)>>2)];
      var $u15=(($22+4)|0);
      var $info16=$u15;
      var $23=HEAP32[(($info16)>>2)];
      var $24=$cc_addr;
      var $na17=(($24+28)|0);
      var $25=HEAP32[(($na17)>>2)];
      var $26=$cc_addr;
      var $tostore18=(($26+32)|0);
      var $27=HEAP32[(($tostore18)>>2)];
      _luaK_setlist($20, $23, $25, $27);
      label = 10; break;
    case 10: 

      Module.print(INDENT + 'Exiting: _lastlistfield');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_lastlistfield["X"]=1;

function _listfield($ls, $cc) {
  var label = 0;

  Module.print(INDENT + ' Entering: _listfield: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';

  var $ls_addr;
  var $cc_addr;
  $ls_addr=$ls;
  $cc_addr=$cc;
  var $0=$ls_addr;
  var $1=$cc_addr;
  var $v=(($1)|0);
  _expr($0, $v);
  var $2=$ls_addr;
  var $fs=(($2+36)|0);
  var $3=HEAP32[(($fs)>>2)];
  var $4=$cc_addr;
  var $na=(($4+28)|0);
  var $5=HEAP32[(($na)>>2)];
  _checklimit($3, $5, 2147483645, ((5246692)|0));
  var $6=$cc_addr;
  var $na1=(($6+28)|0);
  var $7=HEAP32[(($na1)>>2)];
  var $inc=((($7)+(1))|0);
  HEAP32[(($na1)>>2)]=$inc;
  var $8=$cc_addr;
  var $tostore=(($8+32)|0);
  var $9=HEAP32[(($tostore)>>2)];
  var $inc2=((($9)+(1))|0);
  HEAP32[(($tostore)>>2)]=$inc2;

  Module.print(INDENT + 'Exiting: _listfield');
  INDENT = INDENT.substr(0, INDENT.length-2);
  return;
  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _recfield($ls, $cc) {
  var label = 0;
  var __stackBase__  = STACKTOP; STACKTOP = (STACKTOP + 40)|0; _memset(__stackBase__, 0, 40);
  Module.print(INDENT + ' Entering: _recfield: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $ls_addr;
      var $cc_addr;
      var $fs;
      var $reg;
      var $key=__stackBase__;
      var $val=(__stackBase__)+(20);
      var $rkkey;
      $ls_addr=$ls;
      $cc_addr=$cc;
      var $0=$ls_addr;
      var $fs1=(($0+36)|0);
      var $1=HEAP32[(($fs1)>>2)];
      $fs=$1;
      var $2=$ls_addr;
      var $fs2=(($2+36)|0);
      var $3=HEAP32[(($fs2)>>2)];
      var $freereg=(($3+48)|0);
      var $4=HEAP8[($freereg)];
      var $conv=(($4)&255);
      $reg=$conv;
      var $5=$ls_addr;
      var $t=(($5+12)|0);
      var $token=(($t)|0);
      var $6=HEAP32[(($token)>>2)];
      var $cmp=(($6)|0)==288;
      if ($cmp) { label = 3; break; } else { label = 4; break; }
    case 3: 
      var $7=$fs;
      var $8=$cc_addr;
      var $nh=(($8+24)|0);
      var $9=HEAP32[(($nh)>>2)];
      _checklimit($7, $9, 2147483645, ((5246692)|0));
      var $10=$ls_addr;
      _checkname($10, $key);
      label = 5; break;
    case 4: 
      var $11=$ls_addr;
      _yindex($11, $key);
      label = 5; break;
    case 5: 
      var $12=$cc_addr;
      var $nh4=(($12+24)|0);
      var $13=HEAP32[(($nh4)>>2)];
      var $inc=((($13)+(1))|0);
      HEAP32[(($nh4)>>2)]=$inc;
      var $14=$ls_addr;
      _checknext($14, 61);
      var $15=$fs;
      var $call=_luaK_exp2RK($15, $key);
      $rkkey=$call;
      var $16=$ls_addr;
      _expr($16, $val);
      var $17=$fs;
      var $18=$cc_addr;
      var $t5=(($18+20)|0);
      var $19=HEAP32[(($t5)>>2)];
      var $u=(($19+4)|0);
      var $info=$u;
      var $20=HEAP32[(($info)>>2)];
      var $21=$rkkey;
      var $22=$fs;
      var $call6=_luaK_exp2RK($22, $val);
      var $call7=_luaK_codeABC($17, 10, $20, $21, $call6);
      var $23=$reg;
      var $conv8=(($23) & 255);
      var $24=$fs;
      var $freereg9=(($24+48)|0);
      HEAP8[($freereg9)]=$conv8;
      STACKTOP = __stackBase__;
      Module.print(INDENT + 'Exiting: _recfield');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_recfield["X"]=1;

function _checkname($ls, $e) {
  var label = 0;

  Module.print(INDENT + ' Entering: _checkname: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';

  var $ls_addr;
  var $e_addr;
  $ls_addr=$ls;
  $e_addr=$e;
  var $0=$ls_addr;
  var $1=$e_addr;
  var $2=$ls_addr;
  var $call=_str_checkname($2);
  _codestring($0, $1, $call);

  Module.print(INDENT + 'Exiting: _checkname');
  INDENT = INDENT.substr(0, INDENT.length-2);
  return;
  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _yindex($ls, $v) {
  var label = 0;

  Module.print(INDENT + ' Entering: _yindex: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';

  var $ls_addr;
  var $v_addr;
  $ls_addr=$ls;
  $v_addr=$v;
  var $0=$ls_addr;
  _luaX_next($0);
  var $1=$ls_addr;
  var $2=$v_addr;
  _expr($1, $2);
  var $3=$ls_addr;
  var $fs=(($3+36)|0);
  var $4=HEAP32[(($fs)>>2)];
  var $5=$v_addr;
  _luaK_exp2val($4, $5);
  var $6=$ls_addr;
  _checknext($6, 93);

  Module.print(INDENT + 'Exiting: _yindex');
  INDENT = INDENT.substr(0, INDENT.length-2);
  return;
  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _fieldsel($ls, $v) {
  var label = 0;
  var __stackBase__  = STACKTOP; STACKTOP = (STACKTOP + 20)|0; _memset(__stackBase__, 0, 20);
  Module.print(INDENT + ' Entering: _fieldsel: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';

  var $ls_addr;
  var $v_addr;
  var $fs;
  var $key=__stackBase__;
  $ls_addr=$ls;
  $v_addr=$v;
  var $0=$ls_addr;
  var $fs1=(($0+36)|0);
  var $1=HEAP32[(($fs1)>>2)];
  $fs=$1;
  var $2=$fs;
  var $3=$v_addr;
  _luaK_exp2anyregup($2, $3);
  var $4=$ls_addr;
  _luaX_next($4);
  var $5=$ls_addr;
  _checkname($5, $key);
  var $6=$fs;
  var $7=$v_addr;
  _luaK_indexed($6, $7, $key);
  STACKTOP = __stackBase__;
  Module.print(INDENT + 'Exiting: _fieldsel');
  INDENT = INDENT.substr(0, INDENT.length-2);
  return;
  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _parlist($ls) {
  var label = 0;

  Module.print(INDENT + ' Entering: _parlist: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $ls_addr;
      var $fs;
      var $f;
      var $nparams;
      $ls_addr=$ls;
      var $0=$ls_addr;
      var $fs1=(($0+36)|0);
      var $1=HEAP32[(($fs1)>>2)];
      $fs=$1;
      var $2=$fs;
      var $f2=(($2)|0);
      var $3=HEAP32[(($f2)>>2)];
      $f=$3;
      $nparams=0;
      var $4=$f;
      var $is_vararg=(($4+77)|0);
      HEAP8[($is_vararg)]=0;
      var $5=$ls_addr;
      var $t=(($5+12)|0);
      var $token=(($t)|0);
      var $6=HEAP32[(($token)>>2)];
      var $cmp=(($6)|0)!=41;
      if ($cmp) { label = 3; break; } else { label = 13; break; }
    case 3: 
      label = 4; break;
    case 4: 
      var $7=$ls_addr;
      var $t3=(($7+12)|0);
      var $token4=(($t3)|0);
      var $8=HEAP32[(($token4)>>2)];
      if ((($8)|0)==288) {
        label = 5; break;
      }
      else if ((($8)|0)==280) {
        label = 6; break;
      }
      else {
      label = 7; break;
      }
      
    case 5: 
      var $9=$ls_addr;
      var $10=$ls_addr;
      var $call=_str_checkname($10);
      _new_localvar($9, $call);
      var $11=$nparams;
      var $inc=((($11)+(1))|0);
      $nparams=$inc;
      label = 8; break;
    case 6: 
      var $12=$ls_addr;
      _luaX_next($12);
      var $13=$f;
      var $is_vararg6=(($13+77)|0);
      HEAP8[($is_vararg6)]=1;
      label = 8; break;
    case 7: 
      var $14=$ls_addr;
      _luaX_syntaxerror($14, ((5247168)|0));

    case 8: 
      label = 9; break;
    case 9: 
      var $15=$f;
      var $is_vararg7=(($15+77)|0);
      var $16=HEAP8[($is_vararg7)];
      var $tobool=(($16 << 24) >> 24)!=0;
      if ($tobool) { var $18 = 0;label = 11; break; } else { label = 10; break; }
    case 10: 
      var $17=$ls_addr;
      var $call8=_testnext($17, 44);
      var $tobool9=(($call8)|0)!=0;
      var $18 = $tobool9;label = 11; break;
    case 11: 
      var $18;
      if ($18) { label = 4; break; } else { label = 12; break; }
    case 12: 
      label = 13; break;
    case 13: 
      var $19=$ls_addr;
      var $20=$nparams;
      _adjustlocalvars($19, $20);
      var $21=$fs;
      var $nactvar=(($21+46)|0);
      var $22=HEAP8[($nactvar)];
      var $23=$f;
      var $numparams=(($23+76)|0);
      HEAP8[($numparams)]=$22;
      var $24=$fs;
      var $25=$fs;
      var $nactvar10=(($25+46)|0);
      var $26=HEAP8[($nactvar10)];
      var $conv=(($26)&255);
      _luaK_reserveregs($24, $conv);

      Module.print(INDENT + 'Exiting: _parlist');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_parlist["X"]=1;

function _errorlimit($fs, $limit, $what) {
  var label = 0;
  var __stackBase__  = STACKTOP; _memset(__stackBase__, 0, 0);
  Module.print(INDENT + ' Entering: _errorlimit: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $fs_addr;
      var $limit_addr;
      var $what_addr;
      var $L;
      var $msg;
      var $line;
      var $where;
      $fs_addr=$fs;
      $limit_addr=$limit;
      $what_addr=$what;
      var $0=$fs_addr;
      var $ls=(($0+12)|0);
      var $1=HEAP32[(($ls)>>2)];
      var $L1=(($1+40)|0);
      var $2=HEAP32[(($L1)>>2)];
      $L=$2;
      var $3=$fs_addr;
      var $f=(($3)|0);
      var $4=HEAP32[(($f)>>2)];
      var $linedefined=(($4+64)|0);
      var $5=HEAP32[(($linedefined)>>2)];
      $line=$5;
      var $6=$line;
      var $cmp=(($6)|0)==0;
      if ($cmp) { label = 3; break; } else { label = 4; break; }
    case 3: 
      var $cond = ((5246628)|0);label = 5; break;
    case 4: 
      var $7=$L;
      var $8=$line;
      var $call=_luaO_pushfstring($7, ((5246564)|0), (tempInt=STACKTOP,_memset(STACKTOP, 0, 4),STACKTOP = (STACKTOP + 4)|0,HEAP32[((tempInt)>>2)]=$8,tempInt));
      var $cond = $call;label = 5; break;
    case 5: 
      var $cond;
      $where=$cond;
      var $9=$L;
      var $10=$what_addr;
      var $11=$limit_addr;
      var $12=$where;
      var $call2=_luaO_pushfstring($9, ((5246416)|0), (tempInt=STACKTOP,_memset(STACKTOP, 0, 12),STACKTOP = (STACKTOP + 12)|0,HEAP32[((tempInt)>>2)]=$10,HEAP32[(((tempInt)+(4))>>2)]=$11,HEAP32[(((tempInt)+(8))>>2)]=$12,tempInt));
      $msg=$call2;
      var $13=$fs_addr;
      var $ls3=(($13+12)|0);
      var $14=HEAP32[(($ls3)>>2)];
      var $15=$msg;
      _luaX_syntaxerror($14, $15);

    case 6: 
      STACKTOP = __stackBase__;
      Module.print(INDENT + 'Exiting: _errorlimit');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _primaryexp($ls, $v) {
  var label = 0;

  Module.print(INDENT + ' Entering: _primaryexp: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $ls_addr;
      var $v_addr;
      var $line;
      $ls_addr=$ls;
      $v_addr=$v;
      var $0=$ls_addr;
      var $t=(($0+12)|0);
      var $token=(($t)|0);
      var $1=HEAP32[(($token)>>2)];
      if ((($1)|0)==40) {
        label = 3; break;
      }
      else if ((($1)|0)==288) {
        label = 4; break;
      }
      else {
      label = 5; break;
      }
      
    case 3: 
      var $2=$ls_addr;
      var $linenumber=(($2+4)|0);
      var $3=HEAP32[(($linenumber)>>2)];
      $line=$3;
      var $4=$ls_addr;
      _luaX_next($4);
      var $5=$ls_addr;
      var $6=$v_addr;
      _expr($5, $6);
      var $7=$ls_addr;
      var $8=$line;
      _check_match($7, 41, 40, $8);
      var $9=$ls_addr;
      var $fs=(($9+36)|0);
      var $10=HEAP32[(($fs)>>2)];
      var $11=$v_addr;
      _luaK_dischargevars($10, $11);
      label = 6; break;
    case 4: 
      var $12=$ls_addr;
      var $13=$v_addr;
      _singlevar($12, $13);
      label = 6; break;
    case 5: 
      var $14=$ls_addr;
      _luaX_syntaxerror($14, ((5246264)|0));

    case 6: 

      Module.print(INDENT + 'Exiting: _primaryexp');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _markupval($fs, $level) {
  var label = 0;

  Module.print(INDENT + ' Entering: _markupval: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $fs_addr;
      var $level_addr;
      var $bl;
      $fs_addr=$fs;
      $level_addr=$level;
      var $0=$fs_addr;
      var $bl1=(($0+16)|0);
      var $1=HEAP32[(($bl1)>>2)];
      $bl=$1;
      label = 3; break;
    case 3: 
      var $2=$bl;
      var $nactvar=(($2+8)|0);
      var $3=HEAP8[($nactvar)];
      var $conv=(($3)&255);
      var $4=$level_addr;
      var $cmp=(($conv)|0) > (($4)|0);
      if ($cmp) { label = 4; break; } else { label = 5; break; }
    case 4: 
      var $5=$bl;
      var $previous=(($5)|0);
      var $6=HEAP32[(($previous)>>2)];
      $bl=$6;
      label = 3; break;
    case 5: 
      var $7=$bl;
      var $upval=(($7+9)|0);
      HEAP8[($upval)]=1;

      Module.print(INDENT + 'Exiting: _markupval');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _enterblock($fs, $bl, $isloop) {
  var label = 0;

  Module.print(INDENT + ' Entering: _enterblock: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';

  var $fs_addr;
  var $bl_addr;
  var $isloop_addr;
  $fs_addr=$fs;
  $bl_addr=$bl;
  $isloop_addr=$isloop;
  var $0=$isloop_addr;
  var $1=$bl_addr;
  var $isloop1=(($1+10)|0);
  HEAP8[($isloop1)]=$0;
  var $2=$fs_addr;
  var $nactvar=(($2+46)|0);
  var $3=HEAP8[($nactvar)];
  var $4=$bl_addr;
  var $nactvar2=(($4+8)|0);
  HEAP8[($nactvar2)]=$3;
  var $5=$fs_addr;
  var $ls=(($5+12)|0);
  var $6=HEAP32[(($ls)>>2)];
  var $dyd=(($6+52)|0);
  var $7=HEAP32[(($dyd)>>2)];
  var $label=(($7+24)|0);
  var $n=(($label+4)|0);
  var $8=HEAP32[(($n)>>2)];
  var $conv=(($8) & 65535);
  var $9=$bl_addr;
  var $firstlabel=(($9+4)|0);
  HEAP16[(($firstlabel)>>1)]=$conv;
  var $10=$fs_addr;
  var $ls3=(($10+12)|0);
  var $11=HEAP32[(($ls3)>>2)];
  var $dyd4=(($11+52)|0);
  var $12=HEAP32[(($dyd4)>>2)];
  var $gt=(($12+12)|0);
  var $n5=(($gt+4)|0);
  var $13=HEAP32[(($n5)>>2)];
  var $conv6=(($13) & 65535);
  var $14=$bl_addr;
  var $firstgoto=(($14+6)|0);
  HEAP16[(($firstgoto)>>1)]=$conv6;
  var $15=$bl_addr;
  var $upval=(($15+9)|0);
  HEAP8[($upval)]=0;
  var $16=$fs_addr;
  var $bl7=(($16+16)|0);
  var $17=HEAP32[(($bl7)>>2)];
  var $18=$bl_addr;
  var $previous=(($18)|0);
  HEAP32[(($previous)>>2)]=$17;
  var $19=$bl_addr;
  var $20=$fs_addr;
  var $bl8=(($20+16)|0);
  HEAP32[(($bl8)>>2)]=$19;

  Module.print(INDENT + 'Exiting: _enterblock');
  INDENT = INDENT.substr(0, INDENT.length-2);
  return;
  INDENT = INDENT.substr(0, INDENT.length-2);
}
_enterblock["X"]=1;

function _singlevar($ls, $var) {
  var label = 0;
  var __stackBase__  = STACKTOP; STACKTOP = (STACKTOP + 20)|0; _memset(__stackBase__, 0, 20);
  Module.print(INDENT + ' Entering: _singlevar: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $ls_addr;
      var $var_addr;
      var $varname;
      var $fs;
      var $key=__stackBase__;
      $ls_addr=$ls;
      $var_addr=$var;
      var $0=$ls_addr;
      var $call=_str_checkname($0);
      $varname=$call;
      var $1=$ls_addr;
      var $fs1=(($1+36)|0);
      var $2=HEAP32[(($fs1)>>2)];
      $fs=$2;
      var $3=$fs;
      var $4=$varname;
      var $5=$var_addr;
      var $call2=_singlevaraux($3, $4, $5, 1);
      var $cmp=(($call2)|0)==0;
      if ($cmp) { label = 3; break; } else { label = 4; break; }
    case 3: 
      var $6=$fs;
      var $7=$ls_addr;
      var $envn=(($7+60)|0);
      var $8=HEAP32[(($envn)>>2)];
      var $9=$var_addr;
      var $call3=_singlevaraux($6, $8, $9, 1);
      var $10=$ls_addr;
      var $11=$varname;
      _codestring($10, $key, $11);
      var $12=$fs;
      var $13=$var_addr;
      _luaK_indexed($12, $13, $key);
      label = 4; break;
    case 4: 
      STACKTOP = __stackBase__;
      Module.print(INDENT + 'Exiting: _singlevar');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _singlevaraux($fs, $n, $var, $base) {
  var label = 0;

  Module.print(INDENT + ' Entering: _singlevaraux: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $retval;
      var $fs_addr;
      var $n_addr;
      var $var_addr;
      var $base_addr;
      var $v;
      var $idx;
      $fs_addr=$fs;
      $n_addr=$n;
      $var_addr=$var;
      $base_addr=$base;
      var $0=$fs_addr;
      var $cmp=(($0)|0)==0;
      if ($cmp) { label = 3; break; } else { label = 4; break; }
    case 3: 
      $retval=0;
      label = 13; break;
    case 4: 
      var $1=$fs_addr;
      var $2=$n_addr;
      var $call=_searchvar($1, $2);
      $v=$call;
      var $3=$v;
      var $cmp1=(($3)|0) >= 0;
      if ($cmp1) { label = 5; break; } else { label = 8; break; }
    case 5: 
      var $4=$var_addr;
      var $5=$v;
      _init_exp($4, 7, $5);
      var $6=$base_addr;
      var $tobool=(($6)|0)!=0;
      if ($tobool) { label = 7; break; } else { label = 6; break; }
    case 6: 
      var $7=$fs_addr;
      var $8=$v;
      _markupval($7, $8);
      label = 7; break;
    case 7: 
      $retval=7;
      label = 13; break;
    case 8: 
      var $9=$fs_addr;
      var $10=$n_addr;
      var $call5=_searchupvalue($9, $10);
      $idx=$call5;
      var $11=$idx;
      var $cmp6=(($11)|0) < 0;
      if ($cmp6) { label = 9; break; } else { label = 12; break; }
    case 9: 
      var $12=$fs_addr;
      var $prev=(($12+8)|0);
      var $13=HEAP32[(($prev)>>2)];
      var $14=$n_addr;
      var $15=$var_addr;
      var $call8=_singlevaraux($13, $14, $15, 0);
      var $cmp9=(($call8)|0)==0;
      if ($cmp9) { label = 10; break; } else { label = 11; break; }
    case 10: 
      $retval=0;
      label = 13; break;
    case 11: 
      var $16=$fs_addr;
      var $17=$n_addr;
      var $18=$var_addr;
      var $call12=_newupvalue($16, $17, $18);
      $idx=$call12;
      label = 12; break;
    case 12: 
      var $19=$var_addr;
      var $20=$idx;
      _init_exp($19, 8, $20);
      $retval=8;
      label = 13; break;
    case 13: 
      var $21=$retval;

      Module.print(INDENT + 'Exiting: _singlevaraux');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return $21;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_singlevaraux["X"]=1;

function _searchvar($fs, $n) {
  var label = 0;

  Module.print(INDENT + ' Entering: _searchvar: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $retval;
      var $fs_addr;
      var $n_addr;
      var $i;
      $fs_addr=$fs;
      $n_addr=$n;
      var $0=$fs_addr;
      var $nactvar=(($0+46)|0);
      var $1=HEAP8[($nactvar)];
      var $conv=(($1)&255);
      var $sub=((($conv)-(1))|0);
      $i=$sub;
      label = 3; break;
    case 3: 
      var $2=$i;
      var $cmp=(($2)|0) >= 0;
      if ($cmp) { label = 4; break; } else { label = 8; break; }
    case 4: 
      var $3=$n_addr;
      var $4=$fs_addr;
      var $5=$i;
      var $call=_getlocvar($4, $5);
      var $varname=(($call)|0);
      var $6=HEAP32[(($varname)>>2)];
      var $call2=_luaS_eqstr($3, $6);
      var $tobool=(($call2)|0)!=0;
      if ($tobool) { label = 5; break; } else { label = 6; break; }
    case 5: 
      var $7=$i;
      $retval=$7;
      label = 9; break;
    case 6: 
      label = 7; break;
    case 7: 
      var $8=$i;
      var $dec=((($8)-(1))|0);
      $i=$dec;
      label = 3; break;
    case 8: 
      $retval=-1;
      label = 9; break;
    case 9: 
      var $9=$retval;

      Module.print(INDENT + 'Exiting: _searchvar');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return $9;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _searchupvalue($fs, $name) {
  var label = 0;

  Module.print(INDENT + ' Entering: _searchupvalue: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $retval;
      var $fs_addr;
      var $name_addr;
      var $i;
      var $up;
      $fs_addr=$fs;
      $name_addr=$name;
      var $0=$fs_addr;
      var $f=(($0)|0);
      var $1=HEAP32[(($f)>>2)];
      var $upvalues=(($1+28)|0);
      var $2=HEAP32[(($upvalues)>>2)];
      $up=$2;
      $i=0;
      label = 3; break;
    case 3: 
      var $3=$i;
      var $4=$fs_addr;
      var $nups=(($4+47)|0);
      var $5=HEAP8[($nups)];
      var $conv=(($5)&255);
      var $cmp=(($3)|0) < (($conv)|0);
      if ($cmp) { label = 4; break; } else { label = 8; break; }
    case 4: 
      var $6=$i;
      var $7=$up;
      var $arrayidx=(($7+($6<<3))|0);
      var $name2=(($arrayidx)|0);
      var $8=HEAP32[(($name2)>>2)];
      var $9=$name_addr;
      var $call=_luaS_eqstr($8, $9);
      var $tobool=(($call)|0)!=0;
      if ($tobool) { label = 5; break; } else { label = 6; break; }
    case 5: 
      var $10=$i;
      $retval=$10;
      label = 9; break;
    case 6: 
      label = 7; break;
    case 7: 
      var $11=$i;
      var $inc=((($11)+(1))|0);
      $i=$inc;
      label = 3; break;
    case 8: 
      $retval=-1;
      label = 9; break;
    case 9: 
      var $12=$retval;

      Module.print(INDENT + 'Exiting: _searchupvalue');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return $12;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _skipnoopstat($ls) {
  var label = 0;

  Module.print(INDENT + ' Entering: _skipnoopstat: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $ls_addr;
      $ls_addr=$ls;
      label = 3; break;
    case 3: 
      var $0=$ls_addr;
      var $t=(($0+12)|0);
      var $token=(($t)|0);
      var $1=HEAP32[(($token)>>2)];
      var $cmp=(($1)|0)==59;
      if ($cmp) { var $4 = 1;label = 5; break; } else { label = 4; break; }
    case 4: 
      var $2=$ls_addr;
      var $t1=(($2+12)|0);
      var $token2=(($t1)|0);
      var $3=HEAP32[(($token2)>>2)];
      var $cmp3=(($3)|0)==285;
      var $4 = $cmp3;label = 5; break;
    case 5: 
      var $4;
      if ($4) { label = 6; break; } else { label = 7; break; }
    case 6: 
      var $5=$ls_addr;
      _statement($5);
      label = 3; break;
    case 7: 

      Module.print(INDENT + 'Exiting: _skipnoopstat');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _funcname($ls, $v) {
  var label = 0;

  Module.print(INDENT + ' Entering: _funcname: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $ls_addr;
      var $v_addr;
      var $ismethod;
      $ls_addr=$ls;
      $v_addr=$v;
      $ismethod=0;
      var $0=$ls_addr;
      var $1=$v_addr;
      _singlevar($0, $1);
      label = 3; break;
    case 3: 
      var $2=$ls_addr;
      var $t=(($2+12)|0);
      var $token=(($t)|0);
      var $3=HEAP32[(($token)>>2)];
      var $cmp=(($3)|0)==46;
      if ($cmp) { label = 4; break; } else { label = 5; break; }
    case 4: 
      var $4=$ls_addr;
      var $5=$v_addr;
      _fieldsel($4, $5);
      label = 3; break;
    case 5: 
      var $6=$ls_addr;
      var $t1=(($6+12)|0);
      var $token2=(($t1)|0);
      var $7=HEAP32[(($token2)>>2)];
      var $cmp3=(($7)|0)==58;
      if ($cmp3) { label = 6; break; } else { label = 7; break; }
    case 6: 
      $ismethod=1;
      var $8=$ls_addr;
      var $9=$v_addr;
      _fieldsel($8, $9);
      label = 7; break;
    case 7: 
      var $10=$ismethod;

      Module.print(INDENT + 'Exiting: _funcname');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return $10;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _cond($ls) {
  var label = 0;
  var __stackBase__  = STACKTOP; STACKTOP = (STACKTOP + 20)|0; _memset(__stackBase__, 0, 20);
  Module.print(INDENT + ' Entering: _cond: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $ls_addr;
      var $v=__stackBase__;
      $ls_addr=$ls;
      var $0=$ls_addr;
      _expr($0, $v);
      var $k=(($v)|0);
      var $1=HEAP32[(($k)>>2)];
      var $cmp=(($1)|0)==1;
      if ($cmp) { label = 3; break; } else { label = 4; break; }
    case 3: 
      var $k1=(($v)|0);
      HEAP32[(($k1)>>2)]=3;
      label = 4; break;
    case 4: 
      var $2=$ls_addr;
      var $fs=(($2+36)|0);
      var $3=HEAP32[(($fs)>>2)];
      _luaK_goiftrue($3, $v);
      var $f=(($v+16)|0);
      var $4=HEAP32[(($f)>>2)];
      STACKTOP = __stackBase__;
      Module.print(INDENT + 'Exiting: _cond');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return $4;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _fornum($ls, $varname, $line) {
  var label = 0;

  Module.print(INDENT + ' Entering: _fornum: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $ls_addr;
      var $varname_addr;
      var $line_addr;
      var $fs;
      var $base;
      $ls_addr=$ls;
      $varname_addr=$varname;
      $line_addr=$line;
      var $0=$ls_addr;
      var $fs1=(($0+36)|0);
      var $1=HEAP32[(($fs1)>>2)];
      $fs=$1;
      var $2=$fs;
      var $freereg=(($2+48)|0);
      var $3=HEAP8[($freereg)];
      var $conv=(($3)&255);
      $base=$conv;
      var $4=$ls_addr;
      _new_localvarliteral_($4, ((5245648)|0), 11);
      var $5=$ls_addr;
      _new_localvarliteral_($5, ((5245600)|0), 11);
      var $6=$ls_addr;
      _new_localvarliteral_($6, ((5245556)|0), 10);
      var $7=$ls_addr;
      var $8=$varname_addr;
      _new_localvar($7, $8);
      var $9=$ls_addr;
      _checknext($9, 61);
      var $10=$ls_addr;
      var $call=_exp1($10);
      var $11=$ls_addr;
      _checknext($11, 44);
      var $12=$ls_addr;
      var $call2=_exp1($12);
      var $13=$ls_addr;
      var $call3=_testnext($13, 44);
      var $tobool=(($call3)|0)!=0;
      if ($tobool) { label = 3; break; } else { label = 4; break; }
    case 3: 
      var $14=$ls_addr;
      var $call4=_exp1($14);
      label = 5; break;
    case 4: 
      var $15=$fs;
      var $16=$fs;
      var $freereg5=(($16+48)|0);
      var $17=HEAP8[($freereg5)];
      var $conv6=(($17)&255);
      var $18=$fs;
      var $call7=_luaK_numberK($18, 1);
      var $call8=_luaK_codek($15, $conv6, $call7);
      var $19=$fs;
      _luaK_reserveregs($19, 1);
      label = 5; break;
    case 5: 
      var $20=$ls_addr;
      var $21=$base;
      var $22=$line_addr;
      _forbody($20, $21, $22, 1, 1);

      Module.print(INDENT + 'Exiting: _fornum');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_fornum["X"]=1;

function _forlist($ls, $indexname) {
  var label = 0;
  var __stackBase__  = STACKTOP; STACKTOP = (STACKTOP + 20)|0; _memset(__stackBase__, 0, 20);
  Module.print(INDENT + ' Entering: _forlist: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $ls_addr;
      var $indexname_addr;
      var $fs;
      var $e=__stackBase__;
      var $nvars;
      var $line;
      var $base;
      $ls_addr=$ls;
      $indexname_addr=$indexname;
      var $0=$ls_addr;
      var $fs1=(($0+36)|0);
      var $1=HEAP32[(($fs1)>>2)];
      $fs=$1;
      $nvars=4;
      var $2=$fs;
      var $freereg=(($2+48)|0);
      var $3=HEAP8[($freereg)];
      var $conv=(($3)&255);
      $base=$conv;
      var $4=$ls_addr;
      _new_localvarliteral_($4, ((5246004)|0), 15);
      var $5=$ls_addr;
      _new_localvarliteral_($5, ((5245872)|0), 11);
      var $6=$ls_addr;
      _new_localvarliteral_($6, ((5245724)|0), 13);
      var $7=$ls_addr;
      var $8=$indexname_addr;
      _new_localvar($7, $8);
      label = 3; break;
    case 3: 
      var $9=$ls_addr;
      var $call=_testnext($9, 44);
      var $tobool=(($call)|0)!=0;
      if ($tobool) { label = 4; break; } else { label = 5; break; }
    case 4: 
      var $10=$ls_addr;
      var $11=$ls_addr;
      var $call2=_str_checkname($11);
      _new_localvar($10, $call2);
      var $12=$nvars;
      var $inc=((($12)+(1))|0);
      $nvars=$inc;
      label = 3; break;
    case 5: 
      var $13=$ls_addr;
      _checknext($13, 268);
      var $14=$ls_addr;
      var $linenumber=(($14+4)|0);
      var $15=HEAP32[(($linenumber)>>2)];
      $line=$15;
      var $16=$ls_addr;
      var $17=$ls_addr;
      var $call3=_explist($17, $e);
      _adjust_assign($16, 3, $call3, $e);
      var $18=$fs;
      _luaK_checkstack($18, 3);
      var $19=$ls_addr;
      var $20=$base;
      var $21=$line;
      var $22=$nvars;
      var $sub=((($22)-(3))|0);
      _forbody($19, $20, $21, $sub, 0);
      STACKTOP = __stackBase__;
      Module.print(INDENT + 'Exiting: _forlist');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_forlist["X"]=1;

function _forbody($ls, $base, $line, $nvars, $isnum) {
  var label = 0;
  var __stackBase__  = STACKTOP; STACKTOP = (STACKTOP + 12)|0; _memset(__stackBase__, 0, 12);
  Module.print(INDENT + ' Entering: _forbody: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $ls_addr;
      var $base_addr;
      var $line_addr;
      var $nvars_addr;
      var $isnum_addr;
      var $bl=__stackBase__;
      var $fs;
      var $prep;
      var $endfor;
      $ls_addr=$ls;
      $base_addr=$base;
      $line_addr=$line;
      $nvars_addr=$nvars;
      $isnum_addr=$isnum;
      var $0=$ls_addr;
      var $fs1=(($0+36)|0);
      var $1=HEAP32[(($fs1)>>2)];
      $fs=$1;
      var $2=$ls_addr;
      _adjustlocalvars($2, 3);
      var $3=$ls_addr;
      _checknext($3, 259);
      var $4=$isnum_addr;
      var $tobool=(($4)|0)!=0;
      if ($tobool) { label = 3; break; } else { label = 4; break; }
    case 3: 
      var $5=$fs;
      var $6=$base_addr;
      var $call=_luaK_codeABx($5, 33, $6, 131070);
      var $cond = $call;label = 5; break;
    case 4: 
      var $7=$fs;
      var $call2=_luaK_jump($7);
      var $cond = $call2;label = 5; break;
    case 5: 
      var $cond;
      $prep=$cond;
      var $8=$fs;
      _enterblock($8, $bl, 0);
      var $9=$ls_addr;
      var $10=$nvars_addr;
      _adjustlocalvars($9, $10);
      var $11=$fs;
      var $12=$nvars_addr;
      _luaK_reserveregs($11, $12);
      var $13=$ls_addr;
      _block($13);
      var $14=$fs;
      _leaveblock($14);
      var $15=$fs;
      var $16=$prep;
      _luaK_patchtohere($15, $16);
      var $17=$isnum_addr;
      var $tobool3=(($17)|0)!=0;
      if ($tobool3) { label = 6; break; } else { label = 7; break; }
    case 6: 
      var $18=$fs;
      var $19=$base_addr;
      var $call4=_luaK_codeABx($18, 32, $19, 131070);
      $endfor=$call4;
      label = 8; break;
    case 7: 
      var $20=$fs;
      var $21=$base_addr;
      var $22=$nvars_addr;
      var $call5=_luaK_codeABC($20, 34, $21, 0, $22);
      var $23=$fs;
      var $24=$line_addr;
      _luaK_fixline($23, $24);
      var $25=$fs;
      var $26=$base_addr;
      var $add=((($26)+(2))|0);
      var $call6=_luaK_codeABx($25, 35, $add, 131070);
      $endfor=$call6;
      label = 8; break;
    case 8: 
      var $27=$fs;
      var $28=$endfor;
      var $29=$prep;
      var $add7=((($29)+(1))|0);
      _luaK_patchlist($27, $28, $add7);
      var $30=$fs;
      var $31=$line_addr;
      _luaK_fixline($30, $31);
      STACKTOP = __stackBase__;
      Module.print(INDENT + 'Exiting: _forbody');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_forbody["X"]=1;

function _exp1($ls) {
  var label = 0;
  var __stackBase__  = STACKTOP; STACKTOP = (STACKTOP + 20)|0; _memset(__stackBase__, 0, 20);
  Module.print(INDENT + ' Entering: _exp1: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';

  var $ls_addr;
  var $e=__stackBase__;
  var $reg;
  $ls_addr=$ls;
  var $0=$ls_addr;
  _expr($0, $e);
  var $1=$ls_addr;
  var $fs=(($1+36)|0);
  var $2=HEAP32[(($fs)>>2)];
  _luaK_exp2nextreg($2, $e);
  var $u=(($e+4)|0);
  var $info=$u;
  var $3=HEAP32[(($info)>>2)];
  $reg=$3;
  var $4=$reg;
  STACKTOP = __stackBase__;
  Module.print(INDENT + 'Exiting: _exp1');
  INDENT = INDENT.substr(0, INDENT.length-2);
  return $4;
  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _funcargs($ls, $f, $line) {
  var label = 0;
  var __stackBase__  = STACKTOP; STACKTOP = (STACKTOP + 20)|0; _memset(__stackBase__, 0, 20);
  Module.print(INDENT + ' Entering: _funcargs: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $ls_addr;
      var $f_addr;
      var $line_addr;
      var $fs;
      var $args=__stackBase__;
      var $base;
      var $nparams;
      $ls_addr=$ls;
      $f_addr=$f;
      $line_addr=$line;
      var $0=$ls_addr;
      var $fs1=(($0+36)|0);
      var $1=HEAP32[(($fs1)>>2)];
      $fs=$1;
      var $2=$ls_addr;
      var $t=(($2+12)|0);
      var $token=(($t)|0);
      var $3=HEAP32[(($token)>>2)];
      if ((($3)|0)==40) {
        label = 3; break;
      }
      else if ((($3)|0)==123) {
        label = 7; break;
      }
      else if ((($3)|0)==289) {
        label = 8; break;
      }
      else {
      label = 9; break;
      }
      
    case 3: 
      var $4=$ls_addr;
      _luaX_next($4);
      var $5=$ls_addr;
      var $t2=(($5+12)|0);
      var $token3=(($t2)|0);
      var $6=HEAP32[(($token3)>>2)];
      var $cmp=(($6)|0)==41;
      if ($cmp) { label = 4; break; } else { label = 5; break; }
    case 4: 
      var $k=(($args)|0);
      HEAP32[(($k)>>2)]=0;
      label = 6; break;
    case 5: 
      var $7=$ls_addr;
      var $call=_explist($7, $args);
      var $8=$fs;
      _luaK_setreturns($8, $args, -1);
      label = 6; break;
    case 6: 
      var $9=$ls_addr;
      var $10=$line_addr;
      _check_match($9, 41, 40, $10);
      label = 10; break;
    case 7: 
      var $11=$ls_addr;
      _constructor($11, $args);
      label = 10; break;
    case 8: 
      var $12=$ls_addr;
      var $13=$ls_addr;
      var $t6=(($13+12)|0);
      var $seminfo=(($t6+4)|0);
      var $ts=$seminfo;
      var $14=HEAP32[(($ts)>>2)];
      _codestring($12, $args, $14);
      var $15=$ls_addr;
      _luaX_next($15);
      label = 10; break;
    case 9: 
      var $16=$ls_addr;
      _luaX_syntaxerror($16, ((5246340)|0));

    case 10: 
      var $17=$f_addr;
      var $u=(($17+4)|0);
      var $info=$u;
      var $18=HEAP32[(($info)>>2)];
      $base=$18;
      var $k7=(($args)|0);
      var $19=HEAP32[(($k7)>>2)];
      var $cmp8=(($19)|0)==12;
      if ($cmp8) { label = 12; break; } else { label = 11; break; }
    case 11: 
      var $k9=(($args)|0);
      var $20=HEAP32[(($k9)>>2)];
      var $cmp10=(($20)|0)==13;
      if ($cmp10) { label = 12; break; } else { label = 13; break; }
    case 12: 
      $nparams=-1;
      label = 16; break;
    case 13: 
      var $k13=(($args)|0);
      var $21=HEAP32[(($k13)>>2)];
      var $cmp14=(($21)|0)!=0;
      if ($cmp14) { label = 14; break; } else { label = 15; break; }
    case 14: 
      var $22=$fs;
      _luaK_exp2nextreg($22, $args);
      label = 15; break;
    case 15: 
      var $23=$fs;
      var $freereg=(($23+48)|0);
      var $24=HEAP8[($freereg)];
      var $conv=(($24)&255);
      var $25=$base;
      var $add=((($25)+(1))|0);
      var $sub=((($conv)-($add))|0);
      $nparams=$sub;
      label = 16; break;
    case 16: 
      var $26=$f_addr;
      var $27=$fs;
      var $28=$base;
      var $29=$nparams;
      var $add18=((($29)+(1))|0);
      var $call19=_luaK_codeABC($27, 29, $28, $add18, 2);
      _init_exp($26, 12, $call19);
      var $30=$fs;
      var $31=$line_addr;
      _luaK_fixline($30, $31);
      var $32=$base;
      var $add20=((($32)+(1))|0);
      var $conv21=(($add20) & 255);
      var $33=$fs;
      var $freereg22=(($33+48)|0);
      HEAP8[($freereg22)]=$conv21;
      STACKTOP = __stackBase__;
      Module.print(INDENT + 'Exiting: _funcargs');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_funcargs["X"]=1;

function _checkrepeated($fs, $ll, $label) {
  var label = 0;
  var __stackBase__  = STACKTOP; _memset(__stackBase__, 0, 0);
  Module.print(INDENT + ' Entering: _checkrepeated: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $fs_addr;
      var $ll_addr;
      var $label_addr;
      var $i;
      var $msg;
      $fs_addr=$fs;
      $ll_addr=$ll;
      $label_addr=$label;
      var $0=$fs_addr;
      var $bl=(($0+16)|0);
      var $1=HEAP32[(($bl)>>2)];
      var $firstlabel=(($1+4)|0);
      var $2=HEAP16[(($firstlabel)>>1)];
      var $conv=(($2 << 16) >> 16);
      $i=$conv;
      label = 3; break;
    case 3: 
      var $3=$i;
      var $4=$ll_addr;
      var $n=(($4+4)|0);
      var $5=HEAP32[(($n)>>2)];
      var $cmp=(($3)|0) < (($5)|0);
      if ($cmp) { label = 4; break; } else { label = 8; break; }
    case 4: 
      var $6=$label_addr;
      var $7=$i;
      var $8=$ll_addr;
      var $arr=(($8)|0);
      var $9=HEAP32[(($arr)>>2)];
      var $arrayidx=(($9+($7<<4))|0);
      var $name=(($arrayidx)|0);
      var $10=HEAP32[(($name)>>2)];
      var $call=_luaS_eqstr($6, $10);
      var $tobool=(($call)|0)!=0;
      if ($tobool) { label = 5; break; } else { label = 6; break; }
    case 5: 
      var $11=$fs_addr;
      var $ls=(($11+12)|0);
      var $12=HEAP32[(($ls)>>2)];
      var $L=(($12+40)|0);
      var $13=HEAP32[(($L)>>2)];
      var $14=$label_addr;
      var $add_ptr=(($14+16)|0);
      var $15=$add_ptr;
      var $16=$i;
      var $17=$ll_addr;
      var $arr2=(($17)|0);
      var $18=HEAP32[(($arr2)>>2)];
      var $arrayidx3=(($18+($16<<4))|0);
      var $line=(($arrayidx3+8)|0);
      var $19=HEAP32[(($line)>>2)];
      var $call4=_luaO_pushfstring($13, ((5246144)|0), (tempInt=STACKTOP,_memset(STACKTOP, 0, 8),STACKTOP = (STACKTOP + 8)|0,HEAP32[((tempInt)>>2)]=$15,HEAP32[(((tempInt)+(4))>>2)]=$19,tempInt));
      $msg=$call4;
      var $20=$fs_addr;
      var $ls5=(($20+12)|0);
      var $21=HEAP32[(($ls5)>>2)];
      var $22=$msg;
      _semerror($21, $22);

    case 6: 
      label = 7; break;
    case 7: 
      var $23=$i;
      var $inc=((($23)+(1))|0);
      $i=$inc;
      label = 3; break;
    case 8: 
      STACKTOP = __stackBase__;
      Module.print(INDENT + 'Exiting: _checkrepeated');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_checkrepeated["X"]=1;

function _luaE_setdebt($g, $debt) {
  var label = 0;

  Module.print(INDENT + ' Entering: _luaE_setdebt: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';

  var $g_addr;
  var $debt_addr;
  $g_addr=$g;
  $debt_addr=$debt;
  var $0=$debt_addr;
  var $1=$g_addr;
  var $GCdebt=(($1+12)|0);
  var $2=HEAP32[(($GCdebt)>>2)];
  var $sub=((($0)-($2))|0);
  var $3=$g_addr;
  var $totalbytes=(($3+8)|0);
  var $4=HEAP32[(($totalbytes)>>2)];
  var $sub1=((($4)-($sub))|0);
  HEAP32[(($totalbytes)>>2)]=$sub1;
  var $5=$debt_addr;
  var $6=$g_addr;
  var $GCdebt2=(($6+12)|0);
  HEAP32[(($GCdebt2)>>2)]=$5;

  Module.print(INDENT + 'Exiting: _luaE_setdebt');
  INDENT = INDENT.substr(0, INDENT.length-2);
  return;
  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _preinit_state($L, $g) {
  var label = 0;

  Module.print(INDENT + ' Entering: _preinit_state: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';

  var $L_addr;
  var $g_addr;
  $L_addr=$L;
  $g_addr=$g;
  var $0=$g_addr;
  var $1=$L_addr;
  var $l_G=(($1+12)|0);
  HEAP32[(($l_G)>>2)]=$0;
  var $2=$L_addr;
  var $stack=(($2+28)|0);
  HEAP32[(($stack)>>2)]=0;
  var $3=$L_addr;
  var $ci=(($3+16)|0);
  HEAP32[(($ci)>>2)]=0;
  var $4=$L_addr;
  var $stacksize=(($4+32)|0);
  HEAP32[(($stacksize)>>2)]=0;
  var $5=$L_addr;
  var $errorJmp=(($5+64)|0);
  HEAP32[(($errorJmp)>>2)]=0;
  var $6=$L_addr;
  var $nCcalls=(($6+38)|0);
  HEAP16[(($nCcalls)>>1)]=0;
  var $7=$L_addr;
  var $hook=(($7+52)|0);
  HEAP32[(($hook)>>2)]=0;
  var $8=$L_addr;
  var $hookmask=(($8+40)|0);
  HEAP8[($hookmask)]=0;
  var $9=$L_addr;
  var $basehookcount=(($9+44)|0);
  HEAP32[(($basehookcount)>>2)]=0;
  var $10=$L_addr;
  var $allowhook=(($10+41)|0);
  HEAP8[($allowhook)]=1;
  var $11=$L_addr;
  var $basehookcount1=(($11+44)|0);
  var $12=HEAP32[(($basehookcount1)>>2)];
  var $13=$L_addr;
  var $hookcount=(($13+48)|0);
  HEAP32[(($hookcount)>>2)]=$12;
  var $14=$L_addr;
  var $openupval=(($14+56)|0);
  HEAP32[(($openupval)>>2)]=0;
  var $15=$L_addr;
  var $nny=(($15+36)|0);
  HEAP16[(($nny)>>1)]=1;
  var $16=$L_addr;
  var $status=(($16+6)|0);
  HEAP8[($status)]=0;
  var $17=$L_addr;
  var $errfunc=(($17+68)|0);
  HEAP32[(($errfunc)>>2)]=0;

  Module.print(INDENT + 'Exiting: _preinit_state');
  INDENT = INDENT.substr(0, INDENT.length-2);
  return;
  INDENT = INDENT.substr(0, INDENT.length-2);
}
_preinit_state["X"]=1;

function _test_then_block($ls, $escapelist) {
  var label = 0;
  var __stackBase__  = STACKTOP; STACKTOP = (STACKTOP + 32)|0; _memset(__stackBase__, 0, 32);
  Module.print(INDENT + ' Entering: _test_then_block: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $ls_addr;
      var $escapelist_addr;
      var $bl=__stackBase__;
      var $fs;
      var $v=(__stackBase__)+(12);
      var $jf;
      $ls_addr=$ls;
      $escapelist_addr=$escapelist;
      var $0=$ls_addr;
      var $fs1=(($0+36)|0);
      var $1=HEAP32[(($fs1)>>2)];
      $fs=$1;
      var $2=$ls_addr;
      _luaX_next($2);
      var $3=$ls_addr;
      _expr($3, $v);
      var $4=$ls_addr;
      _checknext($4, 275);
      var $5=$ls_addr;
      var $t=(($5+12)|0);
      var $token=(($t)|0);
      var $6=HEAP32[(($token)>>2)];
      var $cmp=(($6)|0)==266;
      if ($cmp) { label = 4; break; } else { label = 3; break; }
    case 3: 
      var $7=$ls_addr;
      var $t2=(($7+12)|0);
      var $token3=(($t2)|0);
      var $8=HEAP32[(($token3)>>2)];
      var $cmp4=(($8)|0)==258;
      if ($cmp4) { label = 4; break; } else { label = 8; break; }
    case 4: 
      var $9=$ls_addr;
      var $fs5=(($9+36)|0);
      var $10=HEAP32[(($fs5)>>2)];
      _luaK_goiffalse($10, $v);
      var $11=$fs;
      _enterblock($11, $bl, 0);
      var $12=$ls_addr;
      var $t6=(($v+12)|0);
      var $13=HEAP32[(($t6)>>2)];
      _gotostat($12, $13);
      var $14=$ls_addr;
      _skipnoopstat($14);
      var $15=$ls_addr;
      var $call=_block_follow($15, 0);
      var $tobool=(($call)|0)!=0;
      if ($tobool) { label = 5; break; } else { label = 6; break; }
    case 5: 
      var $16=$fs;
      _leaveblock($16);
      label = 13; break;
    case 6: 
      var $17=$fs;
      var $call8=_luaK_jump($17);
      $jf=$call8;
      label = 7; break;
    case 7: 
      label = 9; break;
    case 8: 
      var $18=$ls_addr;
      var $fs10=(($18+36)|0);
      var $19=HEAP32[(($fs10)>>2)];
      _luaK_goiftrue($19, $v);
      var $20=$fs;
      _enterblock($20, $bl, 0);
      var $f=(($v+16)|0);
      var $21=HEAP32[(($f)>>2)];
      $jf=$21;
      label = 9; break;
    case 9: 
      var $22=$ls_addr;
      _statlist($22);
      var $23=$fs;
      _leaveblock($23);
      var $24=$ls_addr;
      var $t12=(($24+12)|0);
      var $token13=(($t12)|0);
      var $25=HEAP32[(($token13)>>2)];
      var $cmp14=(($25)|0)==260;
      if ($cmp14) { label = 11; break; } else { label = 10; break; }
    case 10: 
      var $26=$ls_addr;
      var $t16=(($26+12)|0);
      var $token17=(($t16)|0);
      var $27=HEAP32[(($token17)>>2)];
      var $cmp18=(($27)|0)==261;
      if ($cmp18) { label = 11; break; } else { label = 12; break; }
    case 11: 
      var $28=$fs;
      var $29=$escapelist_addr;
      var $30=$fs;
      var $call20=_luaK_jump($30);
      _luaK_concat($28, $29, $call20);
      label = 12; break;
    case 12: 
      var $31=$fs;
      var $32=$jf;
      _luaK_patchtohere($31, $32);
      label = 13; break;
    case 13: 
      STACKTOP = __stackBase__;
      Module.print(INDENT + 'Exiting: _test_then_block');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_test_then_block["X"]=1;

function _luaE_extendCI($L) {
  var label = 0;

  Module.print(INDENT + ' Entering: _luaE_extendCI: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';

  var $L_addr;
  var $ci;
  $L_addr=$L;
  var $0=$L_addr;
  var $call=_luaM_realloc_($0, 0, 0, 40);
  var $1=$call;
  $ci=$1;
  var $2=$ci;
  var $3=$L_addr;
  var $ci1=(($3+16)|0);
  var $4=HEAP32[(($ci1)>>2)];
  var $next=(($4+12)|0);
  HEAP32[(($next)>>2)]=$2;
  var $5=$L_addr;
  var $ci2=(($5+16)|0);
  var $6=HEAP32[(($ci2)>>2)];
  var $7=$ci;
  var $previous=(($7+8)|0);
  HEAP32[(($previous)>>2)]=$6;
  var $8=$ci;
  var $next3=(($8+12)|0);
  HEAP32[(($next3)>>2)]=0;
  var $9=$ci;

  Module.print(INDENT + 'Exiting: _luaE_extendCI');
  INDENT = INDENT.substr(0, INDENT.length-2);
  return $9;
  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _luaE_freeCI($L) {
  var label = 0;

  Module.print(INDENT + ' Entering: _luaE_freeCI: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $L_addr;
      var $ci;
      var $next;
      $L_addr=$L;
      var $0=$L_addr;
      var $ci1=(($0+16)|0);
      var $1=HEAP32[(($ci1)>>2)];
      $ci=$1;
      var $2=$ci;
      var $next2=(($2+12)|0);
      var $3=HEAP32[(($next2)>>2)];
      $next=$3;
      var $4=$ci;
      var $next3=(($4+12)|0);
      HEAP32[(($next3)>>2)]=0;
      label = 3; break;
    case 3: 
      var $5=$next;
      $ci=$5;
      var $cmp=(($5)|0)!=0;
      if ($cmp) { label = 4; break; } else { label = 5; break; }
    case 4: 
      var $6=$ci;
      var $next4=(($6+12)|0);
      var $7=HEAP32[(($next4)>>2)];
      $next=$7;
      var $8=$L_addr;
      var $9=$ci;
      var $10=$9;
      var $call=_luaM_realloc_($8, $10, 40, 0);
      label = 3; break;
    case 5: 

      Module.print(INDENT + 'Exiting: _luaE_freeCI');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _lua_newthread($L) {
  var label = 0;

  Module.print(INDENT + ' Entering: _lua_newthread: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $L_addr;
      var $L1;
      var $io;
      $L_addr=$L;
      var $0=$L_addr;
      var $l_G=(($0+12)|0);
      var $1=HEAP32[(($l_G)>>2)];
      var $GCdebt=(($1+12)|0);
      var $2=HEAP32[(($GCdebt)>>2)];
      var $cmp=(($2)|0) > 0;
      if ($cmp) { label = 3; break; } else { label = 4; break; }
    case 3: 
      var $3=$L_addr;
      _luaC_step($3);
      label = 4; break;
    case 4: 
      var $4=$L_addr;
      var $call=_luaC_newobj($4, 8, 112, 0, 0);
      var $th=$call;
      $L1=$th;
      var $5=$L_addr;
      var $top=(($5+8)|0);
      var $6=HEAP32[(($top)>>2)];
      $io=$6;
      var $7=$L1;
      var $8=$7;
      var $9=$io;
      var $value_=(($9)|0);
      var $gc=$value_;
      HEAP32[(($gc)>>2)]=$8;
      var $10=$io;
      var $tt_=(($10+8)|0);
      HEAP32[(($tt_)>>2)]=72;
      var $11=$L_addr;
      var $top1=(($11+8)|0);
      var $12=HEAP32[(($top1)>>2)];
      var $incdec_ptr=(($12+12)|0);
      HEAP32[(($top1)>>2)]=$incdec_ptr;
      var $13=$L1;
      var $14=$L_addr;
      var $l_G2=(($14+12)|0);
      var $15=HEAP32[(($l_G2)>>2)];
      _preinit_state($13, $15);
      var $16=$L_addr;
      var $hookmask=(($16+40)|0);
      var $17=HEAP8[($hookmask)];
      var $18=$L1;
      var $hookmask3=(($18+40)|0);
      HEAP8[($hookmask3)]=$17;
      var $19=$L_addr;
      var $basehookcount=(($19+44)|0);
      var $20=HEAP32[(($basehookcount)>>2)];
      var $21=$L1;
      var $basehookcount4=(($21+44)|0);
      HEAP32[(($basehookcount4)>>2)]=$20;
      var $22=$L_addr;
      var $hook=(($22+52)|0);
      var $23=HEAP32[(($hook)>>2)];
      var $24=$L1;
      var $hook5=(($24+52)|0);
      HEAP32[(($hook5)>>2)]=$23;
      var $25=$L1;
      var $basehookcount6=(($25+44)|0);
      var $26=HEAP32[(($basehookcount6)>>2)];
      var $27=$L1;
      var $hookcount=(($27+48)|0);
      HEAP32[(($hookcount)>>2)]=$26;
      var $28=$L_addr;
      var $29=$L1;
      var $30=$L_addr;
      _stack_init($29, $30);
      var $31=$L1;

      Module.print(INDENT + 'Exiting: _lua_newthread');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return $31;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_lua_newthread["X"]=1;

function _stack_init($L1, $L) {
  var label = 0;

  Module.print(INDENT + ' Entering: _stack_init: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $L1_addr;
      var $L_addr;
      var $i;
      var $ci;
      $L1_addr=$L1;
      $L_addr=$L;
      var $0=$L_addr;
      var $call=_luaM_realloc_($0, 0, 0, 480);
      var $1=$call;
      var $2=$L1_addr;
      var $stack=(($2+28)|0);
      HEAP32[(($stack)>>2)]=$1;
      var $3=$L1_addr;
      var $stacksize=(($3+32)|0);
      HEAP32[(($stacksize)>>2)]=40;
      $i=0;
      label = 3; break;
    case 3: 
      var $4=$i;
      var $cmp=(($4)|0) < 40;
      if ($cmp) { label = 4; break; } else { label = 6; break; }
    case 4: 
      var $5=$L1_addr;
      var $stack1=(($5+28)|0);
      var $6=HEAP32[(($stack1)>>2)];
      var $7=$i;
      var $add_ptr=(($6+((($7)*(12))&-1))|0);
      var $tt_=(($add_ptr+8)|0);
      HEAP32[(($tt_)>>2)]=0;
      label = 5; break;
    case 5: 
      var $8=$i;
      var $inc=((($8)+(1))|0);
      $i=$inc;
      label = 3; break;
    case 6: 
      var $9=$L1_addr;
      var $stack2=(($9+28)|0);
      var $10=HEAP32[(($stack2)>>2)];
      var $11=$L1_addr;
      var $top=(($11+8)|0);
      HEAP32[(($top)>>2)]=$10;
      var $12=$L1_addr;
      var $stack3=(($12+28)|0);
      var $13=HEAP32[(($stack3)>>2)];
      var $14=$L1_addr;
      var $stacksize4=(($14+32)|0);
      var $15=HEAP32[(($stacksize4)>>2)];
      var $add_ptr5=(($13+((($15)*(12))&-1))|0);
      var $add_ptr6=((($add_ptr5)-(60))|0);
      var $16=$L1_addr;
      var $stack_last=(($16+24)|0);
      HEAP32[(($stack_last)>>2)]=$add_ptr6;
      var $17=$L1_addr;
      var $base_ci=(($17+72)|0);
      $ci=$base_ci;
      var $18=$ci;
      var $previous=(($18+8)|0);
      HEAP32[(($previous)>>2)]=0;
      var $19=$ci;
      var $next=(($19+12)|0);
      HEAP32[(($next)>>2)]=0;
      var $20=$ci;
      var $callstatus=(($20+18)|0);
      HEAP8[($callstatus)]=0;
      var $21=$L1_addr;
      var $top7=(($21+8)|0);
      var $22=HEAP32[(($top7)>>2)];
      var $23=$ci;
      var $func=(($23)|0);
      HEAP32[(($func)>>2)]=$22;
      var $24=$L1_addr;
      var $top8=(($24+8)|0);
      var $25=HEAP32[(($top8)>>2)];
      var $incdec_ptr=(($25+12)|0);
      HEAP32[(($top8)>>2)]=$incdec_ptr;
      var $tt_9=(($25+8)|0);
      HEAP32[(($tt_9)>>2)]=0;
      var $26=$L1_addr;
      var $top10=(($26+8)|0);
      var $27=HEAP32[(($top10)>>2)];
      var $add_ptr11=(($27+240)|0);
      var $28=$ci;
      var $top12=(($28+4)|0);
      HEAP32[(($top12)>>2)]=$add_ptr11;
      var $29=$ci;
      var $30=$L1_addr;
      var $ci13=(($30+16)|0);
      HEAP32[(($ci13)>>2)]=$29;

      Module.print(INDENT + 'Exiting: _stack_init');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_stack_init["X"]=1;

function _luaE_freethread($L, $L1) {
  var label = 0;

  Module.print(INDENT + ' Entering: _luaE_freethread: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';

  var $L_addr;
  var $L1_addr;
  var $l;
  $L_addr=$L;
  $L1_addr=$L1;
  var $0=$L1_addr;
  var $1=$0;
  var $add_ptr=(($1)|0);
  var $2=$add_ptr;
  $l=$2;
  var $3=$L1_addr;
  var $4=$L1_addr;
  var $stack=(($4+28)|0);
  var $5=HEAP32[(($stack)>>2)];
  _luaF_close($3, $5);
  var $6=$L_addr;
  var $7=$L1_addr;
  _freestack($7);
  var $8=$L_addr;
  var $9=$l;
  var $10=$9;
  var $call=_luaM_realloc_($8, $10, 112, 0);

  Module.print(INDENT + 'Exiting: _luaE_freethread');
  INDENT = INDENT.substr(0, INDENT.length-2);
  return;
  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _freestack($L) {
  var label = 0;

  Module.print(INDENT + ' Entering: _freestack: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $L_addr;
      $L_addr=$L;
      var $0=$L_addr;
      var $stack=(($0+28)|0);
      var $1=HEAP32[(($stack)>>2)];
      var $cmp=(($1)|0)==0;
      if ($cmp) { label = 3; break; } else { label = 4; break; }
    case 3: 
      label = 5; break;
    case 4: 
      var $2=$L_addr;
      var $base_ci=(($2+72)|0);
      var $3=$L_addr;
      var $ci=(($3+16)|0);
      HEAP32[(($ci)>>2)]=$base_ci;
      var $4=$L_addr;
      _luaE_freeCI($4);
      var $5=$L_addr;
      var $6=$L_addr;
      var $stack1=(($6+28)|0);
      var $7=HEAP32[(($stack1)>>2)];
      var $8=$7;
      var $9=$L_addr;
      var $stacksize=(($9+32)|0);
      var $10=HEAP32[(($stacksize)>>2)];
      var $mul=((($10)*(12))&-1);
      var $call=_luaM_realloc_($5, $8, $mul, 0);
      label = 5; break;
    case 5: 

      Module.print(INDENT + 'Exiting: _freestack');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _lua_newstate($f, $ud) {
  var label = 0;

  Module.print(INDENT + ' Entering: _lua_newstate: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $retval;
      var $f_addr;
      var $ud_addr;
      var $i;
      var $L;
      var $g;
      var $l;
      $f_addr=$f;
      $ud_addr=$ud;
      var $0=$f_addr;
      var $1=$ud_addr;
      var $call=FUNCTION_TABLE[$0]($1, 0, 8, 380);
      var $2=$call;
      $l=$2;
      var $3=$l;
      var $cmp=(($3)|0)==0;
      if ($cmp) { label = 3; break; } else { label = 4; break; }
    case 3: 
      $retval=0;
      label = 12; break;
    case 4: 
      var $4=$l;
      var $l1=(($4)|0);
      var $l2=(($l1)|0);
      $L=$l2;
      var $5=$l;
      var $g3=(($5+112)|0);
      $g=$g3;
      var $6=$L;
      var $next=(($6)|0);
      HEAP32[(($next)>>2)]=0;
      var $7=$L;
      var $tt=(($7+4)|0);
      HEAP8[($tt)]=8;
      var $8=$g;
      var $currentwhite=(($8+52)|0);
      HEAP8[($currentwhite)]=33;
      var $9=$g;
      var $currentwhite4=(($9+52)|0);
      var $10=HEAP8[($currentwhite4)];
      var $conv=(($10)&255);
      var $and=$conv & 3;
      var $conv5=(($and) & 255);
      var $11=$L;
      var $marked=(($11+5)|0);
      HEAP8[($marked)]=$conv5;
      var $12=$g;
      var $gckind=(($12+54)|0);
      HEAP8[($gckind)]=0;
      var $13=$L;
      var $14=$g;
      _preinit_state($13, $14);
      var $15=$f_addr;
      var $16=$g;
      var $frealloc=(($16)|0);
      HEAP32[(($frealloc)>>2)]=$15;
      var $17=$ud_addr;
      var $18=$g;
      var $ud6=(($18+4)|0);
      HEAP32[(($ud6)>>2)]=$17;
      var $19=$L;
      var $20=$g;
      var $mainthread=(($20+152)|0);
      HEAP32[(($mainthread)>>2)]=$19;
      var $21=$L;
      var $call7=_makeseed($21);
      var $22=$g;
      var $seed=(($22+48)|0);
      HEAP32[(($seed)>>2)]=$call7;
      var $23=$g;
      var $uvhead=(($23+100)|0);
      var $24=$g;
      var $uvhead8=(($24+100)|0);
      var $u=(($uvhead8+12)|0);
      var $l9=$u;
      var $prev=(($l9)|0);
      HEAP32[(($prev)>>2)]=$uvhead;
      var $25=$g;
      var $uvhead10=(($25+100)|0);
      var $26=$g;
      var $uvhead11=(($26+100)|0);
      var $u12=(($uvhead11+12)|0);
      var $l13=$u12;
      var $next14=(($l13+4)|0);
      HEAP32[(($next14)>>2)]=$uvhead10;
      var $27=$g;
      var $gcrunning=(($27+55)|0);
      HEAP8[($gcrunning)]=0;
      var $28=$g;
      var $GCestimate=(($28+20)|0);
      HEAP32[(($GCestimate)>>2)]=0;
      var $29=$g;
      var $strt=(($29+24)|0);
      var $size=(($strt+8)|0);
      HEAP32[(($size)>>2)]=0;
      var $30=$g;
      var $strt15=(($30+24)|0);
      var $nuse=(($strt15+4)|0);
      HEAP32[(($nuse)>>2)]=0;
      var $31=$g;
      var $strt16=(($31+24)|0);
      var $hash=(($strt16)|0);
      HEAP32[(($hash)>>2)]=0;
      var $32=$g;
      var $l_registry=(($32+36)|0);
      var $tt_=(($l_registry+8)|0);
      HEAP32[(($tt_)>>2)]=0;
      var $33=$g;
      var $buff=(($33+124)|0);
      var $buffer=(($buff)|0);
      HEAP32[(($buffer)>>2)]=0;
      var $34=$g;
      var $buff17=(($34+124)|0);
      var $buffsize=(($buff17+8)|0);
      HEAP32[(($buffsize)>>2)]=0;
      var $35=$g;
      var $panic=(($35+148)|0);
      HEAP32[(($panic)>>2)]=0;
      var $call18=_lua_version(0);
      var $36=$g;
      var $version=(($36+156)|0);
      HEAP32[(($version)>>2)]=$call18;
      var $37=$g;
      var $gcstate=(($37+53)|0);
      HEAP8[($gcstate)]=5;
      var $38=$g;
      var $allgc=(($38+60)|0);
      HEAP32[(($allgc)>>2)]=0;
      var $39=$g;
      var $finobj=(($39+64)|0);
      HEAP32[(($finobj)>>2)]=0;
      var $40=$g;
      var $tobefnz=(($40+96)|0);
      HEAP32[(($tobefnz)>>2)]=0;
      var $41=$g;
      var $sweepfin=(($41+72)|0);
      HEAP32[(($sweepfin)>>2)]=0;
      var $42=$g;
      var $sweepgc=(($42+68)|0);
      HEAP32[(($sweepgc)>>2)]=0;
      var $43=$g;
      var $grayagain=(($43+80)|0);
      HEAP32[(($grayagain)>>2)]=0;
      var $44=$g;
      var $gray=(($44+76)|0);
      HEAP32[(($gray)>>2)]=0;
      var $45=$g;
      var $allweak=(($45+92)|0);
      HEAP32[(($allweak)>>2)]=0;
      var $46=$g;
      var $ephemeron=(($46+88)|0);
      HEAP32[(($ephemeron)>>2)]=0;
      var $47=$g;
      var $weak=(($47+84)|0);
      HEAP32[(($weak)>>2)]=0;
      var $48=$g;
      var $totalbytes=(($48+8)|0);
      HEAP32[(($totalbytes)>>2)]=380;
      var $49=$g;
      var $GCdebt=(($49+12)|0);
      HEAP32[(($GCdebt)>>2)]=0;
      var $50=$g;
      var $gcpause=(($50+136)|0);
      HEAP32[(($gcpause)>>2)]=200;
      var $51=$g;
      var $gcmajorinc=(($51+140)|0);
      HEAP32[(($gcmajorinc)>>2)]=200;
      var $52=$g;
      var $gcstepmul=(($52+144)|0);
      HEAP32[(($gcstepmul)>>2)]=200;
      $i=0;
      label = 5; break;
    case 5: 
      var $53=$i;
      var $cmp19=(($53)|0) < 9;
      if ($cmp19) { label = 6; break; } else { label = 8; break; }
    case 6: 
      var $54=$i;
      var $55=$g;
      var $mt=(($55+232)|0);
      var $arrayidx=(($mt+($54<<2))|0);
      HEAP32[(($arrayidx)>>2)]=0;
      label = 7; break;
    case 7: 
      var $56=$i;
      var $inc=((($56)+(1))|0);
      $i=$inc;
      label = 5; break;
    case 8: 
      var $57=$L;
      var $call21=_luaD_rawrunprotected($57, 16, 0);
      var $cmp22=(($call21)|0)!=0;
      if ($cmp22) { label = 9; break; } else { label = 10; break; }
    case 9: 
      var $58=$L;
      _close_state($58);
      $L=0;
      label = 11; break;
    case 10: 
      var $59=$L;
      label = 11; break;
    case 11: 
      var $60=$L;
      $retval=$60;
      label = 12; break;
    case 12: 
      var $61=$retval;

      Module.print(INDENT + 'Exiting: _lua_newstate');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return $61;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_lua_newstate["X"]=1;

function _makeseed($L) {
  var label = 0;
  var __stackBase__  = STACKTOP; STACKTOP = (STACKTOP + 36)|0; _memset(__stackBase__, 0, 36);
  Module.print(INDENT + ' Entering: _makeseed: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';

  var $L_addr;
  var $buff=__stackBase__;
  var $h=(__stackBase__)+(16);
  var $p;
  var $t=(__stackBase__)+(20);
  var $t1=(__stackBase__)+(24);
  var $t5=(__stackBase__)+(28);
  var $t9=(__stackBase__)+(32);
  $L_addr=$L;
  var $call=_time(0);
  HEAP32[(($h)>>2)]=$call;
  $p=0;
  var $0=$L_addr;
  var $1=$0;
  HEAP32[(($t)>>2)]=$1;
  var $arraydecay=(($buff)|0);
  var $2=$p;
  var $add_ptr=(($arraydecay+$2)|0);
  var $3=$t;
  HEAP8[($add_ptr)]=HEAP8[($3)];HEAP8[((($add_ptr)+(1))|0)]=HEAP8[((($3)+(1))|0)];HEAP8[((($add_ptr)+(2))|0)]=HEAP8[((($3)+(2))|0)];HEAP8[((($add_ptr)+(3))|0)]=HEAP8[((($3)+(3))|0)];
  var $4=$p;
  var $add=((($4)+(4))|0);
  $p=$add;
  var $5=$h;
  HEAP32[(($t1)>>2)]=$5;
  var $arraydecay2=(($buff)|0);
  var $6=$p;
  var $add_ptr3=(($arraydecay2+$6)|0);
  var $7=$t1;
  HEAP8[($add_ptr3)]=HEAP8[($7)];HEAP8[((($add_ptr3)+(1))|0)]=HEAP8[((($7)+(1))|0)];HEAP8[((($add_ptr3)+(2))|0)]=HEAP8[((($7)+(2))|0)];HEAP8[((($add_ptr3)+(3))|0)]=HEAP8[((($7)+(3))|0)];
  var $8=$p;
  var $add4=((($8)+(4))|0);
  $p=$add4;
  HEAP32[(($t5)>>2)]=5243784;
  var $arraydecay6=(($buff)|0);
  var $9=$p;
  var $add_ptr7=(($arraydecay6+$9)|0);
  var $10=$t5;
  HEAP8[($add_ptr7)]=HEAP8[($10)];HEAP8[((($add_ptr7)+(1))|0)]=HEAP8[((($10)+(1))|0)];HEAP8[((($add_ptr7)+(2))|0)]=HEAP8[((($10)+(2))|0)];HEAP8[((($add_ptr7)+(3))|0)]=HEAP8[((($10)+(3))|0)];
  var $11=$p;
  var $add8=((($11)+(4))|0);
  $p=$add8;
  HEAP32[(($t9)>>2)]=(2);
  var $arraydecay10=(($buff)|0);
  var $12=$p;
  var $add_ptr11=(($arraydecay10+$12)|0);
  var $13=$t9;
  HEAP8[($add_ptr11)]=HEAP8[($13)];HEAP8[((($add_ptr11)+(1))|0)]=HEAP8[((($13)+(1))|0)];HEAP8[((($add_ptr11)+(2))|0)]=HEAP8[((($13)+(2))|0)];HEAP8[((($add_ptr11)+(3))|0)]=HEAP8[((($13)+(3))|0)];
  var $14=$p;
  var $add12=((($14)+(4))|0);
  $p=$add12;
  var $arraydecay13=(($buff)|0);
  var $15=$p;
  var $16=HEAP32[(($h)>>2)];
  var $call14=_luaS_hash($arraydecay13, $15, $16);
  STACKTOP = __stackBase__;
  Module.print(INDENT + 'Exiting: _makeseed');
  INDENT = INDENT.substr(0, INDENT.length-2);
  return $call14;
  INDENT = INDENT.substr(0, INDENT.length-2);
}
_makeseed["X"]=1;

function _f_luaopen($L, $ud) {
  var label = 0;

  Module.print(INDENT + ' Entering: _f_luaopen: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';

  var $L_addr;
  var $ud_addr;
  var $g;
  $L_addr=$L;
  $ud_addr=$ud;
  var $0=$L_addr;
  var $l_G=(($0+12)|0);
  var $1=HEAP32[(($l_G)>>2)];
  $g=$1;
  var $2=$ud_addr;
  var $3=$L_addr;
  var $4=$L_addr;
  _stack_init($3, $4);
  var $5=$L_addr;
  var $6=$g;
  _init_registry($5, $6);
  var $7=$L_addr;
  _luaS_resize($7, 32);
  var $8=$L_addr;
  _luaT_init($8);
  var $9=$L_addr;
  _luaX_init($9);
  var $10=$L_addr;
  var $call=_luaS_newlstr($10, ((5245968)|0), 17);
  var $11=$g;
  var $memerrmsg=(($11+160)|0);
  HEAP32[(($memerrmsg)>>2)]=$call;
  var $12=$g;
  var $memerrmsg1=(($12+160)|0);
  var $13=HEAP32[(($memerrmsg1)>>2)];
  var $tsv=$13;
  var $marked=(($tsv+5)|0);
  var $14=HEAP8[($marked)];
  var $conv=(($14)&255);
  var $or=$conv | 32;
  var $conv2=(($or) & 255);
  HEAP8[($marked)]=$conv2;
  var $15=$g;
  var $gcrunning=(($15+55)|0);
  HEAP8[($gcrunning)]=1;

  Module.print(INDENT + 'Exiting: _f_luaopen');
  INDENT = INDENT.substr(0, INDENT.length-2);
  return;
  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _close_state($L) {
  var label = 0;

  Module.print(INDENT + ' Entering: _close_state: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';

  var $L_addr;
  var $g;
  $L_addr=$L;
  var $0=$L_addr;
  var $l_G=(($0+12)|0);
  var $1=HEAP32[(($l_G)>>2)];
  $g=$1;
  var $2=$L_addr;
  var $3=$L_addr;
  var $stack=(($3+28)|0);
  var $4=HEAP32[(($stack)>>2)];
  _luaF_close($2, $4);
  var $5=$L_addr;
  _luaC_freeallobjects($5);
  var $6=$L_addr;
  var $7=$L_addr;
  var $l_G1=(($7+12)|0);
  var $8=HEAP32[(($l_G1)>>2)];
  var $strt=(($8+24)|0);
  var $hash=(($strt)|0);
  var $9=HEAP32[(($hash)>>2)];
  var $10=$9;
  var $11=$L_addr;
  var $l_G2=(($11+12)|0);
  var $12=HEAP32[(($l_G2)>>2)];
  var $strt3=(($12+24)|0);
  var $size=(($strt3+8)|0);
  var $13=HEAP32[(($size)>>2)];
  var $mul=($13<<2);
  var $call=_luaM_realloc_($6, $10, $mul, 0);
  var $14=$L_addr;
  var $15=$g;
  var $buff=(($15+124)|0);
  var $buffer=(($buff)|0);
  var $16=HEAP32[(($buffer)>>2)];
  var $17=$g;
  var $buff4=(($17+124)|0);
  var $buffsize=(($buff4+8)|0);
  var $18=HEAP32[(($buffsize)>>2)];
  var $mul5=$18;
  var $call6=_luaM_realloc_($14, $16, $mul5, 0);
  var $19=$g;
  var $buff7=(($19+124)|0);
  var $buffer8=(($buff7)|0);
  HEAP32[(($buffer8)>>2)]=$call6;
  var $20=$g;
  var $buff9=(($20+124)|0);
  var $buffsize10=(($buff9+8)|0);
  HEAP32[(($buffsize10)>>2)]=0;
  var $21=$L_addr;
  _freestack($21);
  var $22=$g;
  var $frealloc=(($22)|0);
  var $23=HEAP32[(($frealloc)>>2)];
  var $24=$g;
  var $ud=(($24+4)|0);
  var $25=HEAP32[(($ud)>>2)];
  var $26=$L_addr;
  var $27=$26;
  var $add_ptr=(($27)|0);
  var $28=$add_ptr;
  var $29=$28;
  var $call11=FUNCTION_TABLE[$23]($25, $29, 380, 0);

  Module.print(INDENT + 'Exiting: _close_state');
  INDENT = INDENT.substr(0, INDENT.length-2);
  return;
  INDENT = INDENT.substr(0, INDENT.length-2);
}
_close_state["X"]=1;

function _lua_close($L) {
  var label = 0;

  Module.print(INDENT + ' Entering: _lua_close: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';

  var $L_addr;
  $L_addr=$L;
  var $0=$L_addr;
  var $l_G=(($0+12)|0);
  var $1=HEAP32[(($l_G)>>2)];
  var $mainthread=(($1+152)|0);
  var $2=HEAP32[(($mainthread)>>2)];
  $L_addr=$2;
  var $3=$L_addr;
  var $4=$L_addr;
  _close_state($4);

  Module.print(INDENT + 'Exiting: _lua_close');
  INDENT = INDENT.substr(0, INDENT.length-2);
  return;
  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _init_registry($L, $g) {
  var label = 0;
  var __stackBase__  = STACKTOP; STACKTOP = (STACKTOP + 12)|0; _memset(__stackBase__, 0, 12);
  Module.print(INDENT + ' Entering: _init_registry: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';

  var $L_addr;
  var $g_addr;
  var $mt=__stackBase__;
  var $registry;
  var $io;
  var $io1;
  var $io5;
  $L_addr=$L;
  $g_addr=$g;
  var $0=$L_addr;
  var $call=_luaH_new($0);
  $registry=$call;
  var $1=$g_addr;
  var $l_registry=(($1+36)|0);
  $io=$l_registry;
  var $2=$registry;
  var $3=$2;
  var $4=$io;
  var $value_=(($4)|0);
  var $gc=$value_;
  HEAP32[(($gc)>>2)]=$3;
  var $5=$io;
  var $tt_=(($5+8)|0);
  HEAP32[(($tt_)>>2)]=69;
  var $6=$L_addr;
  var $7=$registry;
  _luaH_resize($6, $7, 2, 0);
  $io1=$mt;
  var $8=$L_addr;
  var $9=$8;
  var $10=$io1;
  var $value_2=(($10)|0);
  var $gc3=$value_2;
  HEAP32[(($gc3)>>2)]=$9;
  var $11=$io1;
  var $tt_4=(($11+8)|0);
  HEAP32[(($tt_4)>>2)]=72;
  var $12=$L_addr;
  var $13=$registry;
  _luaH_setint($12, $13, 1, $mt);
  $io5=$mt;
  var $14=$L_addr;
  var $call6=_luaH_new($14);
  var $15=$call6;
  var $16=$io5;
  var $value_7=(($16)|0);
  var $gc8=$value_7;
  HEAP32[(($gc8)>>2)]=$15;
  var $17=$io5;
  var $tt_9=(($17+8)|0);
  HEAP32[(($tt_9)>>2)]=69;
  var $18=$L_addr;
  var $19=$registry;
  _luaH_setint($18, $19, 2, $mt);
  STACKTOP = __stackBase__;
  Module.print(INDENT + 'Exiting: _init_registry');
  INDENT = INDENT.substr(0, INDENT.length-2);
  return;
  INDENT = INDENT.substr(0, INDENT.length-2);
}
_init_registry["X"]=1;

function _luaS_hash($str, $l, $seed) {
  var label = 0;

  Module.print(INDENT + ' Entering: _luaS_hash: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $str_addr;
      var $l_addr;
      var $seed_addr;
      var $h;
      var $l1;
      var $step;
      $str_addr=$str;
      $l_addr=$l;
      $seed_addr=$seed;
      var $0=$seed_addr;
      var $1=$l_addr;
      var $xor=$0 ^ $1;
      $h=$xor;
      var $2=$l_addr;
      var $shr=$2 >>> 5;
      var $add=((($shr)+(1))|0);
      $step=$add;
      var $3=$l_addr;
      $l1=$3;
      label = 3; break;
    case 3: 
      var $4=$l1;
      var $5=$step;
      var $cmp=(($4)>>>0) >= (($5)>>>0);
      if ($cmp) { label = 4; break; } else { label = 6; break; }
    case 4: 
      var $6=$h;
      var $7=$h;
      var $shl=$7 << 5;
      var $8=$h;
      var $shr1=$8 >>> 2;
      var $add2=((($shl)+($shr1))|0);
      var $9=$l1;
      var $sub=((($9)-(1))|0);
      var $10=$str_addr;
      var $arrayidx=(($10+$sub)|0);
      var $11=HEAP8[($arrayidx)];
      var $conv=(($11)&255);
      var $add3=((($add2)+($conv))|0);
      var $xor4=$6 ^ $add3;
      $h=$xor4;
      label = 5; break;
    case 5: 
      var $12=$step;
      var $13=$l1;
      var $sub5=((($13)-($12))|0);
      $l1=$sub5;
      label = 3; break;
    case 6: 
      var $14=$h;

      Module.print(INDENT + 'Exiting: _luaS_hash');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return $14;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _luaS_eqlngstr($a, $b) {
  var label = 0;

  Module.print(INDENT + ' Entering: _luaS_eqlngstr: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $a_addr;
      var $b_addr;
      var $len;
      $a_addr=$a;
      $b_addr=$b;
      var $0=$a_addr;
      var $tsv=$0;
      var $len1=(($tsv+12)|0);
      var $1=HEAP32[(($len1)>>2)];
      $len=$1;
      var $2=$a_addr;
      var $3=$b_addr;
      var $cmp=(($2)|0)==(($3)|0);
      if ($cmp) { var $13 = 1;label = 6; break; } else { label = 3; break; }
    case 3: 
      var $4=$len;
      var $5=$b_addr;
      var $tsv2=$5;
      var $len3=(($tsv2+12)|0);
      var $6=HEAP32[(($len3)>>2)];
      var $cmp4=(($4)|0)==(($6)|0);
      if ($cmp4) { label = 4; break; } else { var $12 = 0;label = 5; break; }
    case 4: 
      var $7=$a_addr;
      var $add_ptr=(($7+16)|0);
      var $8=$add_ptr;
      var $9=$b_addr;
      var $add_ptr5=(($9+16)|0);
      var $10=$add_ptr5;
      var $11=$len;
      var $call=_memcmp($8, $10, $11);
      var $cmp6=(($call)|0)==0;
      var $12 = $cmp6;label = 5; break;
    case 5: 
      var $12;
      var $13 = $12;label = 6; break;
    case 6: 
      var $13;
      var $lor_ext=(($13)&1);

      Module.print(INDENT + 'Exiting: _luaS_eqlngstr');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return $lor_ext;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _luaS_eqstr($a, $b) {
  var label = 0;

  Module.print(INDENT + ' Entering: _luaS_eqstr: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $a_addr;
      var $b_addr;
      $a_addr=$a;
      $b_addr=$b;
      var $0=$a_addr;
      var $tsv=$0;
      var $tt=(($tsv+4)|0);
      var $1=HEAP8[($tt)];
      var $conv=(($1)&255);
      var $2=$b_addr;
      var $tsv1=$2;
      var $tt2=(($tsv1+4)|0);
      var $3=HEAP8[($tt2)];
      var $conv3=(($3)&255);
      var $cmp=(($conv)|0)==(($conv3)|0);
      if ($cmp) { label = 3; break; } else { var $10 = 0;label = 7; break; }
    case 3: 
      var $4=$a_addr;
      var $tsv5=$4;
      var $tt6=(($tsv5+4)|0);
      var $5=HEAP8[($tt6)];
      var $conv7=(($5)&255);
      var $cmp8=(($conv7)|0)==4;
      if ($cmp8) { label = 4; break; } else { label = 5; break; }
    case 4: 
      var $6=$a_addr;
      var $7=$b_addr;
      var $cmp10=(($6)|0)==(($7)|0);
      var $conv11=(($cmp10)&1);
      var $cond = $conv11;label = 6; break;
    case 5: 
      var $8=$a_addr;
      var $9=$b_addr;
      var $call=_luaS_eqlngstr($8, $9);
      var $cond = $call;label = 6; break;
    case 6: 
      var $cond;
      var $tobool=(($cond)|0)!=0;
      var $10 = $tobool;label = 7; break;
    case 7: 
      var $10;
      var $land_ext=(($10)&1);

      Module.print(INDENT + 'Exiting: _luaS_eqstr');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return $land_ext;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _internshrstr($L, $str, $l) {
  var label = 0;

  Module.print(INDENT + ' Entering: _internshrstr: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $retval;
      var $L_addr;
      var $str_addr;
      var $l_addr;
      var $o;
      var $g;
      var $h;
      var $ts;
      $L_addr=$L;
      $str_addr=$str;
      $l_addr=$l;
      var $0=$L_addr;
      var $l_G=(($0+12)|0);
      var $1=HEAP32[(($l_G)>>2)];
      $g=$1;
      var $2=$str_addr;
      var $3=$l_addr;
      var $4=$g;
      var $seed=(($4+48)|0);
      var $5=HEAP32[(($seed)>>2)];
      var $call=_luaS_hash($2, $3, $5);
      $h=$call;
      var $6=$h;
      var $7=$g;
      var $strt=(($7+24)|0);
      var $size=(($strt+8)|0);
      var $8=HEAP32[(($size)>>2)];
      var $sub=((($8)-(1))|0);
      var $and=$6 & $sub;
      var $9=$g;
      var $strt1=(($9+24)|0);
      var $hash=(($strt1)|0);
      var $10=HEAP32[(($hash)>>2)];
      var $arrayidx=(($10+($and<<2))|0);
      var $11=HEAP32[(($arrayidx)>>2)];
      $o=$11;
      label = 3; break;
    case 3: 
      var $12=$o;
      var $cmp=(($12)|0)!=0;
      if ($cmp) { label = 4; break; } else { label = 12; break; }
    case 4: 
      var $13=$o;
      var $ts2=$13;
      $ts=$ts2;
      var $14=$h;
      var $15=$ts;
      var $tsv=$15;
      var $hash3=(($tsv+8)|0);
      var $16=HEAP32[(($hash3)>>2)];
      var $cmp4=(($14)|0)==(($16)|0);
      if ($cmp4) { label = 5; break; } else { label = 10; break; }
    case 5: 
      var $17=$ts;
      var $tsv5=$17;
      var $len=(($tsv5+12)|0);
      var $18=HEAP32[(($len)>>2)];
      var $19=$l_addr;
      var $cmp6=(($18)|0)==(($19)|0);
      if ($cmp6) { label = 6; break; } else { label = 10; break; }
    case 6: 
      var $20=$str_addr;
      var $21=$ts;
      var $add_ptr=(($21+16)|0);
      var $22=$add_ptr;
      var $23=$l_addr;
      var $mul=$23;
      var $call8=_memcmp($20, $22, $mul);
      var $cmp9=(($call8)|0)==0;
      if ($cmp9) { label = 7; break; } else { label = 10; break; }
    case 7: 
      var $24=$o;
      var $gch=$24;
      var $marked=(($gch+5)|0);
      var $25=HEAP8[($marked)];
      var $conv=(($25)&255);
      var $xor=$conv ^ 3;
      var $26=$L_addr;
      var $l_G10=(($26+12)|0);
      var $27=HEAP32[(($l_G10)>>2)];
      var $currentwhite=(($27+52)|0);
      var $28=HEAP8[($currentwhite)];
      var $conv11=(($28)&255);
      var $xor12=$conv11 ^ 3;
      var $and13=$xor & $xor12;
      var $tobool=(($and13)|0)!=0;
      if ($tobool) { label = 9; break; } else { label = 8; break; }
    case 8: 
      var $29=$o;
      var $gch15=$29;
      var $marked16=(($gch15+5)|0);
      var $30=HEAP8[($marked16)];
      var $conv17=(($30)&255);
      var $xor18=$conv17 ^ 3;
      var $conv19=(($xor18) & 255);
      HEAP8[($marked16)]=$conv19;
      label = 9; break;
    case 9: 
      var $31=$ts;
      $retval=$31;
      label = 13; break;
    case 10: 
      label = 11; break;
    case 11: 
      var $32=$o;
      var $gch21=$32;
      var $next=(($gch21)|0);
      var $33=HEAP32[(($next)>>2)];
      $o=$33;
      label = 3; break;
    case 12: 
      var $34=$L_addr;
      var $35=$str_addr;
      var $36=$l_addr;
      var $37=$h;
      var $call22=_newshrstr($34, $35, $36, $37);
      $retval=$call22;
      label = 13; break;
    case 13: 
      var $38=$retval;

      Module.print(INDENT + 'Exiting: _internshrstr');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return $38;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_internshrstr["X"]=1;

function _createstrobj($L, $str, $l, $tag, $h, $list) {
  var label = 0;

  Module.print(INDENT + ' Entering: _createstrobj: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';

  var $L_addr;
  var $str_addr;
  var $l_addr;
  var $tag_addr;
  var $h_addr;
  var $list_addr;
  var $ts;
  var $totalsize;
  $L_addr=$L;
  $str_addr=$str;
  $l_addr=$l;
  $tag_addr=$tag;
  $h_addr=$h;
  $list_addr=$list;
  var $0=$l_addr;
  var $add=((($0)+(1))|0);
  var $mul=$add;
  var $add1=((($mul)+(16))|0);
  $totalsize=$add1;
  var $1=$L_addr;
  var $2=$tag_addr;
  var $3=$totalsize;
  var $4=$list_addr;
  var $call=_luaC_newobj($1, $2, $3, $4, 0);
  var $ts2=$call;
  $ts=$ts2;
  var $5=$l_addr;
  var $6=$ts;
  var $tsv=$6;
  var $len=(($tsv+12)|0);
  HEAP32[(($len)>>2)]=$5;
  var $7=$h_addr;
  var $8=$ts;
  var $tsv3=$8;
  var $hash=(($tsv3+8)|0);
  HEAP32[(($hash)>>2)]=$7;
  var $9=$ts;
  var $tsv4=$9;
  var $extra=(($tsv4+6)|0);
  HEAP8[($extra)]=0;
  var $10=$ts;
  var $add_ptr=(($10+16)|0);
  var $11=$add_ptr;
  var $12=$str_addr;
  var $13=$l_addr;
  var $mul5=$13;
  _memcpy($11, $12, $mul5);
  var $14=$l_addr;
  var $15=$ts;
  var $add_ptr6=(($15+16)|0);
  var $16=$add_ptr6;
  var $arrayidx=(($16+$14)|0);
  HEAP8[($arrayidx)]=0;
  var $17=$ts;

  Module.print(INDENT + 'Exiting: _createstrobj');
  INDENT = INDENT.substr(0, INDENT.length-2);
  return $17;
  INDENT = INDENT.substr(0, INDENT.length-2);
}
_createstrobj["X"]=1;

function _luaS_new($L, $str) {
  var label = 0;

  Module.print(INDENT + ' Entering: _luaS_new: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';

  var $L_addr;
  var $str_addr;
  $L_addr=$L;
  $str_addr=$str;
  var $0=$L_addr;
  var $1=$str_addr;
  var $2=$str_addr;
  var $call=_strlen($2);
  var $call1=_luaS_newlstr($0, $1, $call);

  Module.print(INDENT + 'Exiting: _luaS_new');
  INDENT = INDENT.substr(0, INDENT.length-2);
  return $call1;
  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _newshrstr($L, $str, $l, $h) {
  var label = 0;

  Module.print(INDENT + ' Entering: _newshrstr: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $L_addr;
      var $str_addr;
      var $l_addr;
      var $h_addr;
      var $list;
      var $tb;
      var $s;
      $L_addr=$L;
      $str_addr=$str;
      $l_addr=$l;
      $h_addr=$h;
      var $0=$L_addr;
      var $l_G=(($0+12)|0);
      var $1=HEAP32[(($l_G)>>2)];
      var $strt=(($1+24)|0);
      $tb=$strt;
      var $2=$tb;
      var $nuse=(($2+4)|0);
      var $3=HEAP32[(($nuse)>>2)];
      var $4=$tb;
      var $size=(($4+8)|0);
      var $5=HEAP32[(($size)>>2)];
      var $cmp=(($3)>>>0) >= (($5)>>>0);
      if ($cmp) { label = 3; break; } else { label = 5; break; }
    case 3: 
      var $6=$tb;
      var $size1=(($6+8)|0);
      var $7=HEAP32[(($size1)>>2)];
      var $cmp2=(($7)|0) <= 1073741822;
      if ($cmp2) { label = 4; break; } else { label = 5; break; }
    case 4: 
      var $8=$L_addr;
      var $9=$tb;
      var $size3=(($9+8)|0);
      var $10=HEAP32[(($size3)>>2)];
      var $mul=($10<<1);
      _luaS_resize($8, $mul);
      label = 5; break;
    case 5: 
      var $11=$h_addr;
      var $12=$tb;
      var $size4=(($12+8)|0);
      var $13=HEAP32[(($size4)>>2)];
      var $sub=((($13)-(1))|0);
      var $and=$11 & $sub;
      var $14=$tb;
      var $hash=(($14)|0);
      var $15=HEAP32[(($hash)>>2)];
      var $arrayidx=(($15+($and<<2))|0);
      $list=$arrayidx;
      var $16=$L_addr;
      var $17=$str_addr;
      var $18=$l_addr;
      var $19=$h_addr;
      var $20=$list;
      var $call=_createstrobj($16, $17, $18, 4, $19, $20);
      $s=$call;
      var $21=$tb;
      var $nuse5=(($21+4)|0);
      var $22=HEAP32[(($nuse5)>>2)];
      var $inc=((($22)+(1))|0);
      HEAP32[(($nuse5)>>2)]=$inc;
      var $23=$s;

      Module.print(INDENT + 'Exiting: _newshrstr');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return $23;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_newshrstr["X"]=1;

function _luaH_next($L, $t, $key) {
  var label = 0;

  Module.print(INDENT + ' Entering: _luaH_next: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $retval;
      var $L_addr;
      var $t_addr;
      var $key_addr;
      var $i;
      var $io;
      var $io2;
      var $io1;
      var $io221;
      var $io124;
      var $io229;
      var $io133;
      $L_addr=$L;
      $t_addr=$t;
      $key_addr=$key;
      var $0=$L_addr;
      var $1=$t_addr;
      var $2=$key_addr;
      var $call=_findindex($0, $1, $2);
      $i=$call;
      var $3=$i;
      var $inc=((($3)+(1))|0);
      $i=$inc;
      label = 3; break;
    case 3: 
      var $4=$i;
      var $5=$t_addr;
      var $sizearray=(($5+28)|0);
      var $6=HEAP32[(($sizearray)>>2)];
      var $cmp=(($4)|0) < (($6)|0);
      if ($cmp) { label = 4; break; } else { label = 8; break; }
    case 4: 
      var $7=$i;
      var $8=$t_addr;
      var $array=(($8+12)|0);
      var $9=HEAP32[(($array)>>2)];
      var $arrayidx=(($9+((($7)*(12))&-1))|0);
      var $tt_=(($arrayidx+8)|0);
      var $10=HEAP32[(($tt_)>>2)];
      var $cmp1=(($10)|0)==0;
      if ($cmp1) { label = 6; break; } else { label = 5; break; }
    case 5: 
      var $11=$key_addr;
      $io=$11;
      var $12=$i;
      var $add=((($12)+(1))|0);
      var $conv=(($add)|0);
      var $13=$io;
      var $value_=(($13)|0);
      var $n=$value_;
      (HEAPF64[(tempDoublePtr)>>3]=$conv,HEAP32[(($n)>>2)]=HEAP32[((tempDoublePtr)>>2)],HEAP32[((($n)+(4))>>2)]=HEAP32[(((tempDoublePtr)+(4))>>2)]);
      var $14=$io;
      var $tt_2=(($14+8)|0);
      HEAP32[(($tt_2)>>2)]=3;
      var $15=$i;
      var $16=$t_addr;
      var $array3=(($16+12)|0);
      var $17=HEAP32[(($array3)>>2)];
      var $arrayidx4=(($17+((($15)*(12))&-1))|0);
      $io2=$arrayidx4;
      var $18=$key_addr;
      var $add_ptr=(($18+12)|0);
      $io1=$add_ptr;
      var $19=$io1;
      var $value_5=(($19)|0);
      var $20=$io2;
      var $value_6=(($20)|0);
      var $21=$value_5;
      var $22=$value_6;
      HEAP32[(($21)>>2)]=HEAP32[(($22)>>2)];HEAP32[((($21)+(4))>>2)]=HEAP32[((($22)+(4))>>2)];
      var $23=$io2;
      var $tt_7=(($23+8)|0);
      var $24=HEAP32[(($tt_7)>>2)];
      var $25=$io1;
      var $tt_8=(($25+8)|0);
      HEAP32[(($tt_8)>>2)]=$24;
      $retval=1;
      label = 15; break;
    case 6: 
      label = 7; break;
    case 7: 
      var $26=$i;
      var $inc9=((($26)+(1))|0);
      $i=$inc9;
      label = 3; break;
    case 8: 
      var $27=$t_addr;
      var $sizearray10=(($27+28)|0);
      var $28=HEAP32[(($sizearray10)>>2)];
      var $29=$i;
      var $sub=((($29)-($28))|0);
      $i=$sub;
      label = 9; break;
    case 9: 
      var $30=$i;
      var $31=$t_addr;
      var $lsizenode=(($31+7)|0);
      var $32=HEAP8[($lsizenode)];
      var $conv12=(($32)&255);
      var $shl=1 << $conv12;
      var $cmp13=(($30)|0) < (($shl)|0);
      if ($cmp13) { label = 10; break; } else { label = 14; break; }
    case 10: 
      var $33=$i;
      var $34=$t_addr;
      var $node=(($34+16)|0);
      var $35=HEAP32[(($node)>>2)];
      var $arrayidx16=(($35+((($33)*(28))&-1))|0);
      var $i_val=(($arrayidx16)|0);
      var $tt_17=(($i_val+8)|0);
      var $36=HEAP32[(($tt_17)>>2)];
      var $cmp18=(($36)|0)==0;
      if ($cmp18) { label = 12; break; } else { label = 11; break; }
    case 11: 
      var $37=$i;
      var $38=$t_addr;
      var $node22=(($38+16)|0);
      var $39=HEAP32[(($node22)>>2)];
      var $arrayidx23=(($39+((($37)*(28))&-1))|0);
      var $i_key=(($arrayidx23+12)|0);
      var $tvk=$i_key;
      $io221=$tvk;
      var $40=$key_addr;
      $io124=$40;
      var $41=$io124;
      var $value_25=(($41)|0);
      var $42=$io221;
      var $value_26=(($42)|0);
      var $43=$value_25;
      var $44=$value_26;
      HEAP32[(($43)>>2)]=HEAP32[(($44)>>2)];HEAP32[((($43)+(4))>>2)]=HEAP32[((($44)+(4))>>2)];
      var $45=$io221;
      var $tt_27=(($45+8)|0);
      var $46=HEAP32[(($tt_27)>>2)];
      var $47=$io124;
      var $tt_28=(($47+8)|0);
      HEAP32[(($tt_28)>>2)]=$46;
      var $48=$i;
      var $49=$t_addr;
      var $node30=(($49+16)|0);
      var $50=HEAP32[(($node30)>>2)];
      var $arrayidx31=(($50+((($48)*(28))&-1))|0);
      var $i_val32=(($arrayidx31)|0);
      $io229=$i_val32;
      var $51=$key_addr;
      var $add_ptr34=(($51+12)|0);
      $io133=$add_ptr34;
      var $52=$io133;
      var $value_35=(($52)|0);
      var $53=$io229;
      var $value_36=(($53)|0);
      var $54=$value_35;
      var $55=$value_36;
      HEAP32[(($54)>>2)]=HEAP32[(($55)>>2)];HEAP32[((($54)+(4))>>2)]=HEAP32[((($55)+(4))>>2)];
      var $56=$io229;
      var $tt_37=(($56+8)|0);
      var $57=HEAP32[(($tt_37)>>2)];
      var $58=$io133;
      var $tt_38=(($58+8)|0);
      HEAP32[(($tt_38)>>2)]=$57;
      $retval=1;
      label = 15; break;
    case 12: 
      label = 13; break;
    case 13: 
      var $59=$i;
      var $inc41=((($59)+(1))|0);
      $i=$inc41;
      label = 9; break;
    case 14: 
      $retval=0;
      label = 15; break;
    case 15: 
      var $60=$retval;

      Module.print(INDENT + 'Exiting: _luaH_next');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return $60;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_luaH_next["X"]=1;

function _luaS_resize($L, $newsize) {
  var label = 0;

  Module.print(INDENT + ' Entering: _luaS_resize: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $L_addr;
      var $newsize_addr;
      var $i;
      var $tb;
      var $p;
      var $next;
      var $h;
      $L_addr=$L;
      $newsize_addr=$newsize;
      var $0=$L_addr;
      var $l_G=(($0+12)|0);
      var $1=HEAP32[(($l_G)>>2)];
      var $strt=(($1+24)|0);
      $tb=$strt;
      var $2=$L_addr;
      _luaC_runtilstate($2, -5);
      var $3=$newsize_addr;
      var $4=$tb;
      var $size=(($4+8)|0);
      var $5=HEAP32[(($size)>>2)];
      var $cmp=(($3)|0) > (($5)|0);
      if ($cmp) { label = 3; break; } else { label = 11; break; }
    case 3: 
      var $6=$newsize_addr;
      var $add=((($6)+(1))|0);
      var $cmp1=(($add)>>>0) > 1073741823;
      if ($cmp1) { label = 4; break; } else { label = 5; break; }
    case 4: 
      var $7=$L_addr;
      _luaM_toobig($7);

      label = 6; break;
    case 5: 
      var $9=$L_addr;
      var $10=$tb;
      var $hash=(($10)|0);
      var $11=HEAP32[(($hash)>>2)];
      var $12=$11;
      var $13=$tb;
      var $size2=(($13+8)|0);
      var $14=HEAP32[(($size2)>>2)];
      var $mul=($14<<2);
      var $15=$newsize_addr;
      var $mul3=($15<<2);
      var $call=_luaM_realloc_($9, $12, $mul, $mul3);
      var $cond = $call;label = 6; break;
    case 6: 
      var $cond;
      var $16=$cond;
      var $17=$tb;
      var $hash4=(($17)|0);
      HEAP32[(($hash4)>>2)]=$16;
      var $18=$tb;
      var $size5=(($18+8)|0);
      var $19=HEAP32[(($size5)>>2)];
      $i=$19;
      label = 7; break;
    case 7: 
      var $20=$i;
      var $21=$newsize_addr;
      var $cmp6=(($20)|0) < (($21)|0);
      if ($cmp6) { label = 8; break; } else { label = 10; break; }
    case 8: 
      var $22=$i;
      var $23=$tb;
      var $hash7=(($23)|0);
      var $24=HEAP32[(($hash7)>>2)];
      var $arrayidx=(($24+($22<<2))|0);
      HEAP32[(($arrayidx)>>2)]=0;
      label = 9; break;
    case 9: 
      var $25=$i;
      var $inc=((($25)+(1))|0);
      $i=$inc;
      label = 7; break;
    case 10: 
      label = 11; break;
    case 11: 
      $i=0;
      label = 12; break;
    case 12: 
      var $26=$i;
      var $27=$tb;
      var $size9=(($27+8)|0);
      var $28=HEAP32[(($size9)>>2)];
      var $cmp10=(($26)|0) < (($28)|0);
      if ($cmp10) { label = 13; break; } else { label = 18; break; }
    case 13: 
      var $29=$i;
      var $30=$tb;
      var $hash12=(($30)|0);
      var $31=HEAP32[(($hash12)>>2)];
      var $arrayidx13=(($31+($29<<2))|0);
      var $32=HEAP32[(($arrayidx13)>>2)];
      $p=$32;
      var $33=$i;
      var $34=$tb;
      var $hash14=(($34)|0);
      var $35=HEAP32[(($hash14)>>2)];
      var $arrayidx15=(($35+($33<<2))|0);
      HEAP32[(($arrayidx15)>>2)]=0;
      label = 14; break;
    case 14: 
      var $36=$p;
      var $tobool=(($36)|0)!=0;
      if ($tobool) { label = 15; break; } else { label = 16; break; }
    case 15: 
      var $37=$p;
      var $gch=$37;
      var $next16=(($gch)|0);
      var $38=HEAP32[(($next16)>>2)];
      $next=$38;
      var $39=$p;
      var $ts=$39;
      var $tsv=$ts;
      var $hash17=(($tsv+8)|0);
      var $40=HEAP32[(($hash17)>>2)];
      var $41=$newsize_addr;
      var $sub=((($41)-(1))|0);
      var $and=$40 & $sub;
      $h=$and;
      var $42=$h;
      var $43=$tb;
      var $hash18=(($43)|0);
      var $44=HEAP32[(($hash18)>>2)];
      var $arrayidx19=(($44+($42<<2))|0);
      var $45=HEAP32[(($arrayidx19)>>2)];
      var $46=$p;
      var $gch20=$46;
      var $next21=(($gch20)|0);
      HEAP32[(($next21)>>2)]=$45;
      var $47=$p;
      var $48=$h;
      var $49=$tb;
      var $hash22=(($49)|0);
      var $50=HEAP32[(($hash22)>>2)];
      var $arrayidx23=(($50+($48<<2))|0);
      HEAP32[(($arrayidx23)>>2)]=$47;
      var $51=$p;
      var $gch24=$51;
      var $marked=(($gch24+5)|0);
      var $52=HEAP8[($marked)];
      var $conv=(($52)&255);
      var $and25=$conv & 191;
      var $conv26=(($and25) & 255);
      HEAP8[($marked)]=$conv26;
      var $53=$next;
      $p=$53;
      label = 14; break;
    case 16: 
      label = 17; break;
    case 17: 
      var $54=$i;
      var $inc28=((($54)+(1))|0);
      $i=$inc28;
      label = 12; break;
    case 18: 
      var $55=$newsize_addr;
      var $56=$tb;
      var $size30=(($56+8)|0);
      var $57=HEAP32[(($size30)>>2)];
      var $cmp31=(($55)|0) < (($57)|0);
      if ($cmp31) { label = 19; break; } else { label = 23; break; }
    case 19: 
      var $58=$newsize_addr;
      var $add34=((($58)+(1))|0);
      var $cmp35=(($add34)>>>0) > 1073741823;
      if ($cmp35) { label = 20; break; } else { label = 21; break; }
    case 20: 
      var $59=$L_addr;
      _luaM_toobig($59);

      label = 22; break;
    case 21: 
      var $61=$L_addr;
      var $62=$tb;
      var $hash39=(($62)|0);
      var $63=HEAP32[(($hash39)>>2)];
      var $64=$63;
      var $65=$tb;
      var $size40=(($65+8)|0);
      var $66=HEAP32[(($size40)>>2)];
      var $mul41=($66<<2);
      var $67=$newsize_addr;
      var $mul42=($67<<2);
      var $call43=_luaM_realloc_($61, $64, $mul41, $mul42);
      var $cond45 = $call43;label = 22; break;
    case 22: 
      var $cond45;
      var $68=$cond45;
      var $69=$tb;
      var $hash46=(($69)|0);
      HEAP32[(($hash46)>>2)]=$68;
      label = 23; break;
    case 23: 
      var $70=$newsize_addr;
      var $71=$tb;
      var $size48=(($71+8)|0);
      HEAP32[(($size48)>>2)]=$70;

      Module.print(INDENT + 'Exiting: _luaS_resize');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_luaS_resize["X"]=1;

function _luaS_newlstr($L, $str, $l) {
  var label = 0;

  Module.print(INDENT + ' Entering: _luaS_newlstr: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $retval;
      var $L_addr;
      var $str_addr;
      var $l_addr;
      $L_addr=$L;
      $str_addr=$str;
      $l_addr=$l;
      var $0=$l_addr;
      var $cmp=(($0)>>>0) <= 40;
      if ($cmp) { label = 3; break; } else { label = 4; break; }
    case 3: 
      var $1=$L_addr;
      var $2=$str_addr;
      var $3=$l_addr;
      var $call=_internshrstr($1, $2, $3);
      $retval=$call;
      label = 7; break;
    case 4: 
      var $4=$l_addr;
      var $add=((($4)+(1))|0);
      var $cmp1=(($add)>>>0) > 4294967277;
      if ($cmp1) { label = 5; break; } else { label = 6; break; }
    case 5: 
      var $5=$L_addr;
      _luaM_toobig($5);

    case 6: 
      var $6=$L_addr;
      var $7=$str_addr;
      var $8=$l_addr;
      var $9=$L_addr;
      var $l_G=(($9+12)|0);
      var $10=HEAP32[(($l_G)>>2)];
      var $seed=(($10+48)|0);
      var $11=HEAP32[(($seed)>>2)];
      var $call3=_createstrobj($6, $7, $8, 20, $11, 0);
      $retval=$call3;
      label = 7; break;
    case 7: 
      var $12=$retval;

      Module.print(INDENT + 'Exiting: _luaS_newlstr');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return $12;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _luaS_newudata($L, $s, $e) {
  var label = 0;

  Module.print(INDENT + ' Entering: _luaS_newudata: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $L_addr;
      var $s_addr;
      var $e_addr;
      var $u;
      $L_addr=$L;
      $s_addr=$s;
      $e_addr=$e;
      var $0=$s_addr;
      var $cmp=(($0)>>>0) > 4294967273;
      if ($cmp) { label = 3; break; } else { label = 4; break; }
    case 3: 
      var $1=$L_addr;
      _luaM_toobig($1);

    case 4: 
      var $2=$L_addr;
      var $3=$s_addr;
      var $add=((($3)+(20))|0);
      var $call=_luaC_newobj($2, 7, $add, 0, 0);
      var $u1=$call;
      $u=$u1;
      var $4=$s_addr;
      var $5=$u;
      var $uv=$5;
      var $len=(($uv+16)|0);
      HEAP32[(($len)>>2)]=$4;
      var $6=$u;
      var $uv2=$6;
      var $metatable=(($uv2+8)|0);
      HEAP32[(($metatable)>>2)]=0;
      var $7=$e_addr;
      var $8=$u;
      var $uv3=$8;
      var $env=(($uv3+12)|0);
      HEAP32[(($env)>>2)]=$7;
      var $9=$u;

      Module.print(INDENT + 'Exiting: _luaS_newudata');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return $9;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _luaH_setint($L, $t, $key, $value) {
  var label = 0;
  var __stackBase__  = STACKTOP; STACKTOP = (STACKTOP + 12)|0; _memset(__stackBase__, 0, 12);
  Module.print(INDENT + ' Entering: _luaH_setint: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $L_addr;
      var $t_addr;
      var $key_addr;
      var $value_addr;
      var $p;
      var $cell;
      var $k=__stackBase__;
      var $io;
      var $io2;
      var $io1;
      $L_addr=$L;
      $t_addr=$t;
      $key_addr=$key;
      $value_addr=$value;
      var $0=$t_addr;
      var $1=$key_addr;
      var $call=_luaH_getint($0, $1);
      $p=$call;
      var $2=$p;
      var $cmp=(($2)|0)!=5243784;
      if ($cmp) { label = 3; break; } else { label = 4; break; }
    case 3: 
      var $3=$p;
      $cell=$3;
      label = 5; break;
    case 4: 
      $io=$k;
      var $4=$key_addr;
      var $conv=(($4)|0);
      var $5=$io;
      var $value_=(($5)|0);
      var $n=$value_;
      (HEAPF64[(tempDoublePtr)>>3]=$conv,HEAP32[(($n)>>2)]=HEAP32[((tempDoublePtr)>>2)],HEAP32[((($n)+(4))>>2)]=HEAP32[(((tempDoublePtr)+(4))>>2)]);
      var $6=$io;
      var $tt_=(($6+8)|0);
      HEAP32[(($tt_)>>2)]=3;
      var $7=$L_addr;
      var $8=$t_addr;
      var $call1=_luaH_newkey($7, $8, $k);
      $cell=$call1;
      label = 5; break;
    case 5: 
      var $9=$value_addr;
      $io2=$9;
      var $10=$cell;
      $io1=$10;
      var $11=$io1;
      var $value_2=(($11)|0);
      var $12=$io2;
      var $value_3=(($12)|0);
      var $13=$value_2;
      var $14=$value_3;
      HEAP32[(($13)>>2)]=HEAP32[(($14)>>2)];HEAP32[((($13)+(4))>>2)]=HEAP32[((($14)+(4))>>2)];
      var $15=$io2;
      var $tt_4=(($15+8)|0);
      var $16=HEAP32[(($tt_4)>>2)];
      var $17=$io1;
      var $tt_5=(($17+8)|0);
      HEAP32[(($tt_5)>>2)]=$16;
      STACKTOP = __stackBase__;
      Module.print(INDENT + 'Exiting: _luaH_setint');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_luaH_setint["X"]=1;

function _luaH_set($L, $t, $key) {
  var label = 0;

  Module.print(INDENT + ' Entering: _luaH_set: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $retval;
      var $L_addr;
      var $t_addr;
      var $key_addr;
      var $p;
      $L_addr=$L;
      $t_addr=$t;
      $key_addr=$key;
      var $0=$t_addr;
      var $1=$key_addr;
      var $call=_luaH_get($0, $1);
      $p=$call;
      var $2=$p;
      var $cmp=(($2)|0)!=5243784;
      if ($cmp) { label = 3; break; } else { label = 4; break; }
    case 3: 
      var $3=$p;
      $retval=$3;
      label = 5; break;
    case 4: 
      var $4=$L_addr;
      var $5=$t_addr;
      var $6=$key_addr;
      var $call1=_luaH_newkey($4, $5, $6);
      $retval=$call1;
      label = 5; break;
    case 5: 
      var $7=$retval;

      Module.print(INDENT + 'Exiting: _luaH_set');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return $7;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _luaH_resizearray($L, $t, $nasize) {
  var label = 0;

  Module.print(INDENT + ' Entering: _luaH_resizearray: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $L_addr;
      var $t_addr;
      var $nasize_addr;
      var $nsize;
      $L_addr=$L;
      $t_addr=$t;
      $nasize_addr=$nasize;
      var $0=$t_addr;
      var $node=(($0+16)|0);
      var $1=HEAP32[(($node)>>2)];
      var $cmp=(($1)|0)==5244060;
      if ($cmp) { label = 3; break; } else { label = 4; break; }
    case 3: 
      var $cond = 0;label = 5; break;
    case 4: 
      var $2=$t_addr;
      var $lsizenode=(($2+7)|0);
      var $3=HEAP8[($lsizenode)];
      var $conv=(($3)&255);
      var $shl=1 << $conv;
      var $cond = $shl;label = 5; break;
    case 5: 
      var $cond;
      $nsize=$cond;
      var $4=$L_addr;
      var $5=$t_addr;
      var $6=$nasize_addr;
      var $7=$nsize;
      _luaH_resize($4, $5, $6, $7);

      Module.print(INDENT + 'Exiting: _luaH_resizearray');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _luaH_new($L) {
  var label = 0;

  Module.print(INDENT + ' Entering: _luaH_new: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';

  var $L_addr;
  var $t;
  $L_addr=$L;
  var $0=$L_addr;
  var $call=_luaC_newobj($0, 5, 32, 0, 0);
  var $h=$call;
  $t=$h;
  var $1=$t;
  var $metatable=(($1+8)|0);
  HEAP32[(($metatable)>>2)]=0;
  var $2=$t;
  var $flags=(($2+6)|0);
  HEAP8[($flags)]=-1;
  var $3=$t;
  var $array=(($3+12)|0);
  HEAP32[(($array)>>2)]=0;
  var $4=$t;
  var $sizearray=(($4+28)|0);
  HEAP32[(($sizearray)>>2)]=0;
  var $5=$L_addr;
  var $6=$t;
  _setnodevector($5, $6, 0);
  var $7=$t;

  Module.print(INDENT + 'Exiting: _luaH_new');
  INDENT = INDENT.substr(0, INDENT.length-2);
  return $7;
  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _luaH_free($L, $t) {
  var label = 0;

  Module.print(INDENT + ' Entering: _luaH_free: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $L_addr;
      var $t_addr;
      $L_addr=$L;
      $t_addr=$t;
      var $0=$t_addr;
      var $node=(($0+16)|0);
      var $1=HEAP32[(($node)>>2)];
      var $cmp=(($1)|0)==5244060;
      if ($cmp) { label = 4; break; } else { label = 3; break; }
    case 3: 
      var $2=$L_addr;
      var $3=$t_addr;
      var $node1=(($3+16)|0);
      var $4=HEAP32[(($node1)>>2)];
      var $5=$4;
      var $6=$t_addr;
      var $lsizenode=(($6+7)|0);
      var $7=HEAP8[($lsizenode)];
      var $conv=(($7)&255);
      var $shl=1 << $conv;
      var $mul=((($shl)*(28))&-1);
      var $call=_luaM_realloc_($2, $5, $mul, 0);
      label = 4; break;
    case 4: 
      var $8=$L_addr;
      var $9=$t_addr;
      var $array=(($9+12)|0);
      var $10=HEAP32[(($array)>>2)];
      var $11=$10;
      var $12=$t_addr;
      var $sizearray=(($12+28)|0);
      var $13=HEAP32[(($sizearray)>>2)];
      var $mul2=((($13)*(12))&-1);
      var $call3=_luaM_realloc_($8, $11, $mul2, 0);
      var $14=$L_addr;
      var $15=$t_addr;
      var $16=$15;
      var $call4=_luaM_realloc_($14, $16, 32, 0);

      Module.print(INDENT + 'Exiting: _luaH_free');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _findindex($L, $t, $key) {
  var label = 0;
  var __stackBase__  = STACKTOP; _memset(__stackBase__, 0, 0);
  Module.print(INDENT + ' Entering: _findindex: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $retval;
      var $L_addr;
      var $t_addr;
      var $key_addr;
      var $i;
      var $n;
      $L_addr=$L;
      $t_addr=$t;
      $key_addr=$key;
      var $0=$key_addr;
      var $tt_=(($0+8)|0);
      var $1=HEAP32[(($tt_)>>2)];
      var $cmp=(($1)|0)==0;
      if ($cmp) { label = 3; break; } else { label = 4; break; }
    case 3: 
      $retval=-1;
      label = 18; break;
    case 4: 
      var $2=$key_addr;
      var $call=_arrayindex($2);
      $i=$call;
      var $3=$i;
      var $cmp1=0 < (($3)|0);
      if ($cmp1) { label = 5; break; } else { label = 7; break; }
    case 5: 
      var $4=$i;
      var $5=$t_addr;
      var $sizearray=(($5+28)|0);
      var $6=HEAP32[(($sizearray)>>2)];
      var $cmp2=(($4)|0) <= (($6)|0);
      if ($cmp2) { label = 6; break; } else { label = 7; break; }
    case 6: 
      var $7=$i;
      var $sub=((($7)-(1))|0);
      $retval=$sub;
      label = 18; break;
    case 7: 
      var $8=$t_addr;
      var $9=$key_addr;
      var $call4=_mainposition($8, $9);
      $n=$call4;
      label = 8; break;
    case 8: 
      var $10=$n;
      var $i_key=(($10+12)|0);
      var $tvk=$i_key;
      var $tt_5=(($tvk+8)|0);
      var $11=HEAP32[(($tt_5)>>2)];
      var $12=$key_addr;
      var $tt_6=(($12+8)|0);
      var $13=HEAP32[(($tt_6)>>2)];
      var $cmp7=(($11)|0)==(($13)|0);
      if ($cmp7) { label = 9; break; } else { label = 10; break; }
    case 9: 
      var $14=$n;
      var $i_key9=(($14+12)|0);
      var $tvk10=$i_key9;
      var $15=$key_addr;
      var $call11=_luaV_equalobj_(0, $tvk10, $15);
      var $tobool=(($call11)|0)!=0;
      if ($tobool) { label = 13; break; } else { label = 10; break; }
    case 10: 
      var $16=$n;
      var $i_key12=(($16+12)|0);
      var $tvk13=$i_key12;
      var $tt_14=(($tvk13+8)|0);
      var $17=HEAP32[(($tt_14)>>2)];
      var $cmp15=(($17)|0)==11;
      if ($cmp15) { label = 11; break; } else { label = 14; break; }
    case 11: 
      var $18=$key_addr;
      var $tt_17=(($18+8)|0);
      var $19=HEAP32[(($tt_17)>>2)];
      var $and=$19 & 64;
      var $tobool18=(($and)|0)!=0;
      if ($tobool18) { label = 12; break; } else { label = 14; break; }
    case 12: 
      var $20=$n;
      var $i_key20=(($20+12)|0);
      var $tvk21=$i_key20;
      var $value_=(($tvk21)|0);
      var $gc=$value_;
      var $21=HEAP32[(($gc)>>2)];
      var $22=$21;
      var $23=$key_addr;
      var $value_22=(($23)|0);
      var $gc23=$value_22;
      var $24=HEAP32[(($gc23)>>2)];
      var $25=$24;
      var $cmp24=(($22)|0)==(($25)|0);
      if ($cmp24) { label = 13; break; } else { label = 14; break; }
    case 13: 
      var $26=$n;
      var $27=$t_addr;
      var $node=(($27+16)|0);
      var $28=HEAP32[(($node)>>2)];
      var $arrayidx=(($28)|0);
      var $sub_ptr_lhs_cast=$26;
      var $sub_ptr_rhs_cast=$arrayidx;
      var $sub_ptr_sub=((($sub_ptr_lhs_cast)-($sub_ptr_rhs_cast))|0);
      var $sub_ptr_div=((((($sub_ptr_sub)|0))/(28))&-1);
      $i=$sub_ptr_div;
      var $29=$i;
      var $30=$t_addr;
      var $sizearray26=(($30+28)|0);
      var $31=HEAP32[(($sizearray26)>>2)];
      var $add=((($29)+($31))|0);
      $retval=$add;
      label = 18; break;
    case 14: 
      var $32=$n;
      var $i_key28=(($32+12)|0);
      var $nk=$i_key28;
      var $next=(($nk+12)|0);
      var $33=HEAP32[(($next)>>2)];
      $n=$33;
      label = 15; break;
    case 15: 
      var $34=$n;
      var $cmp30=(($34)|0)==0;
      if ($cmp30) { label = 16; break; } else { label = 17; break; }
    case 16: 
      var $35=$L_addr;
      _luaG_runerror($35, ((5245312)|0), (tempInt=STACKTOP,_memset(STACKTOP, 0, 1),STACKTOP = (STACKTOP + 1)|0,STACKTOP = ((((STACKTOP)+3)>>2)<<2),HEAP32[((tempInt)>>2)]=0,tempInt));

    case 17: 
      label = 8; break;
    case 18: 
      var $36=$retval;
      STACKTOP = __stackBase__;
      Module.print(INDENT + 'Exiting: _findindex');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return $36;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_findindex["X"]=1;

function _luaH_resize($L, $t, $nasize, $nhsize) {
  var label = 0;

  Module.print(INDENT + ' Entering: _luaH_resize: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $L_addr;
      var $t_addr;
      var $nasize_addr;
      var $nhsize_addr;
      var $i;
      var $oldasize;
      var $oldhsize;
      var $nold;
      var $old;
      var $io2;
      var $io1;
      $L_addr=$L;
      $t_addr=$t;
      $nasize_addr=$nasize;
      $nhsize_addr=$nhsize;
      var $0=$t_addr;
      var $sizearray=(($0+28)|0);
      var $1=HEAP32[(($sizearray)>>2)];
      $oldasize=$1;
      var $2=$t_addr;
      var $lsizenode=(($2+7)|0);
      var $3=HEAP8[($lsizenode)];
      var $conv=(($3)&255);
      $oldhsize=$conv;
      var $4=$t_addr;
      var $node=(($4+16)|0);
      var $5=HEAP32[(($node)>>2)];
      $nold=$5;
      var $6=$nasize_addr;
      var $7=$oldasize;
      var $cmp=(($6)|0) > (($7)|0);
      if ($cmp) { label = 3; break; } else { label = 4; break; }
    case 3: 
      var $8=$L_addr;
      var $9=$t_addr;
      var $10=$nasize_addr;
      _setarrayvector($8, $9, $10);
      label = 4; break;
    case 4: 
      var $11=$L_addr;
      var $12=$t_addr;
      var $13=$nhsize_addr;
      _setnodevector($11, $12, $13);
      var $14=$nasize_addr;
      var $15=$oldasize;
      var $cmp2=(($14)|0) < (($15)|0);
      if ($cmp2) { label = 5; break; } else { label = 15; break; }
    case 5: 
      var $16=$nasize_addr;
      var $17=$t_addr;
      var $sizearray5=(($17+28)|0);
      HEAP32[(($sizearray5)>>2)]=$16;
      var $18=$nasize_addr;
      $i=$18;
      label = 6; break;
    case 6: 
      var $19=$i;
      var $20=$oldasize;
      var $cmp6=(($19)|0) < (($20)|0);
      if ($cmp6) { label = 7; break; } else { label = 11; break; }
    case 7: 
      var $21=$i;
      var $22=$t_addr;
      var $array=(($22+12)|0);
      var $23=HEAP32[(($array)>>2)];
      var $arrayidx=(($23+((($21)*(12))&-1))|0);
      var $tt_=(($arrayidx+8)|0);
      var $24=HEAP32[(($tt_)>>2)];
      var $cmp8=(($24)|0)==0;
      if ($cmp8) { label = 9; break; } else { label = 8; break; }
    case 8: 
      var $25=$L_addr;
      var $26=$t_addr;
      var $27=$i;
      var $add=((($27)+(1))|0);
      var $28=$i;
      var $29=$t_addr;
      var $array11=(($29+12)|0);
      var $30=HEAP32[(($array11)>>2)];
      var $arrayidx12=(($30+((($28)*(12))&-1))|0);
      _luaH_setint($25, $26, $add, $arrayidx12);
      label = 9; break;
    case 9: 
      label = 10; break;
    case 10: 
      var $31=$i;
      var $inc=((($31)+(1))|0);
      $i=$inc;
      label = 6; break;
    case 11: 
      var $32=$nasize_addr;
      var $add14=((($32)+(1))|0);
      var $cmp15=(($add14)>>>0) > 357913941;
      if ($cmp15) { label = 12; break; } else { label = 13; break; }
    case 12: 
      var $33=$L_addr;
      _luaM_toobig($33);

      label = 14; break;
    case 13: 
      var $35=$L_addr;
      var $36=$t_addr;
      var $array17=(($36+12)|0);
      var $37=HEAP32[(($array17)>>2)];
      var $38=$37;
      var $39=$oldasize;
      var $mul=((($39)*(12))&-1);
      var $40=$nasize_addr;
      var $mul18=((($40)*(12))&-1);
      var $call=_luaM_realloc_($35, $38, $mul, $mul18);
      var $cond = $call;label = 14; break;
    case 14: 
      var $cond;
      var $41=$cond;
      var $42=$t_addr;
      var $array19=(($42+12)|0);
      HEAP32[(($array19)>>2)]=$41;
      label = 15; break;
    case 15: 
      var $43=$oldhsize;
      var $shl=1 << $43;
      var $sub=((($shl)-(1))|0);
      $i=$sub;
      label = 16; break;
    case 16: 
      var $44=$i;
      var $cmp22=(($44)|0) >= 0;
      if ($cmp22) { label = 17; break; } else { label = 21; break; }
    case 17: 
      var $45=$nold;
      var $46=$i;
      var $add_ptr=(($45+((($46)*(28))&-1))|0);
      $old=$add_ptr;
      var $47=$old;
      var $i_val=(($47)|0);
      var $tt_25=(($i_val+8)|0);
      var $48=HEAP32[(($tt_25)>>2)];
      var $cmp26=(($48)|0)==0;
      if ($cmp26) { label = 19; break; } else { label = 18; break; }
    case 18: 
      var $49=$old;
      var $i_val29=(($49)|0);
      $io2=$i_val29;
      var $50=$L_addr;
      var $51=$t_addr;
      var $52=$old;
      var $i_key=(($52+12)|0);
      var $tvk=$i_key;
      var $call30=_luaH_set($50, $51, $tvk);
      $io1=$call30;
      var $53=$io1;
      var $value_=(($53)|0);
      var $54=$io2;
      var $value_31=(($54)|0);
      var $55=$value_;
      var $56=$value_31;
      HEAP32[(($55)>>2)]=HEAP32[(($56)>>2)];HEAP32[((($55)+(4))>>2)]=HEAP32[((($56)+(4))>>2)];
      var $57=$io2;
      var $tt_32=(($57+8)|0);
      var $58=HEAP32[(($tt_32)>>2)];
      var $59=$io1;
      var $tt_33=(($59+8)|0);
      HEAP32[(($tt_33)>>2)]=$58;
      label = 19; break;
    case 19: 
      label = 20; break;
    case 20: 
      var $60=$i;
      var $dec=((($60)-(1))|0);
      $i=$dec;
      label = 16; break;
    case 21: 
      var $61=$nold;
      var $cmp37=(($61)|0)==5244060;
      if ($cmp37) { label = 23; break; } else { label = 22; break; }
    case 22: 
      var $62=$L_addr;
      var $63=$nold;
      var $64=$63;
      var $65=$oldhsize;
      var $shl40=1 << $65;
      var $mul41=((($shl40)*(28))&-1);
      var $call42=_luaM_realloc_($62, $64, $mul41, 0);
      label = 23; break;
    case 23: 

      Module.print(INDENT + 'Exiting: _luaH_resize');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_luaH_resize["X"]=1;

function _setarrayvector($L, $t, $size) {
  var label = 0;

  Module.print(INDENT + ' Entering: _setarrayvector: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $L_addr;
      var $t_addr;
      var $size_addr;
      var $i;
      $L_addr=$L;
      $t_addr=$t;
      $size_addr=$size;
      var $0=$size_addr;
      var $add=((($0)+(1))|0);
      var $cmp=(($add)>>>0) > 357913941;
      if ($cmp) { label = 3; break; } else { label = 4; break; }
    case 3: 
      var $1=$L_addr;
      _luaM_toobig($1);

      label = 5; break;
    case 4: 
      var $3=$L_addr;
      var $4=$t_addr;
      var $array=(($4+12)|0);
      var $5=HEAP32[(($array)>>2)];
      var $6=$5;
      var $7=$t_addr;
      var $sizearray=(($7+28)|0);
      var $8=HEAP32[(($sizearray)>>2)];
      var $mul=((($8)*(12))&-1);
      var $9=$size_addr;
      var $mul1=((($9)*(12))&-1);
      var $call=_luaM_realloc_($3, $6, $mul, $mul1);
      var $cond = $call;label = 5; break;
    case 5: 
      var $cond;
      var $10=$cond;
      var $11=$t_addr;
      var $array2=(($11+12)|0);
      HEAP32[(($array2)>>2)]=$10;
      var $12=$t_addr;
      var $sizearray3=(($12+28)|0);
      var $13=HEAP32[(($sizearray3)>>2)];
      $i=$13;
      label = 6; break;
    case 6: 
      var $14=$i;
      var $15=$size_addr;
      var $cmp4=(($14)|0) < (($15)|0);
      if ($cmp4) { label = 7; break; } else { label = 9; break; }
    case 7: 
      var $16=$i;
      var $17=$t_addr;
      var $array5=(($17+12)|0);
      var $18=HEAP32[(($array5)>>2)];
      var $arrayidx=(($18+((($16)*(12))&-1))|0);
      var $tt_=(($arrayidx+8)|0);
      HEAP32[(($tt_)>>2)]=0;
      label = 8; break;
    case 8: 
      var $19=$i;
      var $inc=((($19)+(1))|0);
      $i=$inc;
      label = 6; break;
    case 9: 
      var $20=$size_addr;
      var $21=$t_addr;
      var $sizearray6=(($21+28)|0);
      HEAP32[(($sizearray6)>>2)]=$20;

      Module.print(INDENT + 'Exiting: _setarrayvector');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_setarrayvector["X"]=1;

function _setnodevector($L, $t, $size) {
  var label = 0;
  var __stackBase__  = STACKTOP; _memset(__stackBase__, 0, 0);
  Module.print(INDENT + ' Entering: _setnodevector: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $L_addr;
      var $t_addr;
      var $size_addr;
      var $lsize;
      var $i;
      var $n;
      $L_addr=$L;
      $t_addr=$t;
      $size_addr=$size;
      var $0=$size_addr;
      var $cmp=(($0)|0)==0;
      if ($cmp) { label = 3; break; } else { label = 4; break; }
    case 3: 
      var $1=$t_addr;
      var $node=(($1+16)|0);
      HEAP32[(($node)>>2)]=5244060;
      $lsize=0;
      label = 14; break;
    case 4: 
      var $2=$size_addr;
      var $call=_luaO_ceillog2($2);
      $lsize=$call;
      var $3=$lsize;
      var $cmp1=(($3)|0) > 30;
      if ($cmp1) { label = 5; break; } else { label = 6; break; }
    case 5: 
      var $4=$L_addr;
      _luaG_runerror($4, ((5245848)|0), (tempInt=STACKTOP,_memset(STACKTOP, 0, 1),STACKTOP = (STACKTOP + 1)|0,STACKTOP = ((((STACKTOP)+3)>>2)<<2),HEAP32[((tempInt)>>2)]=0,tempInt));

    case 6: 
      var $5=$lsize;
      var $shl=1 << $5;
      $size_addr=$shl;
      var $6=$size_addr;
      var $add=((($6)+(1))|0);
      var $cmp3=(($add)>>>0) > 153391689;
      if ($cmp3) { label = 7; break; } else { label = 8; break; }
    case 7: 
      var $7=$L_addr;
      _luaM_toobig($7);

      label = 9; break;
    case 8: 
      var $9=$L_addr;
      var $10=$size_addr;
      var $mul=((($10)*(28))&-1);
      var $call4=_luaM_realloc_($9, 0, 0, $mul);
      var $cond = $call4;label = 9; break;
    case 9: 
      var $cond;
      var $11=$cond;
      var $12=$t_addr;
      var $node5=(($12+16)|0);
      HEAP32[(($node5)>>2)]=$11;
      $i=0;
      label = 10; break;
    case 10: 
      var $13=$i;
      var $14=$size_addr;
      var $cmp6=(($13)|0) < (($14)|0);
      if ($cmp6) { label = 11; break; } else { label = 13; break; }
    case 11: 
      var $15=$i;
      var $16=$t_addr;
      var $node7=(($16+16)|0);
      var $17=HEAP32[(($node7)>>2)];
      var $arrayidx=(($17+((($15)*(28))&-1))|0);
      $n=$arrayidx;
      var $18=$n;
      var $i_key=(($18+12)|0);
      var $nk=$i_key;
      var $next=(($nk+12)|0);
      HEAP32[(($next)>>2)]=0;
      var $19=$n;
      var $i_key8=(($19+12)|0);
      var $tvk=$i_key8;
      var $tt_=(($tvk+8)|0);
      HEAP32[(($tt_)>>2)]=0;
      var $20=$n;
      var $i_val=(($20)|0);
      var $tt_9=(($i_val+8)|0);
      HEAP32[(($tt_9)>>2)]=0;
      label = 12; break;
    case 12: 
      var $21=$i;
      var $inc=((($21)+(1))|0);
      $i=$inc;
      label = 10; break;
    case 13: 
      label = 14; break;
    case 14: 
      var $22=$lsize;
      var $conv=(($22) & 255);
      var $23=$t_addr;
      var $lsizenode=(($23+7)|0);
      HEAP8[($lsizenode)]=$conv;
      var $24=$size_addr;
      var $25=$t_addr;
      var $node11=(($25+16)|0);
      var $26=HEAP32[(($node11)>>2)];
      var $arrayidx12=(($26+((($24)*(28))&-1))|0);
      var $27=$t_addr;
      var $lastfree=(($27+20)|0);
      HEAP32[(($lastfree)>>2)]=$arrayidx12;
      STACKTOP = __stackBase__;
      Module.print(INDENT + 'Exiting: _setnodevector');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_setnodevector["X"]=1;

function _getfreepos($t) {
  var label = 0;

  Module.print(INDENT + ' Entering: _getfreepos: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $retval;
      var $t_addr;
      $t_addr=$t;
      label = 3; break;
    case 3: 
      var $0=$t_addr;
      var $lastfree=(($0+20)|0);
      var $1=HEAP32[(($lastfree)>>2)];
      var $2=$t_addr;
      var $node=(($2+16)|0);
      var $3=HEAP32[(($node)>>2)];
      var $cmp=(($1)>>>0) > (($3)>>>0);
      if ($cmp) { label = 4; break; } else { label = 7; break; }
    case 4: 
      var $4=$t_addr;
      var $lastfree1=(($4+20)|0);
      var $5=HEAP32[(($lastfree1)>>2)];
      var $incdec_ptr=((($5)-(28))|0);
      HEAP32[(($lastfree1)>>2)]=$incdec_ptr;
      var $6=$t_addr;
      var $lastfree2=(($6+20)|0);
      var $7=HEAP32[(($lastfree2)>>2)];
      var $i_key=(($7+12)|0);
      var $tvk=$i_key;
      var $tt_=(($tvk+8)|0);
      var $8=HEAP32[(($tt_)>>2)];
      var $cmp3=(($8)|0)==0;
      if ($cmp3) { label = 5; break; } else { label = 6; break; }
    case 5: 
      var $9=$t_addr;
      var $lastfree4=(($9+20)|0);
      var $10=HEAP32[(($lastfree4)>>2)];
      $retval=$10;
      label = 8; break;
    case 6: 
      label = 3; break;
    case 7: 
      $retval=0;
      label = 8; break;
    case 8: 
      var $11=$retval;

      Module.print(INDENT + 'Exiting: _getfreepos');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return $11;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _hashnum($t, $n) {
  var label = 0;
  var __stackBase__  = STACKTOP; STACKTOP = (STACKTOP + 8)|0; _memset(__stackBase__, 0, 8);
  Module.print(INDENT + ' Entering: _hashnum: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $t_addr;
      var $n_addr;
      var $i;
      var $u=__stackBase__;
      $t_addr=$t;
      $n_addr=$n;
      var $0=$n_addr;
      var $add=($0)+(1);
      var $l_d=$u;
      (HEAPF64[(tempDoublePtr)>>3]=$add,HEAP32[(($l_d)>>2)]=HEAP32[((tempDoublePtr)>>2)],HEAP32[((($l_d)+(4))>>2)]=HEAP32[(((tempDoublePtr)+(4))>>2)]);
      var $l_p=$u;
      var $arrayidx=(($l_p)|0);
      var $1=HEAP32[(($arrayidx)>>2)];
      $i=$1;
      var $l_p1=$u;
      var $arrayidx2=(($l_p1+4)|0);
      var $2=HEAP32[(($arrayidx2)>>2)];
      var $3=$i;
      var $add3=((($3)+($2))|0);
      $i=$add3;
      var $4=$i;
      var $cmp=(($4)|0) < 0;
      if ($cmp) { label = 3; break; } else { label = 6; break; }
    case 3: 
      var $5=$i;
      var $6=$i;
      var $sub=(((-$6))|0);
      var $cmp4=(($5)|0)==(($sub)|0);
      if ($cmp4) { label = 4; break; } else { label = 5; break; }
    case 4: 
      $i=0;
      label = 5; break;
    case 5: 
      var $7=$i;
      var $sub6=(((-$7))|0);
      $i=$sub6;
      label = 6; break;
    case 6: 
      var $8=$i;
      var $9=$t_addr;
      var $lsizenode=(($9+7)|0);
      var $10=HEAP8[($lsizenode)];
      var $conv=(($10)&255);
      var $shl=1 << $conv;
      var $sub8=((($shl)-(1))|0);
      var $or=$sub8 | 1;
      var $rem=((($8)|0))%((($or)|0));
      var $11=$t_addr;
      var $node=(($11+16)|0);
      var $12=HEAP32[(($node)>>2)];
      var $arrayidx9=(($12+((($rem)*(28))&-1))|0);
      STACKTOP = __stackBase__;
      Module.print(INDENT + 'Exiting: _hashnum');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return $arrayidx9;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _luaH_getstr($t, $key) {
  var label = 0;

  Module.print(INDENT + ' Entering: _luaH_getstr: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $retval;
      var $t_addr;
      var $key_addr;
      var $n;
      $t_addr=$t;
      $key_addr=$key;
      var $0=$key_addr;
      var $tsv=$0;
      var $hash=(($tsv+8)|0);
      var $1=HEAP32[(($hash)>>2)];
      var $2=$t_addr;
      var $lsizenode=(($2+7)|0);
      var $3=HEAP8[($lsizenode)];
      var $conv=(($3)&255);
      var $shl=1 << $conv;
      var $sub=((($shl)-(1))|0);
      var $and=$1 & $sub;
      var $4=$t_addr;
      var $node=(($4+16)|0);
      var $5=HEAP32[(($node)>>2)];
      var $arrayidx=(($5+((($and)*(28))&-1))|0);
      $n=$arrayidx;
      label = 3; break;
    case 3: 
      var $6=$n;
      var $i_key=(($6+12)|0);
      var $tvk=$i_key;
      var $tt_=(($tvk+8)|0);
      var $7=HEAP32[(($tt_)>>2)];
      var $cmp=(($7)|0)==68;
      if ($cmp) { label = 4; break; } else { label = 6; break; }
    case 4: 
      var $8=$n;
      var $i_key2=(($8+12)|0);
      var $tvk3=$i_key2;
      var $value_=(($tvk3)|0);
      var $gc=$value_;
      var $9=HEAP32[(($gc)>>2)];
      var $ts=$9;
      var $10=$key_addr;
      var $cmp4=(($ts)|0)==(($10)|0);
      if ($cmp4) { label = 5; break; } else { label = 6; break; }
    case 5: 
      var $11=$n;
      var $i_val=(($11)|0);
      $retval=$i_val;
      label = 10; break;
    case 6: 
      var $12=$n;
      var $i_key6=(($12+12)|0);
      var $nk=$i_key6;
      var $next=(($nk+12)|0);
      var $13=HEAP32[(($next)>>2)];
      $n=$13;
      label = 7; break;
    case 7: 
      label = 8; break;
    case 8: 
      var $14=$n;
      var $tobool=(($14)|0)!=0;
      if ($tobool) { label = 3; break; } else { label = 9; break; }
    case 9: 
      $retval=5243784;
      label = 10; break;
    case 10: 
      var $15=$retval;

      Module.print(INDENT + 'Exiting: _luaH_getstr');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return $15;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_luaH_getstr["X"]=1;

function _mainposition($t, $key) {
  var label = 0;

  Module.print(INDENT + ' Entering: _mainposition: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $retval;
      var $t_addr;
      var $key_addr;
      var $s;
      $t_addr=$t;
      $key_addr=$key;
      var $0=$key_addr;
      var $tt_=(($0+8)|0);
      var $1=HEAP32[(($tt_)>>2)];
      var $and=$1 & 63;
      if ((($and)|0)==3) {
        label = 3; break;
      }
      else if ((($and)|0)==20) {
        label = 4; break;
      }
      else if ((($and)|0)==4) {
        label = 7; break;
      }
      else if ((($and)|0)==1) {
        label = 8; break;
      }
      else if ((($and)|0)==2) {
        label = 9; break;
      }
      else if ((($and)|0)==22) {
        label = 10; break;
      }
      else {
      label = 11; break;
      }
      
    case 3: 
      var $2=$t_addr;
      var $3=$key_addr;
      var $value_=(($3)|0);
      var $n=$value_;
      var $4=(HEAP32[((tempDoublePtr)>>2)]=HEAP32[(($n)>>2)],HEAP32[(((tempDoublePtr)+(4))>>2)]=HEAP32[((($n)+(4))>>2)],HEAPF64[(tempDoublePtr)>>3]);
      var $call=_hashnum($2, $4);
      $retval=$call;
      label = 12; break;
    case 4: 
      var $5=$key_addr;
      var $value_2=(($5)|0);
      var $gc=$value_2;
      var $6=HEAP32[(($gc)>>2)];
      var $ts=$6;
      $s=$ts;
      var $7=$s;
      var $tsv=$7;
      var $extra=(($tsv+6)|0);
      var $8=HEAP8[($extra)];
      var $conv=(($8)&255);
      var $cmp=(($conv)|0)==0;
      if ($cmp) { label = 5; break; } else { label = 6; break; }
    case 5: 
      var $9=$s;
      var $add_ptr=(($9+16)|0);
      var $10=$add_ptr;
      var $11=$s;
      var $tsv4=$11;
      var $len=(($tsv4+12)|0);
      var $12=HEAP32[(($len)>>2)];
      var $13=$s;
      var $tsv5=$13;
      var $hash=(($tsv5+8)|0);
      var $14=HEAP32[(($hash)>>2)];
      var $call6=_luaS_hash($10, $12, $14);
      var $15=$s;
      var $tsv7=$15;
      var $hash8=(($tsv7+8)|0);
      HEAP32[(($hash8)>>2)]=$call6;
      var $16=$s;
      var $tsv9=$16;
      var $extra10=(($tsv9+6)|0);
      HEAP8[($extra10)]=1;
      label = 6; break;
    case 6: 
      var $17=$key_addr;
      var $value_11=(($17)|0);
      var $gc12=$value_11;
      var $18=HEAP32[(($gc12)>>2)];
      var $ts13=$18;
      var $tsv14=$ts13;
      var $hash15=(($tsv14+8)|0);
      var $19=HEAP32[(($hash15)>>2)];
      var $20=$t_addr;
      var $lsizenode=(($20+7)|0);
      var $21=HEAP8[($lsizenode)];
      var $conv16=(($21)&255);
      var $shl=1 << $conv16;
      var $sub=((($shl)-(1))|0);
      var $and17=$19 & $sub;
      var $22=$t_addr;
      var $node=(($22+16)|0);
      var $23=HEAP32[(($node)>>2)];
      var $arrayidx=(($23+((($and17)*(28))&-1))|0);
      $retval=$arrayidx;
      label = 12; break;
    case 7: 
      var $24=$key_addr;
      var $value_19=(($24)|0);
      var $gc20=$value_19;
      var $25=HEAP32[(($gc20)>>2)];
      var $ts21=$25;
      var $tsv22=$ts21;
      var $hash23=(($tsv22+8)|0);
      var $26=HEAP32[(($hash23)>>2)];
      var $27=$t_addr;
      var $lsizenode24=(($27+7)|0);
      var $28=HEAP8[($lsizenode24)];
      var $conv25=(($28)&255);
      var $shl26=1 << $conv25;
      var $sub27=((($shl26)-(1))|0);
      var $and28=$26 & $sub27;
      var $29=$t_addr;
      var $node29=(($29+16)|0);
      var $30=HEAP32[(($node29)>>2)];
      var $arrayidx30=(($30+((($and28)*(28))&-1))|0);
      $retval=$arrayidx30;
      label = 12; break;
    case 8: 
      var $31=$key_addr;
      var $value_32=(($31)|0);
      var $b=$value_32;
      var $32=HEAP32[(($b)>>2)];
      var $33=$t_addr;
      var $lsizenode33=(($33+7)|0);
      var $34=HEAP8[($lsizenode33)];
      var $conv34=(($34)&255);
      var $shl35=1 << $conv34;
      var $sub36=((($shl35)-(1))|0);
      var $and37=$32 & $sub36;
      var $35=$t_addr;
      var $node38=(($35+16)|0);
      var $36=HEAP32[(($node38)>>2)];
      var $arrayidx39=(($36+((($and37)*(28))&-1))|0);
      $retval=$arrayidx39;
      label = 12; break;
    case 9: 
      var $37=$key_addr;
      var $value_41=(($37)|0);
      var $p=$value_41;
      var $38=HEAP32[(($p)>>2)];
      var $39=$38;
      var $40=$t_addr;
      var $lsizenode42=(($40+7)|0);
      var $41=HEAP8[($lsizenode42)];
      var $conv43=(($41)&255);
      var $shl44=1 << $conv43;
      var $sub45=((($shl44)-(1))|0);
      var $or=$sub45 | 1;
      var $rem=((($39)>>>0))%((($or)>>>0));
      var $42=$t_addr;
      var $node46=(($42+16)|0);
      var $43=HEAP32[(($node46)>>2)];
      var $arrayidx47=(($43+((($rem)*(28))&-1))|0);
      $retval=$arrayidx47;
      label = 12; break;
    case 10: 
      var $44=$key_addr;
      var $value_49=(($44)|0);
      var $f=$value_49;
      var $45=HEAP32[(($f)>>2)];
      var $46=$45;
      var $47=$t_addr;
      var $lsizenode50=(($47+7)|0);
      var $48=HEAP8[($lsizenode50)];
      var $conv51=(($48)&255);
      var $shl52=1 << $conv51;
      var $sub53=((($shl52)-(1))|0);
      var $or54=$sub53 | 1;
      var $rem55=((($46)>>>0))%((($or54)>>>0));
      var $49=$t_addr;
      var $node56=(($49+16)|0);
      var $50=HEAP32[(($node56)>>2)];
      var $arrayidx57=(($50+((($rem55)*(28))&-1))|0);
      $retval=$arrayidx57;
      label = 12; break;
    case 11: 
      var $51=$key_addr;
      var $value_58=(($51)|0);
      var $gc59=$value_58;
      var $52=HEAP32[(($gc59)>>2)];
      var $53=$52;
      var $54=$t_addr;
      var $lsizenode60=(($54+7)|0);
      var $55=HEAP8[($lsizenode60)];
      var $conv61=(($55)&255);
      var $shl62=1 << $conv61;
      var $sub63=((($shl62)-(1))|0);
      var $or64=$sub63 | 1;
      var $rem65=((($53)>>>0))%((($or64)>>>0));
      var $56=$t_addr;
      var $node66=(($56+16)|0);
      var $57=HEAP32[(($node66)>>2)];
      var $arrayidx67=(($57+((($rem65)*(28))&-1))|0);
      $retval=$arrayidx67;
      label = 12; break;
    case 12: 
      var $58=$retval;

      Module.print(INDENT + 'Exiting: _mainposition');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return $58;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_mainposition["X"]=1;

function _rehash($L, $t, $ek) {
  var label = 0;
  var __stackBase__  = STACKTOP; STACKTOP = (STACKTOP + 128)|0; _memset(__stackBase__, 0, 128);
  Module.print(INDENT + ' Entering: _rehash: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $L_addr;
      var $t_addr;
      var $ek_addr;
      var $nasize=__stackBase__;
      var $na;
      var $nums=(__stackBase__)+(4);
      var $i;
      var $totaluse;
      $L_addr=$L;
      $t_addr=$t;
      $ek_addr=$ek;
      $i=0;
      label = 3; break;
    case 3: 
      var $0=$i;
      var $cmp=(($0)|0) <= 30;
      if ($cmp) { label = 4; break; } else { label = 6; break; }
    case 4: 
      var $1=$i;
      var $arrayidx=(($nums+($1<<2))|0);
      HEAP32[(($arrayidx)>>2)]=0;
      label = 5; break;
    case 5: 
      var $2=$i;
      var $inc=((($2)+(1))|0);
      $i=$inc;
      label = 3; break;
    case 6: 
      var $3=$t_addr;
      var $arraydecay=(($nums)|0);
      var $call=_numusearray($3, $arraydecay);
      HEAP32[(($nasize)>>2)]=$call;
      var $4=HEAP32[(($nasize)>>2)];
      $totaluse=$4;
      var $5=$t_addr;
      var $arraydecay1=(($nums)|0);
      var $call2=_numusehash($5, $arraydecay1, $nasize);
      var $6=$totaluse;
      var $add=((($6)+($call2))|0);
      $totaluse=$add;
      var $7=$ek_addr;
      var $arraydecay3=(($nums)|0);
      var $call4=_countint($7, $arraydecay3);
      var $8=HEAP32[(($nasize)>>2)];
      var $add5=((($8)+($call4))|0);
      HEAP32[(($nasize)>>2)]=$add5;
      var $9=$totaluse;
      var $inc6=((($9)+(1))|0);
      $totaluse=$inc6;
      var $arraydecay7=(($nums)|0);
      var $call8=_computesizes($arraydecay7, $nasize);
      $na=$call8;
      var $10=$L_addr;
      var $11=$t_addr;
      var $12=HEAP32[(($nasize)>>2)];
      var $13=$totaluse;
      var $14=$na;
      var $sub=((($13)-($14))|0);
      _luaH_resize($10, $11, $12, $sub);
      STACKTOP = __stackBase__;
      Module.print(INDENT + 'Exiting: _rehash');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_rehash["X"]=1;

function _luaH_getint($t, $key) {
  var label = 0;

  Module.print(INDENT + ' Entering: _luaH_getint: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $retval;
      var $t_addr;
      var $key_addr;
      var $nk;
      var $n;
      $t_addr=$t;
      $key_addr=$key;
      var $0=$key_addr;
      var $sub=((($0)-(1))|0);
      var $1=$t_addr;
      var $sizearray=(($1+28)|0);
      var $2=HEAP32[(($sizearray)>>2)];
      var $cmp=(($sub)>>>0) < (($2)>>>0);
      if ($cmp) { label = 3; break; } else { label = 4; break; }
    case 3: 
      var $3=$key_addr;
      var $sub1=((($3)-(1))|0);
      var $4=$t_addr;
      var $array=(($4+12)|0);
      var $5=HEAP32[(($array)>>2)];
      var $arrayidx=(($5+((($sub1)*(12))&-1))|0);
      $retval=$arrayidx;
      label = 12; break;
    case 4: 
      var $6=$key_addr;
      var $conv=(($6)|0);
      $nk=$conv;
      var $7=$t_addr;
      var $8=$nk;
      var $call=_hashnum($7, $8);
      $n=$call;
      label = 5; break;
    case 5: 
      var $9=$n;
      var $i_key=(($9+12)|0);
      var $tvk=$i_key;
      var $tt_=(($tvk+8)|0);
      var $10=HEAP32[(($tt_)>>2)];
      var $cmp2=(($10)|0)==3;
      if ($cmp2) { label = 6; break; } else { label = 8; break; }
    case 6: 
      var $11=$n;
      var $i_key4=(($11+12)|0);
      var $tvk5=$i_key4;
      var $value_=(($tvk5)|0);
      var $n6=$value_;
      var $12=(HEAP32[((tempDoublePtr)>>2)]=HEAP32[(($n6)>>2)],HEAP32[(((tempDoublePtr)+(4))>>2)]=HEAP32[((($n6)+(4))>>2)],HEAPF64[(tempDoublePtr)>>3]);
      var $13=$nk;
      var $cmp7=$12 == $13;
      if ($cmp7) { label = 7; break; } else { label = 8; break; }
    case 7: 
      var $14=$n;
      var $i_val=(($14)|0);
      $retval=$i_val;
      label = 12; break;
    case 8: 
      var $15=$n;
      var $i_key11=(($15+12)|0);
      var $nk12=$i_key11;
      var $next=(($nk12+12)|0);
      var $16=HEAP32[(($next)>>2)];
      $n=$16;
      label = 9; break;
    case 9: 
      label = 10; break;
    case 10: 
      var $17=$n;
      var $tobool=(($17)|0)!=0;
      if ($tobool) { label = 5; break; } else { label = 11; break; }
    case 11: 
      $retval=5243784;
      label = 12; break;
    case 12: 
      var $18=$retval;

      Module.print(INDENT + 'Exiting: _luaH_getint');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return $18;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_luaH_getint["X"]=1;

function _luaH_get($t, $key) {
  var label = 0;
  var __stackBase__  = STACKTOP; STACKTOP = (STACKTOP + 8)|0; _memset(__stackBase__, 0, 8);
  Module.print(INDENT + ' Entering: _luaH_get: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $retval;
      var $t_addr;
      var $key_addr;
      var $k;
      var $n;
      var $u=__stackBase__;
      var $n11;
      $t_addr=$t;
      $key_addr=$key;
      var $0=$key_addr;
      var $tt_=(($0+8)|0);
      var $1=HEAP32[(($tt_)>>2)];
      var $and=$1 & 63;
      if ((($and)|0)==0) {
        label = 3; break;
      }
      else if ((($and)|0)==4) {
        label = 4; break;
      }
      else if ((($and)|0)==3) {
        label = 5; break;
      }
      else {
      label = 8; break;
      }
      
    case 3: 
      $retval=5243784;
      label = 16; break;
    case 4: 
      var $2=$t_addr;
      var $3=$key_addr;
      var $value_=(($3)|0);
      var $gc=$value_;
      var $4=HEAP32[(($gc)>>2)];
      var $ts=$4;
      var $call=_luaH_getstr($2, $ts);
      $retval=$call;
      label = 16; break;
    case 5: 
      var $5=$key_addr;
      var $value_3=(($5)|0);
      var $n4=$value_3;
      var $6=(HEAP32[((tempDoublePtr)>>2)]=HEAP32[(($n4)>>2)],HEAP32[(((tempDoublePtr)+(4))>>2)]=HEAP32[((($n4)+(4))>>2)],HEAPF64[(tempDoublePtr)>>3]);
      $n=$6;
      var $7=$n;
      var $add=($7)+(6755399441055744);
      var $l_d=$u;
      (HEAPF64[(tempDoublePtr)>>3]=$add,HEAP32[(($l_d)>>2)]=HEAP32[((tempDoublePtr)>>2)],HEAP32[((($l_d)+(4))>>2)]=HEAP32[(((tempDoublePtr)+(4))>>2)]);
      var $8=HEAP32[((((5244056)|0))>>2)];
      var $cmp=(($8)|0)==33;
      var $conv=(($cmp)&1);
      var $l_p=$u;
      var $arrayidx=(($l_p+($conv<<2))|0);
      var $9=HEAP32[(($arrayidx)>>2)];
      $k=$9;
      var $10=$k;
      var $conv5=(($10)|0);
      var $11=$key_addr;
      var $value_6=(($11)|0);
      var $n7=$value_6;
      var $12=(HEAP32[((tempDoublePtr)>>2)]=HEAP32[(($n7)>>2)],HEAP32[(((tempDoublePtr)+(4))>>2)]=HEAP32[((($n7)+(4))>>2)],HEAPF64[(tempDoublePtr)>>3]);
      var $cmp8=$conv5 == $12;
      if ($cmp8) { label = 6; break; } else { label = 7; break; }
    case 6: 
      var $13=$t_addr;
      var $14=$k;
      var $call10=_luaH_getint($13, $14);
      $retval=$call10;
      label = 16; break;
    case 7: 
      label = 8; break;
    case 8: 
      var $15=$t_addr;
      var $16=$key_addr;
      var $call12=_mainposition($15, $16);
      $n11=$call12;
      label = 9; break;
    case 9: 
      var $17=$n11;
      var $i_key=(($17+12)|0);
      var $tvk=$i_key;
      var $tt_13=(($tvk+8)|0);
      var $18=HEAP32[(($tt_13)>>2)];
      var $19=$key_addr;
      var $tt_14=(($19+8)|0);
      var $20=HEAP32[(($tt_14)>>2)];
      var $cmp15=(($18)|0)==(($20)|0);
      if ($cmp15) { label = 10; break; } else { label = 12; break; }
    case 10: 
      var $21=$n11;
      var $i_key17=(($21+12)|0);
      var $tvk18=$i_key17;
      var $22=$key_addr;
      var $call19=_luaV_equalobj_(0, $tvk18, $22);
      var $tobool=(($call19)|0)!=0;
      if ($tobool) { label = 11; break; } else { label = 12; break; }
    case 11: 
      var $23=$n11;
      var $i_val=(($23)|0);
      $retval=$i_val;
      label = 16; break;
    case 12: 
      var $24=$n11;
      var $i_key21=(($24+12)|0);
      var $nk=$i_key21;
      var $next=(($nk+12)|0);
      var $25=HEAP32[(($next)>>2)];
      $n11=$25;
      label = 13; break;
    case 13: 
      label = 14; break;
    case 14: 
      var $26=$n11;
      var $tobool23=(($26)|0)!=0;
      if ($tobool23) { label = 9; break; } else { label = 15; break; }
    case 15: 
      $retval=5243784;
      label = 16; break;
    case 16: 
      var $27=$retval;
      STACKTOP = __stackBase__;
      Module.print(INDENT + 'Exiting: _luaH_get');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return $27;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_luaH_get["X"]=1;

function _luaH_newkey($L, $t, $key) {
  var label = 0;
  var __stackBase__  = STACKTOP; _memset(__stackBase__, 0, 0);
  Module.print(INDENT + ' Entering: _luaH_newkey: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $retval;
      var $L_addr;
      var $t_addr;
      var $key_addr;
      var $mp;
      var $othern;
      var $n12;
      var $io2;
      var $io1;
      $L_addr=$L;
      $t_addr=$t;
      $key_addr=$key;
      var $0=$key_addr;
      var $tt_=(($0+8)|0);
      var $1=HEAP32[(($tt_)>>2)];
      var $cmp=(($1)|0)==0;
      if ($cmp) { label = 3; break; } else { label = 4; break; }
    case 3: 
      var $2=$L_addr;
      _luaG_runerror($2, ((5245696)|0), (tempInt=STACKTOP,_memset(STACKTOP, 0, 1),STACKTOP = (STACKTOP + 1)|0,STACKTOP = ((((STACKTOP)+3)>>2)<<2),HEAP32[((tempInt)>>2)]=0,tempInt));

    case 4: 
      var $3=$key_addr;
      var $tt_1=(($3+8)|0);
      var $4=HEAP32[(($tt_1)>>2)];
      var $cmp2=(($4)|0)==3;
      if ($cmp2) { label = 5; break; } else { label = 7; break; }
    case 5: 
      var $5=$key_addr;
      var $value_=(($5)|0);
      var $n=$value_;
      var $6=(HEAP32[((tempDoublePtr)>>2)]=HEAP32[(($n)>>2)],HEAP32[(((tempDoublePtr)+(4))>>2)]=HEAP32[((($n)+(4))>>2)],HEAPF64[(tempDoublePtr)>>3]);
      var $7=$key_addr;
      var $value_3=(($7)|0);
      var $n4=$value_3;
      var $8=(HEAP32[((tempDoublePtr)>>2)]=HEAP32[(($n4)>>2)],HEAP32[(((tempDoublePtr)+(4))>>2)]=HEAP32[((($n4)+(4))>>2)],HEAPF64[(tempDoublePtr)>>3]);
      var $cmp5=$6 == $8;
      if ($cmp5) { label = 7; break; } else { label = 6; break; }
    case 6: 
      var $9=$L_addr;
      _luaG_runerror($9, ((5246820)|0), (tempInt=STACKTOP,_memset(STACKTOP, 0, 1),STACKTOP = (STACKTOP + 1)|0,STACKTOP = ((((STACKTOP)+3)>>2)<<2),HEAP32[((tempInt)>>2)]=0,tempInt));

    case 7: 
      label = 8; break;
    case 8: 
      var $10=$t_addr;
      var $11=$key_addr;
      var $call=_mainposition($10, $11);
      $mp=$call;
      var $12=$mp;
      var $i_val=(($12)|0);
      var $tt_8=(($i_val+8)|0);
      var $13=HEAP32[(($tt_8)>>2)];
      var $cmp9=(($13)|0)==0;
      if ($cmp9) { label = 9; break; } else { label = 10; break; }
    case 9: 
      var $14=$mp;
      var $cmp10=(($14)|0)==5244060;
      if ($cmp10) { label = 10; break; } else { label = 19; break; }
    case 10: 
      var $15=$t_addr;
      var $call13=_getfreepos($15);
      $n12=$call13;
      var $16=$n12;
      var $cmp14=(($16)|0)==0;
      if ($cmp14) { label = 11; break; } else { label = 12; break; }
    case 11: 
      var $17=$L_addr;
      var $18=$t_addr;
      var $19=$key_addr;
      _rehash($17, $18, $19);
      var $20=$L_addr;
      var $21=$t_addr;
      var $22=$key_addr;
      var $call16=_luaH_set($20, $21, $22);
      $retval=$call16;
      label = 24; break;
    case 12: 
      var $23=$t_addr;
      var $24=$mp;
      var $i_key=(($24+12)|0);
      var $tvk=$i_key;
      var $call18=_mainposition($23, $tvk);
      $othern=$call18;
      var $25=$othern;
      var $26=$mp;
      var $cmp19=(($25)|0)!=(($26)|0);
      if ($cmp19) { label = 13; break; } else { label = 17; break; }
    case 13: 
      label = 14; break;
    case 14: 
      var $27=$othern;
      var $i_key21=(($27+12)|0);
      var $nk=$i_key21;
      var $next=(($nk+12)|0);
      var $28=HEAP32[(($next)>>2)];
      var $29=$mp;
      var $cmp22=(($28)|0)!=(($29)|0);
      if ($cmp22) { label = 15; break; } else { label = 16; break; }
    case 15: 
      var $30=$othern;
      var $i_key23=(($30+12)|0);
      var $nk24=$i_key23;
      var $next25=(($nk24+12)|0);
      var $31=HEAP32[(($next25)>>2)];
      $othern=$31;
      label = 14; break;
    case 16: 
      var $32=$n12;
      var $33=$othern;
      var $i_key26=(($33+12)|0);
      var $nk27=$i_key26;
      var $next28=(($nk27+12)|0);
      HEAP32[(($next28)>>2)]=$32;
      var $34=$n12;
      var $35=$mp;
      var $36=$34;
      var $37=$35;
      HEAP32[(($36)>>2)]=HEAP32[(($37)>>2)];HEAP32[((($36)+(4))>>2)]=HEAP32[((($37)+(4))>>2)];HEAP32[((($36)+(8))>>2)]=HEAP32[((($37)+(8))>>2)];HEAP32[((($36)+(12))>>2)]=HEAP32[((($37)+(12))>>2)];HEAP32[((($36)+(16))>>2)]=HEAP32[((($37)+(16))>>2)];HEAP32[((($36)+(20))>>2)]=HEAP32[((($37)+(20))>>2)];HEAP32[((($36)+(24))>>2)]=HEAP32[((($37)+(24))>>2)];
      var $38=$mp;
      var $i_key29=(($38+12)|0);
      var $nk30=$i_key29;
      var $next31=(($nk30+12)|0);
      HEAP32[(($next31)>>2)]=0;
      var $39=$mp;
      var $i_val32=(($39)|0);
      var $tt_33=(($i_val32+8)|0);
      HEAP32[(($tt_33)>>2)]=0;
      label = 18; break;
    case 17: 
      var $40=$mp;
      var $i_key35=(($40+12)|0);
      var $nk36=$i_key35;
      var $next37=(($nk36+12)|0);
      var $41=HEAP32[(($next37)>>2)];
      var $42=$n12;
      var $i_key38=(($42+12)|0);
      var $nk39=$i_key38;
      var $next40=(($nk39+12)|0);
      HEAP32[(($next40)>>2)]=$41;
      var $43=$n12;
      var $44=$mp;
      var $i_key41=(($44+12)|0);
      var $nk42=$i_key41;
      var $next43=(($nk42+12)|0);
      HEAP32[(($next43)>>2)]=$43;
      var $45=$n12;
      $mp=$45;
      label = 18; break;
    case 18: 
      label = 19; break;
    case 19: 
      var $46=$key_addr;
      $io2=$46;
      var $47=$mp;
      var $i_key46=(($47+12)|0);
      var $tvk47=$i_key46;
      $io1=$tvk47;
      var $48=$io1;
      var $value_48=(($48)|0);
      var $49=$io2;
      var $value_49=(($49)|0);
      var $50=$value_48;
      var $51=$value_49;
      HEAP32[(($50)>>2)]=HEAP32[(($51)>>2)];HEAP32[((($50)+(4))>>2)]=HEAP32[((($51)+(4))>>2)];
      var $52=$io2;
      var $tt_50=(($52+8)|0);
      var $53=HEAP32[(($tt_50)>>2)];
      var $54=$io1;
      var $tt_51=(($54+8)|0);
      HEAP32[(($tt_51)>>2)]=$53;
      var $55=$key_addr;
      var $tt_52=(($55+8)|0);
      var $56=HEAP32[(($tt_52)>>2)];
      var $and=$56 & 64;
      var $tobool=(($and)|0)!=0;
      if ($tobool) { label = 20; break; } else { label = 23; break; }
    case 20: 
      var $57=$key_addr;
      var $value_54=(($57)|0);
      var $gc=$value_54;
      var $58=HEAP32[(($gc)>>2)];
      var $gch=$58;
      var $marked=(($gch+5)|0);
      var $59=HEAP8[($marked)];
      var $conv=(($59)&255);
      var $and55=$conv & 3;
      var $tobool56=(($and55)|0)!=0;
      if ($tobool56) { label = 21; break; } else { label = 23; break; }
    case 21: 
      var $60=$t_addr;
      var $61=$60;
      var $gch58=$61;
      var $marked59=(($gch58+5)|0);
      var $62=HEAP8[($marked59)];
      var $conv60=(($62)&255);
      var $and61=$conv60 & 4;
      var $tobool62=(($and61)|0)!=0;
      if ($tobool62) { label = 22; break; } else { label = 23; break; }
    case 22: 
      var $63=$L_addr;
      var $64=$t_addr;
      var $65=$64;
      _luaC_barrierback_($63, $65);
      label = 23; break;
    case 23: 
      var $66=$mp;
      var $i_val65=(($66)|0);
      $retval=$i_val65;
      label = 24; break;
    case 24: 
      var $67=$retval;
      STACKTOP = __stackBase__;
      Module.print(INDENT + 'Exiting: _luaH_newkey');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return $67;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_luaH_newkey["X"]=1;

function _numusearray($t, $nums) {
  var label = 0;

  Module.print(INDENT + ' Entering: _numusearray: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $t_addr;
      var $nums_addr;
      var $lg;
      var $ttlg;
      var $ause;
      var $i;
      var $lc;
      var $lim;
      $t_addr=$t;
      $nums_addr=$nums;
      $ause=0;
      $i=1;
      $lg=0;
      $ttlg=1;
      label = 3; break;
    case 3: 
      var $0=$lg;
      var $cmp=(($0)|0) <= 30;
      if ($cmp) { label = 4; break; } else { label = 16; break; }
    case 4: 
      $lc=0;
      var $1=$ttlg;
      $lim=$1;
      var $2=$lim;
      var $3=$t_addr;
      var $sizearray=(($3+28)|0);
      var $4=HEAP32[(($sizearray)>>2)];
      var $cmp1=(($2)|0) > (($4)|0);
      if ($cmp1) { label = 5; break; } else { label = 8; break; }
    case 5: 
      var $5=$t_addr;
      var $sizearray2=(($5+28)|0);
      var $6=HEAP32[(($sizearray2)>>2)];
      $lim=$6;
      var $7=$i;
      var $8=$lim;
      var $cmp3=(($7)|0) > (($8)|0);
      if ($cmp3) { label = 6; break; } else { label = 7; break; }
    case 6: 
      label = 16; break;
    case 7: 
      label = 8; break;
    case 8: 
      label = 9; break;
    case 9: 
      var $9=$i;
      var $10=$lim;
      var $cmp7=(($9)|0) <= (($10)|0);
      if ($cmp7) { label = 10; break; } else { label = 14; break; }
    case 10: 
      var $11=$i;
      var $sub=((($11)-(1))|0);
      var $12=$t_addr;
      var $array=(($12+12)|0);
      var $13=HEAP32[(($array)>>2)];
      var $arrayidx=(($13+((($sub)*(12))&-1))|0);
      var $tt_=(($arrayidx+8)|0);
      var $14=HEAP32[(($tt_)>>2)];
      var $cmp9=(($14)|0)==0;
      if ($cmp9) { label = 12; break; } else { label = 11; break; }
    case 11: 
      var $15=$lc;
      var $inc=((($15)+(1))|0);
      $lc=$inc;
      label = 12; break;
    case 12: 
      label = 13; break;
    case 13: 
      var $16=$i;
      var $inc12=((($16)+(1))|0);
      $i=$inc12;
      label = 9; break;
    case 14: 
      var $17=$lc;
      var $18=$lg;
      var $19=$nums_addr;
      var $arrayidx13=(($19+($18<<2))|0);
      var $20=HEAP32[(($arrayidx13)>>2)];
      var $add=((($20)+($17))|0);
      HEAP32[(($arrayidx13)>>2)]=$add;
      var $21=$lc;
      var $22=$ause;
      var $add14=((($22)+($21))|0);
      $ause=$add14;
      label = 15; break;
    case 15: 
      var $23=$lg;
      var $inc16=((($23)+(1))|0);
      $lg=$inc16;
      var $24=$ttlg;
      var $mul=($24<<1);
      $ttlg=$mul;
      label = 3; break;
    case 16: 
      var $25=$ause;

      Module.print(INDENT + 'Exiting: _numusearray');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return $25;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_numusearray["X"]=1;

function _computesizes($nums, $narray) {
  var label = 0;

  Module.print(INDENT + ' Entering: _computesizes: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $nums_addr;
      var $narray_addr;
      var $i;
      var $twotoi;
      var $a;
      var $na;
      var $n;
      $nums_addr=$nums;
      $narray_addr=$narray;
      $a=0;
      $na=0;
      $n=0;
      $i=0;
      $twotoi=1;
      label = 3; break;
    case 3: 
      var $0=$twotoi;
      var $div=((((($0)|0))/(2))&-1);
      var $1=$narray_addr;
      var $2=HEAP32[(($1)>>2)];
      var $cmp=(($div)|0) < (($2)|0);
      if ($cmp) { label = 4; break; } else { label = 12; break; }
    case 4: 
      var $3=$i;
      var $4=$nums_addr;
      var $arrayidx=(($4+($3<<2))|0);
      var $5=HEAP32[(($arrayidx)>>2)];
      var $cmp1=(($5)|0) > 0;
      if ($cmp1) { label = 5; break; } else { label = 8; break; }
    case 5: 
      var $6=$i;
      var $7=$nums_addr;
      var $arrayidx2=(($7+($6<<2))|0);
      var $8=HEAP32[(($arrayidx2)>>2)];
      var $9=$a;
      var $add=((($9)+($8))|0);
      $a=$add;
      var $10=$a;
      var $11=$twotoi;
      var $div3=((((($11)|0))/(2))&-1);
      var $cmp4=(($10)|0) > (($div3)|0);
      if ($cmp4) { label = 6; break; } else { label = 7; break; }
    case 6: 
      var $12=$twotoi;
      $n=$12;
      var $13=$a;
      $na=$13;
      label = 7; break;
    case 7: 
      label = 8; break;
    case 8: 
      var $14=$a;
      var $15=$narray_addr;
      var $16=HEAP32[(($15)>>2)];
      var $cmp7=(($14)|0)==(($16)|0);
      if ($cmp7) { label = 9; break; } else { label = 10; break; }
    case 9: 
      label = 12; break;
    case 10: 
      label = 11; break;
    case 11: 
      var $17=$i;
      var $inc=((($17)+(1))|0);
      $i=$inc;
      var $18=$twotoi;
      var $mul=($18<<1);
      $twotoi=$mul;
      label = 3; break;
    case 12: 
      var $19=$n;
      var $20=$narray_addr;
      HEAP32[(($20)>>2)]=$19;
      var $21=$na;

      Module.print(INDENT + 'Exiting: _computesizes');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return $21;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_computesizes["X"]=1;

function _arrayindex($key) {
  var label = 0;
  var __stackBase__  = STACKTOP; STACKTOP = (STACKTOP + 8)|0; _memset(__stackBase__, 0, 8);
  Module.print(INDENT + ' Entering: _arrayindex: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $retval;
      var $key_addr;
      var $n;
      var $k;
      var $u=__stackBase__;
      $key_addr=$key;
      var $0=$key_addr;
      var $tt_=(($0+8)|0);
      var $1=HEAP32[(($tt_)>>2)];
      var $cmp=(($1)|0)==3;
      if ($cmp) { label = 3; break; } else { label = 6; break; }
    case 3: 
      var $2=$key_addr;
      var $value_=(($2)|0);
      var $n1=$value_;
      var $3=(HEAP32[((tempDoublePtr)>>2)]=HEAP32[(($n1)>>2)],HEAP32[(((tempDoublePtr)+(4))>>2)]=HEAP32[((($n1)+(4))>>2)],HEAPF64[(tempDoublePtr)>>3]);
      $n=$3;
      var $4=$n;
      var $add=($4)+(6755399441055744);
      var $l_d=$u;
      (HEAPF64[(tempDoublePtr)>>3]=$add,HEAP32[(($l_d)>>2)]=HEAP32[((tempDoublePtr)>>2)],HEAP32[((($l_d)+(4))>>2)]=HEAP32[(((tempDoublePtr)+(4))>>2)]);
      var $5=HEAP32[((((5244092)|0))>>2)];
      var $cmp2=(($5)|0)==33;
      var $conv=(($cmp2)&1);
      var $l_p=$u;
      var $arrayidx=(($l_p+($conv<<2))|0);
      var $6=HEAP32[(($arrayidx)>>2)];
      $k=$6;
      var $7=$k;
      var $conv3=(($7)|0);
      var $8=$n;
      var $cmp4=$conv3 == $8;
      if ($cmp4) { label = 4; break; } else { label = 5; break; }
    case 4: 
      var $9=$k;
      $retval=$9;
      label = 7; break;
    case 5: 
      label = 6; break;
    case 6: 
      $retval=-1;
      label = 7; break;
    case 7: 
      var $10=$retval;
      STACKTOP = __stackBase__;
      Module.print(INDENT + 'Exiting: _arrayindex');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return $10;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _luaH_getn($t) {
  var label = 0;

  Module.print(INDENT + ' Entering: _luaH_getn: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $retval;
      var $t_addr;
      var $j;
      var $i;
      var $m;
      $t_addr=$t;
      var $0=$t_addr;
      var $sizearray=(($0+28)|0);
      var $1=HEAP32[(($sizearray)>>2)];
      $j=$1;
      var $2=$j;
      var $cmp=(($2)>>>0) > 0;
      if ($cmp) { label = 3; break; } else { label = 11; break; }
    case 3: 
      var $3=$j;
      var $sub=((($3)-(1))|0);
      var $4=$t_addr;
      var $array=(($4+12)|0);
      var $5=HEAP32[(($array)>>2)];
      var $arrayidx=(($5+((($sub)*(12))&-1))|0);
      var $tt_=(($arrayidx+8)|0);
      var $6=HEAP32[(($tt_)>>2)];
      var $cmp1=(($6)|0)==0;
      if ($cmp1) { label = 4; break; } else { label = 11; break; }
    case 4: 
      $i=0;
      label = 5; break;
    case 5: 
      var $7=$j;
      var $8=$i;
      var $sub2=((($7)-($8))|0);
      var $cmp3=(($sub2)>>>0) > 1;
      if ($cmp3) { label = 6; break; } else { label = 10; break; }
    case 6: 
      var $9=$i;
      var $10=$j;
      var $add=((($9)+($10))|0);
      var $div=Math.floor(((($add)>>>0))/(2));
      $m=$div;
      var $11=$m;
      var $sub4=((($11)-(1))|0);
      var $12=$t_addr;
      var $array5=(($12+12)|0);
      var $13=HEAP32[(($array5)>>2)];
      var $arrayidx6=(($13+((($sub4)*(12))&-1))|0);
      var $tt_7=(($arrayidx6+8)|0);
      var $14=HEAP32[(($tt_7)>>2)];
      var $cmp8=(($14)|0)==0;
      if ($cmp8) { label = 7; break; } else { label = 8; break; }
    case 7: 
      var $15=$m;
      $j=$15;
      label = 9; break;
    case 8: 
      var $16=$m;
      $i=$16;
      label = 9; break;
    case 9: 
      label = 5; break;
    case 10: 
      var $17=$i;
      $retval=$17;
      label = 14; break;
    case 11: 
      var $18=$t_addr;
      var $node=(($18+16)|0);
      var $19=HEAP32[(($node)>>2)];
      var $cmp11=(($19)|0)==5244060;
      if ($cmp11) { label = 12; break; } else { label = 13; break; }
    case 12: 
      var $20=$j;
      $retval=$20;
      label = 14; break;
    case 13: 
      var $21=$t_addr;
      var $22=$j;
      var $call=_unbound_search($21, $22);
      $retval=$call;
      label = 14; break;
    case 14: 
      var $23=$retval;

      Module.print(INDENT + 'Exiting: _luaH_getn');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return $23;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_luaH_getn["X"]=1;

function _unbound_search($t, $j) {
  var label = 0;

  Module.print(INDENT + ' Entering: _unbound_search: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $retval;
      var $t_addr;
      var $j_addr;
      var $i;
      var $m;
      $t_addr=$t;
      $j_addr=$j;
      var $0=$j_addr;
      $i=$0;
      var $1=$j_addr;
      var $inc=((($1)+(1))|0);
      $j_addr=$inc;
      label = 3; break;
    case 3: 
      var $2=$t_addr;
      var $3=$j_addr;
      var $call=_luaH_getint($2, $3);
      var $tt_=(($call+8)|0);
      var $4=HEAP32[(($tt_)>>2)];
      var $cmp=(($4)|0)==0;
      var $lnot=$cmp ^ 1;
      if ($lnot) { label = 4; break; } else { label = 10; break; }
    case 4: 
      var $5=$j_addr;
      $i=$5;
      var $6=$j_addr;
      var $mul=($6<<1);
      $j_addr=$mul;
      var $7=$j_addr;
      var $cmp1=(($7)>>>0) > 2147483645;
      if ($cmp1) { label = 5; break; } else { label = 9; break; }
    case 5: 
      $i=1;
      label = 6; break;
    case 6: 
      var $8=$t_addr;
      var $9=$i;
      var $call3=_luaH_getint($8, $9);
      var $tt_4=(($call3+8)|0);
      var $10=HEAP32[(($tt_4)>>2)];
      var $cmp5=(($10)|0)==0;
      var $lnot6=$cmp5 ^ 1;
      if ($lnot6) { label = 7; break; } else { label = 8; break; }
    case 7: 
      var $11=$i;
      var $inc8=((($11)+(1))|0);
      $i=$inc8;
      label = 6; break;
    case 8: 
      var $12=$i;
      var $sub=((($12)-(1))|0);
      $retval=$sub;
      label = 17; break;
    case 9: 
      label = 3; break;
    case 10: 
      label = 11; break;
    case 11: 
      var $13=$j_addr;
      var $14=$i;
      var $sub11=((($13)-($14))|0);
      var $cmp12=(($sub11)>>>0) > 1;
      if ($cmp12) { label = 12; break; } else { label = 16; break; }
    case 12: 
      var $15=$i;
      var $16=$j_addr;
      var $add=((($15)+($16))|0);
      var $div=Math.floor(((($add)>>>0))/(2));
      $m=$div;
      var $17=$t_addr;
      var $18=$m;
      var $call14=_luaH_getint($17, $18);
      var $tt_15=(($call14+8)|0);
      var $19=HEAP32[(($tt_15)>>2)];
      var $cmp16=(($19)|0)==0;
      if ($cmp16) { label = 13; break; } else { label = 14; break; }
    case 13: 
      var $20=$m;
      $j_addr=$20;
      label = 15; break;
    case 14: 
      var $21=$m;
      $i=$21;
      label = 15; break;
    case 15: 
      label = 11; break;
    case 16: 
      var $22=$i;
      $retval=$22;
      label = 17; break;
    case 17: 
      var $23=$retval;

      Module.print(INDENT + 'Exiting: _unbound_search');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return $23;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_unbound_search["X"]=1;

function _numusehash($t, $nums, $pnasize) {
  var label = 0;

  Module.print(INDENT + ' Entering: _numusehash: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $t_addr;
      var $nums_addr;
      var $pnasize_addr;
      var $totaluse;
      var $ause;
      var $i;
      var $n;
      $t_addr=$t;
      $nums_addr=$nums;
      $pnasize_addr=$pnasize;
      $totaluse=0;
      $ause=0;
      var $0=$t_addr;
      var $lsizenode=(($0+7)|0);
      var $1=HEAP8[($lsizenode)];
      var $conv=(($1)&255);
      var $shl=1 << $conv;
      $i=$shl;
      label = 3; break;
    case 3: 
      var $2=$i;
      var $dec=((($2)-(1))|0);
      $i=$dec;
      var $tobool=(($2)|0)!=0;
      if ($tobool) { label = 4; break; } else { label = 7; break; }
    case 4: 
      var $3=$i;
      var $4=$t_addr;
      var $node=(($4+16)|0);
      var $5=HEAP32[(($node)>>2)];
      var $arrayidx=(($5+((($3)*(28))&-1))|0);
      $n=$arrayidx;
      var $6=$n;
      var $i_val=(($6)|0);
      var $tt_=(($i_val+8)|0);
      var $7=HEAP32[(($tt_)>>2)];
      var $cmp=(($7)|0)==0;
      if ($cmp) { label = 6; break; } else { label = 5; break; }
    case 5: 
      var $8=$n;
      var $i_key=(($8+12)|0);
      var $tvk=$i_key;
      var $9=$nums_addr;
      var $call=_countint($tvk, $9);
      var $10=$ause;
      var $add=((($10)+($call))|0);
      $ause=$add;
      var $11=$totaluse;
      var $inc=((($11)+(1))|0);
      $totaluse=$inc;
      label = 6; break;
    case 6: 
      label = 3; break;
    case 7: 
      var $12=$ause;
      var $13=$pnasize_addr;
      var $14=HEAP32[(($13)>>2)];
      var $add2=((($14)+($12))|0);
      HEAP32[(($13)>>2)]=$add2;
      var $15=$totaluse;

      Module.print(INDENT + 'Exiting: _numusehash');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return $15;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_numusehash["X"]=1;

function _countint($key, $nums) {
  var label = 0;

  Module.print(INDENT + ' Entering: _countint: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $retval;
      var $key_addr;
      var $nums_addr;
      var $k;
      $key_addr=$key;
      $nums_addr=$nums;
      var $0=$key_addr;
      var $call=_arrayindex($0);
      $k=$call;
      var $1=$k;
      var $cmp=0 < (($1)|0);
      if ($cmp) { label = 3; break; } else { label = 5; break; }
    case 3: 
      var $2=$k;
      var $cmp1=(($2)|0) <= 1073741824;
      if ($cmp1) { label = 4; break; } else { label = 5; break; }
    case 4: 
      var $3=$k;
      var $call2=_luaO_ceillog2($3);
      var $4=$nums_addr;
      var $arrayidx=(($4+($call2<<2))|0);
      var $5=HEAP32[(($arrayidx)>>2)];
      var $inc=((($5)+(1))|0);
      HEAP32[(($arrayidx)>>2)]=$inc;
      $retval=1;
      label = 6; break;
    case 5: 
      $retval=0;
      label = 6; break;
    case 6: 
      var $6=$retval;

      Module.print(INDENT + 'Exiting: _countint');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return $6;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _luaT_init($L) {
  var label = 0;

  Module.print(INDENT + ' Entering: _luaT_init: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $L_addr;
      var $i;
      $L_addr=$L;
      $i=0;
      label = 3; break;
    case 3: 
      var $0=$i;
      var $cmp=(($0)|0) < 17;
      if ($cmp) { label = 4; break; } else { label = 6; break; }
    case 4: 
      var $1=$L_addr;
      var $2=$i;
      var $arrayidx=((5243512+($2<<2))|0);
      var $3=HEAP32[(($arrayidx)>>2)];
      var $call=_luaS_new($1, $3);
      var $4=$i;
      var $5=$L_addr;
      var $l_G=(($5+12)|0);
      var $6=HEAP32[(($l_G)>>2)];
      var $tmname=(($6+164)|0);
      var $arrayidx1=(($tmname+($4<<2))|0);
      HEAP32[(($arrayidx1)>>2)]=$call;
      var $7=$i;
      var $8=$L_addr;
      var $l_G2=(($8+12)|0);
      var $9=HEAP32[(($l_G2)>>2)];
      var $tmname3=(($9+164)|0);
      var $arrayidx4=(($tmname3+($7<<2))|0);
      var $10=HEAP32[(($arrayidx4)>>2)];
      var $tsv=$10;
      var $marked=(($tsv+5)|0);
      var $11=HEAP8[($marked)];
      var $conv=(($11)&255);
      var $or=$conv | 32;
      var $conv5=(($or) & 255);
      HEAP8[($marked)]=$conv5;
      label = 5; break;
    case 5: 
      var $12=$i;
      var $inc=((($12)+(1))|0);
      $i=$inc;
      label = 3; break;
    case 6: 

      Module.print(INDENT + 'Exiting: _luaT_init');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _luaT_gettm($events, $event, $ename) {
  var label = 0;

  Module.print(INDENT + ' Entering: _luaT_gettm: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $retval;
      var $events_addr;
      var $event_addr;
      var $ename_addr;
      var $tm;
      $events_addr=$events;
      $event_addr=$event;
      $ename_addr=$ename;
      var $0=$events_addr;
      var $1=$ename_addr;
      var $call=_luaH_getstr($0, $1);
      $tm=$call;
      var $2=$tm;
      var $tt_=(($2+8)|0);
      var $3=HEAP32[(($tt_)>>2)];
      var $cmp=(($3)|0)==0;
      if ($cmp) { label = 3; break; } else { label = 4; break; }
    case 3: 
      var $4=$event_addr;
      var $shl=1 << $4;
      var $conv=(($shl) & 255);
      var $conv1=(($conv)&255);
      var $5=$events_addr;
      var $flags=(($5+6)|0);
      var $6=HEAP8[($flags)];
      var $conv2=(($6)&255);
      var $or=$conv2 | $conv1;
      var $conv3=(($or) & 255);
      HEAP8[($flags)]=$conv3;
      $retval=0;
      label = 5; break;
    case 4: 
      var $7=$tm;
      $retval=$7;
      label = 5; break;
    case 5: 
      var $8=$retval;

      Module.print(INDENT + 'Exiting: _luaT_gettm');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return $8;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _luaT_gettmbyobj($L, $o, $event) {
  var label = 0;

  Module.print(INDENT + ' Entering: _luaT_gettmbyobj: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $L_addr;
      var $o_addr;
      var $event_addr;
      var $mt;
      $L_addr=$L;
      $o_addr=$o;
      $event_addr=$event;
      var $0=$o_addr;
      var $tt_=(($0+8)|0);
      var $1=HEAP32[(($tt_)>>2)];
      var $and=$1 & 15;
      if ((($and)|0)==5) {
        label = 3; break;
      }
      else if ((($and)|0)==7) {
        label = 4; break;
      }
      else {
      label = 5; break;
      }
      
    case 3: 
      var $2=$o_addr;
      var $value_=(($2)|0);
      var $gc=$value_;
      var $3=HEAP32[(($gc)>>2)];
      var $h=$3;
      var $metatable=(($h+8)|0);
      var $4=HEAP32[(($metatable)>>2)];
      $mt=$4;
      label = 6; break;
    case 4: 
      var $5=$o_addr;
      var $value_2=(($5)|0);
      var $gc3=$value_2;
      var $6=HEAP32[(($gc3)>>2)];
      var $u=$6;
      var $uv=$u;
      var $metatable4=(($uv+8)|0);
      var $7=HEAP32[(($metatable4)>>2)];
      $mt=$7;
      label = 6; break;
    case 5: 
      var $8=$o_addr;
      var $tt_5=(($8+8)|0);
      var $9=HEAP32[(($tt_5)>>2)];
      var $and6=$9 & 15;
      var $10=$L_addr;
      var $l_G=(($10+12)|0);
      var $11=HEAP32[(($l_G)>>2)];
      var $mt7=(($11+232)|0);
      var $arrayidx=(($mt7+($and6<<2))|0);
      var $12=HEAP32[(($arrayidx)>>2)];
      $mt=$12;
      label = 6; break;
    case 6: 
      var $13=$mt;
      var $tobool=(($13)|0)!=0;
      if ($tobool) { label = 7; break; } else { label = 8; break; }
    case 7: 
      var $14=$mt;
      var $15=$event_addr;
      var $16=$L_addr;
      var $l_G8=(($16+12)|0);
      var $17=HEAP32[(($l_G8)>>2)];
      var $tmname=(($17+164)|0);
      var $arrayidx9=(($tmname+($15<<2))|0);
      var $18=HEAP32[(($arrayidx9)>>2)];
      var $call=_luaH_getstr($14, $18);
      var $cond = $call;label = 9; break;
    case 8: 
      var $cond = 5243784;label = 9; break;
    case 9: 
      var $cond;

      Module.print(INDENT + 'Exiting: _luaT_gettmbyobj');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return $cond;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_luaT_gettmbyobj["X"]=1;

function _luaU_undump($L, $Z, $buff, $name) {
  var label = 0;
  var __stackBase__  = STACKTOP; STACKTOP = (STACKTOP + 16)|0; _memset(__stackBase__, 0, 16);
  Module.print(INDENT + ' Entering: _luaU_undump: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $L_addr;
      var $Z_addr;
      var $buff_addr;
      var $name_addr;
      var $S=__stackBase__;
      var $cl;
      var $io;
      var $p32;
      var $io41;
      $L_addr=$L;
      $Z_addr=$Z;
      $buff_addr=$buff;
      $name_addr=$name;
      var $0=$name_addr;
      var $1=HEAP8[($0)];
      var $conv=(($1 << 24) >> 24);
      var $cmp=(($conv)|0)==64;
      if ($cmp) { label = 4; break; } else { label = 3; break; }
    case 3: 
      var $2=$name_addr;
      var $3=HEAP8[($2)];
      var $conv2=(($3 << 24) >> 24);
      var $cmp3=(($conv2)|0)==61;
      if ($cmp3) { label = 4; break; } else { label = 5; break; }
    case 4: 
      var $4=$name_addr;
      var $add_ptr=(($4+1)|0);
      var $name5=(($S+12)|0);
      HEAP32[(($name5)>>2)]=$add_ptr;
      label = 9; break;
    case 5: 
      var $5=$name_addr;
      var $6=HEAP8[($5)];
      var $conv6=(($6 << 24) >> 24);
      var $7=HEAP8[((((5245420)|0))|0)];
      var $conv7=(($7 << 24) >> 24);
      var $cmp8=(($conv6)|0)==(($conv7)|0);
      if ($cmp8) { label = 6; break; } else { label = 7; break; }
    case 6: 
      var $name11=(($S+12)|0);
      HEAP32[(($name11)>>2)]=((5246760)|0);
      label = 8; break;
    case 7: 
      var $8=$name_addr;
      var $name13=(($S+12)|0);
      HEAP32[(($name13)>>2)]=$8;
      label = 8; break;
    case 8: 
      label = 9; break;
    case 9: 
      var $9=$L_addr;
      var $L15=(($S)|0);
      HEAP32[(($L15)>>2)]=$9;
      var $10=$Z_addr;
      var $Z16=(($S+4)|0);
      HEAP32[(($Z16)>>2)]=$10;
      var $11=$buff_addr;
      var $b=(($S+8)|0);
      HEAP32[(($b)>>2)]=$11;
      _LoadHeader($S);
      var $12=$L_addr;
      var $call=_luaF_newLclosure($12, 1);
      $cl=$call;
      var $13=$L_addr;
      var $top=(($13+8)|0);
      var $14=HEAP32[(($top)>>2)];
      $io=$14;
      var $15=$cl;
      var $16=$15;
      var $17=$io;
      var $value_=(($17)|0);
      var $gc=$value_;
      HEAP32[(($gc)>>2)]=$16;
      var $18=$io;
      var $tt_=(($18+8)|0);
      HEAP32[(($tt_)>>2)]=70;
      var $19=$L_addr;
      var $top17=(($19+8)|0);
      var $20=HEAP32[(($top17)>>2)];
      var $incdec_ptr=(($20+12)|0);
      HEAP32[(($top17)>>2)]=$incdec_ptr;
      var $21=$L_addr;
      var $stack_last=(($21+24)|0);
      var $22=HEAP32[(($stack_last)>>2)];
      var $23=$L_addr;
      var $top18=(($23+8)|0);
      var $24=HEAP32[(($top18)>>2)];
      var $sub_ptr_lhs_cast=$22;
      var $sub_ptr_rhs_cast=$24;
      var $sub_ptr_sub=((($sub_ptr_lhs_cast)-($sub_ptr_rhs_cast))|0);
      var $sub_ptr_div=((((($sub_ptr_sub)|0))/(12))&-1);
      var $cmp19=(($sub_ptr_div)|0) <= 0;
      if ($cmp19) { label = 10; break; } else { label = 11; break; }
    case 10: 
      var $25=$L_addr;
      _luaD_growstack($25, 0);
      label = 12; break;
    case 11: 
      label = 12; break;
    case 12: 
      var $26=$L_addr;
      var $call24=_luaF_newproto($26);
      var $27=$cl;
      var $l=$27;
      var $p=(($l+12)|0);
      HEAP32[(($p)>>2)]=$call24;
      var $28=$cl;
      var $l25=$28;
      var $p26=(($l25+12)|0);
      var $29=HEAP32[(($p26)>>2)];
      _LoadFunction($S, $29);
      var $30=$cl;
      var $l27=$30;
      var $p28=(($l27+12)|0);
      var $31=HEAP32[(($p28)>>2)];
      var $sizeupvalues=(($31+40)|0);
      var $32=HEAP32[(($sizeupvalues)>>2)];
      var $cmp29=(($32)|0)!=1;
      if ($cmp29) { label = 13; break; } else { label = 14; break; }
    case 13: 
      var $33=$cl;
      var $l33=$33;
      var $p34=(($l33+12)|0);
      var $34=HEAP32[(($p34)>>2)];
      $p32=$34;
      var $35=$L_addr;
      var $36=$cl;
      var $l35=$36;
      var $p36=(($l35+12)|0);
      var $37=HEAP32[(($p36)>>2)];
      var $sizeupvalues37=(($37+40)|0);
      var $38=HEAP32[(($sizeupvalues37)>>2)];
      var $call38=_luaF_newLclosure($35, $38);
      $cl=$call38;
      var $39=$p32;
      var $40=$cl;
      var $l39=$40;
      var $p40=(($l39+12)|0);
      HEAP32[(($p40)>>2)]=$39;
      var $41=$L_addr;
      var $top42=(($41+8)|0);
      var $42=HEAP32[(($top42)>>2)];
      var $add_ptr43=((($42)-(12))|0);
      $io41=$add_ptr43;
      var $43=$cl;
      var $44=$43;
      var $45=$io41;
      var $value_44=(($45)|0);
      var $gc45=$value_44;
      HEAP32[(($gc45)>>2)]=$44;
      var $46=$io41;
      var $tt_46=(($46+8)|0);
      HEAP32[(($tt_46)>>2)]=70;
      label = 14; break;
    case 14: 
      var $47=$cl;
      STACKTOP = __stackBase__;
      Module.print(INDENT + 'Exiting: _luaU_undump');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return $47;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_luaU_undump["X"]=1;

function _LoadHeader($S) {
  var label = 0;
  var __stackBase__  = STACKTOP; STACKTOP = (STACKTOP + 40)|0; _memset(__stackBase__, 0, 40);
  Module.print(INDENT + ' Entering: _LoadHeader: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $S_addr;
      var $h=__stackBase__;
      var $s=(__stackBase__)+(20);
      $S_addr=$S;
      var $arraydecay=(($h)|0);
      _luaU_header($arraydecay);
      var $0=$s;
      var $1=$h;
      HEAP8[($0)]=HEAP8[($1)];
      var $2=$S_addr;
      var $arraydecay1=(($s)|0);
      var $add_ptr=(($arraydecay1+1)|0);
      _LoadBlock($2, $add_ptr, 17);
      var $arraydecay2=(($h)|0);
      var $arraydecay3=(($s)|0);
      var $call=_memcmp($arraydecay2, $arraydecay3, 18);
      var $cmp=(($call)|0)==0;
      if ($cmp) { label = 3; break; } else { label = 4; break; }
    case 3: 
      STACKTOP = __stackBase__;
      Module.print(INDENT + 'Exiting: _LoadHeader');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return;
    case 4: 
      var $arraydecay4=(($h)|0);
      var $arraydecay5=(($s)|0);
      var $call6=_memcmp($arraydecay4, $arraydecay5, 4);
      var $cmp7=(($call6)|0)!=0;
      if ($cmp7) { label = 5; break; } else { label = 6; break; }
    case 5: 
      var $3=$S_addr;
      _error($3, ((5244260)|0));

    case 6: 
      var $arraydecay10=(($h)|0);
      var $arraydecay11=(($s)|0);
      var $call12=_memcmp($arraydecay10, $arraydecay11, 6);
      var $cmp13=(($call12)|0)!=0;
      if ($cmp13) { label = 7; break; } else { label = 8; break; }
    case 7: 
      var $4=$S_addr;
      _error($4, ((5244148)|0));

    case 8: 
      var $arraydecay16=(($h)|0);
      var $arraydecay17=(($s)|0);
      var $call18=_memcmp($arraydecay16, $arraydecay17, 12);
      var $cmp19=(($call18)|0)!=0;
      if ($cmp19) { label = 9; break; } else { label = 10; break; }
    case 9: 
      var $5=$S_addr;
      _error($5, ((5247144)|0));

    case 10: 
      var $6=$S_addr;
      _error($6, ((5244432)|0));

  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _LoadFunction($S, $f) {
  var label = 0;

  Module.print(INDENT + ' Entering: _LoadFunction: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';

  var $S_addr;
  var $f_addr;
  $S_addr=$S;
  $f_addr=$f;
  var $0=$S_addr;
  var $call=_LoadInt($0);
  var $1=$f_addr;
  var $linedefined=(($1+64)|0);
  HEAP32[(($linedefined)>>2)]=$call;
  var $2=$S_addr;
  var $call1=_LoadInt($2);
  var $3=$f_addr;
  var $lastlinedefined=(($3+68)|0);
  HEAP32[(($lastlinedefined)>>2)]=$call1;
  var $4=$S_addr;
  var $call2=_LoadChar($4);
  var $conv=(($call2) & 255);
  var $5=$f_addr;
  var $numparams=(($5+76)|0);
  HEAP8[($numparams)]=$conv;
  var $6=$S_addr;
  var $call3=_LoadChar($6);
  var $conv4=(($call3) & 255);
  var $7=$f_addr;
  var $is_vararg=(($7+77)|0);
  HEAP8[($is_vararg)]=$conv4;
  var $8=$S_addr;
  var $call5=_LoadChar($8);
  var $conv6=(($call5) & 255);
  var $9=$f_addr;
  var $maxstacksize=(($9+78)|0);
  HEAP8[($maxstacksize)]=$conv6;
  var $10=$S_addr;
  var $11=$f_addr;
  _LoadCode($10, $11);
  var $12=$S_addr;
  var $13=$f_addr;
  _LoadConstants($12, $13);
  var $14=$S_addr;
  var $15=$f_addr;
  _LoadUpvalues($14, $15);
  var $16=$S_addr;
  var $17=$f_addr;
  _LoadDebug($16, $17);

  Module.print(INDENT + 'Exiting: _LoadFunction');
  INDENT = INDENT.substr(0, INDENT.length-2);
  return;
  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _luaU_header($h) {
  var label = 0;
  var __stackBase__  = STACKTOP; STACKTOP = (STACKTOP + 4)|0; _memset(__stackBase__, 0, 4);
  Module.print(INDENT + ' Entering: _luaU_header: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';

  var $h_addr;
  var $x=__stackBase__;
  $h_addr=$h;
  HEAP32[(($x)>>2)]=1;
  var $0=$h_addr;
  HEAP8[($0)]=HEAP8[((((5245420)|0))|0)];HEAP8[((($0)+(1))|0)]=HEAP8[(((((5245420)|0))+(1))|0)];HEAP8[((($0)+(2))|0)]=HEAP8[(((((5245420)|0))+(2))|0)];HEAP8[((($0)+(3))|0)]=HEAP8[(((((5245420)|0))+(3))|0)];
  var $1=$h_addr;
  var $add_ptr=(($1+4)|0);
  $h_addr=$add_ptr;
  var $2=HEAP8[((((5245784)|0))|0)];
  var $conv=(($2 << 24) >> 24);
  var $sub=((($conv)-(48))|0);
  var $mul=($sub<<4);
  var $3=HEAP8[((((5245256)|0))|0)];
  var $conv1=(($3 << 24) >> 24);
  var $sub2=((($conv1)-(48))|0);
  var $add=((($mul)+($sub2))|0);
  var $conv3=(($add) & 255);
  var $4=$h_addr;
  var $incdec_ptr=(($4+1)|0);
  $h_addr=$incdec_ptr;
  HEAP8[($4)]=$conv3;
  var $5=$h_addr;
  var $incdec_ptr4=(($5+1)|0);
  $h_addr=$incdec_ptr4;
  HEAP8[($5)]=0;
  var $6=$x;
  var $7=HEAP8[($6)];
  var $8=$h_addr;
  var $incdec_ptr5=(($8+1)|0);
  $h_addr=$incdec_ptr5;
  HEAP8[($8)]=$7;
  var $9=$h_addr;
  var $incdec_ptr6=(($9+1)|0);
  $h_addr=$incdec_ptr6;
  HEAP8[($9)]=4;
  var $10=$h_addr;
  var $incdec_ptr7=(($10+1)|0);
  $h_addr=$incdec_ptr7;
  HEAP8[($10)]=4;
  var $11=$h_addr;
  var $incdec_ptr8=(($11+1)|0);
  $h_addr=$incdec_ptr8;
  HEAP8[($11)]=4;
  var $12=$h_addr;
  var $incdec_ptr9=(($12+1)|0);
  $h_addr=$incdec_ptr9;
  HEAP8[($12)]=8;
  var $13=$h_addr;
  var $incdec_ptr10=(($13+1)|0);
  $h_addr=$incdec_ptr10;
  HEAP8[($13)]=0;
  var $14=$h_addr;
  HEAP8[($14)]=HEAP8[((((5244988)|0))|0)];HEAP8[((($14)+(1))|0)]=HEAP8[(((((5244988)|0))+(1))|0)];HEAP8[((($14)+(2))|0)]=HEAP8[(((((5244988)|0))+(2))|0)];HEAP8[((($14)+(3))|0)]=HEAP8[(((((5244988)|0))+(3))|0)];HEAP8[((($14)+(4))|0)]=HEAP8[(((((5244988)|0))+(4))|0)];HEAP8[((($14)+(5))|0)]=HEAP8[(((((5244988)|0))+(5))|0)];
  STACKTOP = __stackBase__;
  Module.print(INDENT + 'Exiting: _luaU_header');
  INDENT = INDENT.substr(0, INDENT.length-2);
  return;
  INDENT = INDENT.substr(0, INDENT.length-2);
}
_luaU_header["X"]=1;

function _LoadChar($S) {
  var label = 0;
  var __stackBase__  = STACKTOP; STACKTOP = (STACKTOP + 4)|0; _memset(__stackBase__, 0, 4);
  Module.print(INDENT + ' Entering: _LoadChar: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';

  var $S_addr;
  var $x=__stackBase__;
  $S_addr=$S;
  var $0=$S_addr;
  _LoadBlock($0, $x, 1);
  var $1=HEAP8[($x)];
  var $conv=(($1 << 24) >> 24);
  STACKTOP = __stackBase__;
  Module.print(INDENT + 'Exiting: _LoadChar');
  INDENT = INDENT.substr(0, INDENT.length-2);
  return $conv;
  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _LoadString($S) {
  var label = 0;
  var __stackBase__  = STACKTOP; STACKTOP = (STACKTOP + 4)|0; _memset(__stackBase__, 0, 4);
  Module.print(INDENT + ' Entering: _LoadString: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $retval;
      var $S_addr;
      var $size=__stackBase__;
      var $s;
      $S_addr=$S;
      var $0=$S_addr;
      var $1=$size;
      _LoadBlock($0, $1, 4);
      var $2=HEAP32[(($size)>>2)];
      var $cmp=(($2)|0)==0;
      if ($cmp) { label = 3; break; } else { label = 4; break; }
    case 3: 
      $retval=0;
      label = 5; break;
    case 4: 
      var $3=$S_addr;
      var $L=(($3)|0);
      var $4=HEAP32[(($L)>>2)];
      var $5=$S_addr;
      var $b=(($5+8)|0);
      var $6=HEAP32[(($b)>>2)];
      var $7=HEAP32[(($size)>>2)];
      var $call=_luaZ_openspace($4, $6, $7);
      $s=$call;
      var $8=$S_addr;
      var $9=$s;
      var $10=HEAP32[(($size)>>2)];
      var $mul=$10;
      _LoadBlock($8, $9, $mul);
      var $11=$S_addr;
      var $L1=(($11)|0);
      var $12=HEAP32[(($L1)>>2)];
      var $13=$s;
      var $14=HEAP32[(($size)>>2)];
      var $sub=((($14)-(1))|0);
      var $call2=_luaS_newlstr($12, $13, $sub);
      $retval=$call2;
      label = 5; break;
    case 5: 
      var $15=$retval;
      STACKTOP = __stackBase__;
      Module.print(INDENT + 'Exiting: _LoadString');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return $15;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _LoadNumber($S) {
  var label = 0;
  var __stackBase__  = STACKTOP; STACKTOP = (STACKTOP + 8)|0; _memset(__stackBase__, 0, 8);
  Module.print(INDENT + ' Entering: _LoadNumber: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';

  var $S_addr;
  var $x=__stackBase__;
  $S_addr=$S;
  var $0=$S_addr;
  var $1=$x;
  _LoadBlock($0, $1, 8);
  var $2=(HEAP32[((tempDoublePtr)>>2)]=HEAP32[(($x)>>2)],HEAP32[(((tempDoublePtr)+(4))>>2)]=HEAP32[((($x)+(4))>>2)],HEAPF64[(tempDoublePtr)>>3]);
  STACKTOP = __stackBase__;
  Module.print(INDENT + 'Exiting: _LoadNumber');
  INDENT = INDENT.substr(0, INDENT.length-2);
  return $2;
  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _luaV_tonumber($obj, $n) {
  var label = 0;
  var __stackBase__  = STACKTOP; STACKTOP = (STACKTOP + 8)|0; _memset(__stackBase__, 0, 8);
  Module.print(INDENT + ' Entering: _luaV_tonumber: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $retval;
      var $obj_addr;
      var $n_addr;
      var $num=__stackBase__;
      var $io;
      $obj_addr=$obj;
      $n_addr=$n;
      var $0=$obj_addr;
      var $tt_=(($0+8)|0);
      var $1=HEAP32[(($tt_)>>2)];
      var $cmp=(($1)|0)==3;
      if ($cmp) { label = 3; break; } else { label = 4; break; }
    case 3: 
      var $2=$obj_addr;
      $retval=$2;
      label = 8; break;
    case 4: 
      var $3=$obj_addr;
      var $tt_1=(($3+8)|0);
      var $4=HEAP32[(($tt_1)>>2)];
      var $and=$4 & 15;
      var $cmp2=(($and)|0)==4;
      if ($cmp2) { label = 5; break; } else { label = 7; break; }
    case 5: 
      var $5=$obj_addr;
      var $value_=(($5)|0);
      var $gc=$value_;
      var $6=HEAP32[(($gc)>>2)];
      var $ts=$6;
      var $add_ptr=(($ts+16)|0);
      var $7=$add_ptr;
      var $8=$obj_addr;
      var $value_3=(($8)|0);
      var $gc4=$value_3;
      var $9=HEAP32[(($gc4)>>2)];
      var $ts5=$9;
      var $tsv=$ts5;
      var $len=(($tsv+12)|0);
      var $10=HEAP32[(($len)>>2)];
      var $call=_luaO_str2d($7, $10, $num);
      var $tobool=(($call)|0)!=0;
      if ($tobool) { label = 6; break; } else { label = 7; break; }
    case 6: 
      var $11=$n_addr;
      $io=$11;
      var $12=(HEAP32[((tempDoublePtr)>>2)]=HEAP32[(($num)>>2)],HEAP32[(((tempDoublePtr)+(4))>>2)]=HEAP32[((($num)+(4))>>2)],HEAPF64[(tempDoublePtr)>>3]);
      var $13=$io;
      var $value_7=(($13)|0);
      var $n8=$value_7;
      (HEAPF64[(tempDoublePtr)>>3]=$12,HEAP32[(($n8)>>2)]=HEAP32[((tempDoublePtr)>>2)],HEAP32[((($n8)+(4))>>2)]=HEAP32[(((tempDoublePtr)+(4))>>2)]);
      var $14=$io;
      var $tt_9=(($14+8)|0);
      HEAP32[(($tt_9)>>2)]=3;
      var $15=$n_addr;
      $retval=$15;
      label = 8; break;
    case 7: 
      $retval=0;
      label = 8; break;
    case 8: 
      var $16=$retval;
      STACKTOP = __stackBase__;
      Module.print(INDENT + 'Exiting: _luaV_tonumber');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return $16;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_luaV_tonumber["X"]=1;

function _LoadInt($S) {
  var label = 0;
  var __stackBase__  = STACKTOP; STACKTOP = (STACKTOP + 4)|0; _memset(__stackBase__, 0, 4);
  Module.print(INDENT + ' Entering: _LoadInt: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $S_addr;
      var $x=__stackBase__;
      $S_addr=$S;
      var $0=$S_addr;
      var $1=$x;
      _LoadBlock($0, $1, 4);
      var $2=HEAP32[(($x)>>2)];
      var $cmp=(($2)|0) < 0;
      if ($cmp) { label = 3; break; } else { label = 4; break; }
    case 3: 
      var $3=$S_addr;
      _error($3, ((5244432)|0));

    case 4: 
      var $4=HEAP32[(($x)>>2)];
      STACKTOP = __stackBase__;
      Module.print(INDENT + 'Exiting: _LoadInt');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return $4;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _LoadCode($S, $f) {
  var label = 0;

  Module.print(INDENT + ' Entering: _LoadCode: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $S_addr;
      var $f_addr;
      var $n;
      $S_addr=$S;
      $f_addr=$f;
      var $0=$S_addr;
      var $call=_LoadInt($0);
      $n=$call;
      var $1=$n;
      var $add=((($1)+(1))|0);
      var $cmp=(($add)>>>0) > 1073741823;
      if ($cmp) { label = 3; break; } else { label = 4; break; }
    case 3: 
      var $2=$S_addr;
      var $L=(($2)|0);
      var $3=HEAP32[(($L)>>2)];
      _luaM_toobig($3);

      label = 5; break;
    case 4: 
      var $5=$S_addr;
      var $L1=(($5)|0);
      var $6=HEAP32[(($L1)>>2)];
      var $7=$n;
      var $mul=($7<<2);
      var $call2=_luaM_realloc_($6, 0, 0, $mul);
      var $cond = $call2;label = 5; break;
    case 5: 
      var $cond;
      var $8=$cond;
      var $9=$f_addr;
      var $code=(($9+12)|0);
      HEAP32[(($code)>>2)]=$8;
      var $10=$n;
      var $11=$f_addr;
      var $sizecode=(($11+48)|0);
      HEAP32[(($sizecode)>>2)]=$10;
      var $12=$S_addr;
      var $13=$f_addr;
      var $code3=(($13+12)|0);
      var $14=HEAP32[(($code3)>>2)];
      var $15=$14;
      var $16=$n;
      var $mul4=($16<<2);
      _LoadBlock($12, $15, $mul4);

      Module.print(INDENT + 'Exiting: _LoadCode');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _LoadConstants($S, $f) {
  var label = 0;

  Module.print(INDENT + ' Entering: _LoadConstants: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $S_addr;
      var $f_addr;
      var $i;
      var $n;
      var $o;
      var $t;
      var $io;
      var $io16;
      var $io22;
      var $x_;
      $S_addr=$S;
      $f_addr=$f;
      var $0=$S_addr;
      var $call=_LoadInt($0);
      $n=$call;
      var $1=$n;
      var $add=((($1)+(1))|0);
      var $cmp=(($add)>>>0) > 357913941;
      if ($cmp) { label = 3; break; } else { label = 4; break; }
    case 3: 
      var $2=$S_addr;
      var $L=(($2)|0);
      var $3=HEAP32[(($L)>>2)];
      _luaM_toobig($3);

      label = 5; break;
    case 4: 
      var $5=$S_addr;
      var $L1=(($5)|0);
      var $6=HEAP32[(($L1)>>2)];
      var $7=$n;
      var $mul=((($7)*(12))&-1);
      var $call2=_luaM_realloc_($6, 0, 0, $mul);
      var $cond = $call2;label = 5; break;
    case 5: 
      var $cond;
      var $8=$cond;
      var $9=$f_addr;
      var $k=(($9+8)|0);
      HEAP32[(($k)>>2)]=$8;
      var $10=$n;
      var $11=$f_addr;
      var $sizek=(($11+44)|0);
      HEAP32[(($sizek)>>2)]=$10;
      $i=0;
      label = 6; break;
    case 6: 
      var $12=$i;
      var $13=$n;
      var $cmp3=(($12)|0) < (($13)|0);
      if ($cmp3) { label = 7; break; } else { label = 9; break; }
    case 7: 
      var $14=$i;
      var $15=$f_addr;
      var $k4=(($15+8)|0);
      var $16=HEAP32[(($k4)>>2)];
      var $arrayidx=(($16+((($14)*(12))&-1))|0);
      var $tt_=(($arrayidx+8)|0);
      HEAP32[(($tt_)>>2)]=0;
      label = 8; break;
    case 8: 
      var $17=$i;
      var $inc=((($17)+(1))|0);
      $i=$inc;
      label = 6; break;
    case 9: 
      $i=0;
      label = 10; break;
    case 10: 
      var $18=$i;
      var $19=$n;
      var $cmp6=(($18)|0) < (($19)|0);
      if ($cmp6) { label = 11; break; } else { label = 19; break; }
    case 11: 
      var $20=$i;
      var $21=$f_addr;
      var $k8=(($21+8)|0);
      var $22=HEAP32[(($k8)>>2)];
      var $arrayidx9=(($22+((($20)*(12))&-1))|0);
      $o=$arrayidx9;
      var $23=$S_addr;
      var $call10=_LoadChar($23);
      $t=$call10;
      var $24=$t;
      if ((($24)|0)==0) {
        label = 12; break;
      }
      else if ((($24)|0)==1) {
        label = 13; break;
      }
      else if ((($24)|0)==3) {
        label = 14; break;
      }
      else if ((($24)|0)==4) {
        label = 15; break;
      }
      else {
      label = 16; break;
      }
      
    case 12: 
      var $25=$o;
      var $tt_11=(($25+8)|0);
      HEAP32[(($tt_11)>>2)]=0;
      label = 17; break;
    case 13: 
      var $26=$o;
      $io=$26;
      var $27=$S_addr;
      var $call13=_LoadChar($27);
      var $28=$io;
      var $value_=(($28)|0);
      var $b=$value_;
      HEAP32[(($b)>>2)]=$call13;
      var $29=$io;
      var $tt_14=(($29+8)|0);
      HEAP32[(($tt_14)>>2)]=1;
      label = 17; break;
    case 14: 
      var $30=$o;
      $io16=$30;
      var $31=$S_addr;
      var $call17=_LoadNumber($31);
      var $32=$io16;
      var $value_18=(($32)|0);
      var $n19=$value_18;
      (HEAPF64[(tempDoublePtr)>>3]=$call17,HEAP32[(($n19)>>2)]=HEAP32[((tempDoublePtr)>>2)],HEAP32[((($n19)+(4))>>2)]=HEAP32[(((tempDoublePtr)+(4))>>2)]);
      var $33=$io16;
      var $tt_20=(($33+8)|0);
      HEAP32[(($tt_20)>>2)]=3;
      label = 17; break;
    case 15: 
      var $34=$o;
      $io22=$34;
      var $35=$S_addr;
      var $call23=_LoadString($35);
      $x_=$call23;
      var $36=$x_;
      var $37=$36;
      var $38=$io22;
      var $value_24=(($38)|0);
      var $gc=$value_24;
      HEAP32[(($gc)>>2)]=$37;
      var $39=$x_;
      var $tsv=$39;
      var $tt=(($tsv+4)|0);
      var $40=HEAP8[($tt)];
      var $conv=(($40)&255);
      var $or=$conv | 64;
      var $41=$io22;
      var $tt_25=(($41+8)|0);
      HEAP32[(($tt_25)>>2)]=$or;
      label = 17; break;
    case 16: 
      label = 17; break;
    case 17: 
      label = 18; break;
    case 18: 
      var $42=$i;
      var $inc27=((($42)+(1))|0);
      $i=$inc27;
      label = 10; break;
    case 19: 
      var $43=$S_addr;
      var $call29=_LoadInt($43);
      $n=$call29;
      var $44=$n;
      var $add30=((($44)+(1))|0);
      var $cmp31=(($add30)>>>0) > 1073741823;
      if ($cmp31) { label = 20; break; } else { label = 21; break; }
    case 20: 
      var $45=$S_addr;
      var $L34=(($45)|0);
      var $46=HEAP32[(($L34)>>2)];
      _luaM_toobig($46);

      label = 22; break;
    case 21: 
      var $48=$S_addr;
      var $L36=(($48)|0);
      var $49=HEAP32[(($L36)>>2)];
      var $50=$n;
      var $mul37=($50<<2);
      var $call38=_luaM_realloc_($49, 0, 0, $mul37);
      var $cond40 = $call38;label = 22; break;
    case 22: 
      var $cond40;
      var $51=$cond40;
      var $52=$f_addr;
      var $p=(($52+16)|0);
      HEAP32[(($p)>>2)]=$51;
      var $53=$n;
      var $54=$f_addr;
      var $sizep=(($54+56)|0);
      HEAP32[(($sizep)>>2)]=$53;
      $i=0;
      label = 23; break;
    case 23: 
      var $55=$i;
      var $56=$n;
      var $cmp42=(($55)|0) < (($56)|0);
      if ($cmp42) { label = 24; break; } else { label = 26; break; }
    case 24: 
      var $57=$i;
      var $58=$f_addr;
      var $p45=(($58+16)|0);
      var $59=HEAP32[(($p45)>>2)];
      var $arrayidx46=(($59+($57<<2))|0);
      HEAP32[(($arrayidx46)>>2)]=0;
      label = 25; break;
    case 25: 
      var $60=$i;
      var $inc48=((($60)+(1))|0);
      $i=$inc48;
      label = 23; break;
    case 26: 
      $i=0;
      label = 27; break;
    case 27: 
      var $61=$i;
      var $62=$n;
      var $cmp51=(($61)|0) < (($62)|0);
      if ($cmp51) { label = 28; break; } else { label = 30; break; }
    case 28: 
      var $63=$S_addr;
      var $L54=(($63)|0);
      var $64=HEAP32[(($L54)>>2)];
      var $call55=_luaF_newproto($64);
      var $65=$i;
      var $66=$f_addr;
      var $p56=(($66+16)|0);
      var $67=HEAP32[(($p56)>>2)];
      var $arrayidx57=(($67+($65<<2))|0);
      HEAP32[(($arrayidx57)>>2)]=$call55;
      var $68=$S_addr;
      var $69=$i;
      var $70=$f_addr;
      var $p58=(($70+16)|0);
      var $71=HEAP32[(($p58)>>2)];
      var $arrayidx59=(($71+($69<<2))|0);
      var $72=HEAP32[(($arrayidx59)>>2)];
      _LoadFunction($68, $72);
      label = 29; break;
    case 29: 
      var $73=$i;
      var $inc61=((($73)+(1))|0);
      $i=$inc61;
      label = 27; break;
    case 30: 

      Module.print(INDENT + 'Exiting: _LoadConstants');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_LoadConstants["X"]=1;

function _LoadUpvalues($S, $f) {
  var label = 0;

  Module.print(INDENT + ' Entering: _LoadUpvalues: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $S_addr;
      var $f_addr;
      var $i;
      var $n;
      $S_addr=$S;
      $f_addr=$f;
      var $0=$S_addr;
      var $call=_LoadInt($0);
      $n=$call;
      var $1=$n;
      var $add=((($1)+(1))|0);
      var $cmp=(($add)>>>0) > 536870911;
      if ($cmp) { label = 3; break; } else { label = 4; break; }
    case 3: 
      var $2=$S_addr;
      var $L=(($2)|0);
      var $3=HEAP32[(($L)>>2)];
      _luaM_toobig($3);

      label = 5; break;
    case 4: 
      var $5=$S_addr;
      var $L1=(($5)|0);
      var $6=HEAP32[(($L1)>>2)];
      var $7=$n;
      var $mul=($7<<3);
      var $call2=_luaM_realloc_($6, 0, 0, $mul);
      var $cond = $call2;label = 5; break;
    case 5: 
      var $cond;
      var $8=$cond;
      var $9=$f_addr;
      var $upvalues=(($9+28)|0);
      HEAP32[(($upvalues)>>2)]=$8;
      var $10=$n;
      var $11=$f_addr;
      var $sizeupvalues=(($11+40)|0);
      HEAP32[(($sizeupvalues)>>2)]=$10;
      $i=0;
      label = 6; break;
    case 6: 
      var $12=$i;
      var $13=$n;
      var $cmp3=(($12)|0) < (($13)|0);
      if ($cmp3) { label = 7; break; } else { label = 9; break; }
    case 7: 
      var $14=$i;
      var $15=$f_addr;
      var $upvalues4=(($15+28)|0);
      var $16=HEAP32[(($upvalues4)>>2)];
      var $arrayidx=(($16+($14<<3))|0);
      var $name=(($arrayidx)|0);
      HEAP32[(($name)>>2)]=0;
      label = 8; break;
    case 8: 
      var $17=$i;
      var $inc=((($17)+(1))|0);
      $i=$inc;
      label = 6; break;
    case 9: 
      $i=0;
      label = 10; break;
    case 10: 
      var $18=$i;
      var $19=$n;
      var $cmp6=(($18)|0) < (($19)|0);
      if ($cmp6) { label = 11; break; } else { label = 13; break; }
    case 11: 
      var $20=$S_addr;
      var $call8=_LoadChar($20);
      var $conv=(($call8) & 255);
      var $21=$i;
      var $22=$f_addr;
      var $upvalues9=(($22+28)|0);
      var $23=HEAP32[(($upvalues9)>>2)];
      var $arrayidx10=(($23+($21<<3))|0);
      var $instack=(($arrayidx10+4)|0);
      HEAP8[($instack)]=$conv;
      var $24=$S_addr;
      var $call11=_LoadChar($24);
      var $conv12=(($call11) & 255);
      var $25=$i;
      var $26=$f_addr;
      var $upvalues13=(($26+28)|0);
      var $27=HEAP32[(($upvalues13)>>2)];
      var $arrayidx14=(($27+($25<<3))|0);
      var $idx=(($arrayidx14+5)|0);
      HEAP8[($idx)]=$conv12;
      label = 12; break;
    case 12: 
      var $28=$i;
      var $inc16=((($28)+(1))|0);
      $i=$inc16;
      label = 10; break;
    case 13: 

      Module.print(INDENT + 'Exiting: _LoadUpvalues');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_LoadUpvalues["X"]=1;

function _LoadDebug($S, $f) {
  var label = 0;

  Module.print(INDENT + ' Entering: _LoadDebug: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $S_addr;
      var $f_addr;
      var $i;
      var $n;
      $S_addr=$S;
      $f_addr=$f;
      var $0=$S_addr;
      var $call=_LoadString($0);
      var $1=$f_addr;
      var $source=(($1+36)|0);
      HEAP32[(($source)>>2)]=$call;
      var $2=$S_addr;
      var $call1=_LoadInt($2);
      $n=$call1;
      var $3=$n;
      var $add=((($3)+(1))|0);
      var $cmp=(($add)>>>0) > 1073741823;
      if ($cmp) { label = 3; break; } else { label = 4; break; }
    case 3: 
      var $4=$S_addr;
      var $L=(($4)|0);
      var $5=HEAP32[(($L)>>2)];
      _luaM_toobig($5);

      label = 5; break;
    case 4: 
      var $7=$S_addr;
      var $L2=(($7)|0);
      var $8=HEAP32[(($L2)>>2)];
      var $9=$n;
      var $mul=($9<<2);
      var $call3=_luaM_realloc_($8, 0, 0, $mul);
      var $cond = $call3;label = 5; break;
    case 5: 
      var $cond;
      var $10=$cond;
      var $11=$f_addr;
      var $lineinfo=(($11+20)|0);
      HEAP32[(($lineinfo)>>2)]=$10;
      var $12=$n;
      var $13=$f_addr;
      var $sizelineinfo=(($13+52)|0);
      HEAP32[(($sizelineinfo)>>2)]=$12;
      var $14=$S_addr;
      var $15=$f_addr;
      var $lineinfo4=(($15+20)|0);
      var $16=HEAP32[(($lineinfo4)>>2)];
      var $17=$16;
      var $18=$n;
      var $mul5=($18<<2);
      _LoadBlock($14, $17, $mul5);
      var $19=$S_addr;
      var $call6=_LoadInt($19);
      $n=$call6;
      var $20=$n;
      var $add7=((($20)+(1))|0);
      var $cmp8=(($add7)>>>0) > 357913941;
      if ($cmp8) { label = 6; break; } else { label = 7; break; }
    case 6: 
      var $21=$S_addr;
      var $L10=(($21)|0);
      var $22=HEAP32[(($L10)>>2)];
      _luaM_toobig($22);

      label = 8; break;
    case 7: 
      var $24=$S_addr;
      var $L12=(($24)|0);
      var $25=HEAP32[(($L12)>>2)];
      var $26=$n;
      var $mul13=((($26)*(12))&-1);
      var $call14=_luaM_realloc_($25, 0, 0, $mul13);
      var $cond16 = $call14;label = 8; break;
    case 8: 
      var $cond16;
      var $27=$cond16;
      var $28=$f_addr;
      var $locvars=(($28+24)|0);
      HEAP32[(($locvars)>>2)]=$27;
      var $29=$n;
      var $30=$f_addr;
      var $sizelocvars=(($30+60)|0);
      HEAP32[(($sizelocvars)>>2)]=$29;
      $i=0;
      label = 9; break;
    case 9: 
      var $31=$i;
      var $32=$n;
      var $cmp17=(($31)|0) < (($32)|0);
      if ($cmp17) { label = 10; break; } else { label = 12; break; }
    case 10: 
      var $33=$i;
      var $34=$f_addr;
      var $locvars18=(($34+24)|0);
      var $35=HEAP32[(($locvars18)>>2)];
      var $arrayidx=(($35+((($33)*(12))&-1))|0);
      var $varname=(($arrayidx)|0);
      HEAP32[(($varname)>>2)]=0;
      label = 11; break;
    case 11: 
      var $36=$i;
      var $inc=((($36)+(1))|0);
      $i=$inc;
      label = 9; break;
    case 12: 
      $i=0;
      label = 13; break;
    case 13: 
      var $37=$i;
      var $38=$n;
      var $cmp20=(($37)|0) < (($38)|0);
      if ($cmp20) { label = 14; break; } else { label = 16; break; }
    case 14: 
      var $39=$S_addr;
      var $call22=_LoadString($39);
      var $40=$i;
      var $41=$f_addr;
      var $locvars23=(($41+24)|0);
      var $42=HEAP32[(($locvars23)>>2)];
      var $arrayidx24=(($42+((($40)*(12))&-1))|0);
      var $varname25=(($arrayidx24)|0);
      HEAP32[(($varname25)>>2)]=$call22;
      var $43=$S_addr;
      var $call26=_LoadInt($43);
      var $44=$i;
      var $45=$f_addr;
      var $locvars27=(($45+24)|0);
      var $46=HEAP32[(($locvars27)>>2)];
      var $arrayidx28=(($46+((($44)*(12))&-1))|0);
      var $startpc=(($arrayidx28+4)|0);
      HEAP32[(($startpc)>>2)]=$call26;
      var $47=$S_addr;
      var $call29=_LoadInt($47);
      var $48=$i;
      var $49=$f_addr;
      var $locvars30=(($49+24)|0);
      var $50=HEAP32[(($locvars30)>>2)];
      var $arrayidx31=(($50+((($48)*(12))&-1))|0);
      var $endpc=(($arrayidx31+8)|0);
      HEAP32[(($endpc)>>2)]=$call29;
      label = 15; break;
    case 15: 
      var $51=$i;
      var $inc33=((($51)+(1))|0);
      $i=$inc33;
      label = 13; break;
    case 16: 
      var $52=$S_addr;
      var $call35=_LoadInt($52);
      $n=$call35;
      $i=0;
      label = 17; break;
    case 17: 
      var $53=$i;
      var $54=$n;
      var $cmp37=(($53)|0) < (($54)|0);
      if ($cmp37) { label = 18; break; } else { label = 20; break; }
    case 18: 
      var $55=$S_addr;
      var $call39=_LoadString($55);
      var $56=$i;
      var $57=$f_addr;
      var $upvalues=(($57+28)|0);
      var $58=HEAP32[(($upvalues)>>2)];
      var $arrayidx40=(($58+($56<<3))|0);
      var $name=(($arrayidx40)|0);
      HEAP32[(($name)>>2)]=$call39;
      label = 19; break;
    case 19: 
      var $59=$i;
      var $inc42=((($59)+(1))|0);
      $i=$inc42;
      label = 17; break;
    case 20: 

      Module.print(INDENT + 'Exiting: _LoadDebug');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_LoadDebug["X"]=1;

function _LoadBlock($S, $b, $size) {
  var label = 0;

  Module.print(INDENT + ' Entering: _LoadBlock: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $S_addr;
      var $b_addr;
      var $size_addr;
      $S_addr=$S;
      $b_addr=$b;
      $size_addr=$size;
      var $0=$S_addr;
      var $Z=(($0+4)|0);
      var $1=HEAP32[(($Z)>>2)];
      var $2=$b_addr;
      var $3=$size_addr;
      var $call=_luaZ_read($1, $2, $3);
      var $cmp=(($call)|0)!=0;
      if ($cmp) { label = 3; break; } else { label = 4; break; }
    case 3: 
      var $4=$S_addr;
      _error($4, ((5244684)|0));

    case 4: 

      Module.print(INDENT + 'Exiting: _LoadBlock');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _error($S, $why) {
  var label = 0;
  var __stackBase__  = STACKTOP; _memset(__stackBase__, 0, 0);
  Module.print(INDENT + ' Entering: _error: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $S_addr;
      var $why_addr;
      $S_addr=$S;
      $why_addr=$why;
      var $0=$S_addr;
      var $L=(($0)|0);
      var $1=HEAP32[(($L)>>2)];
      var $2=$S_addr;
      var $name=(($2+12)|0);
      var $3=HEAP32[(($name)>>2)];
      var $4=$why_addr;
      var $call=_luaO_pushfstring($1, ((5244548)|0), (tempInt=STACKTOP,_memset(STACKTOP, 0, 8),STACKTOP = (STACKTOP + 8)|0,HEAP32[((tempInt)>>2)]=$3,HEAP32[(((tempInt)+(4))>>2)]=$4,tempInt));
      var $5=$S_addr;
      var $L1=(($5)|0);
      var $6=HEAP32[(($L1)>>2)];
      _luaD_throw($6, 3);

    case 3: 
      STACKTOP = __stackBase__;
      Module.print(INDENT + 'Exiting: _error');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _luaV_tostring($L, $obj) {
  var label = 0;
  var __stackBase__  = STACKTOP; STACKTOP = (STACKTOP + 32)|0; _memset(__stackBase__, 0, 32);
  Module.print(INDENT + ' Entering: _luaV_tostring: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $retval;
      var $L_addr;
      var $obj_addr;
      var $s=__stackBase__;
      var $n;
      var $l;
      var $io;
      var $x_;
      $L_addr=$L;
      $obj_addr=$obj;
      var $0=$obj_addr;
      var $tt_=(($0+8)|0);
      var $1=HEAP32[(($tt_)>>2)];
      var $cmp=(($1)|0)==3;
      if ($cmp) { label = 4; break; } else { label = 3; break; }
    case 3: 
      $retval=0;
      label = 5; break;
    case 4: 
      var $2=$obj_addr;
      var $value_=(($2)|0);
      var $n1=$value_;
      var $3=(HEAP32[((tempDoublePtr)>>2)]=HEAP32[(($n1)>>2)],HEAP32[(((tempDoublePtr)+(4))>>2)]=HEAP32[((($n1)+(4))>>2)],HEAPF64[(tempDoublePtr)>>3]);
      $n=$3;
      var $arraydecay=(($s)|0);
      var $4=$n;
      var $call=_sprintf($arraydecay, ((5245384)|0), (tempInt=STACKTOP,_memset(STACKTOP, 0, 8),STACKTOP = (STACKTOP + 8)|0,(HEAPF64[(tempDoublePtr)>>3]=$4,HEAP32[((tempInt)>>2)]=HEAP32[((tempDoublePtr)>>2)],HEAP32[(((tempInt)+(4))>>2)]=HEAP32[(((tempDoublePtr)+(4))>>2)]),tempInt));
      $l=$call;
      var $5=$obj_addr;
      $io=$5;
      var $6=$L_addr;
      var $arraydecay2=(($s)|0);
      var $7=$l;
      var $call3=_luaS_newlstr($6, $arraydecay2, $7);
      $x_=$call3;
      var $8=$x_;
      var $9=$8;
      var $10=$io;
      var $value_4=(($10)|0);
      var $gc=$value_4;
      HEAP32[(($gc)>>2)]=$9;
      var $11=$x_;
      var $tsv=$11;
      var $tt=(($tsv+4)|0);
      var $12=HEAP8[($tt)];
      var $conv=(($12)&255);
      var $or=$conv | 64;
      var $13=$io;
      var $tt_5=(($13+8)|0);
      HEAP32[(($tt_5)>>2)]=$or;
      $retval=1;
      label = 5; break;
    case 5: 
      var $14=$retval;
      STACKTOP = __stackBase__;
      Module.print(INDENT + 'Exiting: _luaV_tostring');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return $14;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_luaV_tostring["X"]=1;

function _callTM($L, $f, $p1, $p2, $p3, $hasres) {
  var label = 0;

  Module.print(INDENT + ' Entering: _callTM: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $L_addr;
      var $f_addr;
      var $p1_addr;
      var $p2_addr;
      var $p3_addr;
      var $hasres_addr;
      var $result;
      var $io2;
      var $io1;
      var $io23;
      var $io14;
      var $io211;
      var $io112;
      var $io219;
      var $io120;
      var $io238;
      var $io141;
      $L_addr=$L;
      $f_addr=$f;
      $p1_addr=$p1;
      $p2_addr=$p2;
      $p3_addr=$p3;
      $hasres_addr=$hasres;
      var $0=$p3_addr;
      var $1=$0;
      var $2=$L_addr;
      var $stack=(($2+28)|0);
      var $3=HEAP32[(($stack)>>2)];
      var $4=$3;
      var $sub_ptr_lhs_cast=$1;
      var $sub_ptr_rhs_cast=$4;
      var $sub_ptr_sub=((($sub_ptr_lhs_cast)-($sub_ptr_rhs_cast))|0);
      $result=$sub_ptr_sub;
      var $5=$f_addr;
      $io2=$5;
      var $6=$L_addr;
      var $top=(($6+8)|0);
      var $7=HEAP32[(($top)>>2)];
      var $incdec_ptr=(($7+12)|0);
      HEAP32[(($top)>>2)]=$incdec_ptr;
      $io1=$7;
      var $8=$io1;
      var $value_=(($8)|0);
      var $9=$io2;
      var $value_1=(($9)|0);
      var $10=$value_;
      var $11=$value_1;
      HEAP32[(($10)>>2)]=HEAP32[(($11)>>2)];HEAP32[((($10)+(4))>>2)]=HEAP32[((($11)+(4))>>2)];
      var $12=$io2;
      var $tt_=(($12+8)|0);
      var $13=HEAP32[(($tt_)>>2)];
      var $14=$io1;
      var $tt_2=(($14+8)|0);
      HEAP32[(($tt_2)>>2)]=$13;
      var $15=$p1_addr;
      $io23=$15;
      var $16=$L_addr;
      var $top5=(($16+8)|0);
      var $17=HEAP32[(($top5)>>2)];
      var $incdec_ptr6=(($17+12)|0);
      HEAP32[(($top5)>>2)]=$incdec_ptr6;
      $io14=$17;
      var $18=$io14;
      var $value_7=(($18)|0);
      var $19=$io23;
      var $value_8=(($19)|0);
      var $20=$value_7;
      var $21=$value_8;
      HEAP32[(($20)>>2)]=HEAP32[(($21)>>2)];HEAP32[((($20)+(4))>>2)]=HEAP32[((($21)+(4))>>2)];
      var $22=$io23;
      var $tt_9=(($22+8)|0);
      var $23=HEAP32[(($tt_9)>>2)];
      var $24=$io14;
      var $tt_10=(($24+8)|0);
      HEAP32[(($tt_10)>>2)]=$23;
      var $25=$p2_addr;
      $io211=$25;
      var $26=$L_addr;
      var $top13=(($26+8)|0);
      var $27=HEAP32[(($top13)>>2)];
      var $incdec_ptr14=(($27+12)|0);
      HEAP32[(($top13)>>2)]=$incdec_ptr14;
      $io112=$27;
      var $28=$io112;
      var $value_15=(($28)|0);
      var $29=$io211;
      var $value_16=(($29)|0);
      var $30=$value_15;
      var $31=$value_16;
      HEAP32[(($30)>>2)]=HEAP32[(($31)>>2)];HEAP32[((($30)+(4))>>2)]=HEAP32[((($31)+(4))>>2)];
      var $32=$io211;
      var $tt_17=(($32+8)|0);
      var $33=HEAP32[(($tt_17)>>2)];
      var $34=$io112;
      var $tt_18=(($34+8)|0);
      HEAP32[(($tt_18)>>2)]=$33;
      var $35=$hasres_addr;
      var $tobool=(($35)|0)!=0;
      if ($tobool) { label = 4; break; } else { label = 3; break; }
    case 3: 
      var $36=$p3_addr;
      $io219=$36;
      var $37=$L_addr;
      var $top21=(($37+8)|0);
      var $38=HEAP32[(($top21)>>2)];
      var $incdec_ptr22=(($38+12)|0);
      HEAP32[(($top21)>>2)]=$incdec_ptr22;
      $io120=$38;
      var $39=$io120;
      var $value_23=(($39)|0);
      var $40=$io219;
      var $value_24=(($40)|0);
      var $41=$value_23;
      var $42=$value_24;
      HEAP32[(($41)>>2)]=HEAP32[(($42)>>2)];HEAP32[((($41)+(4))>>2)]=HEAP32[((($42)+(4))>>2)];
      var $43=$io219;
      var $tt_25=(($43+8)|0);
      var $44=HEAP32[(($tt_25)>>2)];
      var $45=$io120;
      var $tt_26=(($45+8)|0);
      HEAP32[(($tt_26)>>2)]=$44;
      label = 4; break;
    case 4: 
      var $46=$L_addr;
      var $stack_last=(($46+24)|0);
      var $47=HEAP32[(($stack_last)>>2)];
      var $48=$L_addr;
      var $top27=(($48+8)|0);
      var $49=HEAP32[(($top27)>>2)];
      var $sub_ptr_lhs_cast28=$47;
      var $sub_ptr_rhs_cast29=$49;
      var $sub_ptr_sub30=((($sub_ptr_lhs_cast28)-($sub_ptr_rhs_cast29))|0);
      var $sub_ptr_div=((((($sub_ptr_sub30)|0))/(12))&-1);
      var $cmp=(($sub_ptr_div)|0) <= 0;
      if ($cmp) { label = 5; break; } else { label = 6; break; }
    case 5: 
      var $50=$L_addr;
      _luaD_growstack($50, 0);
      label = 7; break;
    case 6: 
      label = 7; break;
    case 7: 
      var $51=$L_addr;
      var $52=$L_addr;
      var $top33=(($52+8)|0);
      var $53=HEAP32[(($top33)>>2)];
      var $54=$hasres_addr;
      var $sub=(((4)-($54))|0);
      var $idx_neg=(((-$sub))|0);
      var $add_ptr=(($53+((($idx_neg)*(12))&-1))|0);
      var $55=$hasres_addr;
      var $56=$L_addr;
      var $ci=(($56+16)|0);
      var $57=HEAP32[(($ci)>>2)];
      var $callstatus=(($57+18)|0);
      var $58=HEAP8[($callstatus)];
      var $conv=(($58)&255);
      var $and=$conv & 1;
      _luaD_call($51, $add_ptr, $55, $and);
      var $59=$hasres_addr;
      var $tobool34=(($59)|0)!=0;
      if ($tobool34) { label = 8; break; } else { label = 9; break; }
    case 8: 
      var $60=$L_addr;
      var $stack36=(($60+28)|0);
      var $61=HEAP32[(($stack36)>>2)];
      var $62=$61;
      var $63=$result;
      var $add_ptr37=(($62+$63)|0);
      var $64=$add_ptr37;
      $p3_addr=$64;
      var $65=$L_addr;
      var $top39=(($65+8)|0);
      var $66=HEAP32[(($top39)>>2)];
      var $incdec_ptr40=((($66)-(12))|0);
      HEAP32[(($top39)>>2)]=$incdec_ptr40;
      $io238=$incdec_ptr40;
      var $67=$p3_addr;
      $io141=$67;
      var $68=$io141;
      var $value_42=(($68)|0);
      var $69=$io238;
      var $value_43=(($69)|0);
      var $70=$value_42;
      var $71=$value_43;
      HEAP32[(($70)>>2)]=HEAP32[(($71)>>2)];HEAP32[((($70)+(4))>>2)]=HEAP32[((($71)+(4))>>2)];
      var $72=$io238;
      var $tt_44=(($72+8)|0);
      var $73=HEAP32[(($tt_44)>>2)];
      var $74=$io141;
      var $tt_45=(($74+8)|0);
      HEAP32[(($tt_45)>>2)]=$73;
      label = 9; break;
    case 9: 

      Module.print(INDENT + 'Exiting: _callTM');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_callTM["X"]=1;

function _l_strcmp($ls, $rs) {
  var label = 0;

  Module.print(INDENT + ' Entering: _l_strcmp: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $retval;
      var $ls_addr;
      var $rs_addr;
      var $l;
      var $ll;
      var $r;
      var $lr;
      var $temp;
      var $len4;
      $ls_addr=$ls;
      $rs_addr=$rs;
      var $0=$ls_addr;
      var $add_ptr=(($0+16)|0);
      var $1=$add_ptr;
      $l=$1;
      var $2=$ls_addr;
      var $tsv=$2;
      var $len=(($tsv+12)|0);
      var $3=HEAP32[(($len)>>2)];
      $ll=$3;
      var $4=$rs_addr;
      var $add_ptr1=(($4+16)|0);
      var $5=$add_ptr1;
      $r=$5;
      var $6=$rs_addr;
      var $tsv2=$6;
      var $len3=(($tsv2+12)|0);
      var $7=HEAP32[(($len3)>>2)];
      $lr=$7;
      label = 3; break;
    case 3: 
      var $8=$l;
      var $9=$r;
      var $call=_strcmp($8, $9);
      $temp=$call;
      var $10=$temp;
      var $cmp=(($10)|0)!=0;
      if ($cmp) { label = 4; break; } else { label = 5; break; }
    case 4: 
      var $11=$temp;
      $retval=$11;
      label = 12; break;
    case 5: 
      var $12=$l;
      var $call5=_strlen($12);
      $len4=$call5;
      var $13=$len4;
      var $14=$lr;
      var $cmp6=(($13)|0)==(($14)|0);
      if ($cmp6) { label = 6; break; } else { label = 7; break; }
    case 6: 
      var $15=$len4;
      var $16=$ll;
      var $cmp8=(($15)|0)==(($16)|0);
      var $cond=$cmp8 ? 0 : 1;
      $retval=$cond;
      label = 12; break;
    case 7: 
      var $17=$len4;
      var $18=$ll;
      var $cmp10=(($17)|0)==(($18)|0);
      if ($cmp10) { label = 8; break; } else { label = 9; break; }
    case 8: 
      $retval=-1;
      label = 12; break;
    case 9: 
      label = 10; break;
    case 10: 
      var $19=$len4;
      var $inc=((($19)+(1))|0);
      $len4=$inc;
      var $20=$len4;
      var $21=$l;
      var $add_ptr13=(($21+$20)|0);
      $l=$add_ptr13;
      var $22=$len4;
      var $23=$ll;
      var $sub=((($23)-($22))|0);
      $ll=$sub;
      var $24=$len4;
      var $25=$r;
      var $add_ptr14=(($25+$24)|0);
      $r=$add_ptr14;
      var $26=$len4;
      var $27=$lr;
      var $sub15=((($27)-($26))|0);
      $lr=$sub15;
      label = 11; break;
    case 11: 
      label = 3; break;
    case 12: 
      var $28=$retval;

      Module.print(INDENT + 'Exiting: _l_strcmp');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return $28;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_l_strcmp["X"]=1;

function _call_orderTM($L, $p1, $p2, $event) {
  var label = 0;

  Module.print(INDENT + ' Entering: _call_orderTM: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $retval;
      var $L_addr;
      var $p1_addr;
      var $p2_addr;
      var $event_addr;
      $L_addr=$L;
      $p1_addr=$p1;
      $p2_addr=$p2;
      $event_addr=$event;
      var $0=$L_addr;
      var $1=$p1_addr;
      var $2=$p2_addr;
      var $3=$L_addr;
      var $top=(($3+8)|0);
      var $4=HEAP32[(($top)>>2)];
      var $5=$event_addr;
      var $call=_call_binTM($0, $1, $2, $4, $5);
      var $tobool=(($call)|0)!=0;
      if ($tobool) { label = 4; break; } else { label = 3; break; }
    case 3: 
      $retval=-1;
      label = 9; break;
    case 4: 
      var $6=$L_addr;
      var $top1=(($6+8)|0);
      var $7=HEAP32[(($top1)>>2)];
      var $tt_=(($7+8)|0);
      var $8=HEAP32[(($tt_)>>2)];
      var $cmp=(($8)|0)==0;
      if ($cmp) { var $16 = 1;label = 8; break; } else { label = 5; break; }
    case 5: 
      var $9=$L_addr;
      var $top2=(($9+8)|0);
      var $10=HEAP32[(($top2)>>2)];
      var $tt_3=(($10+8)|0);
      var $11=HEAP32[(($tt_3)>>2)];
      var $cmp4=(($11)|0)==1;
      if ($cmp4) { label = 6; break; } else { var $15 = 0;label = 7; break; }
    case 6: 
      var $12=$L_addr;
      var $top5=(($12+8)|0);
      var $13=HEAP32[(($top5)>>2)];
      var $value_=(($13)|0);
      var $b=$value_;
      var $14=HEAP32[(($b)>>2)];
      var $cmp6=(($14)|0)==0;
      var $15 = $cmp6;label = 7; break;
    case 7: 
      var $15;
      var $16 = $15;label = 8; break;
    case 8: 
      var $16;
      var $lnot=$16 ^ 1;
      var $lnot_ext=(($lnot)&1);
      $retval=$lnot_ext;
      label = 9; break;
    case 9: 
      var $17=$retval;

      Module.print(INDENT + 'Exiting: _call_orderTM');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return $17;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_call_orderTM["X"]=1;

function _luaV_gettable($L, $t, $key, $val) {
  var label = 0;
  var __stackBase__  = STACKTOP; _memset(__stackBase__, 0, 0);
  Module.print(INDENT + ' Entering: _luaV_gettable: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $L_addr;
      var $t_addr;
      var $key_addr;
      var $val_addr;
      var $loop;
      var $tm;
      var $h;
      var $res;
      var $io2;
      var $io1;
      $L_addr=$L;
      $t_addr=$t;
      $key_addr=$key;
      $val_addr=$val;
      $loop=0;
      label = 3; break;
    case 3: 
      var $0=$loop;
      var $cmp=(($0)|0) < 100;
      if ($cmp) { label = 4; break; } else { label = 22; break; }
    case 4: 
      var $1=$t_addr;
      var $tt_=(($1+8)|0);
      var $2=HEAP32[(($tt_)>>2)];
      var $cmp1=(($2)|0)==69;
      if ($cmp1) { label = 5; break; } else { label = 15; break; }
    case 5: 
      var $3=$t_addr;
      var $value_=(($3)|0);
      var $gc=$value_;
      var $4=HEAP32[(($gc)>>2)];
      var $h2=$4;
      $h=$h2;
      var $5=$h;
      var $6=$key_addr;
      var $call=_luaH_get($5, $6);
      $res=$call;
      var $7=$res;
      var $tt_3=(($7+8)|0);
      var $8=HEAP32[(($tt_3)>>2)];
      var $cmp4=(($8)|0)==0;
      if ($cmp4) { label = 6; break; } else { label = 13; break; }
    case 6: 
      var $9=$h;
      var $metatable=(($9+8)|0);
      var $10=HEAP32[(($metatable)>>2)];
      var $cmp5=(($10)|0)==0;
      if ($cmp5) { label = 7; break; } else { label = 8; break; }
    case 7: 
      var $cond12 = 0;label = 12; break;
    case 8: 
      var $11=$h;
      var $metatable6=(($11+8)|0);
      var $12=HEAP32[(($metatable6)>>2)];
      var $flags=(($12+6)|0);
      var $13=HEAP8[($flags)];
      var $conv=(($13)&255);
      var $and=$conv & 1;
      var $tobool=(($and)|0)!=0;
      if ($tobool) { label = 9; break; } else { label = 10; break; }
    case 9: 
      var $cond = 0;label = 11; break;
    case 10: 
      var $14=$h;
      var $metatable9=(($14+8)|0);
      var $15=HEAP32[(($metatable9)>>2)];
      var $16=$L_addr;
      var $l_G=(($16+12)|0);
      var $17=HEAP32[(($l_G)>>2)];
      var $tmname=(($17+164)|0);
      var $arrayidx=(($tmname)|0);
      var $18=HEAP32[(($arrayidx)>>2)];
      var $call10=_luaT_gettm($15, 0, $18);
      var $cond = $call10;label = 11; break;
    case 11: 
      var $cond;
      var $cond12 = $cond;label = 12; break;
    case 12: 
      var $cond12;
      $tm=$cond12;
      var $cmp13=(($cond12)|0)==0;
      if ($cmp13) { label = 13; break; } else { label = 14; break; }
    case 13: 
      var $19=$res;
      $io2=$19;
      var $20=$val_addr;
      $io1=$20;
      var $21=$io1;
      var $value_16=(($21)|0);
      var $22=$io2;
      var $value_17=(($22)|0);
      var $23=$value_16;
      var $24=$value_17;
      HEAP32[(($23)>>2)]=HEAP32[(($24)>>2)];HEAP32[((($23)+(4))>>2)]=HEAP32[((($24)+(4))>>2)];
      var $25=$io2;
      var $tt_18=(($25+8)|0);
      var $26=HEAP32[(($tt_18)>>2)];
      var $27=$io1;
      var $tt_19=(($27+8)|0);
      HEAP32[(($tt_19)>>2)]=$26;
      label = 23; break;
    case 14: 
      label = 18; break;
    case 15: 
      var $28=$L_addr;
      var $29=$t_addr;
      var $call20=_luaT_gettmbyobj($28, $29, 0);
      $tm=$call20;
      var $tt_21=(($call20+8)|0);
      var $30=HEAP32[(($tt_21)>>2)];
      var $cmp22=(($30)|0)==0;
      if ($cmp22) { label = 16; break; } else { label = 17; break; }
    case 16: 
      var $31=$L_addr;
      var $32=$t_addr;
      _luaG_typeerror($31, $32, ((5246728)|0));

    case 17: 
      label = 18; break;
    case 18: 
      var $33=$tm;
      var $tt_27=(($33+8)|0);
      var $34=HEAP32[(($tt_27)>>2)];
      var $and28=$34 & 15;
      var $cmp29=(($and28)|0)==6;
      if ($cmp29) { label = 19; break; } else { label = 20; break; }
    case 19: 
      var $35=$L_addr;
      var $36=$tm;
      var $37=$t_addr;
      var $38=$key_addr;
      var $39=$val_addr;
      _callTM($35, $36, $37, $38, $39, 1);
      label = 23; break;
    case 20: 
      var $40=$tm;
      $t_addr=$40;
      label = 21; break;
    case 21: 
      var $41=$loop;
      var $inc=((($41)+(1))|0);
      $loop=$inc;
      label = 3; break;
    case 22: 
      var $42=$L_addr;
      _luaG_runerror($42, ((5245748)|0), (tempInt=STACKTOP,_memset(STACKTOP, 0, 1),STACKTOP = (STACKTOP + 1)|0,STACKTOP = ((((STACKTOP)+3)>>2)<<2),HEAP32[((tempInt)>>2)]=0,tempInt));

    case 23: 
      STACKTOP = __stackBase__;
      Module.print(INDENT + 'Exiting: _luaV_gettable');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_luaV_gettable["X"]=1;

function _luaV_settable($L, $t, $key, $val) {
  var label = 0;
  var __stackBase__  = STACKTOP; _memset(__stackBase__, 0, 0);
  Module.print(INDENT + ' Entering: _luaV_settable: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $L_addr;
      var $t_addr;
      var $key_addr;
      var $val_addr;
      var $loop;
      var $tm;
      var $h;
      var $oldval;
      var $io2;
      var $io1;
      $L_addr=$L;
      $t_addr=$t;
      $key_addr=$key;
      $val_addr=$val;
      $loop=0;
      label = 3; break;
    case 3: 
      var $0=$loop;
      var $cmp=(($0)|0) < 100;
      if ($cmp) { label = 4; break; } else { label = 28; break; }
    case 4: 
      var $1=$t_addr;
      var $tt_=(($1+8)|0);
      var $2=HEAP32[(($tt_)>>2)];
      var $cmp1=(($2)|0)==69;
      if ($cmp1) { label = 5; break; } else { label = 21; break; }
    case 5: 
      var $3=$t_addr;
      var $value_=(($3)|0);
      var $gc=$value_;
      var $4=HEAP32[(($gc)>>2)];
      var $h2=$4;
      $h=$h2;
      var $5=$h;
      var $6=$key_addr;
      var $call=_luaH_get($5, $6);
      $oldval=$call;
      var $7=$oldval;
      var $tt_3=(($7+8)|0);
      var $8=HEAP32[(($tt_3)>>2)];
      var $cmp4=(($8)|0)==0;
      if ($cmp4) { label = 6; break; } else { label = 15; break; }
    case 6: 
      var $9=$h;
      var $metatable=(($9+8)|0);
      var $10=HEAP32[(($metatable)>>2)];
      var $cmp5=(($10)|0)==0;
      if ($cmp5) { label = 7; break; } else { label = 8; break; }
    case 7: 
      var $cond12 = 0;label = 12; break;
    case 8: 
      var $11=$h;
      var $metatable6=(($11+8)|0);
      var $12=HEAP32[(($metatable6)>>2)];
      var $flags=(($12+6)|0);
      var $13=HEAP8[($flags)];
      var $conv=(($13)&255);
      var $and=$conv & 2;
      var $tobool=(($and)|0)!=0;
      if ($tobool) { label = 9; break; } else { label = 10; break; }
    case 9: 
      var $cond = 0;label = 11; break;
    case 10: 
      var $14=$h;
      var $metatable9=(($14+8)|0);
      var $15=HEAP32[(($metatable9)>>2)];
      var $16=$L_addr;
      var $l_G=(($16+12)|0);
      var $17=HEAP32[(($l_G)>>2)];
      var $tmname=(($17+164)|0);
      var $arrayidx=(($tmname+4)|0);
      var $18=HEAP32[(($arrayidx)>>2)];
      var $call10=_luaT_gettm($15, 1, $18);
      var $cond = $call10;label = 11; break;
    case 11: 
      var $cond;
      var $cond12 = $cond;label = 12; break;
    case 12: 
      var $cond12;
      $tm=$cond12;
      var $cmp13=(($cond12)|0)==0;
      if ($cmp13) { label = 13; break; } else { label = 20; break; }
    case 13: 
      var $19=$oldval;
      var $cmp15=(($19)|0)!=5243784;
      if ($cmp15) { label = 15; break; } else { label = 14; break; }
    case 14: 
      var $20=$L_addr;
      var $21=$h;
      var $22=$key_addr;
      var $call18=_luaH_newkey($20, $21, $22);
      $oldval=$call18;
      if (1) { label = 15; break; } else { label = 20; break; }
    case 15: 
      var $23=$val_addr;
      $io2=$23;
      var $24=$oldval;
      $io1=$24;
      var $25=$io1;
      var $value_20=(($25)|0);
      var $26=$io2;
      var $value_21=(($26)|0);
      var $27=$value_20;
      var $28=$value_21;
      HEAP32[(($27)>>2)]=HEAP32[(($28)>>2)];HEAP32[((($27)+(4))>>2)]=HEAP32[((($28)+(4))>>2)];
      var $29=$io2;
      var $tt_22=(($29+8)|0);
      var $30=HEAP32[(($tt_22)>>2)];
      var $31=$io1;
      var $tt_23=(($31+8)|0);
      HEAP32[(($tt_23)>>2)]=$30;
      var $32=$h;
      var $flags24=(($32+6)|0);
      HEAP8[($flags24)]=0;
      var $33=$val_addr;
      var $tt_25=(($33+8)|0);
      var $34=HEAP32[(($tt_25)>>2)];
      var $and26=$34 & 64;
      var $tobool27=(($and26)|0)!=0;
      if ($tobool27) { label = 16; break; } else { label = 19; break; }
    case 16: 
      var $35=$val_addr;
      var $value_29=(($35)|0);
      var $gc30=$value_29;
      var $36=HEAP32[(($gc30)>>2)];
      var $gch=$36;
      var $marked=(($gch+5)|0);
      var $37=HEAP8[($marked)];
      var $conv31=(($37)&255);
      var $and32=$conv31 & 3;
      var $tobool33=(($and32)|0)!=0;
      if ($tobool33) { label = 17; break; } else { label = 19; break; }
    case 17: 
      var $38=$h;
      var $39=$38;
      var $gch35=$39;
      var $marked36=(($gch35+5)|0);
      var $40=HEAP8[($marked36)];
      var $conv37=(($40)&255);
      var $and38=$conv37 & 4;
      var $tobool39=(($and38)|0)!=0;
      if ($tobool39) { label = 18; break; } else { label = 19; break; }
    case 18: 
      var $41=$L_addr;
      var $42=$h;
      var $43=$42;
      _luaC_barrierback_($41, $43);
      label = 19; break;
    case 19: 
      label = 29; break;
    case 20: 
      label = 24; break;
    case 21: 
      var $44=$L_addr;
      var $45=$t_addr;
      var $call42=_luaT_gettmbyobj($44, $45, 1);
      $tm=$call42;
      var $tt_43=(($call42+8)|0);
      var $46=HEAP32[(($tt_43)>>2)];
      var $cmp44=(($46)|0)==0;
      if ($cmp44) { label = 22; break; } else { label = 23; break; }
    case 22: 
      var $47=$L_addr;
      var $48=$t_addr;
      _luaG_typeerror($47, $48, ((5246728)|0));

    case 23: 
      label = 24; break;
    case 24: 
      var $49=$tm;
      var $tt_49=(($49+8)|0);
      var $50=HEAP32[(($tt_49)>>2)];
      var $and50=$50 & 15;
      var $cmp51=(($and50)|0)==6;
      if ($cmp51) { label = 25; break; } else { label = 26; break; }
    case 25: 
      var $51=$L_addr;
      var $52=$tm;
      var $53=$t_addr;
      var $54=$key_addr;
      var $55=$val_addr;
      _callTM($51, $52, $53, $54, $55, 0);
      label = 29; break;
    case 26: 
      var $56=$tm;
      $t_addr=$56;
      label = 27; break;
    case 27: 
      var $57=$loop;
      var $inc=((($57)+(1))|0);
      $loop=$inc;
      label = 3; break;
    case 28: 
      var $58=$L_addr;
      _luaG_runerror($58, ((5245228)|0), (tempInt=STACKTOP,_memset(STACKTOP, 0, 1),STACKTOP = (STACKTOP + 1)|0,STACKTOP = ((((STACKTOP)+3)>>2)<<2),HEAP32[((tempInt)>>2)]=0,tempInt));

    case 29: 
      STACKTOP = __stackBase__;
      Module.print(INDENT + 'Exiting: _luaV_settable');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_luaV_settable["X"]=1;

function _luaV_lessthan($L, $l, $r) {
  var label = 0;

  Module.print(INDENT + ' Entering: _luaV_lessthan: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $retval;
      var $L_addr;
      var $l_addr;
      var $r_addr;
      var $res;
      $L_addr=$L;
      $l_addr=$l;
      $r_addr=$r;
      var $0=$l_addr;
      var $tt_=(($0+8)|0);
      var $1=HEAP32[(($tt_)>>2)];
      var $cmp=(($1)|0)==3;
      if ($cmp) { label = 3; break; } else { label = 5; break; }
    case 3: 
      var $2=$r_addr;
      var $tt_1=(($2+8)|0);
      var $3=HEAP32[(($tt_1)>>2)];
      var $cmp2=(($3)|0)==3;
      if ($cmp2) { label = 4; break; } else { label = 5; break; }
    case 4: 
      var $4=$l_addr;
      var $value_=(($4)|0);
      var $n=$value_;
      var $5=(HEAP32[((tempDoublePtr)>>2)]=HEAP32[(($n)>>2)],HEAP32[(((tempDoublePtr)+(4))>>2)]=HEAP32[((($n)+(4))>>2)],HEAPF64[(tempDoublePtr)>>3]);
      var $6=$r_addr;
      var $value_3=(($6)|0);
      var $n4=$value_3;
      var $7=(HEAP32[((tempDoublePtr)>>2)]=HEAP32[(($n4)>>2)],HEAP32[(((tempDoublePtr)+(4))>>2)]=HEAP32[((($n4)+(4))>>2)],HEAPF64[(tempDoublePtr)>>3]);
      var $cmp5=$5 < $7;
      var $conv=(($cmp5)&1);
      $retval=$conv;
      label = 13; break;
    case 5: 
      var $8=$l_addr;
      var $tt_6=(($8+8)|0);
      var $9=HEAP32[(($tt_6)>>2)];
      var $and=$9 & 15;
      var $cmp7=(($and)|0)==4;
      if ($cmp7) { label = 6; break; } else { label = 8; break; }
    case 6: 
      var $10=$r_addr;
      var $tt_10=(($10+8)|0);
      var $11=HEAP32[(($tt_10)>>2)];
      var $and11=$11 & 15;
      var $cmp12=(($and11)|0)==4;
      if ($cmp12) { label = 7; break; } else { label = 8; break; }
    case 7: 
      var $12=$l_addr;
      var $value_15=(($12)|0);
      var $gc=$value_15;
      var $13=HEAP32[(($gc)>>2)];
      var $ts=$13;
      var $14=$r_addr;
      var $value_16=(($14)|0);
      var $gc17=$value_16;
      var $15=HEAP32[(($gc17)>>2)];
      var $ts18=$15;
      var $call=_l_strcmp($ts, $ts18);
      var $cmp19=(($call)|0) < 0;
      var $conv20=(($cmp19)&1);
      $retval=$conv20;
      label = 13; break;
    case 8: 
      var $16=$L_addr;
      var $17=$l_addr;
      var $18=$r_addr;
      var $call22=_call_orderTM($16, $17, $18, 13);
      $res=$call22;
      var $cmp23=(($call22)|0) < 0;
      if ($cmp23) { label = 9; break; } else { label = 10; break; }
    case 9: 
      var $19=$L_addr;
      var $20=$l_addr;
      var $21=$r_addr;
      _luaG_ordererror($19, $20, $21);

    case 10: 
      label = 11; break;
    case 11: 
      label = 12; break;
    case 12: 
      var $22=$res;
      $retval=$22;
      label = 13; break;
    case 13: 
      var $23=$retval;

      Module.print(INDENT + 'Exiting: _luaV_lessthan');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return $23;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_luaV_lessthan["X"]=1;

function _luaV_equalobj_($L, $t1, $t2) {
  var label = 0;

  Module.print(INDENT + ' Entering: _luaV_equalobj_: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $retval;
      var $L_addr;
      var $t1_addr;
      var $t2_addr;
      var $tm;
      $L_addr=$L;
      $t1_addr=$t1;
      $t2_addr=$t2;
      var $0=$t1_addr;
      var $tt_=(($0+8)|0);
      var $1=HEAP32[(($tt_)>>2)];
      var $and=$1 & 63;
      if ((($and)|0)==0) {
        label = 3; break;
      }
      else if ((($and)|0)==3) {
        label = 4; break;
      }
      else if ((($and)|0)==1) {
        label = 5; break;
      }
      else if ((($and)|0)==2) {
        label = 6; break;
      }
      else if ((($and)|0)==22) {
        label = 7; break;
      }
      else if ((($and)|0)==4) {
        label = 8; break;
      }
      else if ((($and)|0)==20) {
        label = 9; break;
      }
      else if ((($and)|0)==7) {
        label = 10; break;
      }
      else if ((($and)|0)==5) {
        label = 16; break;
      }
      else {
      label = 22; break;
      }
      
    case 3: 
      $retval=1;
      label = 30; break;
    case 4: 
      var $2=$t1_addr;
      var $value_=(($2)|0);
      var $n=$value_;
      var $3=(HEAP32[((tempDoublePtr)>>2)]=HEAP32[(($n)>>2)],HEAP32[(((tempDoublePtr)+(4))>>2)]=HEAP32[((($n)+(4))>>2)],HEAPF64[(tempDoublePtr)>>3]);
      var $4=$t2_addr;
      var $value_2=(($4)|0);
      var $n3=$value_2;
      var $5=(HEAP32[((tempDoublePtr)>>2)]=HEAP32[(($n3)>>2)],HEAP32[(((tempDoublePtr)+(4))>>2)]=HEAP32[((($n3)+(4))>>2)],HEAPF64[(tempDoublePtr)>>3]);
      var $cmp=$3 == $5;
      var $conv=(($cmp)&1);
      $retval=$conv;
      label = 30; break;
    case 5: 
      var $6=$t1_addr;
      var $value_5=(($6)|0);
      var $b=$value_5;
      var $7=HEAP32[(($b)>>2)];
      var $8=$t2_addr;
      var $value_6=(($8)|0);
      var $b7=$value_6;
      var $9=HEAP32[(($b7)>>2)];
      var $cmp8=(($7)|0)==(($9)|0);
      var $conv9=(($cmp8)&1);
      $retval=$conv9;
      label = 30; break;
    case 6: 
      var $10=$t1_addr;
      var $value_11=(($10)|0);
      var $p=$value_11;
      var $11=HEAP32[(($p)>>2)];
      var $12=$t2_addr;
      var $value_12=(($12)|0);
      var $p13=$value_12;
      var $13=HEAP32[(($p13)>>2)];
      var $cmp14=(($11)|0)==(($13)|0);
      var $conv15=(($cmp14)&1);
      $retval=$conv15;
      label = 30; break;
    case 7: 
      var $14=$t1_addr;
      var $value_17=(($14)|0);
      var $f=$value_17;
      var $15=HEAP32[(($f)>>2)];
      var $16=$t2_addr;
      var $value_18=(($16)|0);
      var $f19=$value_18;
      var $17=HEAP32[(($f19)>>2)];
      var $cmp20=(($15)|0)==(($17)|0);
      var $conv21=(($cmp20)&1);
      $retval=$conv21;
      label = 30; break;
    case 8: 
      var $18=$t1_addr;
      var $value_23=(($18)|0);
      var $gc=$value_23;
      var $19=HEAP32[(($gc)>>2)];
      var $ts=$19;
      var $20=$t2_addr;
      var $value_24=(($20)|0);
      var $gc25=$value_24;
      var $21=HEAP32[(($gc25)>>2)];
      var $ts26=$21;
      var $cmp27=(($ts)|0)==(($ts26)|0);
      var $conv28=(($cmp27)&1);
      $retval=$conv28;
      label = 30; break;
    case 9: 
      var $22=$t1_addr;
      var $value_30=(($22)|0);
      var $gc31=$value_30;
      var $23=HEAP32[(($gc31)>>2)];
      var $ts32=$23;
      var $24=$t2_addr;
      var $value_33=(($24)|0);
      var $gc34=$value_33;
      var $25=HEAP32[(($gc34)>>2)];
      var $ts35=$25;
      var $call=_luaS_eqlngstr($ts32, $ts35);
      $retval=$call;
      label = 30; break;
    case 10: 
      var $26=$t1_addr;
      var $value_37=(($26)|0);
      var $gc38=$value_37;
      var $27=HEAP32[(($gc38)>>2)];
      var $u=$27;
      var $uv=$u;
      var $28=$t2_addr;
      var $value_39=(($28)|0);
      var $gc40=$value_39;
      var $29=HEAP32[(($gc40)>>2)];
      var $u41=$29;
      var $uv42=$u41;
      var $cmp43=(($uv)|0)==(($uv42)|0);
      if ($cmp43) { label = 11; break; } else { label = 12; break; }
    case 11: 
      $retval=1;
      label = 30; break;
    case 12: 
      var $30=$L_addr;
      var $cmp45=(($30)|0)==0;
      if ($cmp45) { label = 13; break; } else { label = 14; break; }
    case 13: 
      $retval=0;
      label = 30; break;
    case 14: 
      label = 15; break;
    case 15: 
      var $31=$L_addr;
      var $32=$t1_addr;
      var $value_49=(($32)|0);
      var $gc50=$value_49;
      var $33=HEAP32[(($gc50)>>2)];
      var $u51=$33;
      var $uv52=$u51;
      var $metatable=(($uv52+8)|0);
      var $34=HEAP32[(($metatable)>>2)];
      var $35=$t2_addr;
      var $value_53=(($35)|0);
      var $gc54=$value_53;
      var $36=HEAP32[(($gc54)>>2)];
      var $u55=$36;
      var $uv56=$u55;
      var $metatable57=(($uv56+8)|0);
      var $37=HEAP32[(($metatable57)>>2)];
      var $call58=_get_equalTM($31, $34, $37, 5);
      $tm=$call58;
      label = 23; break;
    case 16: 
      var $38=$t1_addr;
      var $value_60=(($38)|0);
      var $gc61=$value_60;
      var $39=HEAP32[(($gc61)>>2)];
      var $h=$39;
      var $40=$t2_addr;
      var $value_62=(($40)|0);
      var $gc63=$value_62;
      var $41=HEAP32[(($gc63)>>2)];
      var $h64=$41;
      var $cmp65=(($h)|0)==(($h64)|0);
      if ($cmp65) { label = 17; break; } else { label = 18; break; }
    case 17: 
      $retval=1;
      label = 30; break;
    case 18: 
      var $42=$L_addr;
      var $cmp69=(($42)|0)==0;
      if ($cmp69) { label = 19; break; } else { label = 20; break; }
    case 19: 
      $retval=0;
      label = 30; break;
    case 20: 
      label = 21; break;
    case 21: 
      var $43=$L_addr;
      var $44=$t1_addr;
      var $value_74=(($44)|0);
      var $gc75=$value_74;
      var $45=HEAP32[(($gc75)>>2)];
      var $h76=$45;
      var $metatable77=(($h76+8)|0);
      var $46=HEAP32[(($metatable77)>>2)];
      var $47=$t2_addr;
      var $value_78=(($47)|0);
      var $gc79=$value_78;
      var $48=HEAP32[(($gc79)>>2)];
      var $h80=$48;
      var $metatable81=(($h80+8)|0);
      var $49=HEAP32[(($metatable81)>>2)];
      var $call82=_get_equalTM($43, $46, $49, 5);
      $tm=$call82;
      label = 23; break;
    case 22: 
      var $50=$t1_addr;
      var $value_83=(($50)|0);
      var $gc84=$value_83;
      var $51=HEAP32[(($gc84)>>2)];
      var $52=$t2_addr;
      var $value_85=(($52)|0);
      var $gc86=$value_85;
      var $53=HEAP32[(($gc86)>>2)];
      var $cmp87=(($51)|0)==(($53)|0);
      var $conv88=(($cmp87)&1);
      $retval=$conv88;
      label = 30; break;
    case 23: 
      var $54=$tm;
      var $cmp89=(($54)|0)==0;
      if ($cmp89) { label = 24; break; } else { label = 25; break; }
    case 24: 
      $retval=0;
      label = 30; break;
    case 25: 
      var $55=$L_addr;
      var $56=$tm;
      var $57=$t1_addr;
      var $58=$t2_addr;
      var $59=$L_addr;
      var $top=(($59+8)|0);
      var $60=HEAP32[(($top)>>2)];
      _callTM($55, $56, $57, $58, $60, 1);
      var $61=$L_addr;
      var $top93=(($61+8)|0);
      var $62=HEAP32[(($top93)>>2)];
      var $tt_94=(($62+8)|0);
      var $63=HEAP32[(($tt_94)>>2)];
      var $cmp95=(($63)|0)==0;
      if ($cmp95) { var $71 = 1;label = 29; break; } else { label = 26; break; }
    case 26: 
      var $64=$L_addr;
      var $top97=(($64+8)|0);
      var $65=HEAP32[(($top97)>>2)];
      var $tt_98=(($65+8)|0);
      var $66=HEAP32[(($tt_98)>>2)];
      var $cmp99=(($66)|0)==1;
      if ($cmp99) { label = 27; break; } else { var $70 = 0;label = 28; break; }
    case 27: 
      var $67=$L_addr;
      var $top101=(($67+8)|0);
      var $68=HEAP32[(($top101)>>2)];
      var $value_102=(($68)|0);
      var $b103=$value_102;
      var $69=HEAP32[(($b103)>>2)];
      var $cmp104=(($69)|0)==0;
      var $70 = $cmp104;label = 28; break;
    case 28: 
      var $70;
      var $71 = $70;label = 29; break;
    case 29: 
      var $71;
      var $lnot=$71 ^ 1;
      var $lnot_ext=(($lnot)&1);
      $retval=$lnot_ext;
      label = 30; break;
    case 30: 
      var $72=$retval;

      Module.print(INDENT + 'Exiting: _luaV_equalobj_');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return $72;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_luaV_equalobj_["X"]=1;

function _get_equalTM($L, $mt1, $mt2, $event) {
  var label = 0;

  Module.print(INDENT + ' Entering: _get_equalTM: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $retval;
      var $L_addr;
      var $mt1_addr;
      var $mt2_addr;
      var $event_addr;
      var $tm1;
      var $tm2;
      $L_addr=$L;
      $mt1_addr=$mt1;
      $mt2_addr=$mt2;
      $event_addr=$event;
      var $0=$mt1_addr;
      var $cmp=(($0)|0)==0;
      if ($cmp) { label = 3; break; } else { label = 4; break; }
    case 3: 
      var $cond4 = 0;label = 8; break;
    case 4: 
      var $1=$mt1_addr;
      var $flags=(($1+6)|0);
      var $2=HEAP8[($flags)];
      var $conv=(($2)&255);
      var $3=$event_addr;
      var $shl=1 << $3;
      var $and=$conv & $shl;
      var $tobool=(($and)|0)!=0;
      if ($tobool) { label = 5; break; } else { label = 6; break; }
    case 5: 
      var $cond = 0;label = 7; break;
    case 6: 
      var $4=$mt1_addr;
      var $5=$event_addr;
      var $6=$event_addr;
      var $7=$L_addr;
      var $l_G=(($7+12)|0);
      var $8=HEAP32[(($l_G)>>2)];
      var $tmname=(($8+164)|0);
      var $arrayidx=(($tmname+($6<<2))|0);
      var $9=HEAP32[(($arrayidx)>>2)];
      var $call=_luaT_gettm($4, $5, $9);
      var $cond = $call;label = 7; break;
    case 7: 
      var $cond;
      var $cond4 = $cond;label = 8; break;
    case 8: 
      var $cond4;
      $tm1=$cond4;
      var $10=$tm1;
      var $cmp5=(($10)|0)==0;
      if ($cmp5) { label = 9; break; } else { label = 10; break; }
    case 9: 
      $retval=0;
      label = 24; break;
    case 10: 
      var $11=$mt1_addr;
      var $12=$mt2_addr;
      var $cmp7=(($11)|0)==(($12)|0);
      if ($cmp7) { label = 11; break; } else { label = 12; break; }
    case 11: 
      var $13=$tm1;
      $retval=$13;
      label = 24; break;
    case 12: 
      var $14=$mt2_addr;
      var $cmp11=(($14)|0)==0;
      if ($cmp11) { label = 13; break; } else { label = 14; break; }
    case 13: 
      var $cond29 = 0;label = 18; break;
    case 14: 
      var $15=$mt2_addr;
      var $flags15=(($15+6)|0);
      var $16=HEAP8[($flags15)];
      var $conv16=(($16)&255);
      var $17=$event_addr;
      var $shl17=1 << $17;
      var $and18=$conv16 & $shl17;
      var $tobool19=(($and18)|0)!=0;
      if ($tobool19) { label = 15; break; } else { label = 16; break; }
    case 15: 
      var $cond27 = 0;label = 17; break;
    case 16: 
      var $18=$mt2_addr;
      var $19=$event_addr;
      var $20=$event_addr;
      var $21=$L_addr;
      var $l_G22=(($21+12)|0);
      var $22=HEAP32[(($l_G22)>>2)];
      var $tmname23=(($22+164)|0);
      var $arrayidx24=(($tmname23+($20<<2))|0);
      var $23=HEAP32[(($arrayidx24)>>2)];
      var $call25=_luaT_gettm($18, $19, $23);
      var $cond27 = $call25;label = 17; break;
    case 17: 
      var $cond27;
      var $cond29 = $cond27;label = 18; break;
    case 18: 
      var $cond29;
      $tm2=$cond29;
      var $24=$tm2;
      var $cmp30=(($24)|0)==0;
      if ($cmp30) { label = 19; break; } else { label = 20; break; }
    case 19: 
      $retval=0;
      label = 24; break;
    case 20: 
      var $25=$tm1;
      var $tt_=(($25+8)|0);
      var $26=HEAP32[(($tt_)>>2)];
      var $27=$tm2;
      var $tt_34=(($27+8)|0);
      var $28=HEAP32[(($tt_34)>>2)];
      var $cmp35=(($26)|0)==(($28)|0);
      if ($cmp35) { label = 21; break; } else { label = 23; break; }
    case 21: 
      var $29=$tm1;
      var $30=$tm2;
      var $call37=_luaV_equalobj_(0, $29, $30);
      var $tobool38=(($call37)|0)!=0;
      if ($tobool38) { label = 22; break; } else { label = 23; break; }
    case 22: 
      var $31=$tm1;
      $retval=$31;
      label = 24; break;
    case 23: 
      $retval=0;
      label = 24; break;
    case 24: 
      var $32=$retval;

      Module.print(INDENT + 'Exiting: _get_equalTM');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return $32;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_get_equalTM["X"]=1;

function _call_binTM($L, $p1, $p2, $res, $event) {
  var label = 0;

  Module.print(INDENT + ' Entering: _call_binTM: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $retval;
      var $L_addr;
      var $p1_addr;
      var $p2_addr;
      var $res_addr;
      var $event_addr;
      var $tm;
      $L_addr=$L;
      $p1_addr=$p1;
      $p2_addr=$p2;
      $res_addr=$res;
      $event_addr=$event;
      var $0=$L_addr;
      var $1=$p1_addr;
      var $2=$event_addr;
      var $call=_luaT_gettmbyobj($0, $1, $2);
      $tm=$call;
      var $3=$tm;
      var $tt_=(($3+8)|0);
      var $4=HEAP32[(($tt_)>>2)];
      var $cmp=(($4)|0)==0;
      if ($cmp) { label = 3; break; } else { label = 4; break; }
    case 3: 
      var $5=$L_addr;
      var $6=$p2_addr;
      var $7=$event_addr;
      var $call1=_luaT_gettmbyobj($5, $6, $7);
      $tm=$call1;
      label = 4; break;
    case 4: 
      var $8=$tm;
      var $tt_2=(($8+8)|0);
      var $9=HEAP32[(($tt_2)>>2)];
      var $cmp3=(($9)|0)==0;
      if ($cmp3) { label = 5; break; } else { label = 6; break; }
    case 5: 
      $retval=0;
      label = 7; break;
    case 6: 
      var $10=$L_addr;
      var $11=$tm;
      var $12=$p1_addr;
      var $13=$p2_addr;
      var $14=$res_addr;
      _callTM($10, $11, $12, $13, $14, 1);
      $retval=1;
      label = 7; break;
    case 7: 
      var $15=$retval;

      Module.print(INDENT + 'Exiting: _call_binTM');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return $15;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _luaV_lessequal($L, $l, $r) {
  var label = 0;

  Module.print(INDENT + ' Entering: _luaV_lessequal: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $retval;
      var $L_addr;
      var $l_addr;
      var $r_addr;
      var $res;
      $L_addr=$L;
      $l_addr=$l;
      $r_addr=$r;
      var $0=$l_addr;
      var $tt_=(($0+8)|0);
      var $1=HEAP32[(($tt_)>>2)];
      var $cmp=(($1)|0)==3;
      if ($cmp) { label = 3; break; } else { label = 5; break; }
    case 3: 
      var $2=$r_addr;
      var $tt_1=(($2+8)|0);
      var $3=HEAP32[(($tt_1)>>2)];
      var $cmp2=(($3)|0)==3;
      if ($cmp2) { label = 4; break; } else { label = 5; break; }
    case 4: 
      var $4=$l_addr;
      var $value_=(($4)|0);
      var $n=$value_;
      var $5=(HEAP32[((tempDoublePtr)>>2)]=HEAP32[(($n)>>2)],HEAP32[(((tempDoublePtr)+(4))>>2)]=HEAP32[((($n)+(4))>>2)],HEAPF64[(tempDoublePtr)>>3]);
      var $6=$r_addr;
      var $value_3=(($6)|0);
      var $n4=$value_3;
      var $7=(HEAP32[((tempDoublePtr)>>2)]=HEAP32[(($n4)>>2)],HEAP32[(((tempDoublePtr)+(4))>>2)]=HEAP32[((($n4)+(4))>>2)],HEAPF64[(tempDoublePtr)>>3]);
      var $cmp5=$5 <= $7;
      var $conv=(($cmp5)&1);
      $retval=$conv;
      label = 16; break;
    case 5: 
      var $8=$l_addr;
      var $tt_6=(($8+8)|0);
      var $9=HEAP32[(($tt_6)>>2)];
      var $and=$9 & 15;
      var $cmp7=(($and)|0)==4;
      if ($cmp7) { label = 6; break; } else { label = 8; break; }
    case 6: 
      var $10=$r_addr;
      var $tt_10=(($10+8)|0);
      var $11=HEAP32[(($tt_10)>>2)];
      var $and11=$11 & 15;
      var $cmp12=(($and11)|0)==4;
      if ($cmp12) { label = 7; break; } else { label = 8; break; }
    case 7: 
      var $12=$l_addr;
      var $value_15=(($12)|0);
      var $gc=$value_15;
      var $13=HEAP32[(($gc)>>2)];
      var $ts=$13;
      var $14=$r_addr;
      var $value_16=(($14)|0);
      var $gc17=$value_16;
      var $15=HEAP32[(($gc17)>>2)];
      var $ts18=$15;
      var $call=_l_strcmp($ts, $ts18);
      var $cmp19=(($call)|0) <= 0;
      var $conv20=(($cmp19)&1);
      $retval=$conv20;
      label = 16; break;
    case 8: 
      var $16=$L_addr;
      var $17=$l_addr;
      var $18=$r_addr;
      var $call22=_call_orderTM($16, $17, $18, 14);
      $res=$call22;
      var $cmp23=(($call22)|0) >= 0;
      if ($cmp23) { label = 9; break; } else { label = 10; break; }
    case 9: 
      var $19=$res;
      $retval=$19;
      label = 16; break;
    case 10: 
      var $20=$L_addr;
      var $21=$r_addr;
      var $22=$l_addr;
      var $call27=_call_orderTM($20, $21, $22, 13);
      $res=$call27;
      var $cmp28=(($call27)|0) < 0;
      if ($cmp28) { label = 11; break; } else { label = 12; break; }
    case 11: 
      var $23=$L_addr;
      var $24=$l_addr;
      var $25=$r_addr;
      _luaG_ordererror($23, $24, $25);

    case 12: 
      label = 13; break;
    case 13: 
      label = 14; break;
    case 14: 
      label = 15; break;
    case 15: 
      var $26=$res;
      var $tobool=(($26)|0)!=0;
      var $lnot=$tobool ^ 1;
      var $lnot_ext=(($lnot)&1);
      $retval=$lnot_ext;
      label = 16; break;
    case 16: 
      var $27=$retval;

      Module.print(INDENT + 'Exiting: _luaV_lessequal');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return $27;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_luaV_lessequal["X"]=1;

function _luaV_concat($L, $total) {
  var label = 0;
  var __stackBase__  = STACKTOP; _memset(__stackBase__, 0, 0);
  Module.print(INDENT + ' Entering: _luaV_concat: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $L_addr;
      var $total_addr;
      var $top;
      var $n;
      var $io2;
      var $io1;
      var $tl;
      var $buffer;
      var $i;
      var $l;
      var $l83;
      var $io;
      var $x_;
      $L_addr=$L;
      $total_addr=$total;
      label = 3; break;
    case 3: 
      var $0=$L_addr;
      var $top1=(($0+8)|0);
      var $1=HEAP32[(($top1)>>2)];
      $top=$1;
      $n=2;
      var $2=$top;
      var $add_ptr=((($2)-(24))|0);
      var $tt_=(($add_ptr+8)|0);
      var $3=HEAP32[(($tt_)>>2)];
      var $and=$3 & 15;
      var $cmp=(($and)|0)==4;
      if ($cmp) { label = 5; break; } else { label = 4; break; }
    case 4: 
      var $4=$top;
      var $add_ptr2=((($4)-(24))|0);
      var $tt_3=(($add_ptr2+8)|0);
      var $5=HEAP32[(($tt_3)>>2)];
      var $cmp4=(($5)|0)==3;
      if ($cmp4) { label = 5; break; } else { label = 7; break; }
    case 5: 
      var $6=$top;
      var $add_ptr6=((($6)-(12))|0);
      var $tt_7=(($add_ptr6+8)|0);
      var $7=HEAP32[(($tt_7)>>2)];
      var $and8=$7 & 15;
      var $cmp9=(($and8)|0)==4;
      if ($cmp9) { label = 10; break; } else { label = 6; break; }
    case 6: 
      var $8=$L_addr;
      var $9=$top;
      var $add_ptr11=((($9)-(12))|0);
      var $call=_luaV_tostring($8, $add_ptr11);
      var $tobool=(($call)|0)!=0;
      if ($tobool) { label = 10; break; } else { label = 7; break; }
    case 7: 
      var $10=$L_addr;
      var $11=$top;
      var $add_ptr12=((($11)-(24))|0);
      var $12=$top;
      var $add_ptr13=((($12)-(12))|0);
      var $13=$top;
      var $add_ptr14=((($13)-(24))|0);
      var $call15=_call_binTM($10, $add_ptr12, $add_ptr13, $add_ptr14, 15);
      var $tobool16=(($call15)|0)!=0;
      if ($tobool16) { label = 9; break; } else { label = 8; break; }
    case 8: 
      var $14=$L_addr;
      var $15=$top;
      var $add_ptr18=((($15)-(24))|0);
      var $16=$top;
      var $add_ptr19=((($16)-(12))|0);
      _luaG_concaterror($14, $add_ptr18, $add_ptr19);

    case 9: 
      label = 33; break;
    case 10: 
      var $17=$top;
      var $add_ptr20=((($17)-(12))|0);
      var $value_=(($add_ptr20)|0);
      var $gc=$value_;
      var $18=HEAP32[(($gc)>>2)];
      var $ts=$18;
      var $tsv=$ts;
      var $len=(($tsv+12)|0);
      var $19=HEAP32[(($len)>>2)];
      var $cmp21=(($19)|0)==0;
      if ($cmp21) { label = 11; break; } else { label = 14; break; }
    case 11: 
      var $20=$top;
      var $add_ptr23=((($20)-(24))|0);
      var $tt_24=(($add_ptr23+8)|0);
      var $21=HEAP32[(($tt_24)>>2)];
      var $and25=$21 & 15;
      var $cmp26=(($and25)|0)==4;
      if ($cmp26) { var $24 = 1;label = 13; break; } else { label = 12; break; }
    case 12: 
      var $22=$L_addr;
      var $23=$top;
      var $add_ptr27=((($23)-(24))|0);
      var $call28=_luaV_tostring($22, $add_ptr27);
      var $tobool29=(($call28)|0)!=0;
      var $24 = $tobool29;label = 13; break;
    case 13: 
      var $24;
      var $lor_ext=(($24)&1);
      label = 32; break;
    case 14: 
      var $25=$top;
      var $add_ptr31=((($25)-(24))|0);
      var $tt_32=(($add_ptr31+8)|0);
      var $26=HEAP32[(($tt_32)>>2)];
      var $and33=$26 & 15;
      var $cmp34=(($and33)|0)==4;
      if ($cmp34) { label = 15; break; } else { label = 17; break; }
    case 15: 
      var $27=$top;
      var $add_ptr35=((($27)-(24))|0);
      var $value_36=(($add_ptr35)|0);
      var $gc37=$value_36;
      var $28=HEAP32[(($gc37)>>2)];
      var $ts38=$28;
      var $tsv39=$ts38;
      var $len40=(($tsv39+12)|0);
      var $29=HEAP32[(($len40)>>2)];
      var $cmp41=(($29)|0)==0;
      if ($cmp41) { label = 16; break; } else { label = 17; break; }
    case 16: 
      var $30=$top;
      var $add_ptr43=((($30)-(12))|0);
      $io2=$add_ptr43;
      var $31=$top;
      var $add_ptr44=((($31)-(24))|0);
      $io1=$add_ptr44;
      var $32=$io1;
      var $value_45=(($32)|0);
      var $33=$io2;
      var $value_46=(($33)|0);
      var $34=$value_45;
      var $35=$value_46;
      HEAP32[(($34)>>2)]=HEAP32[(($35)>>2)];HEAP32[((($34)+(4))>>2)]=HEAP32[((($35)+(4))>>2)];
      var $36=$io2;
      var $tt_47=(($36+8)|0);
      var $37=HEAP32[(($tt_47)>>2)];
      var $38=$io1;
      var $tt_48=(($38+8)|0);
      HEAP32[(($tt_48)>>2)]=$37;
      label = 31; break;
    case 17: 
      var $39=$top;
      var $add_ptr50=((($39)-(12))|0);
      var $value_51=(($add_ptr50)|0);
      var $gc52=$value_51;
      var $40=HEAP32[(($gc52)>>2)];
      var $ts53=$40;
      var $tsv54=$ts53;
      var $len55=(($tsv54+12)|0);
      var $41=HEAP32[(($len55)>>2)];
      $tl=$41;
      $i=1;
      label = 18; break;
    case 18: 
      var $42=$i;
      var $43=$total_addr;
      var $cmp56=(($42)|0) < (($43)|0);
      if ($cmp56) { label = 19; break; } else { var $51 = 0;label = 22; break; }
    case 19: 
      var $44=$top;
      var $45=$i;
      var $idx_neg=(((-$45))|0);
      var $add_ptr57=(($44+((($idx_neg)*(12))&-1))|0);
      var $add_ptr58=((($add_ptr57)-(12))|0);
      var $tt_59=(($add_ptr58+8)|0);
      var $46=HEAP32[(($tt_59)>>2)];
      var $and60=$46 & 15;
      var $cmp61=(($and60)|0)==4;
      if ($cmp61) { var $50 = 1;label = 21; break; } else { label = 20; break; }
    case 20: 
      var $47=$L_addr;
      var $48=$top;
      var $49=$i;
      var $idx_neg63=(((-$49))|0);
      var $add_ptr64=(($48+((($idx_neg63)*(12))&-1))|0);
      var $add_ptr65=((($add_ptr64)-(12))|0);
      var $call66=_luaV_tostring($47, $add_ptr65);
      var $tobool67=(($call66)|0)!=0;
      var $50 = $tobool67;label = 21; break;
    case 21: 
      var $50;
      var $51 = $50;label = 22; break;
    case 22: 
      var $51;
      if ($51) { label = 23; break; } else { label = 27; break; }
    case 23: 
      var $52=$top;
      var $53=$i;
      var $idx_neg70=(((-$53))|0);
      var $add_ptr71=(($52+((($idx_neg70)*(12))&-1))|0);
      var $add_ptr72=((($add_ptr71)-(12))|0);
      var $value_73=(($add_ptr72)|0);
      var $gc74=$value_73;
      var $54=HEAP32[(($gc74)>>2)];
      var $ts75=$54;
      var $tsv76=$ts75;
      var $len77=(($tsv76+12)|0);
      var $55=HEAP32[(($len77)>>2)];
      $l=$55;
      var $56=$l;
      var $57=$tl;
      var $sub=(((-3)-($57))|0);
      var $cmp78=(($56)>>>0) >= (($sub)>>>0);
      if ($cmp78) { label = 24; break; } else { label = 25; break; }
    case 24: 
      var $58=$L_addr;
      _luaG_runerror($58, ((5244960)|0), (tempInt=STACKTOP,_memset(STACKTOP, 0, 1),STACKTOP = (STACKTOP + 1)|0,STACKTOP = ((((STACKTOP)+3)>>2)<<2),HEAP32[((tempInt)>>2)]=0,tempInt));

    case 25: 
      var $59=$l;
      var $60=$tl;
      var $add=((($60)+($59))|0);
      $tl=$add;
      label = 26; break;
    case 26: 
      var $61=$i;
      var $inc=((($61)+(1))|0);
      $i=$inc;
      label = 18; break;
    case 27: 
      var $62=$L_addr;
      var $63=$L_addr;
      var $l_G=(($63+12)|0);
      var $64=HEAP32[(($l_G)>>2)];
      var $buff=(($64+124)|0);
      var $65=$tl;
      var $call81=_luaZ_openspace($62, $buff, $65);
      $buffer=$call81;
      $tl=0;
      var $66=$i;
      $n=$66;
      label = 28; break;
    case 28: 
      var $67=$top;
      var $68=$i;
      var $idx_neg84=(((-$68))|0);
      var $add_ptr85=(($67+((($idx_neg84)*(12))&-1))|0);
      var $value_86=(($add_ptr85)|0);
      var $gc87=$value_86;
      var $69=HEAP32[(($gc87)>>2)];
      var $ts88=$69;
      var $tsv89=$ts88;
      var $len90=(($tsv89+12)|0);
      var $70=HEAP32[(($len90)>>2)];
      $l83=$70;
      var $71=$buffer;
      var $72=$tl;
      var $add_ptr91=(($71+$72)|0);
      var $73=$top;
      var $74=$i;
      var $idx_neg92=(((-$74))|0);
      var $add_ptr93=(($73+((($idx_neg92)*(12))&-1))|0);
      var $value_94=(($add_ptr93)|0);
      var $gc95=$value_94;
      var $75=HEAP32[(($gc95)>>2)];
      var $ts96=$75;
      var $add_ptr97=(($ts96+16)|0);
      var $76=$add_ptr97;
      var $77=$l83;
      var $mul=$77;
      _memcpy($add_ptr91, $76, $mul);
      var $78=$l83;
      var $79=$tl;
      var $add98=((($79)+($78))|0);
      $tl=$add98;
      label = 29; break;
    case 29: 
      var $80=$i;
      var $dec=((($80)-(1))|0);
      $i=$dec;
      var $cmp99=(($dec)|0) > 0;
      if ($cmp99) { label = 28; break; } else { label = 30; break; }
    case 30: 
      var $81=$top;
      var $82=$n;
      var $idx_neg100=(((-$82))|0);
      var $add_ptr101=(($81+((($idx_neg100)*(12))&-1))|0);
      $io=$add_ptr101;
      var $83=$L_addr;
      var $84=$buffer;
      var $85=$tl;
      var $call102=_luaS_newlstr($83, $84, $85);
      $x_=$call102;
      var $86=$x_;
      var $87=$86;
      var $88=$io;
      var $value_103=(($88)|0);
      var $gc104=$value_103;
      HEAP32[(($gc104)>>2)]=$87;
      var $89=$x_;
      var $tsv105=$89;
      var $tt=(($tsv105+4)|0);
      var $90=HEAP8[($tt)];
      var $conv=(($90)&255);
      var $or=$conv | 64;
      var $91=$io;
      var $tt_106=(($91+8)|0);
      HEAP32[(($tt_106)>>2)]=$or;
      label = 31; break;
    case 31: 
      label = 32; break;
    case 32: 
      label = 33; break;
    case 33: 
      var $92=$n;
      var $sub110=((($92)-(1))|0);
      var $93=$total_addr;
      var $sub111=((($93)-($sub110))|0);
      $total_addr=$sub111;
      var $94=$n;
      var $sub112=((($94)-(1))|0);
      var $95=$L_addr;
      var $top113=(($95+8)|0);
      var $96=HEAP32[(($top113)>>2)];
      var $idx_neg114=(((-$sub112))|0);
      var $add_ptr115=(($96+((($idx_neg114)*(12))&-1))|0);
      HEAP32[(($top113)>>2)]=$add_ptr115;
      label = 34; break;
    case 34: 
      var $97=$total_addr;
      var $cmp117=(($97)|0) > 1;
      if ($cmp117) { label = 3; break; } else { label = 35; break; }
    case 35: 
      STACKTOP = __stackBase__;
      Module.print(INDENT + 'Exiting: _luaV_concat');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_luaV_concat["X"]=1;

function _luaV_finishOp($L) {
  var label = 0;

  Module.print(INDENT + ' Entering: _luaV_finishOp: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $L_addr;
      var $ci;
      var $base;
      var $inst;
      var $op;
      var $io2;
      var $io1;
      var $res;
      var $top42;
      var $b45;
      var $total;
      var $io250;
      var $io151;
      var $io262;
      var $io165;
      $L_addr=$L;
      var $0=$L_addr;
      var $ci1=(($0+16)|0);
      var $1=HEAP32[(($ci1)>>2)];
      $ci=$1;
      var $2=$ci;
      var $u=(($2+24)|0);
      var $l=$u;
      var $base2=(($l)|0);
      var $3=HEAP32[(($base2)>>2)];
      $base=$3;
      var $4=$ci;
      var $u3=(($4+24)|0);
      var $l4=$u3;
      var $savedpc=(($l4+4)|0);
      var $5=HEAP32[(($savedpc)>>2)];
      var $add_ptr=((($5)-(4))|0);
      var $6=HEAP32[(($add_ptr)>>2)];
      $inst=$6;
      var $7=$inst;
      var $shr=$7 >>> 0;
      var $and=$shr & 63;
      $op=$and;
      var $8=$op;
      if ((($8)|0)==13 | (($8)|0)==14 | (($8)|0)==15 | (($8)|0)==16 | (($8)|0)==17 | (($8)|0)==18 | (($8)|0)==19 | (($8)|0)==21 | (($8)|0)==6 | (($8)|0)==7 | (($8)|0)==12) {
        label = 3; break;
      }
      else if ((($8)|0)==26 | (($8)|0)==25 | (($8)|0)==24) {
        label = 4; break;
      }
      else if ((($8)|0)==22) {
        label = 14; break;
      }
      else if ((($8)|0)==34) {
        label = 17; break;
      }
      else if ((($8)|0)==29) {
        label = 18; break;
      }
      else if ((($8)|0)==30 | (($8)|0)==8 | (($8)|0)==10) {
        label = 21; break;
      }
      else {
      label = 22; break;
      }
      
    case 3: 
      var $9=$L_addr;
      var $top=(($9+8)|0);
      var $10=HEAP32[(($top)>>2)];
      var $incdec_ptr=((($10)-(12))|0);
      HEAP32[(($top)>>2)]=$incdec_ptr;
      $io2=$incdec_ptr;
      var $11=$base;
      var $12=$inst;
      var $shr5=$12 >>> 6;
      var $and6=$shr5 & 255;
      var $add_ptr7=(($11+((($and6)*(12))&-1))|0);
      $io1=$add_ptr7;
      var $13=$io1;
      var $value_=(($13)|0);
      var $14=$io2;
      var $value_8=(($14)|0);
      var $15=$value_;
      var $16=$value_8;
      HEAP32[(($15)>>2)]=HEAP32[(($16)>>2)];HEAP32[((($15)+(4))>>2)]=HEAP32[((($16)+(4))>>2)];
      var $17=$io2;
      var $tt_=(($17+8)|0);
      var $18=HEAP32[(($tt_)>>2)];
      var $19=$io1;
      var $tt_9=(($19+8)|0);
      HEAP32[(($tt_9)>>2)]=$18;
      label = 23; break;
    case 4: 
      var $20=$L_addr;
      var $top11=(($20+8)|0);
      var $21=HEAP32[(($top11)>>2)];
      var $add_ptr12=((($21)-(12))|0);
      var $tt_13=(($add_ptr12+8)|0);
      var $22=HEAP32[(($tt_13)>>2)];
      var $cmp=(($22)|0)==0;
      if ($cmp) { var $30 = 1;label = 8; break; } else { label = 5; break; }
    case 5: 
      var $23=$L_addr;
      var $top14=(($23+8)|0);
      var $24=HEAP32[(($top14)>>2)];
      var $add_ptr15=((($24)-(12))|0);
      var $tt_16=(($add_ptr15+8)|0);
      var $25=HEAP32[(($tt_16)>>2)];
      var $cmp17=(($25)|0)==1;
      if ($cmp17) { label = 6; break; } else { var $29 = 0;label = 7; break; }
    case 6: 
      var $26=$L_addr;
      var $top18=(($26+8)|0);
      var $27=HEAP32[(($top18)>>2)];
      var $add_ptr19=((($27)-(12))|0);
      var $value_20=(($add_ptr19)|0);
      var $b=$value_20;
      var $28=HEAP32[(($b)>>2)];
      var $cmp21=(($28)|0)==0;
      var $29 = $cmp21;label = 7; break;
    case 7: 
      var $29;
      var $30 = $29;label = 8; break;
    case 8: 
      var $30;
      var $lnot=$30 ^ 1;
      var $lnot_ext=(($lnot)&1);
      $res=$lnot_ext;
      var $31=$L_addr;
      var $top22=(($31+8)|0);
      var $32=HEAP32[(($top22)>>2)];
      var $incdec_ptr23=((($32)-(12))|0);
      HEAP32[(($top22)>>2)]=$incdec_ptr23;
      var $33=$op;
      var $cmp24=(($33)|0)==26;
      if ($cmp24) { label = 9; break; } else { label = 11; break; }
    case 9: 
      var $34=$L_addr;
      var $35=$base;
      var $36=$inst;
      var $shr25=$36 >>> 23;
      var $and26=$shr25 & 511;
      var $add_ptr27=(($35+((($and26)*(12))&-1))|0);
      var $call=_luaT_gettmbyobj($34, $add_ptr27, 14);
      var $tt_28=(($call+8)|0);
      var $37=HEAP32[(($tt_28)>>2)];
      var $cmp29=(($37)|0)==0;
      if ($cmp29) { label = 10; break; } else { label = 11; break; }
    case 10: 
      var $38=$res;
      var $tobool=(($38)|0)!=0;
      var $lnot30=$tobool ^ 1;
      var $lnot_ext31=(($lnot30)&1);
      $res=$lnot_ext31;
      label = 11; break;
    case 11: 
      var $39=$res;
      var $40=$inst;
      var $shr32=$40 >>> 6;
      var $and33=$shr32 & 255;
      var $cmp34=(($39)|0)!=(($and33)|0);
      if ($cmp34) { label = 12; break; } else { label = 13; break; }
    case 12: 
      var $41=$ci;
      var $u36=(($41+24)|0);
      var $l37=$u36;
      var $savedpc38=(($l37+4)|0);
      var $42=HEAP32[(($savedpc38)>>2)];
      var $incdec_ptr39=(($42+4)|0);
      HEAP32[(($savedpc38)>>2)]=$incdec_ptr39;
      label = 13; break;
    case 13: 
      label = 23; break;
    case 14: 
      var $43=$L_addr;
      var $top43=(($43+8)|0);
      var $44=HEAP32[(($top43)>>2)];
      var $add_ptr44=((($44)-(12))|0);
      $top42=$add_ptr44;
      var $45=$inst;
      var $shr46=$45 >>> 23;
      var $and47=$shr46 & 511;
      $b45=$and47;
      var $46=$top42;
      var $add_ptr48=((($46)-(12))|0);
      var $47=$base;
      var $48=$b45;
      var $add_ptr49=(($47+((($48)*(12))&-1))|0);
      var $sub_ptr_lhs_cast=$add_ptr48;
      var $sub_ptr_rhs_cast=$add_ptr49;
      var $sub_ptr_sub=((($sub_ptr_lhs_cast)-($sub_ptr_rhs_cast))|0);
      var $sub_ptr_div=((((($sub_ptr_sub)|0))/(12))&-1);
      $total=$sub_ptr_div;
      var $49=$top42;
      $io250=$49;
      var $50=$top42;
      var $add_ptr52=((($50)-(24))|0);
      $io151=$add_ptr52;
      var $51=$io151;
      var $value_53=(($51)|0);
      var $52=$io250;
      var $value_54=(($52)|0);
      var $53=$value_53;
      var $54=$value_54;
      HEAP32[(($53)>>2)]=HEAP32[(($54)>>2)];HEAP32[((($53)+(4))>>2)]=HEAP32[((($54)+(4))>>2)];
      var $55=$io250;
      var $tt_55=(($55+8)|0);
      var $56=HEAP32[(($tt_55)>>2)];
      var $57=$io151;
      var $tt_56=(($57+8)|0);
      HEAP32[(($tt_56)>>2)]=$56;
      var $58=$total;
      var $cmp57=(($58)|0) > 1;
      if ($cmp57) { label = 15; break; } else { label = 16; break; }
    case 15: 
      var $59=$top42;
      var $add_ptr59=((($59)-(12))|0);
      var $60=$L_addr;
      var $top60=(($60+8)|0);
      HEAP32[(($top60)>>2)]=$add_ptr59;
      var $61=$L_addr;
      var $62=$total;
      _luaV_concat($61, $62);
      label = 16; break;
    case 16: 
      var $63=$L_addr;
      var $top63=(($63+8)|0);
      var $64=HEAP32[(($top63)>>2)];
      var $add_ptr64=((($64)-(12))|0);
      $io262=$add_ptr64;
      var $65=$ci;
      var $u66=(($65+24)|0);
      var $l67=$u66;
      var $base68=(($l67)|0);
      var $66=HEAP32[(($base68)>>2)];
      var $67=$inst;
      var $shr69=$67 >>> 6;
      var $and70=$shr69 & 255;
      var $add_ptr71=(($66+((($and70)*(12))&-1))|0);
      $io165=$add_ptr71;
      var $68=$io165;
      var $value_72=(($68)|0);
      var $69=$io262;
      var $value_73=(($69)|0);
      var $70=$value_72;
      var $71=$value_73;
      HEAP32[(($70)>>2)]=HEAP32[(($71)>>2)];HEAP32[((($70)+(4))>>2)]=HEAP32[((($71)+(4))>>2)];
      var $72=$io262;
      var $tt_74=(($72+8)|0);
      var $73=HEAP32[(($tt_74)>>2)];
      var $74=$io165;
      var $tt_75=(($74+8)|0);
      HEAP32[(($tt_75)>>2)]=$73;
      var $75=$ci;
      var $top76=(($75+4)|0);
      var $76=HEAP32[(($top76)>>2)];
      var $77=$L_addr;
      var $top77=(($77+8)|0);
      HEAP32[(($top77)>>2)]=$76;
      label = 23; break;
    case 17: 
      var $78=$ci;
      var $top79=(($78+4)|0);
      var $79=HEAP32[(($top79)>>2)];
      var $80=$L_addr;
      var $top80=(($80+8)|0);
      HEAP32[(($top80)>>2)]=$79;
      label = 23; break;
    case 18: 
      var $81=$inst;
      var $shr82=$81 >>> 14;
      var $and83=$shr82 & 511;
      var $sub=((($and83)-(1))|0);
      var $cmp84=(($sub)|0) >= 0;
      if ($cmp84) { label = 19; break; } else { label = 20; break; }
    case 19: 
      var $82=$ci;
      var $top86=(($82+4)|0);
      var $83=HEAP32[(($top86)>>2)];
      var $84=$L_addr;
      var $top87=(($84+8)|0);
      HEAP32[(($top87)>>2)]=$83;
      label = 20; break;
    case 20: 
      label = 23; break;
    case 21: 
      label = 23; break;
    case 22: 
      label = 23; break;
    case 23: 

      Module.print(INDENT + 'Exiting: _luaV_finishOp');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_luaV_finishOp["X"]=1;

function _luaV_objlen($L, $ra, $rb) {
  var label = 0;

  Module.print(INDENT + ' Entering: _luaV_objlen: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $L_addr;
      var $ra_addr;
      var $rb_addr;
      var $tm;
      var $h;
      var $io;
      var $io15;
      $L_addr=$L;
      $ra_addr=$ra;
      $rb_addr=$rb;
      var $0=$rb_addr;
      var $tt_=(($0+8)|0);
      var $1=HEAP32[(($tt_)>>2)];
      var $and=$1 & 15;
      if ((($and)|0)==5) {
        label = 3; break;
      }
      else if ((($and)|0)==4) {
        label = 12; break;
      }
      else {
      label = 13; break;
      }
      
    case 3: 
      var $2=$rb_addr;
      var $value_=(($2)|0);
      var $gc=$value_;
      var $3=HEAP32[(($gc)>>2)];
      var $h1=$3;
      $h=$h1;
      var $4=$h;
      var $metatable=(($4+8)|0);
      var $5=HEAP32[(($metatable)>>2)];
      var $cmp=(($5)|0)==0;
      if ($cmp) { label = 4; break; } else { label = 5; break; }
    case 4: 
      var $cond8 = 0;label = 9; break;
    case 5: 
      var $6=$h;
      var $metatable2=(($6+8)|0);
      var $7=HEAP32[(($metatable2)>>2)];
      var $flags=(($7+6)|0);
      var $8=HEAP8[($flags)];
      var $conv=(($8)&255);
      var $and3=$conv & 16;
      var $tobool=(($and3)|0)!=0;
      if ($tobool) { label = 6; break; } else { label = 7; break; }
    case 6: 
      var $cond = 0;label = 8; break;
    case 7: 
      var $9=$h;
      var $metatable6=(($9+8)|0);
      var $10=HEAP32[(($metatable6)>>2)];
      var $11=$L_addr;
      var $l_G=(($11+12)|0);
      var $12=HEAP32[(($l_G)>>2)];
      var $tmname=(($12+164)|0);
      var $arrayidx=(($tmname+16)|0);
      var $13=HEAP32[(($arrayidx)>>2)];
      var $call=_luaT_gettm($10, 4, $13);
      var $cond = $call;label = 8; break;
    case 8: 
      var $cond;
      var $cond8 = $cond;label = 9; break;
    case 9: 
      var $cond8;
      $tm=$cond8;
      var $14=$tm;
      var $tobool9=(($14)|0)!=0;
      if ($tobool9) { label = 10; break; } else { label = 11; break; }
    case 10: 
      label = 16; break;
    case 11: 
      var $15=$ra_addr;
      $io=$15;
      var $16=$h;
      var $call10=_luaH_getn($16);
      var $conv11=(($call10)|0);
      var $17=$io;
      var $value_12=(($17)|0);
      var $n=$value_12;
      (HEAPF64[(tempDoublePtr)>>3]=$conv11,HEAP32[(($n)>>2)]=HEAP32[((tempDoublePtr)>>2)],HEAP32[((($n)+(4))>>2)]=HEAP32[(((tempDoublePtr)+(4))>>2)]);
      var $18=$io;
      var $tt_13=(($18+8)|0);
      HEAP32[(($tt_13)>>2)]=3;
      label = 17; break;
    case 12: 
      var $19=$ra_addr;
      $io15=$19;
      var $20=$rb_addr;
      var $value_16=(($20)|0);
      var $gc17=$value_16;
      var $21=HEAP32[(($gc17)>>2)];
      var $ts=$21;
      var $tsv=$ts;
      var $len=(($tsv+12)|0);
      var $22=HEAP32[(($len)>>2)];
      var $conv18=(($22)>>>0);
      var $23=$io15;
      var $value_19=(($23)|0);
      var $n20=$value_19;
      (HEAPF64[(tempDoublePtr)>>3]=$conv18,HEAP32[(($n20)>>2)]=HEAP32[((tempDoublePtr)>>2)],HEAP32[((($n20)+(4))>>2)]=HEAP32[(((tempDoublePtr)+(4))>>2)]);
      var $24=$io15;
      var $tt_21=(($24+8)|0);
      HEAP32[(($tt_21)>>2)]=3;
      label = 17; break;
    case 13: 
      var $25=$L_addr;
      var $26=$rb_addr;
      var $call22=_luaT_gettmbyobj($25, $26, 4);
      $tm=$call22;
      var $27=$tm;
      var $tt_23=(($27+8)|0);
      var $28=HEAP32[(($tt_23)>>2)];
      var $cmp24=(($28)|0)==0;
      if ($cmp24) { label = 14; break; } else { label = 15; break; }
    case 14: 
      var $29=$L_addr;
      var $30=$rb_addr;
      _luaG_typeerror($29, $30, ((5244648)|0));

    case 15: 
      label = 16; break;
    case 16: 
      var $31=$L_addr;
      var $32=$tm;
      var $33=$rb_addr;
      var $34=$rb_addr;
      var $35=$ra_addr;
      _callTM($31, $32, $33, $34, $35, 1);
      label = 17; break;
    case 17: 

      Module.print(INDENT + 'Exiting: _luaV_objlen');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_luaV_objlen["X"]=1;

function _luaV_arith($L, $ra, $rb, $rc, $op) {
  var label = 0;
  var __stackBase__  = STACKTOP; STACKTOP = (STACKTOP + 24)|0; _memset(__stackBase__, 0, 24);
  Module.print(INDENT + ' Entering: _luaV_arith: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $L_addr;
      var $ra_addr;
      var $rb_addr;
      var $rc_addr;
      var $op_addr;
      var $tempb=__stackBase__;
      var $tempc=(__stackBase__)+(12);
      var $b;
      var $c;
      var $res;
      var $io;
      $L_addr=$L;
      $ra_addr=$ra;
      $rb_addr=$rb;
      $rc_addr=$rc;
      $op_addr=$op;
      var $0=$rb_addr;
      var $call=_luaV_tonumber($0, $tempb);
      $b=$call;
      var $cmp=(($call)|0)!=0;
      if ($cmp) { label = 3; break; } else { label = 5; break; }
    case 3: 
      var $1=$rc_addr;
      var $call1=_luaV_tonumber($1, $tempc);
      $c=$call1;
      var $cmp2=(($call1)|0)!=0;
      if ($cmp2) { label = 4; break; } else { label = 5; break; }
    case 4: 
      var $2=$op_addr;
      var $sub=((($2)-(6))|0);
      var $add=(($sub)|0);
      var $3=$b;
      var $value_=(($3)|0);
      var $n=$value_;
      var $4=(HEAP32[((tempDoublePtr)>>2)]=HEAP32[(($n)>>2)],HEAP32[(((tempDoublePtr)+(4))>>2)]=HEAP32[((($n)+(4))>>2)],HEAPF64[(tempDoublePtr)>>3]);
      var $5=$c;
      var $value_3=(($5)|0);
      var $n4=$value_3;
      var $6=(HEAP32[((tempDoublePtr)>>2)]=HEAP32[(($n4)>>2)],HEAP32[(((tempDoublePtr)+(4))>>2)]=HEAP32[((($n4)+(4))>>2)],HEAPF64[(tempDoublePtr)>>3]);
      var $call5=_luaO_arith($add, $4, $6);
      $res=$call5;
      var $7=$ra_addr;
      $io=$7;
      var $8=$res;
      var $9=$io;
      var $value_6=(($9)|0);
      var $n7=$value_6;
      (HEAPF64[(tempDoublePtr)>>3]=$8,HEAP32[(($n7)>>2)]=HEAP32[((tempDoublePtr)>>2)],HEAP32[((($n7)+(4))>>2)]=HEAP32[(((tempDoublePtr)+(4))>>2)]);
      var $10=$io;
      var $tt_=(($10+8)|0);
      HEAP32[(($tt_)>>2)]=3;
      label = 8; break;
    case 5: 
      var $11=$L_addr;
      var $12=$rb_addr;
      var $13=$rc_addr;
      var $14=$ra_addr;
      var $15=$op_addr;
      var $call8=_call_binTM($11, $12, $13, $14, $15);
      var $tobool=(($call8)|0)!=0;
      if ($tobool) { label = 7; break; } else { label = 6; break; }
    case 6: 
      var $16=$L_addr;
      var $17=$rb_addr;
      var $18=$rc_addr;
      _luaG_aritherror($16, $17, $18);

    case 7: 
      label = 8; break;
    case 8: 
      STACKTOP = __stackBase__;
      Module.print(INDENT + 'Exiting: _luaV_arith');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_luaV_arith["X"]=1;

function _luaV_execute($L) {
  var label = 0;
  var __stackBase__  = STACKTOP; _memset(__stackBase__, 0, 0);
  Module.print(INDENT + ' Entering: _luaV_execute: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $L_addr;
      var $ci;
      var $cl;
      var $k;
      var $base;
      var $i;
      var $ra;
      var $io2;
      var $io1;
      var $rb;
      var $io229;
      var $io130;
      var $rb36;
      var $io244;
      var $io145;
      var $io;
      var $b65;
      var $b73;
      var $io276;
      var $io177;
      var $b83;
      var $a;
      var $uv;
      var $io2169;
      var $io1170;
      var $b230;
      var $c;
      var $t;
      var $io235;
      var $rb259;
      var $io2263;
      var $io1264;
      var $rb289;
      var $rc;
      var $nb;
      var $nc;
      var $io331;
      var $rb340;
      var $rc356;
      var $nb380;
      var $nc383;
      var $io386;
      var $rb396;
      var $rc412;
      var $nb436;
      var $nc439;
      var $io442;
      var $rb452;
      var $rc468;
      var $nb492;
      var $nc495;
      var $io498;
      var $rb508;
      var $rc524;
      var $nb548;
      var $nc551;
      var $io554;
      var $rb568;
      var $rc584;
      var $nb608;
      var $nc611;
      var $io614;
      var $rb624;
      var $nb632;
      var $io635;
      var $rb646;
      var $res;
      var $io660;
      var $b672;
      var $c675;
      var $rb678;
      var $io2691;
      var $io1692;
      var $a719;
      var $rb740;
      var $rc756;
      var $a793;
      var $a862;
      var $a931;
      var $a994;
      var $rb1016;
      var $io21055;
      var $io11056;
      var $a1064;
      var $b1086;
      var $nresults;
      var $b1116;
      var $nci;
      var $oci;
      var $nfunc;
      var $ofunc;
      var $lim;
      var $aux;
      var $io21157;
      var $io11159;
      var $b1193;
      var $step;
      var $idx;
      var $limit;
      var $io1248;
      var $io1252;
      var $init;
      var $plimit;
      var $pstep;
      var $io1292;
      var $cb;
      var $io21310;
      var $io11312;
      var $io21318;
      var $io11320;
      var $io21326;
      var $io11327;
      var $io21354;
      var $io11356;
      var $n1370;
      var $c1373;
      var $last;
      var $h;
      var $val;
      var $p1437;
      var $ncl;
      var $io1451;
      var $b1470;
      var $j;
      var $n1474;
      var $io21514;
      var $io11517;
      $L_addr=$L;
      var $0=$L_addr;
      var $ci1=(($0+16)|0);
      var $1=HEAP32[(($ci1)>>2)];
      $ci=$1;
      label = 3; break;
    case 3: 
      var $2=$ci;
      var $func=(($2)|0);
      var $3=HEAP32[(($func)>>2)];
      var $value_=(($3)|0);
      var $gc=$value_;
      var $4=HEAP32[(($gc)>>2)];
      var $cl2=$4;
      var $l=$cl2;
      $cl=$l;
      var $5=$cl;
      var $p=(($5+12)|0);
      var $6=HEAP32[(($p)>>2)];
      var $k3=(($6+8)|0);
      var $7=HEAP32[(($k3)>>2)];
      $k=$7;
      var $8=$ci;
      var $u=(($8+24)|0);
      var $l4=$u;
      var $base5=(($l4)|0);
      var $9=HEAP32[(($base5)>>2)];
      $base=$9;
      label = 4; break;
    case 4: 
      var $10=$ci;
      var $u6=(($10+24)|0);
      var $l7=$u6;
      var $savedpc=(($l7+4)|0);
      var $11=HEAP32[(($savedpc)>>2)];
      var $incdec_ptr=(($11+4)|0);
      HEAP32[(($savedpc)>>2)]=$incdec_ptr;
      var $12=HEAP32[(($11)>>2)];
      $i=$12;
      var $13=$L_addr;
      var $hookmask=(($13+40)|0);
      var $14=HEAP8[($hookmask)];
      var $conv=(($14)&255);
      var $and=$conv & 12;
      var $tobool=(($and)|0)!=0;
      if ($tobool) { label = 5; break; } else { label = 8; break; }
    case 5: 
      var $15=$L_addr;
      var $hookcount=(($15+48)|0);
      var $16=HEAP32[(($hookcount)>>2)];
      var $dec=((($16)-(1))|0);
      HEAP32[(($hookcount)>>2)]=$dec;
      var $cmp=(($dec)|0)==0;
      if ($cmp) { label = 7; break; } else { label = 6; break; }
    case 6: 
      var $17=$L_addr;
      var $hookmask9=(($17+40)|0);
      var $18=HEAP8[($hookmask9)];
      var $conv10=(($18)&255);
      var $and11=$conv10 & 4;
      var $tobool12=(($and11)|0)!=0;
      if ($tobool12) { label = 7; break; } else { label = 8; break; }
    case 7: 
      var $19=$L_addr;
      _traceexec($19);
      var $20=$ci;
      var $u13=(($20+24)|0);
      var $l14=$u13;
      var $base15=(($l14)|0);
      var $21=HEAP32[(($base15)>>2)];
      $base=$21;
      label = 8; break;
    case 8: 
      var $22=$base;
      var $23=$i;
      var $shr=$23 >>> 6;
      var $and16=$shr & 255;
      var $add_ptr=(($22+((($and16)*(12))&-1))|0);
      $ra=$add_ptr;
      var $24=$i;
      var $shr17=$24 >>> 0;
      var $and18=$shr17 & 63;
      if ((($and18)|0)==0) {
        label = 9; break;
      }
      else if ((($and18)|0)==1) {
        label = 10; break;
      }
      else if ((($and18)|0)==2) {
        label = 11; break;
      }
      else if ((($and18)|0)==3) {
        label = 12; break;
      }
      else if ((($and18)|0)==4) {
        label = 15; break;
      }
      else if ((($and18)|0)==5) {
        label = 19; break;
      }
      else if ((($and18)|0)==6) {
        label = 20; break;
      }
      else if ((($and18)|0)==7) {
        label = 24; break;
      }
      else if ((($and18)|0)==8) {
        label = 28; break;
      }
      else if ((($and18)|0)==9) {
        label = 35; break;
      }
      else if ((($and18)|0)==10) {
        label = 40; break;
      }
      else if ((($and18)|0)==11) {
        label = 47; break;
      }
      else if ((($and18)|0)==12) {
        label = 53; break;
      }
      else if ((($and18)|0)==13) {
        label = 57; break;
      }
      else if ((($and18)|0)==14) {
        label = 68; break;
      }
      else if ((($and18)|0)==15) {
        label = 79; break;
      }
      else if ((($and18)|0)==16) {
        label = 90; break;
      }
      else if ((($and18)|0)==17) {
        label = 101; break;
      }
      else if ((($and18)|0)==18) {
        label = 112; break;
      }
      else if ((($and18)|0)==19) {
        label = 123; break;
      }
      else if ((($and18)|0)==20) {
        label = 127; break;
      }
      else if ((($and18)|0)==21) {
        label = 132; break;
      }
      else if ((($and18)|0)==22) {
        label = 133; break;
      }
      else if ((($and18)|0)==23) {
        label = 139; break;
      }
      else if ((($and18)|0)==24) {
        label = 142; break;
      }
      else if ((($and18)|0)==25) {
        label = 156; break;
      }
      else if ((($and18)|0)==26) {
        label = 168; break;
      }
      else if ((($and18)|0)==27) {
        label = 180; break;
      }
      else if ((($and18)|0)==28) {
        label = 192; break;
      }
      else if ((($and18)|0)==29) {
        label = 204; break;
      }
      else if ((($and18)|0)==30) {
        label = 212; break;
      }
      else if ((($and18)|0)==31) {
        label = 224; break;
      }
      else if ((($and18)|0)==32) {
        label = 233; break;
      }
      else if ((($and18)|0)==33) {
        label = 238; break;
      }
      else if ((($and18)|0)==34) {
        label = 250; break;
      }
      else if ((($and18)|0)==35) {
        label = 251; break;
      }
      else if ((($and18)|0)==36) {
        label = 255; break;
      }
      else if ((($and18)|0)==37) {
        label = 270; break;
      }
      else if ((($and18)|0)==38) {
        label = 276; break;
      }
      else if ((($and18)|0)==39) {
        label = 289; break;
      }
      else {
      label = 290; break;
      }
      
    case 9: 
      var $25=$base;
      var $26=$i;
      var $shr19=$26 >>> 23;
      var $and20=$shr19 & 511;
      var $add_ptr21=(($25+((($and20)*(12))&-1))|0);
      $io2=$add_ptr21;
      var $27=$ra;
      $io1=$27;
      var $28=$io1;
      var $value_22=(($28)|0);
      var $29=$io2;
      var $value_23=(($29)|0);
      var $30=$value_22;
      var $31=$value_23;
      HEAP32[(($30)>>2)]=HEAP32[(($31)>>2)];HEAP32[((($30)+(4))>>2)]=HEAP32[((($31)+(4))>>2)];
      var $32=$io2;
      var $tt_=(($32+8)|0);
      var $33=HEAP32[(($tt_)>>2)];
      var $34=$io1;
      var $tt_24=(($34+8)|0);
      HEAP32[(($tt_24)>>2)]=$33;
      label = 290; break;
    case 10: 
      var $35=$k;
      var $36=$i;
      var $shr26=$36 >>> 14;
      var $and27=$shr26 & 262143;
      var $add_ptr28=(($35+((($and27)*(12))&-1))|0);
      $rb=$add_ptr28;
      var $37=$rb;
      $io229=$37;
      var $38=$ra;
      $io130=$38;
      var $39=$io130;
      var $value_31=(($39)|0);
      var $40=$io229;
      var $value_32=(($40)|0);
      var $41=$value_31;
      var $42=$value_32;
      HEAP32[(($41)>>2)]=HEAP32[(($42)>>2)];HEAP32[((($41)+(4))>>2)]=HEAP32[((($42)+(4))>>2)];
      var $43=$io229;
      var $tt_33=(($43+8)|0);
      var $44=HEAP32[(($tt_33)>>2)];
      var $45=$io130;
      var $tt_34=(($45+8)|0);
      HEAP32[(($tt_34)>>2)]=$44;
      label = 290; break;
    case 11: 
      var $46=$k;
      var $47=$ci;
      var $u37=(($47+24)|0);
      var $l38=$u37;
      var $savedpc39=(($l38+4)|0);
      var $48=HEAP32[(($savedpc39)>>2)];
      var $incdec_ptr40=(($48+4)|0);
      HEAP32[(($savedpc39)>>2)]=$incdec_ptr40;
      var $49=HEAP32[(($48)>>2)];
      var $shr41=$49 >>> 6;
      var $and42=$shr41 & 67108863;
      var $add_ptr43=(($46+((($and42)*(12))&-1))|0);
      $rb36=$add_ptr43;
      var $50=$rb36;
      $io244=$50;
      var $51=$ra;
      $io145=$51;
      var $52=$io145;
      var $value_46=(($52)|0);
      var $53=$io244;
      var $value_47=(($53)|0);
      var $54=$value_46;
      var $55=$value_47;
      HEAP32[(($54)>>2)]=HEAP32[(($55)>>2)];HEAP32[((($54)+(4))>>2)]=HEAP32[((($55)+(4))>>2)];
      var $56=$io244;
      var $tt_48=(($56+8)|0);
      var $57=HEAP32[(($tt_48)>>2)];
      var $58=$io145;
      var $tt_49=(($58+8)|0);
      HEAP32[(($tt_49)>>2)]=$57;
      label = 290; break;
    case 12: 
      var $59=$ra;
      $io=$59;
      var $60=$i;
      var $shr51=$60 >>> 23;
      var $and52=$shr51 & 511;
      var $61=$io;
      var $value_53=(($61)|0);
      var $b=$value_53;
      HEAP32[(($b)>>2)]=$and52;
      var $62=$io;
      var $tt_54=(($62+8)|0);
      HEAP32[(($tt_54)>>2)]=1;
      var $63=$i;
      var $shr55=$63 >>> 14;
      var $and56=$shr55 & 511;
      var $tobool57=(($and56)|0)!=0;
      if ($tobool57) { label = 13; break; } else { label = 14; break; }
    case 13: 
      var $64=$ci;
      var $u59=(($64+24)|0);
      var $l60=$u59;
      var $savedpc61=(($l60+4)|0);
      var $65=HEAP32[(($savedpc61)>>2)];
      var $incdec_ptr62=(($65+4)|0);
      HEAP32[(($savedpc61)>>2)]=$incdec_ptr62;
      label = 14; break;
    case 14: 
      label = 290; break;
    case 15: 
      var $66=$i;
      var $shr66=$66 >>> 23;
      var $and67=$shr66 & 511;
      $b65=$and67;
      label = 16; break;
    case 16: 
      var $67=$ra;
      var $incdec_ptr68=(($67+12)|0);
      $ra=$incdec_ptr68;
      var $tt_69=(($67+8)|0);
      HEAP32[(($tt_69)>>2)]=0;
      label = 17; break;
    case 17: 
      var $68=$b65;
      var $dec70=((($68)-(1))|0);
      $b65=$dec70;
      var $tobool71=(($68)|0)!=0;
      if ($tobool71) { label = 16; break; } else { label = 18; break; }
    case 18: 
      label = 290; break;
    case 19: 
      var $69=$i;
      var $shr74=$69 >>> 23;
      var $and75=$shr74 & 511;
      $b73=$and75;
      var $70=$b73;
      var $71=$cl;
      var $upvals=(($71+16)|0);
      var $arrayidx=(($upvals+($70<<2))|0);
      var $72=HEAP32[(($arrayidx)>>2)];
      var $v=(($72+8)|0);
      var $73=HEAP32[(($v)>>2)];
      $io276=$73;
      var $74=$ra;
      $io177=$74;
      var $75=$io177;
      var $value_78=(($75)|0);
      var $76=$io276;
      var $value_79=(($76)|0);
      var $77=$value_78;
      var $78=$value_79;
      HEAP32[(($77)>>2)]=HEAP32[(($78)>>2)];HEAP32[((($77)+(4))>>2)]=HEAP32[((($78)+(4))>>2)];
      var $79=$io276;
      var $tt_80=(($79+8)|0);
      var $80=HEAP32[(($tt_80)>>2)];
      var $81=$io177;
      var $tt_81=(($81+8)|0);
      HEAP32[(($tt_81)>>2)]=$80;
      label = 290; break;
    case 20: 
      var $82=$i;
      var $shr84=$82 >>> 23;
      var $and85=$shr84 & 511;
      $b83=$and85;
      var $83=$L_addr;
      var $84=$b83;
      var $85=$cl;
      var $upvals86=(($85+16)|0);
      var $arrayidx87=(($upvals86+($84<<2))|0);
      var $86=HEAP32[(($arrayidx87)>>2)];
      var $v88=(($86+8)|0);
      var $87=HEAP32[(($v88)>>2)];
      var $88=$i;
      var $shr89=$88 >>> 14;
      var $and90=$shr89 & 511;
      var $and91=$and90 & 256;
      var $tobool92=(($and91)|0)!=0;
      if ($tobool92) { label = 21; break; } else { label = 22; break; }
    case 21: 
      var $89=$k;
      var $90=$i;
      var $shr93=$90 >>> 14;
      var $and94=$shr93 & 511;
      var $and95=$and94 & -257;
      var $add_ptr96=(($89+((($and95)*(12))&-1))|0);
      var $cond = $add_ptr96;label = 23; break;
    case 22: 
      var $91=$base;
      var $92=$i;
      var $shr97=$92 >>> 14;
      var $and98=$shr97 & 511;
      var $add_ptr99=(($91+((($and98)*(12))&-1))|0);
      var $cond = $add_ptr99;label = 23; break;
    case 23: 
      var $cond;
      var $93=$ra;
      _luaV_gettable($83, $87, $cond, $93);
      var $94=$ci;
      var $u100=(($94+24)|0);
      var $l101=$u100;
      var $base102=(($l101)|0);
      var $95=HEAP32[(($base102)>>2)];
      $base=$95;
      label = 290; break;
    case 24: 
      var $96=$L_addr;
      var $97=$base;
      var $98=$i;
      var $shr104=$98 >>> 23;
      var $and105=$shr104 & 511;
      var $add_ptr106=(($97+((($and105)*(12))&-1))|0);
      var $99=$i;
      var $shr107=$99 >>> 14;
      var $and108=$shr107 & 511;
      var $and109=$and108 & 256;
      var $tobool110=(($and109)|0)!=0;
      if ($tobool110) { label = 25; break; } else { label = 26; break; }
    case 25: 
      var $100=$k;
      var $101=$i;
      var $shr112=$101 >>> 14;
      var $and113=$shr112 & 511;
      var $and114=$and113 & -257;
      var $add_ptr115=(($100+((($and114)*(12))&-1))|0);
      var $cond121 = $add_ptr115;label = 27; break;
    case 26: 
      var $102=$base;
      var $103=$i;
      var $shr117=$103 >>> 14;
      var $and118=$shr117 & 511;
      var $add_ptr119=(($102+((($and118)*(12))&-1))|0);
      var $cond121 = $add_ptr119;label = 27; break;
    case 27: 
      var $cond121;
      var $104=$ra;
      _luaV_gettable($96, $add_ptr106, $cond121, $104);
      var $105=$ci;
      var $u122=(($105+24)|0);
      var $l123=$u122;
      var $base124=(($l123)|0);
      var $106=HEAP32[(($base124)>>2)];
      $base=$106;
      label = 290; break;
    case 28: 
      var $107=$i;
      var $shr126=$107 >>> 6;
      var $and127=$shr126 & 255;
      $a=$and127;
      var $108=$L_addr;
      var $109=$a;
      var $110=$cl;
      var $upvals128=(($110+16)|0);
      var $arrayidx129=(($upvals128+($109<<2))|0);
      var $111=HEAP32[(($arrayidx129)>>2)];
      var $v130=(($111+8)|0);
      var $112=HEAP32[(($v130)>>2)];
      var $113=$i;
      var $shr131=$113 >>> 23;
      var $and132=$shr131 & 511;
      var $and133=$and132 & 256;
      var $tobool134=(($and133)|0)!=0;
      if ($tobool134) { label = 29; break; } else { label = 30; break; }
    case 29: 
      var $114=$k;
      var $115=$i;
      var $shr136=$115 >>> 23;
      var $and137=$shr136 & 511;
      var $and138=$and137 & -257;
      var $add_ptr139=(($114+((($and138)*(12))&-1))|0);
      var $cond145 = $add_ptr139;label = 31; break;
    case 30: 
      var $116=$base;
      var $117=$i;
      var $shr141=$117 >>> 23;
      var $and142=$shr141 & 511;
      var $add_ptr143=(($116+((($and142)*(12))&-1))|0);
      var $cond145 = $add_ptr143;label = 31; break;
    case 31: 
      var $cond145;
      var $118=$i;
      var $shr146=$118 >>> 14;
      var $and147=$shr146 & 511;
      var $and148=$and147 & 256;
      var $tobool149=(($and148)|0)!=0;
      if ($tobool149) { label = 32; break; } else { label = 33; break; }
    case 32: 
      var $119=$k;
      var $120=$i;
      var $shr151=$120 >>> 14;
      var $and152=$shr151 & 511;
      var $and153=$and152 & -257;
      var $add_ptr154=(($119+((($and153)*(12))&-1))|0);
      var $cond160 = $add_ptr154;label = 34; break;
    case 33: 
      var $121=$base;
      var $122=$i;
      var $shr156=$122 >>> 14;
      var $and157=$shr156 & 511;
      var $add_ptr158=(($121+((($and157)*(12))&-1))|0);
      var $cond160 = $add_ptr158;label = 34; break;
    case 34: 
      var $cond160;
      _luaV_settable($108, $112, $cond145, $cond160);
      var $123=$ci;
      var $u161=(($123+24)|0);
      var $l162=$u161;
      var $base163=(($l162)|0);
      var $124=HEAP32[(($base163)>>2)];
      $base=$124;
      label = 290; break;
    case 35: 
      var $125=$i;
      var $shr165=$125 >>> 23;
      var $and166=$shr165 & 511;
      var $126=$cl;
      var $upvals167=(($126+16)|0);
      var $arrayidx168=(($upvals167+($and166<<2))|0);
      var $127=HEAP32[(($arrayidx168)>>2)];
      $uv=$127;
      var $128=$ra;
      $io2169=$128;
      var $129=$uv;
      var $v171=(($129+8)|0);
      var $130=HEAP32[(($v171)>>2)];
      $io1170=$130;
      var $131=$io1170;
      var $value_172=(($131)|0);
      var $132=$io2169;
      var $value_173=(($132)|0);
      var $133=$value_172;
      var $134=$value_173;
      HEAP32[(($133)>>2)]=HEAP32[(($134)>>2)];HEAP32[((($133)+(4))>>2)]=HEAP32[((($134)+(4))>>2)];
      var $135=$io2169;
      var $tt_174=(($135+8)|0);
      var $136=HEAP32[(($tt_174)>>2)];
      var $137=$io1170;
      var $tt_175=(($137+8)|0);
      HEAP32[(($tt_175)>>2)]=$136;
      var $138=$ra;
      var $tt_176=(($138+8)|0);
      var $139=HEAP32[(($tt_176)>>2)];
      var $and177=$139 & 64;
      var $tobool178=(($and177)|0)!=0;
      if ($tobool178) { label = 36; break; } else { label = 39; break; }
    case 36: 
      var $140=$ra;
      var $value_180=(($140)|0);
      var $gc181=$value_180;
      var $141=HEAP32[(($gc181)>>2)];
      var $gch=$141;
      var $marked=(($gch+5)|0);
      var $142=HEAP8[($marked)];
      var $conv182=(($142)&255);
      var $and183=$conv182 & 3;
      var $tobool184=(($and183)|0)!=0;
      if ($tobool184) { label = 37; break; } else { label = 39; break; }
    case 37: 
      var $143=$uv;
      var $144=$143;
      var $gch186=$144;
      var $marked187=(($gch186+5)|0);
      var $145=HEAP8[($marked187)];
      var $conv188=(($145)&255);
      var $and189=$conv188 & 4;
      var $tobool190=(($and189)|0)!=0;
      if ($tobool190) { label = 38; break; } else { label = 39; break; }
    case 38: 
      var $146=$L_addr;
      var $147=$uv;
      var $148=$147;
      var $149=$ra;
      var $value_192=(($149)|0);
      var $gc193=$value_192;
      var $150=HEAP32[(($gc193)>>2)];
      _luaC_barrier_($146, $148, $150);
      label = 39; break;
    case 39: 
      label = 290; break;
    case 40: 
      var $151=$L_addr;
      var $152=$ra;
      var $153=$i;
      var $shr196=$153 >>> 23;
      var $and197=$shr196 & 511;
      var $and198=$and197 & 256;
      var $tobool199=(($and198)|0)!=0;
      if ($tobool199) { label = 41; break; } else { label = 42; break; }
    case 41: 
      var $154=$k;
      var $155=$i;
      var $shr201=$155 >>> 23;
      var $and202=$shr201 & 511;
      var $and203=$and202 & -257;
      var $add_ptr204=(($154+((($and203)*(12))&-1))|0);
      var $cond210 = $add_ptr204;label = 43; break;
    case 42: 
      var $156=$base;
      var $157=$i;
      var $shr206=$157 >>> 23;
      var $and207=$shr206 & 511;
      var $add_ptr208=(($156+((($and207)*(12))&-1))|0);
      var $cond210 = $add_ptr208;label = 43; break;
    case 43: 
      var $cond210;
      var $158=$i;
      var $shr211=$158 >>> 14;
      var $and212=$shr211 & 511;
      var $and213=$and212 & 256;
      var $tobool214=(($and213)|0)!=0;
      if ($tobool214) { label = 44; break; } else { label = 45; break; }
    case 44: 
      var $159=$k;
      var $160=$i;
      var $shr216=$160 >>> 14;
      var $and217=$shr216 & 511;
      var $and218=$and217 & -257;
      var $add_ptr219=(($159+((($and218)*(12))&-1))|0);
      var $cond225 = $add_ptr219;label = 46; break;
    case 45: 
      var $161=$base;
      var $162=$i;
      var $shr221=$162 >>> 14;
      var $and222=$shr221 & 511;
      var $add_ptr223=(($161+((($and222)*(12))&-1))|0);
      var $cond225 = $add_ptr223;label = 46; break;
    case 46: 
      var $cond225;
      _luaV_settable($151, $152, $cond210, $cond225);
      var $163=$ci;
      var $u226=(($163+24)|0);
      var $l227=$u226;
      var $base228=(($l227)|0);
      var $164=HEAP32[(($base228)>>2)];
      $base=$164;
      label = 290; break;
    case 47: 
      var $165=$i;
      var $shr231=$165 >>> 23;
      var $and232=$shr231 & 511;
      $b230=$and232;
      var $166=$i;
      var $shr233=$166 >>> 14;
      var $and234=$shr233 & 511;
      $c=$and234;
      var $167=$L_addr;
      var $call=_luaH_new($167);
      $t=$call;
      var $168=$ra;
      $io235=$168;
      var $169=$t;
      var $170=$169;
      var $171=$io235;
      var $value_236=(($171)|0);
      var $gc237=$value_236;
      HEAP32[(($gc237)>>2)]=$170;
      var $172=$io235;
      var $tt_238=(($172+8)|0);
      HEAP32[(($tt_238)>>2)]=69;
      var $173=$b230;
      var $cmp239=(($173)|0)!=0;
      if ($cmp239) { label = 49; break; } else { label = 48; break; }
    case 48: 
      var $174=$c;
      var $cmp242=(($174)|0)!=0;
      if ($cmp242) { label = 49; break; } else { label = 50; break; }
    case 49: 
      var $175=$L_addr;
      var $176=$t;
      var $177=$b230;
      var $call245=_luaO_fb2int($177);
      var $178=$c;
      var $call246=_luaO_fb2int($178);
      _luaH_resize($175, $176, $call245, $call246);
      label = 50; break;
    case 50: 
      var $179=$L_addr;
      var $l_G=(($179+12)|0);
      var $180=HEAP32[(($l_G)>>2)];
      var $GCdebt=(($180+12)|0);
      var $181=HEAP32[(($GCdebt)>>2)];
      var $cmp248=(($181)|0) > 0;
      if ($cmp248) { label = 51; break; } else { label = 52; break; }
    case 51: 
      var $182=$ra;
      var $add_ptr251=(($182+12)|0);
      var $183=$L_addr;
      var $top=(($183+8)|0);
      HEAP32[(($top)>>2)]=$add_ptr251;
      var $184=$L_addr;
      _luaC_step($184);
      var $185=$ci;
      var $top252=(($185+4)|0);
      var $186=HEAP32[(($top252)>>2)];
      var $187=$L_addr;
      var $top253=(($187+8)|0);
      HEAP32[(($top253)>>2)]=$186;
      label = 52; break;
    case 52: 
      var $188=$ci;
      var $u255=(($188+24)|0);
      var $l256=$u255;
      var $base257=(($l256)|0);
      var $189=HEAP32[(($base257)>>2)];
      $base=$189;
      label = 290; break;
    case 53: 
      var $190=$base;
      var $191=$i;
      var $shr260=$191 >>> 23;
      var $and261=$shr260 & 511;
      var $add_ptr262=(($190+((($and261)*(12))&-1))|0);
      $rb259=$add_ptr262;
      var $192=$rb259;
      $io2263=$192;
      var $193=$ra;
      var $add_ptr265=(($193+12)|0);
      $io1264=$add_ptr265;
      var $194=$io1264;
      var $value_266=(($194)|0);
      var $195=$io2263;
      var $value_267=(($195)|0);
      var $196=$value_266;
      var $197=$value_267;
      HEAP32[(($196)>>2)]=HEAP32[(($197)>>2)];HEAP32[((($196)+(4))>>2)]=HEAP32[((($197)+(4))>>2)];
      var $198=$io2263;
      var $tt_268=(($198+8)|0);
      var $199=HEAP32[(($tt_268)>>2)];
      var $200=$io1264;
      var $tt_269=(($200+8)|0);
      HEAP32[(($tt_269)>>2)]=$199;
      var $201=$L_addr;
      var $202=$rb259;
      var $203=$i;
      var $shr270=$203 >>> 14;
      var $and271=$shr270 & 511;
      var $and272=$and271 & 256;
      var $tobool273=(($and272)|0)!=0;
      if ($tobool273) { label = 54; break; } else { label = 55; break; }
    case 54: 
      var $204=$k;
      var $205=$i;
      var $shr275=$205 >>> 14;
      var $and276=$shr275 & 511;
      var $and277=$and276 & -257;
      var $add_ptr278=(($204+((($and277)*(12))&-1))|0);
      var $cond284 = $add_ptr278;label = 56; break;
    case 55: 
      var $206=$base;
      var $207=$i;
      var $shr280=$207 >>> 14;
      var $and281=$shr280 & 511;
      var $add_ptr282=(($206+((($and281)*(12))&-1))|0);
      var $cond284 = $add_ptr282;label = 56; break;
    case 56: 
      var $cond284;
      var $208=$ra;
      _luaV_gettable($201, $202, $cond284, $208);
      var $209=$ci;
      var $u285=(($209+24)|0);
      var $l286=$u285;
      var $base287=(($l286)|0);
      var $210=HEAP32[(($base287)>>2)];
      $base=$210;
      label = 290; break;
    case 57: 
      var $211=$i;
      var $shr290=$211 >>> 23;
      var $and291=$shr290 & 511;
      var $and292=$and291 & 256;
      var $tobool293=(($and292)|0)!=0;
      if ($tobool293) { label = 58; break; } else { label = 59; break; }
    case 58: 
      var $212=$k;
      var $213=$i;
      var $shr295=$213 >>> 23;
      var $and296=$shr295 & 511;
      var $and297=$and296 & -257;
      var $add_ptr298=(($212+((($and297)*(12))&-1))|0);
      var $cond304 = $add_ptr298;label = 60; break;
    case 59: 
      var $214=$base;
      var $215=$i;
      var $shr300=$215 >>> 23;
      var $and301=$shr300 & 511;
      var $add_ptr302=(($214+((($and301)*(12))&-1))|0);
      var $cond304 = $add_ptr302;label = 60; break;
    case 60: 
      var $cond304;
      $rb289=$cond304;
      var $216=$i;
      var $shr305=$216 >>> 14;
      var $and306=$shr305 & 511;
      var $and307=$and306 & 256;
      var $tobool308=(($and307)|0)!=0;
      if ($tobool308) { label = 61; break; } else { label = 62; break; }
    case 61: 
      var $217=$k;
      var $218=$i;
      var $shr310=$218 >>> 14;
      var $and311=$shr310 & 511;
      var $and312=$and311 & -257;
      var $add_ptr313=(($217+((($and312)*(12))&-1))|0);
      var $cond319 = $add_ptr313;label = 63; break;
    case 62: 
      var $219=$base;
      var $220=$i;
      var $shr315=$220 >>> 14;
      var $and316=$shr315 & 511;
      var $add_ptr317=(($219+((($and316)*(12))&-1))|0);
      var $cond319 = $add_ptr317;label = 63; break;
    case 63: 
      var $cond319;
      $rc=$cond319;
      var $221=$rb289;
      var $tt_320=(($221+8)|0);
      var $222=HEAP32[(($tt_320)>>2)];
      var $cmp321=(($222)|0)==3;
      if ($cmp321) { label = 64; break; } else { label = 66; break; }
    case 64: 
      var $223=$rc;
      var $tt_324=(($223+8)|0);
      var $224=HEAP32[(($tt_324)>>2)];
      var $cmp325=(($224)|0)==3;
      if ($cmp325) { label = 65; break; } else { label = 66; break; }
    case 65: 
      var $225=$rb289;
      var $value_328=(($225)|0);
      var $n=$value_328;
      var $226=(HEAP32[((tempDoublePtr)>>2)]=HEAP32[(($n)>>2)],HEAP32[(((tempDoublePtr)+(4))>>2)]=HEAP32[((($n)+(4))>>2)],HEAPF64[(tempDoublePtr)>>3]);
      $nb=$226;
      var $227=$rc;
      var $value_329=(($227)|0);
      var $n330=$value_329;
      var $228=(HEAP32[((tempDoublePtr)>>2)]=HEAP32[(($n330)>>2)],HEAP32[(((tempDoublePtr)+(4))>>2)]=HEAP32[((($n330)+(4))>>2)],HEAPF64[(tempDoublePtr)>>3]);
      $nc=$228;
      var $229=$ra;
      $io331=$229;
      var $230=$nb;
      var $231=$nc;
      var $add=($230)+($231);
      var $232=$io331;
      var $value_332=(($232)|0);
      var $n333=$value_332;
      (HEAPF64[(tempDoublePtr)>>3]=$add,HEAP32[(($n333)>>2)]=HEAP32[((tempDoublePtr)>>2)],HEAP32[((($n333)+(4))>>2)]=HEAP32[(((tempDoublePtr)+(4))>>2)]);
      var $233=$io331;
      var $tt_334=(($233+8)|0);
      HEAP32[(($tt_334)>>2)]=3;
      label = 67; break;
    case 66: 
      var $234=$L_addr;
      var $235=$ra;
      var $236=$rb289;
      var $237=$rc;
      _luaV_arith($234, $235, $236, $237, 6);
      var $238=$ci;
      var $u335=(($238+24)|0);
      var $l336=$u335;
      var $base337=(($l336)|0);
      var $239=HEAP32[(($base337)>>2)];
      $base=$239;
      label = 67; break;
    case 67: 
      label = 290; break;
    case 68: 
      var $240=$i;
      var $shr341=$240 >>> 23;
      var $and342=$shr341 & 511;
      var $and343=$and342 & 256;
      var $tobool344=(($and343)|0)!=0;
      if ($tobool344) { label = 69; break; } else { label = 70; break; }
    case 69: 
      var $241=$k;
      var $242=$i;
      var $shr346=$242 >>> 23;
      var $and347=$shr346 & 511;
      var $and348=$and347 & -257;
      var $add_ptr349=(($241+((($and348)*(12))&-1))|0);
      var $cond355 = $add_ptr349;label = 71; break;
    case 70: 
      var $243=$base;
      var $244=$i;
      var $shr351=$244 >>> 23;
      var $and352=$shr351 & 511;
      var $add_ptr353=(($243+((($and352)*(12))&-1))|0);
      var $cond355 = $add_ptr353;label = 71; break;
    case 71: 
      var $cond355;
      $rb340=$cond355;
      var $245=$i;
      var $shr357=$245 >>> 14;
      var $and358=$shr357 & 511;
      var $and359=$and358 & 256;
      var $tobool360=(($and359)|0)!=0;
      if ($tobool360) { label = 72; break; } else { label = 73; break; }
    case 72: 
      var $246=$k;
      var $247=$i;
      var $shr362=$247 >>> 14;
      var $and363=$shr362 & 511;
      var $and364=$and363 & -257;
      var $add_ptr365=(($246+((($and364)*(12))&-1))|0);
      var $cond371 = $add_ptr365;label = 74; break;
    case 73: 
      var $248=$base;
      var $249=$i;
      var $shr367=$249 >>> 14;
      var $and368=$shr367 & 511;
      var $add_ptr369=(($248+((($and368)*(12))&-1))|0);
      var $cond371 = $add_ptr369;label = 74; break;
    case 74: 
      var $cond371;
      $rc356=$cond371;
      var $250=$rb340;
      var $tt_372=(($250+8)|0);
      var $251=HEAP32[(($tt_372)>>2)];
      var $cmp373=(($251)|0)==3;
      if ($cmp373) { label = 75; break; } else { label = 77; break; }
    case 75: 
      var $252=$rc356;
      var $tt_376=(($252+8)|0);
      var $253=HEAP32[(($tt_376)>>2)];
      var $cmp377=(($253)|0)==3;
      if ($cmp377) { label = 76; break; } else { label = 77; break; }
    case 76: 
      var $254=$rb340;
      var $value_381=(($254)|0);
      var $n382=$value_381;
      var $255=(HEAP32[((tempDoublePtr)>>2)]=HEAP32[(($n382)>>2)],HEAP32[(((tempDoublePtr)+(4))>>2)]=HEAP32[((($n382)+(4))>>2)],HEAPF64[(tempDoublePtr)>>3]);
      $nb380=$255;
      var $256=$rc356;
      var $value_384=(($256)|0);
      var $n385=$value_384;
      var $257=(HEAP32[((tempDoublePtr)>>2)]=HEAP32[(($n385)>>2)],HEAP32[(((tempDoublePtr)+(4))>>2)]=HEAP32[((($n385)+(4))>>2)],HEAPF64[(tempDoublePtr)>>3]);
      $nc383=$257;
      var $258=$ra;
      $io386=$258;
      var $259=$nb380;
      var $260=$nc383;
      var $sub=($259)-($260);
      var $261=$io386;
      var $value_387=(($261)|0);
      var $n388=$value_387;
      (HEAPF64[(tempDoublePtr)>>3]=$sub,HEAP32[(($n388)>>2)]=HEAP32[((tempDoublePtr)>>2)],HEAP32[((($n388)+(4))>>2)]=HEAP32[(((tempDoublePtr)+(4))>>2)]);
      var $262=$io386;
      var $tt_389=(($262+8)|0);
      HEAP32[(($tt_389)>>2)]=3;
      label = 78; break;
    case 77: 
      var $263=$L_addr;
      var $264=$ra;
      var $265=$rb340;
      var $266=$rc356;
      _luaV_arith($263, $264, $265, $266, 7);
      var $267=$ci;
      var $u391=(($267+24)|0);
      var $l392=$u391;
      var $base393=(($l392)|0);
      var $268=HEAP32[(($base393)>>2)];
      $base=$268;
      label = 78; break;
    case 78: 
      label = 290; break;
    case 79: 
      var $269=$i;
      var $shr397=$269 >>> 23;
      var $and398=$shr397 & 511;
      var $and399=$and398 & 256;
      var $tobool400=(($and399)|0)!=0;
      if ($tobool400) { label = 80; break; } else { label = 81; break; }
    case 80: 
      var $270=$k;
      var $271=$i;
      var $shr402=$271 >>> 23;
      var $and403=$shr402 & 511;
      var $and404=$and403 & -257;
      var $add_ptr405=(($270+((($and404)*(12))&-1))|0);
      var $cond411 = $add_ptr405;label = 82; break;
    case 81: 
      var $272=$base;
      var $273=$i;
      var $shr407=$273 >>> 23;
      var $and408=$shr407 & 511;
      var $add_ptr409=(($272+((($and408)*(12))&-1))|0);
      var $cond411 = $add_ptr409;label = 82; break;
    case 82: 
      var $cond411;
      $rb396=$cond411;
      var $274=$i;
      var $shr413=$274 >>> 14;
      var $and414=$shr413 & 511;
      var $and415=$and414 & 256;
      var $tobool416=(($and415)|0)!=0;
      if ($tobool416) { label = 83; break; } else { label = 84; break; }
    case 83: 
      var $275=$k;
      var $276=$i;
      var $shr418=$276 >>> 14;
      var $and419=$shr418 & 511;
      var $and420=$and419 & -257;
      var $add_ptr421=(($275+((($and420)*(12))&-1))|0);
      var $cond427 = $add_ptr421;label = 85; break;
    case 84: 
      var $277=$base;
      var $278=$i;
      var $shr423=$278 >>> 14;
      var $and424=$shr423 & 511;
      var $add_ptr425=(($277+((($and424)*(12))&-1))|0);
      var $cond427 = $add_ptr425;label = 85; break;
    case 85: 
      var $cond427;
      $rc412=$cond427;
      var $279=$rb396;
      var $tt_428=(($279+8)|0);
      var $280=HEAP32[(($tt_428)>>2)];
      var $cmp429=(($280)|0)==3;
      if ($cmp429) { label = 86; break; } else { label = 88; break; }
    case 86: 
      var $281=$rc412;
      var $tt_432=(($281+8)|0);
      var $282=HEAP32[(($tt_432)>>2)];
      var $cmp433=(($282)|0)==3;
      if ($cmp433) { label = 87; break; } else { label = 88; break; }
    case 87: 
      var $283=$rb396;
      var $value_437=(($283)|0);
      var $n438=$value_437;
      var $284=(HEAP32[((tempDoublePtr)>>2)]=HEAP32[(($n438)>>2)],HEAP32[(((tempDoublePtr)+(4))>>2)]=HEAP32[((($n438)+(4))>>2)],HEAPF64[(tempDoublePtr)>>3]);
      $nb436=$284;
      var $285=$rc412;
      var $value_440=(($285)|0);
      var $n441=$value_440;
      var $286=(HEAP32[((tempDoublePtr)>>2)]=HEAP32[(($n441)>>2)],HEAP32[(((tempDoublePtr)+(4))>>2)]=HEAP32[((($n441)+(4))>>2)],HEAPF64[(tempDoublePtr)>>3]);
      $nc439=$286;
      var $287=$ra;
      $io442=$287;
      var $288=$nb436;
      var $289=$nc439;
      var $mul=($288)*($289);
      var $290=$io442;
      var $value_443=(($290)|0);
      var $n444=$value_443;
      (HEAPF64[(tempDoublePtr)>>3]=$mul,HEAP32[(($n444)>>2)]=HEAP32[((tempDoublePtr)>>2)],HEAP32[((($n444)+(4))>>2)]=HEAP32[(((tempDoublePtr)+(4))>>2)]);
      var $291=$io442;
      var $tt_445=(($291+8)|0);
      HEAP32[(($tt_445)>>2)]=3;
      label = 89; break;
    case 88: 
      var $292=$L_addr;
      var $293=$ra;
      var $294=$rb396;
      var $295=$rc412;
      _luaV_arith($292, $293, $294, $295, 8);
      var $296=$ci;
      var $u447=(($296+24)|0);
      var $l448=$u447;
      var $base449=(($l448)|0);
      var $297=HEAP32[(($base449)>>2)];
      $base=$297;
      label = 89; break;
    case 89: 
      label = 290; break;
    case 90: 
      var $298=$i;
      var $shr453=$298 >>> 23;
      var $and454=$shr453 & 511;
      var $and455=$and454 & 256;
      var $tobool456=(($and455)|0)!=0;
      if ($tobool456) { label = 91; break; } else { label = 92; break; }
    case 91: 
      var $299=$k;
      var $300=$i;
      var $shr458=$300 >>> 23;
      var $and459=$shr458 & 511;
      var $and460=$and459 & -257;
      var $add_ptr461=(($299+((($and460)*(12))&-1))|0);
      var $cond467 = $add_ptr461;label = 93; break;
    case 92: 
      var $301=$base;
      var $302=$i;
      var $shr463=$302 >>> 23;
      var $and464=$shr463 & 511;
      var $add_ptr465=(($301+((($and464)*(12))&-1))|0);
      var $cond467 = $add_ptr465;label = 93; break;
    case 93: 
      var $cond467;
      $rb452=$cond467;
      var $303=$i;
      var $shr469=$303 >>> 14;
      var $and470=$shr469 & 511;
      var $and471=$and470 & 256;
      var $tobool472=(($and471)|0)!=0;
      if ($tobool472) { label = 94; break; } else { label = 95; break; }
    case 94: 
      var $304=$k;
      var $305=$i;
      var $shr474=$305 >>> 14;
      var $and475=$shr474 & 511;
      var $and476=$and475 & -257;
      var $add_ptr477=(($304+((($and476)*(12))&-1))|0);
      var $cond483 = $add_ptr477;label = 96; break;
    case 95: 
      var $306=$base;
      var $307=$i;
      var $shr479=$307 >>> 14;
      var $and480=$shr479 & 511;
      var $add_ptr481=(($306+((($and480)*(12))&-1))|0);
      var $cond483 = $add_ptr481;label = 96; break;
    case 96: 
      var $cond483;
      $rc468=$cond483;
      var $308=$rb452;
      var $tt_484=(($308+8)|0);
      var $309=HEAP32[(($tt_484)>>2)];
      var $cmp485=(($309)|0)==3;
      if ($cmp485) { label = 97; break; } else { label = 99; break; }
    case 97: 
      var $310=$rc468;
      var $tt_488=(($310+8)|0);
      var $311=HEAP32[(($tt_488)>>2)];
      var $cmp489=(($311)|0)==3;
      if ($cmp489) { label = 98; break; } else { label = 99; break; }
    case 98: 
      var $312=$rb452;
      var $value_493=(($312)|0);
      var $n494=$value_493;
      var $313=(HEAP32[((tempDoublePtr)>>2)]=HEAP32[(($n494)>>2)],HEAP32[(((tempDoublePtr)+(4))>>2)]=HEAP32[((($n494)+(4))>>2)],HEAPF64[(tempDoublePtr)>>3]);
      $nb492=$313;
      var $314=$rc468;
      var $value_496=(($314)|0);
      var $n497=$value_496;
      var $315=(HEAP32[((tempDoublePtr)>>2)]=HEAP32[(($n497)>>2)],HEAP32[(((tempDoublePtr)+(4))>>2)]=HEAP32[((($n497)+(4))>>2)],HEAPF64[(tempDoublePtr)>>3]);
      $nc495=$315;
      var $316=$ra;
      $io498=$316;
      var $317=$nb492;
      var $318=$nc495;
      var $div=($317)/($318);
      var $319=$io498;
      var $value_499=(($319)|0);
      var $n500=$value_499;
      (HEAPF64[(tempDoublePtr)>>3]=$div,HEAP32[(($n500)>>2)]=HEAP32[((tempDoublePtr)>>2)],HEAP32[((($n500)+(4))>>2)]=HEAP32[(((tempDoublePtr)+(4))>>2)]);
      var $320=$io498;
      var $tt_501=(($320+8)|0);
      HEAP32[(($tt_501)>>2)]=3;
      label = 100; break;
    case 99: 
      var $321=$L_addr;
      var $322=$ra;
      var $323=$rb452;
      var $324=$rc468;
      _luaV_arith($321, $322, $323, $324, 9);
      var $325=$ci;
      var $u503=(($325+24)|0);
      var $l504=$u503;
      var $base505=(($l504)|0);
      var $326=HEAP32[(($base505)>>2)];
      $base=$326;
      label = 100; break;
    case 100: 
      label = 290; break;
    case 101: 
      var $327=$i;
      var $shr509=$327 >>> 23;
      var $and510=$shr509 & 511;
      var $and511=$and510 & 256;
      var $tobool512=(($and511)|0)!=0;
      if ($tobool512) { label = 102; break; } else { label = 103; break; }
    case 102: 
      var $328=$k;
      var $329=$i;
      var $shr514=$329 >>> 23;
      var $and515=$shr514 & 511;
      var $and516=$and515 & -257;
      var $add_ptr517=(($328+((($and516)*(12))&-1))|0);
      var $cond523 = $add_ptr517;label = 104; break;
    case 103: 
      var $330=$base;
      var $331=$i;
      var $shr519=$331 >>> 23;
      var $and520=$shr519 & 511;
      var $add_ptr521=(($330+((($and520)*(12))&-1))|0);
      var $cond523 = $add_ptr521;label = 104; break;
    case 104: 
      var $cond523;
      $rb508=$cond523;
      var $332=$i;
      var $shr525=$332 >>> 14;
      var $and526=$shr525 & 511;
      var $and527=$and526 & 256;
      var $tobool528=(($and527)|0)!=0;
      if ($tobool528) { label = 105; break; } else { label = 106; break; }
    case 105: 
      var $333=$k;
      var $334=$i;
      var $shr530=$334 >>> 14;
      var $and531=$shr530 & 511;
      var $and532=$and531 & -257;
      var $add_ptr533=(($333+((($and532)*(12))&-1))|0);
      var $cond539 = $add_ptr533;label = 107; break;
    case 106: 
      var $335=$base;
      var $336=$i;
      var $shr535=$336 >>> 14;
      var $and536=$shr535 & 511;
      var $add_ptr537=(($335+((($and536)*(12))&-1))|0);
      var $cond539 = $add_ptr537;label = 107; break;
    case 107: 
      var $cond539;
      $rc524=$cond539;
      var $337=$rb508;
      var $tt_540=(($337+8)|0);
      var $338=HEAP32[(($tt_540)>>2)];
      var $cmp541=(($338)|0)==3;
      if ($cmp541) { label = 108; break; } else { label = 110; break; }
    case 108: 
      var $339=$rc524;
      var $tt_544=(($339+8)|0);
      var $340=HEAP32[(($tt_544)>>2)];
      var $cmp545=(($340)|0)==3;
      if ($cmp545) { label = 109; break; } else { label = 110; break; }
    case 109: 
      var $341=$rb508;
      var $value_549=(($341)|0);
      var $n550=$value_549;
      var $342=(HEAP32[((tempDoublePtr)>>2)]=HEAP32[(($n550)>>2)],HEAP32[(((tempDoublePtr)+(4))>>2)]=HEAP32[((($n550)+(4))>>2)],HEAPF64[(tempDoublePtr)>>3]);
      $nb548=$342;
      var $343=$rc524;
      var $value_552=(($343)|0);
      var $n553=$value_552;
      var $344=(HEAP32[((tempDoublePtr)>>2)]=HEAP32[(($n553)>>2)],HEAP32[(((tempDoublePtr)+(4))>>2)]=HEAP32[((($n553)+(4))>>2)],HEAPF64[(tempDoublePtr)>>3]);
      $nc551=$344;
      var $345=$ra;
      $io554=$345;
      var $346=$nb548;
      var $347=$nb548;
      var $348=$nc551;
      var $div555=($347)/($348);
      var $call556=Math.floor($div555);
      var $349=$nc551;
      var $mul557=($call556)*($349);
      var $sub558=($346)-($mul557);
      var $350=$io554;
      var $value_559=(($350)|0);
      var $n560=$value_559;
      (HEAPF64[(tempDoublePtr)>>3]=$sub558,HEAP32[(($n560)>>2)]=HEAP32[((tempDoublePtr)>>2)],HEAP32[((($n560)+(4))>>2)]=HEAP32[(((tempDoublePtr)+(4))>>2)]);
      var $351=$io554;
      var $tt_561=(($351+8)|0);
      HEAP32[(($tt_561)>>2)]=3;
      label = 111; break;
    case 110: 
      var $352=$L_addr;
      var $353=$ra;
      var $354=$rb508;
      var $355=$rc524;
      _luaV_arith($352, $353, $354, $355, 10);
      var $356=$ci;
      var $u563=(($356+24)|0);
      var $l564=$u563;
      var $base565=(($l564)|0);
      var $357=HEAP32[(($base565)>>2)];
      $base=$357;
      label = 111; break;
    case 111: 
      label = 290; break;
    case 112: 
      var $358=$i;
      var $shr569=$358 >>> 23;
      var $and570=$shr569 & 511;
      var $and571=$and570 & 256;
      var $tobool572=(($and571)|0)!=0;
      if ($tobool572) { label = 113; break; } else { label = 114; break; }
    case 113: 
      var $359=$k;
      var $360=$i;
      var $shr574=$360 >>> 23;
      var $and575=$shr574 & 511;
      var $and576=$and575 & -257;
      var $add_ptr577=(($359+((($and576)*(12))&-1))|0);
      var $cond583 = $add_ptr577;label = 115; break;
    case 114: 
      var $361=$base;
      var $362=$i;
      var $shr579=$362 >>> 23;
      var $and580=$shr579 & 511;
      var $add_ptr581=(($361+((($and580)*(12))&-1))|0);
      var $cond583 = $add_ptr581;label = 115; break;
    case 115: 
      var $cond583;
      $rb568=$cond583;
      var $363=$i;
      var $shr585=$363 >>> 14;
      var $and586=$shr585 & 511;
      var $and587=$and586 & 256;
      var $tobool588=(($and587)|0)!=0;
      if ($tobool588) { label = 116; break; } else { label = 117; break; }
    case 116: 
      var $364=$k;
      var $365=$i;
      var $shr590=$365 >>> 14;
      var $and591=$shr590 & 511;
      var $and592=$and591 & -257;
      var $add_ptr593=(($364+((($and592)*(12))&-1))|0);
      var $cond599 = $add_ptr593;label = 118; break;
    case 117: 
      var $366=$base;
      var $367=$i;
      var $shr595=$367 >>> 14;
      var $and596=$shr595 & 511;
      var $add_ptr597=(($366+((($and596)*(12))&-1))|0);
      var $cond599 = $add_ptr597;label = 118; break;
    case 118: 
      var $cond599;
      $rc584=$cond599;
      var $368=$rb568;
      var $tt_600=(($368+8)|0);
      var $369=HEAP32[(($tt_600)>>2)];
      var $cmp601=(($369)|0)==3;
      if ($cmp601) { label = 119; break; } else { label = 121; break; }
    case 119: 
      var $370=$rc584;
      var $tt_604=(($370+8)|0);
      var $371=HEAP32[(($tt_604)>>2)];
      var $cmp605=(($371)|0)==3;
      if ($cmp605) { label = 120; break; } else { label = 121; break; }
    case 120: 
      var $372=$rb568;
      var $value_609=(($372)|0);
      var $n610=$value_609;
      var $373=(HEAP32[((tempDoublePtr)>>2)]=HEAP32[(($n610)>>2)],HEAP32[(((tempDoublePtr)+(4))>>2)]=HEAP32[((($n610)+(4))>>2)],HEAPF64[(tempDoublePtr)>>3]);
      $nb608=$373;
      var $374=$rc584;
      var $value_612=(($374)|0);
      var $n613=$value_612;
      var $375=(HEAP32[((tempDoublePtr)>>2)]=HEAP32[(($n613)>>2)],HEAP32[(((tempDoublePtr)+(4))>>2)]=HEAP32[((($n613)+(4))>>2)],HEAPF64[(tempDoublePtr)>>3]);
      $nc611=$375;
      var $376=$ra;
      $io614=$376;
      var $377=$nb608;
      var $378=$nc611;
      var $379=Math.pow($377, $378);
      var $380=$io614;
      var $value_615=(($380)|0);
      var $n616=$value_615;
      (HEAPF64[(tempDoublePtr)>>3]=$379,HEAP32[(($n616)>>2)]=HEAP32[((tempDoublePtr)>>2)],HEAP32[((($n616)+(4))>>2)]=HEAP32[(((tempDoublePtr)+(4))>>2)]);
      var $381=$io614;
      var $tt_617=(($381+8)|0);
      HEAP32[(($tt_617)>>2)]=3;
      label = 122; break;
    case 121: 
      var $382=$L_addr;
      var $383=$ra;
      var $384=$rb568;
      var $385=$rc584;
      _luaV_arith($382, $383, $384, $385, 11);
      var $386=$ci;
      var $u619=(($386+24)|0);
      var $l620=$u619;
      var $base621=(($l620)|0);
      var $387=HEAP32[(($base621)>>2)];
      $base=$387;
      label = 122; break;
    case 122: 
      label = 290; break;
    case 123: 
      var $388=$base;
      var $389=$i;
      var $shr625=$389 >>> 23;
      var $and626=$shr625 & 511;
      var $add_ptr627=(($388+((($and626)*(12))&-1))|0);
      $rb624=$add_ptr627;
      var $390=$rb624;
      var $tt_628=(($390+8)|0);
      var $391=HEAP32[(($tt_628)>>2)];
      var $cmp629=(($391)|0)==3;
      if ($cmp629) { label = 124; break; } else { label = 125; break; }
    case 124: 
      var $392=$rb624;
      var $value_633=(($392)|0);
      var $n634=$value_633;
      var $393=(HEAP32[((tempDoublePtr)>>2)]=HEAP32[(($n634)>>2)],HEAP32[(((tempDoublePtr)+(4))>>2)]=HEAP32[((($n634)+(4))>>2)],HEAPF64[(tempDoublePtr)>>3]);
      $nb632=$393;
      var $394=$ra;
      $io635=$394;
      var $395=$nb632;
      var $sub636=(-$395);
      var $396=$io635;
      var $value_637=(($396)|0);
      var $n638=$value_637;
      (HEAPF64[(tempDoublePtr)>>3]=$sub636,HEAP32[(($n638)>>2)]=HEAP32[((tempDoublePtr)>>2)],HEAP32[((($n638)+(4))>>2)]=HEAP32[(((tempDoublePtr)+(4))>>2)]);
      var $397=$io635;
      var $tt_639=(($397+8)|0);
      HEAP32[(($tt_639)>>2)]=3;
      label = 126; break;
    case 125: 
      var $398=$L_addr;
      var $399=$ra;
      var $400=$rb624;
      var $401=$rb624;
      _luaV_arith($398, $399, $400, $401, 12);
      var $402=$ci;
      var $u641=(($402+24)|0);
      var $l642=$u641;
      var $base643=(($l642)|0);
      var $403=HEAP32[(($base643)>>2)];
      $base=$403;
      label = 126; break;
    case 126: 
      label = 290; break;
    case 127: 
      var $404=$base;
      var $405=$i;
      var $shr647=$405 >>> 23;
      var $and648=$shr647 & 511;
      var $add_ptr649=(($404+((($and648)*(12))&-1))|0);
      $rb646=$add_ptr649;
      var $406=$rb646;
      var $tt_650=(($406+8)|0);
      var $407=HEAP32[(($tt_650)>>2)];
      var $cmp651=(($407)|0)==0;
      if ($cmp651) { var $413 = 1;label = 131; break; } else { label = 128; break; }
    case 128: 
      var $408=$rb646;
      var $tt_653=(($408+8)|0);
      var $409=HEAP32[(($tt_653)>>2)];
      var $cmp654=(($409)|0)==1;
      if ($cmp654) { label = 129; break; } else { var $412 = 0;label = 130; break; }
    case 129: 
      var $410=$rb646;
      var $value_656=(($410)|0);
      var $b657=$value_656;
      var $411=HEAP32[(($b657)>>2)];
      var $cmp658=(($411)|0)==0;
      var $412 = $cmp658;label = 130; break;
    case 130: 
      var $412;
      var $413 = $412;label = 131; break;
    case 131: 
      var $413;
      var $lor_ext=(($413)&1);
      $res=$lor_ext;
      var $414=$ra;
      $io660=$414;
      var $415=$res;
      var $416=$io660;
      var $value_661=(($416)|0);
      var $b662=$value_661;
      HEAP32[(($b662)>>2)]=$415;
      var $417=$io660;
      var $tt_663=(($417+8)|0);
      HEAP32[(($tt_663)>>2)]=1;
      label = 290; break;
    case 132: 
      var $418=$L_addr;
      var $419=$ra;
      var $420=$base;
      var $421=$i;
      var $shr665=$421 >>> 23;
      var $and666=$shr665 & 511;
      var $add_ptr667=(($420+((($and666)*(12))&-1))|0);
      _luaV_objlen($418, $419, $add_ptr667);
      var $422=$ci;
      var $u668=(($422+24)|0);
      var $l669=$u668;
      var $base670=(($l669)|0);
      var $423=HEAP32[(($base670)>>2)];
      $base=$423;
      label = 290; break;
    case 133: 
      var $424=$i;
      var $shr673=$424 >>> 23;
      var $and674=$shr673 & 511;
      $b672=$and674;
      var $425=$i;
      var $shr676=$425 >>> 14;
      var $and677=$shr676 & 511;
      $c675=$and677;
      var $426=$base;
      var $427=$c675;
      var $add_ptr679=(($426+((($427)*(12))&-1))|0);
      var $add_ptr680=(($add_ptr679+12)|0);
      var $428=$L_addr;
      var $top681=(($428+8)|0);
      HEAP32[(($top681)>>2)]=$add_ptr680;
      var $429=$L_addr;
      var $430=$c675;
      var $431=$b672;
      var $sub682=((($430)-($431))|0);
      var $add683=((($sub682)+(1))|0);
      _luaV_concat($429, $add683);
      var $432=$ci;
      var $u684=(($432+24)|0);
      var $l685=$u684;
      var $base686=(($l685)|0);
      var $433=HEAP32[(($base686)>>2)];
      $base=$433;
      var $434=$base;
      var $435=$i;
      var $shr687=$435 >>> 6;
      var $and688=$shr687 & 255;
      var $add_ptr689=(($434+((($and688)*(12))&-1))|0);
      $ra=$add_ptr689;
      var $436=$b672;
      var $437=$base;
      var $add_ptr690=(($437+((($436)*(12))&-1))|0);
      $rb678=$add_ptr690;
      var $438=$rb678;
      $io2691=$438;
      var $439=$ra;
      $io1692=$439;
      var $440=$io1692;
      var $value_693=(($440)|0);
      var $441=$io2691;
      var $value_694=(($441)|0);
      var $442=$value_693;
      var $443=$value_694;
      HEAP32[(($442)>>2)]=HEAP32[(($443)>>2)];HEAP32[((($442)+(4))>>2)]=HEAP32[((($443)+(4))>>2)];
      var $444=$io2691;
      var $tt_695=(($444+8)|0);
      var $445=HEAP32[(($tt_695)>>2)];
      var $446=$io1692;
      var $tt_696=(($446+8)|0);
      HEAP32[(($tt_696)>>2)]=$445;
      var $447=$L_addr;
      var $l_G697=(($447+12)|0);
      var $448=HEAP32[(($l_G697)>>2)];
      var $GCdebt698=(($448+12)|0);
      var $449=HEAP32[(($GCdebt698)>>2)];
      var $cmp699=(($449)|0) > 0;
      if ($cmp699) { label = 134; break; } else { label = 138; break; }
    case 134: 
      var $450=$ra;
      var $451=$rb678;
      var $cmp702=(($450)>>>0) >= (($451)>>>0);
      if ($cmp702) { label = 135; break; } else { label = 136; break; }
    case 135: 
      var $452=$ra;
      var $add_ptr705=(($452+12)|0);
      var $cond708 = $add_ptr705;label = 137; break;
    case 136: 
      var $453=$rb678;
      var $cond708 = $453;label = 137; break;
    case 137: 
      var $cond708;
      var $454=$L_addr;
      var $top709=(($454+8)|0);
      HEAP32[(($top709)>>2)]=$cond708;
      var $455=$L_addr;
      _luaC_step($455);
      var $456=$ci;
      var $top710=(($456+4)|0);
      var $457=HEAP32[(($top710)>>2)];
      var $458=$L_addr;
      var $top711=(($458+8)|0);
      HEAP32[(($top711)>>2)]=$457;
      label = 138; break;
    case 138: 
      var $459=$ci;
      var $u713=(($459+24)|0);
      var $l714=$u713;
      var $base715=(($l714)|0);
      var $460=HEAP32[(($base715)>>2)];
      $base=$460;
      var $461=$ci;
      var $top716=(($461+4)|0);
      var $462=HEAP32[(($top716)>>2)];
      var $463=$L_addr;
      var $top717=(($463+8)|0);
      HEAP32[(($top717)>>2)]=$462;
      label = 290; break;
    case 139: 
      var $464=$i;
      var $shr720=$464 >>> 6;
      var $and721=$shr720 & 255;
      $a719=$and721;
      var $465=$a719;
      var $cmp722=(($465)|0) > 0;
      if ($cmp722) { label = 140; break; } else { label = 141; break; }
    case 140: 
      var $466=$L_addr;
      var $467=$ci;
      var $u725=(($467+24)|0);
      var $l726=$u725;
      var $base727=(($l726)|0);
      var $468=HEAP32[(($base727)>>2)];
      var $469=$a719;
      var $add_ptr728=(($468+((($469)*(12))&-1))|0);
      var $add_ptr729=((($add_ptr728)-(12))|0);
      _luaF_close($466, $add_ptr729);
      label = 141; break;
    case 141: 
      var $470=$i;
      var $shr731=$470 >>> 14;
      var $and732=$shr731 & 262143;
      var $sub733=((($and732)-(131071))|0);
      var $add734=(($sub733)|0);
      var $471=$ci;
      var $u735=(($471+24)|0);
      var $l736=$u735;
      var $savedpc737=(($l736+4)|0);
      var $472=HEAP32[(($savedpc737)>>2)];
      var $add_ptr738=(($472+($add734<<2))|0);
      HEAP32[(($savedpc737)>>2)]=$add_ptr738;
      label = 290; break;
    case 142: 
      var $473=$i;
      var $shr741=$473 >>> 23;
      var $and742=$shr741 & 511;
      var $and743=$and742 & 256;
      var $tobool744=(($and743)|0)!=0;
      if ($tobool744) { label = 143; break; } else { label = 144; break; }
    case 143: 
      var $474=$k;
      var $475=$i;
      var $shr746=$475 >>> 23;
      var $and747=$shr746 & 511;
      var $and748=$and747 & -257;
      var $add_ptr749=(($474+((($and748)*(12))&-1))|0);
      var $cond755 = $add_ptr749;label = 145; break;
    case 144: 
      var $476=$base;
      var $477=$i;
      var $shr751=$477 >>> 23;
      var $and752=$shr751 & 511;
      var $add_ptr753=(($476+((($and752)*(12))&-1))|0);
      var $cond755 = $add_ptr753;label = 145; break;
    case 145: 
      var $cond755;
      $rb740=$cond755;
      var $478=$i;
      var $shr757=$478 >>> 14;
      var $and758=$shr757 & 511;
      var $and759=$and758 & 256;
      var $tobool760=(($and759)|0)!=0;
      if ($tobool760) { label = 146; break; } else { label = 147; break; }
    case 146: 
      var $479=$k;
      var $480=$i;
      var $shr762=$480 >>> 14;
      var $and763=$shr762 & 511;
      var $and764=$and763 & -257;
      var $add_ptr765=(($479+((($and764)*(12))&-1))|0);
      var $cond771 = $add_ptr765;label = 148; break;
    case 147: 
      var $481=$base;
      var $482=$i;
      var $shr767=$482 >>> 14;
      var $and768=$shr767 & 511;
      var $add_ptr769=(($481+((($and768)*(12))&-1))|0);
      var $cond771 = $add_ptr769;label = 148; break;
    case 148: 
      var $cond771;
      $rc756=$cond771;
      var $483=$rb740;
      var $tt_772=(($483+8)|0);
      var $484=HEAP32[(($tt_772)>>2)];
      var $485=$rc756;
      var $tt_773=(($485+8)|0);
      var $486=HEAP32[(($tt_773)>>2)];
      var $cmp774=(($484)|0)==(($486)|0);
      if ($cmp774) { label = 149; break; } else { var $490 = 0;label = 150; break; }
    case 149: 
      var $487=$L_addr;
      var $488=$rb740;
      var $489=$rc756;
      var $call777=_luaV_equalobj_($487, $488, $489);
      var $tobool778=(($call777)|0)!=0;
      var $490 = $tobool778;label = 150; break;
    case 150: 
      var $490;
      var $land_ext=(($490)&1);
      var $491=$i;
      var $shr780=$491 >>> 6;
      var $and781=$shr780 & 255;
      var $cmp782=(($land_ext)|0)!=(($and781)|0);
      if ($cmp782) { label = 151; break; } else { label = 152; break; }
    case 151: 
      var $492=$ci;
      var $u785=(($492+24)|0);
      var $l786=$u785;
      var $savedpc787=(($l786+4)|0);
      var $493=HEAP32[(($savedpc787)>>2)];
      var $incdec_ptr788=(($493+4)|0);
      HEAP32[(($savedpc787)>>2)]=$incdec_ptr788;
      label = 155; break;
    case 152: 
      var $494=$ci;
      var $u790=(($494+24)|0);
      var $l791=$u790;
      var $savedpc792=(($l791+4)|0);
      var $495=HEAP32[(($savedpc792)>>2)];
      var $496=HEAP32[(($495)>>2)];
      $i=$496;
      var $497=$i;
      var $shr794=$497 >>> 6;
      var $and795=$shr794 & 255;
      $a793=$and795;
      var $498=$a793;
      var $cmp796=(($498)|0) > 0;
      if ($cmp796) { label = 153; break; } else { label = 154; break; }
    case 153: 
      var $499=$L_addr;
      var $500=$ci;
      var $u799=(($500+24)|0);
      var $l800=$u799;
      var $base801=(($l800)|0);
      var $501=HEAP32[(($base801)>>2)];
      var $502=$a793;
      var $add_ptr802=(($501+((($502)*(12))&-1))|0);
      var $add_ptr803=((($add_ptr802)-(12))|0);
      _luaF_close($499, $add_ptr803);
      label = 154; break;
    case 154: 
      var $503=$i;
      var $shr805=$503 >>> 14;
      var $and806=$shr805 & 262143;
      var $sub807=((($and806)-(131071))|0);
      var $add808=((($sub807)+(1))|0);
      var $504=$ci;
      var $u809=(($504+24)|0);
      var $l810=$u809;
      var $savedpc811=(($l810+4)|0);
      var $505=HEAP32[(($savedpc811)>>2)];
      var $add_ptr812=(($505+($add808<<2))|0);
      HEAP32[(($savedpc811)>>2)]=$add_ptr812;
      label = 155; break;
    case 155: 
      var $506=$ci;
      var $u814=(($506+24)|0);
      var $l815=$u814;
      var $base816=(($l815)|0);
      var $507=HEAP32[(($base816)>>2)];
      $base=$507;
      label = 290; break;
    case 156: 
      var $508=$L_addr;
      var $509=$i;
      var $shr818=$509 >>> 23;
      var $and819=$shr818 & 511;
      var $and820=$and819 & 256;
      var $tobool821=(($and820)|0)!=0;
      if ($tobool821) { label = 157; break; } else { label = 158; break; }
    case 157: 
      var $510=$k;
      var $511=$i;
      var $shr823=$511 >>> 23;
      var $and824=$shr823 & 511;
      var $and825=$and824 & -257;
      var $add_ptr826=(($510+((($and825)*(12))&-1))|0);
      var $cond832 = $add_ptr826;label = 159; break;
    case 158: 
      var $512=$base;
      var $513=$i;
      var $shr828=$513 >>> 23;
      var $and829=$shr828 & 511;
      var $add_ptr830=(($512+((($and829)*(12))&-1))|0);
      var $cond832 = $add_ptr830;label = 159; break;
    case 159: 
      var $cond832;
      var $514=$i;
      var $shr833=$514 >>> 14;
      var $and834=$shr833 & 511;
      var $and835=$and834 & 256;
      var $tobool836=(($and835)|0)!=0;
      if ($tobool836) { label = 160; break; } else { label = 161; break; }
    case 160: 
      var $515=$k;
      var $516=$i;
      var $shr838=$516 >>> 14;
      var $and839=$shr838 & 511;
      var $and840=$and839 & -257;
      var $add_ptr841=(($515+((($and840)*(12))&-1))|0);
      var $cond847 = $add_ptr841;label = 162; break;
    case 161: 
      var $517=$base;
      var $518=$i;
      var $shr843=$518 >>> 14;
      var $and844=$shr843 & 511;
      var $add_ptr845=(($517+((($and844)*(12))&-1))|0);
      var $cond847 = $add_ptr845;label = 162; break;
    case 162: 
      var $cond847;
      var $call848=_luaV_lessthan($508, $cond832, $cond847);
      var $519=$i;
      var $shr849=$519 >>> 6;
      var $and850=$shr849 & 255;
      var $cmp851=(($call848)|0)!=(($and850)|0);
      if ($cmp851) { label = 163; break; } else { label = 164; break; }
    case 163: 
      var $520=$ci;
      var $u854=(($520+24)|0);
      var $l855=$u854;
      var $savedpc856=(($l855+4)|0);
      var $521=HEAP32[(($savedpc856)>>2)];
      var $incdec_ptr857=(($521+4)|0);
      HEAP32[(($savedpc856)>>2)]=$incdec_ptr857;
      label = 167; break;
    case 164: 
      var $522=$ci;
      var $u859=(($522+24)|0);
      var $l860=$u859;
      var $savedpc861=(($l860+4)|0);
      var $523=HEAP32[(($savedpc861)>>2)];
      var $524=HEAP32[(($523)>>2)];
      $i=$524;
      var $525=$i;
      var $shr863=$525 >>> 6;
      var $and864=$shr863 & 255;
      $a862=$and864;
      var $526=$a862;
      var $cmp865=(($526)|0) > 0;
      if ($cmp865) { label = 165; break; } else { label = 166; break; }
    case 165: 
      var $527=$L_addr;
      var $528=$ci;
      var $u868=(($528+24)|0);
      var $l869=$u868;
      var $base870=(($l869)|0);
      var $529=HEAP32[(($base870)>>2)];
      var $530=$a862;
      var $add_ptr871=(($529+((($530)*(12))&-1))|0);
      var $add_ptr872=((($add_ptr871)-(12))|0);
      _luaF_close($527, $add_ptr872);
      label = 166; break;
    case 166: 
      var $531=$i;
      var $shr874=$531 >>> 14;
      var $and875=$shr874 & 262143;
      var $sub876=((($and875)-(131071))|0);
      var $add877=((($sub876)+(1))|0);
      var $532=$ci;
      var $u878=(($532+24)|0);
      var $l879=$u878;
      var $savedpc880=(($l879+4)|0);
      var $533=HEAP32[(($savedpc880)>>2)];
      var $add_ptr881=(($533+($add877<<2))|0);
      HEAP32[(($savedpc880)>>2)]=$add_ptr881;
      label = 167; break;
    case 167: 
      var $534=$ci;
      var $u883=(($534+24)|0);
      var $l884=$u883;
      var $base885=(($l884)|0);
      var $535=HEAP32[(($base885)>>2)];
      $base=$535;
      label = 290; break;
    case 168: 
      var $536=$L_addr;
      var $537=$i;
      var $shr887=$537 >>> 23;
      var $and888=$shr887 & 511;
      var $and889=$and888 & 256;
      var $tobool890=(($and889)|0)!=0;
      if ($tobool890) { label = 169; break; } else { label = 170; break; }
    case 169: 
      var $538=$k;
      var $539=$i;
      var $shr892=$539 >>> 23;
      var $and893=$shr892 & 511;
      var $and894=$and893 & -257;
      var $add_ptr895=(($538+((($and894)*(12))&-1))|0);
      var $cond901 = $add_ptr895;label = 171; break;
    case 170: 
      var $540=$base;
      var $541=$i;
      var $shr897=$541 >>> 23;
      var $and898=$shr897 & 511;
      var $add_ptr899=(($540+((($and898)*(12))&-1))|0);
      var $cond901 = $add_ptr899;label = 171; break;
    case 171: 
      var $cond901;
      var $542=$i;
      var $shr902=$542 >>> 14;
      var $and903=$shr902 & 511;
      var $and904=$and903 & 256;
      var $tobool905=(($and904)|0)!=0;
      if ($tobool905) { label = 172; break; } else { label = 173; break; }
    case 172: 
      var $543=$k;
      var $544=$i;
      var $shr907=$544 >>> 14;
      var $and908=$shr907 & 511;
      var $and909=$and908 & -257;
      var $add_ptr910=(($543+((($and909)*(12))&-1))|0);
      var $cond916 = $add_ptr910;label = 174; break;
    case 173: 
      var $545=$base;
      var $546=$i;
      var $shr912=$546 >>> 14;
      var $and913=$shr912 & 511;
      var $add_ptr914=(($545+((($and913)*(12))&-1))|0);
      var $cond916 = $add_ptr914;label = 174; break;
    case 174: 
      var $cond916;
      var $call917=_luaV_lessequal($536, $cond901, $cond916);
      var $547=$i;
      var $shr918=$547 >>> 6;
      var $and919=$shr918 & 255;
      var $cmp920=(($call917)|0)!=(($and919)|0);
      if ($cmp920) { label = 175; break; } else { label = 176; break; }
    case 175: 
      var $548=$ci;
      var $u923=(($548+24)|0);
      var $l924=$u923;
      var $savedpc925=(($l924+4)|0);
      var $549=HEAP32[(($savedpc925)>>2)];
      var $incdec_ptr926=(($549+4)|0);
      HEAP32[(($savedpc925)>>2)]=$incdec_ptr926;
      label = 179; break;
    case 176: 
      var $550=$ci;
      var $u928=(($550+24)|0);
      var $l929=$u928;
      var $savedpc930=(($l929+4)|0);
      var $551=HEAP32[(($savedpc930)>>2)];
      var $552=HEAP32[(($551)>>2)];
      $i=$552;
      var $553=$i;
      var $shr932=$553 >>> 6;
      var $and933=$shr932 & 255;
      $a931=$and933;
      var $554=$a931;
      var $cmp934=(($554)|0) > 0;
      if ($cmp934) { label = 177; break; } else { label = 178; break; }
    case 177: 
      var $555=$L_addr;
      var $556=$ci;
      var $u937=(($556+24)|0);
      var $l938=$u937;
      var $base939=(($l938)|0);
      var $557=HEAP32[(($base939)>>2)];
      var $558=$a931;
      var $add_ptr940=(($557+((($558)*(12))&-1))|0);
      var $add_ptr941=((($add_ptr940)-(12))|0);
      _luaF_close($555, $add_ptr941);
      label = 178; break;
    case 178: 
      var $559=$i;
      var $shr943=$559 >>> 14;
      var $and944=$shr943 & 262143;
      var $sub945=((($and944)-(131071))|0);
      var $add946=((($sub945)+(1))|0);
      var $560=$ci;
      var $u947=(($560+24)|0);
      var $l948=$u947;
      var $savedpc949=(($l948+4)|0);
      var $561=HEAP32[(($savedpc949)>>2)];
      var $add_ptr950=(($561+($add946<<2))|0);
      HEAP32[(($savedpc949)>>2)]=$add_ptr950;
      label = 179; break;
    case 179: 
      var $562=$ci;
      var $u952=(($562+24)|0);
      var $l953=$u952;
      var $base954=(($l953)|0);
      var $563=HEAP32[(($base954)>>2)];
      $base=$563;
      label = 290; break;
    case 180: 
      var $564=$i;
      var $shr956=$564 >>> 14;
      var $and957=$shr956 & 511;
      var $tobool958=(($and957)|0)!=0;
      if ($tobool958) { label = 181; break; } else { label = 184; break; }
    case 181: 
      var $565=$ra;
      var $tt_960=(($565+8)|0);
      var $566=HEAP32[(($tt_960)>>2)];
      var $cmp961=(($566)|0)==0;
      if ($cmp961) { label = 187; break; } else { label = 182; break; }
    case 182: 
      var $567=$ra;
      var $tt_964=(($567+8)|0);
      var $568=HEAP32[(($tt_964)>>2)];
      var $cmp965=(($568)|0)==1;
      if ($cmp965) { label = 183; break; } else { label = 188; break; }
    case 183: 
      var $569=$ra;
      var $value_968=(($569)|0);
      var $b969=$value_968;
      var $570=HEAP32[(($b969)>>2)];
      var $cmp970=(($570)|0)==0;
      if ($cmp970) { label = 187; break; } else { label = 188; break; }
    case 184: 
      var $571=$ra;
      var $tt_973=(($571+8)|0);
      var $572=HEAP32[(($tt_973)>>2)];
      var $cmp974=(($572)|0)==0;
      if ($cmp974) { label = 188; break; } else { label = 185; break; }
    case 185: 
      var $573=$ra;
      var $tt_977=(($573+8)|0);
      var $574=HEAP32[(($tt_977)>>2)];
      var $cmp978=(($574)|0)==1;
      if ($cmp978) { label = 186; break; } else { label = 187; break; }
    case 186: 
      var $575=$ra;
      var $value_981=(($575)|0);
      var $b982=$value_981;
      var $576=HEAP32[(($b982)>>2)];
      var $cmp983=(($576)|0)==0;
      if ($cmp983) { label = 188; break; } else { label = 187; break; }
    case 187: 
      var $577=$ci;
      var $u986=(($577+24)|0);
      var $l987=$u986;
      var $savedpc988=(($l987+4)|0);
      var $578=HEAP32[(($savedpc988)>>2)];
      var $incdec_ptr989=(($578+4)|0);
      HEAP32[(($savedpc988)>>2)]=$incdec_ptr989;
      label = 191; break;
    case 188: 
      var $579=$ci;
      var $u991=(($579+24)|0);
      var $l992=$u991;
      var $savedpc993=(($l992+4)|0);
      var $580=HEAP32[(($savedpc993)>>2)];
      var $581=HEAP32[(($580)>>2)];
      $i=$581;
      var $582=$i;
      var $shr995=$582 >>> 6;
      var $and996=$shr995 & 255;
      $a994=$and996;
      var $583=$a994;
      var $cmp997=(($583)|0) > 0;
      if ($cmp997) { label = 189; break; } else { label = 190; break; }
    case 189: 
      var $584=$L_addr;
      var $585=$ci;
      var $u1000=(($585+24)|0);
      var $l1001=$u1000;
      var $base1002=(($l1001)|0);
      var $586=HEAP32[(($base1002)>>2)];
      var $587=$a994;
      var $add_ptr1003=(($586+((($587)*(12))&-1))|0);
      var $add_ptr1004=((($add_ptr1003)-(12))|0);
      _luaF_close($584, $add_ptr1004);
      label = 190; break;
    case 190: 
      var $588=$i;
      var $shr1006=$588 >>> 14;
      var $and1007=$shr1006 & 262143;
      var $sub1008=((($and1007)-(131071))|0);
      var $add1009=((($sub1008)+(1))|0);
      var $589=$ci;
      var $u1010=(($589+24)|0);
      var $l1011=$u1010;
      var $savedpc1012=(($l1011+4)|0);
      var $590=HEAP32[(($savedpc1012)>>2)];
      var $add_ptr1013=(($590+($add1009<<2))|0);
      HEAP32[(($savedpc1012)>>2)]=$add_ptr1013;
      label = 191; break;
    case 191: 
      label = 290; break;
    case 192: 
      var $591=$base;
      var $592=$i;
      var $shr1017=$592 >>> 23;
      var $and1018=$shr1017 & 511;
      var $add_ptr1019=(($591+((($and1018)*(12))&-1))|0);
      $rb1016=$add_ptr1019;
      var $593=$i;
      var $shr1020=$593 >>> 14;
      var $and1021=$shr1020 & 511;
      var $tobool1022=(($and1021)|0)!=0;
      if ($tobool1022) { label = 193; break; } else { label = 196; break; }
    case 193: 
      var $594=$rb1016;
      var $tt_1024=(($594+8)|0);
      var $595=HEAP32[(($tt_1024)>>2)];
      var $cmp1025=(($595)|0)==0;
      if ($cmp1025) { label = 199; break; } else { label = 194; break; }
    case 194: 
      var $596=$rb1016;
      var $tt_1028=(($596+8)|0);
      var $597=HEAP32[(($tt_1028)>>2)];
      var $cmp1029=(($597)|0)==1;
      if ($cmp1029) { label = 195; break; } else { label = 200; break; }
    case 195: 
      var $598=$rb1016;
      var $value_1032=(($598)|0);
      var $b1033=$value_1032;
      var $599=HEAP32[(($b1033)>>2)];
      var $cmp1034=(($599)|0)==0;
      if ($cmp1034) { label = 199; break; } else { label = 200; break; }
    case 196: 
      var $600=$rb1016;
      var $tt_1037=(($600+8)|0);
      var $601=HEAP32[(($tt_1037)>>2)];
      var $cmp1038=(($601)|0)==0;
      if ($cmp1038) { label = 200; break; } else { label = 197; break; }
    case 197: 
      var $602=$rb1016;
      var $tt_1041=(($602+8)|0);
      var $603=HEAP32[(($tt_1041)>>2)];
      var $cmp1042=(($603)|0)==1;
      if ($cmp1042) { label = 198; break; } else { label = 199; break; }
    case 198: 
      var $604=$rb1016;
      var $value_1045=(($604)|0);
      var $b1046=$value_1045;
      var $605=HEAP32[(($b1046)>>2)];
      var $cmp1047=(($605)|0)==0;
      if ($cmp1047) { label = 200; break; } else { label = 199; break; }
    case 199: 
      var $606=$ci;
      var $u1050=(($606+24)|0);
      var $l1051=$u1050;
      var $savedpc1052=(($l1051+4)|0);
      var $607=HEAP32[(($savedpc1052)>>2)];
      var $incdec_ptr1053=(($607+4)|0);
      HEAP32[(($savedpc1052)>>2)]=$incdec_ptr1053;
      label = 203; break;
    case 200: 
      var $608=$rb1016;
      $io21055=$608;
      var $609=$ra;
      $io11056=$609;
      var $610=$io11056;
      var $value_1057=(($610)|0);
      var $611=$io21055;
      var $value_1058=(($611)|0);
      var $612=$value_1057;
      var $613=$value_1058;
      HEAP32[(($612)>>2)]=HEAP32[(($613)>>2)];HEAP32[((($612)+(4))>>2)]=HEAP32[((($613)+(4))>>2)];
      var $614=$io21055;
      var $tt_1059=(($614+8)|0);
      var $615=HEAP32[(($tt_1059)>>2)];
      var $616=$io11056;
      var $tt_1060=(($616+8)|0);
      HEAP32[(($tt_1060)>>2)]=$615;
      var $617=$ci;
      var $u1061=(($617+24)|0);
      var $l1062=$u1061;
      var $savedpc1063=(($l1062+4)|0);
      var $618=HEAP32[(($savedpc1063)>>2)];
      var $619=HEAP32[(($618)>>2)];
      $i=$619;
      var $620=$i;
      var $shr1065=$620 >>> 6;
      var $and1066=$shr1065 & 255;
      $a1064=$and1066;
      var $621=$a1064;
      var $cmp1067=(($621)|0) > 0;
      if ($cmp1067) { label = 201; break; } else { label = 202; break; }
    case 201: 
      var $622=$L_addr;
      var $623=$ci;
      var $u1070=(($623+24)|0);
      var $l1071=$u1070;
      var $base1072=(($l1071)|0);
      var $624=HEAP32[(($base1072)>>2)];
      var $625=$a1064;
      var $add_ptr1073=(($624+((($625)*(12))&-1))|0);
      var $add_ptr1074=((($add_ptr1073)-(12))|0);
      _luaF_close($622, $add_ptr1074);
      label = 202; break;
    case 202: 
      var $626=$i;
      var $shr1076=$626 >>> 14;
      var $and1077=$shr1076 & 262143;
      var $sub1078=((($and1077)-(131071))|0);
      var $add1079=((($sub1078)+(1))|0);
      var $627=$ci;
      var $u1080=(($627+24)|0);
      var $l1081=$u1080;
      var $savedpc1082=(($l1081+4)|0);
      var $628=HEAP32[(($savedpc1082)>>2)];
      var $add_ptr1083=(($628+($add1079<<2))|0);
      HEAP32[(($savedpc1082)>>2)]=$add_ptr1083;
      label = 203; break;
    case 203: 
      label = 290; break;
    case 204: 
      var $629=$i;
      var $shr1087=$629 >>> 23;
      var $and1088=$shr1087 & 511;
      $b1086=$and1088;
      var $630=$i;
      var $shr1089=$630 >>> 14;
      var $and1090=$shr1089 & 511;
      var $sub1091=((($and1090)-(1))|0);
      $nresults=$sub1091;
      var $631=$b1086;
      var $cmp1092=(($631)|0)!=0;
      if ($cmp1092) { label = 205; break; } else { label = 206; break; }
    case 205: 
      var $632=$ra;
      var $633=$b1086;
      var $add_ptr1095=(($632+((($633)*(12))&-1))|0);
      var $634=$L_addr;
      var $top1096=(($634+8)|0);
      HEAP32[(($top1096)>>2)]=$add_ptr1095;
      label = 206; break;
    case 206: 
      var $635=$L_addr;
      var $636=$ra;
      var $637=$nresults;
      var $call1098=_luaD_precall($635, $636, $637);
      var $tobool1099=(($call1098)|0)!=0;
      if ($tobool1099) { label = 207; break; } else { label = 210; break; }
    case 207: 
      var $638=$nresults;
      var $cmp1101=(($638)|0) >= 0;
      if ($cmp1101) { label = 208; break; } else { label = 209; break; }
    case 208: 
      var $639=$ci;
      var $top1104=(($639+4)|0);
      var $640=HEAP32[(($top1104)>>2)];
      var $641=$L_addr;
      var $top1105=(($641+8)|0);
      HEAP32[(($top1105)>>2)]=$640;
      label = 209; break;
    case 209: 
      var $642=$ci;
      var $u1107=(($642+24)|0);
      var $l1108=$u1107;
      var $base1109=(($l1108)|0);
      var $643=HEAP32[(($base1109)>>2)];
      $base=$643;
      label = 211; break;
    case 210: 
      var $644=$L_addr;
      var $ci1111=(($644+16)|0);
      var $645=HEAP32[(($ci1111)>>2)];
      $ci=$645;
      var $646=$ci;
      var $callstatus=(($646+18)|0);
      var $647=HEAP8[($callstatus)];
      var $conv1112=(($647)&255);
      var $or=$conv1112 | 4;
      var $conv1113=(($or) & 255);
      HEAP8[($callstatus)]=$conv1113;
      label = 3; break;
    case 211: 
      label = 290; break;
    case 212: 
      var $648=$i;
      var $shr1117=$648 >>> 23;
      var $and1118=$shr1117 & 511;
      $b1116=$and1118;
      var $649=$b1116;
      var $cmp1119=(($649)|0)!=0;
      if ($cmp1119) { label = 213; break; } else { label = 214; break; }
    case 213: 
      var $650=$ra;
      var $651=$b1116;
      var $add_ptr1122=(($650+((($651)*(12))&-1))|0);
      var $652=$L_addr;
      var $top1123=(($652+8)|0);
      HEAP32[(($top1123)>>2)]=$add_ptr1122;
      label = 214; break;
    case 214: 
      var $653=$L_addr;
      var $654=$ra;
      var $call1125=_luaD_precall($653, $654, -1);
      var $tobool1126=(($call1125)|0)!=0;
      if ($tobool1126) { label = 215; break; } else { label = 216; break; }
    case 215: 
      var $655=$ci;
      var $u1128=(($655+24)|0);
      var $l1129=$u1128;
      var $base1130=(($l1129)|0);
      var $656=HEAP32[(($base1130)>>2)];
      $base=$656;
      label = 223; break;
    case 216: 
      var $657=$L_addr;
      var $ci1132=(($657+16)|0);
      var $658=HEAP32[(($ci1132)>>2)];
      $nci=$658;
      var $659=$nci;
      var $previous=(($659+8)|0);
      var $660=HEAP32[(($previous)>>2)];
      $oci=$660;
      var $661=$nci;
      var $func1133=(($661)|0);
      var $662=HEAP32[(($func1133)>>2)];
      $nfunc=$662;
      var $663=$oci;
      var $func1134=(($663)|0);
      var $664=HEAP32[(($func1134)>>2)];
      $ofunc=$664;
      var $665=$nci;
      var $u1135=(($665+24)|0);
      var $l1136=$u1135;
      var $base1137=(($l1136)|0);
      var $666=HEAP32[(($base1137)>>2)];
      var $667=$nfunc;
      var $value_1138=(($667)|0);
      var $gc1139=$value_1138;
      var $668=HEAP32[(($gc1139)>>2)];
      var $cl1140=$668;
      var $l1141=$cl1140;
      var $p1142=(($l1141+12)|0);
      var $669=HEAP32[(($p1142)>>2)];
      var $numparams=(($669+76)|0);
      var $670=HEAP8[($numparams)];
      var $conv1143=(($670)&255);
      var $add_ptr1144=(($666+((($conv1143)*(12))&-1))|0);
      $lim=$add_ptr1144;
      var $671=$cl;
      var $p1145=(($671+12)|0);
      var $672=HEAP32[(($p1145)>>2)];
      var $sizep=(($672+56)|0);
      var $673=HEAP32[(($sizep)>>2)];
      var $cmp1146=(($673)|0) > 0;
      if ($cmp1146) { label = 217; break; } else { label = 218; break; }
    case 217: 
      var $674=$L_addr;
      var $675=$oci;
      var $u1149=(($675+24)|0);
      var $l1150=$u1149;
      var $base1151=(($l1150)|0);
      var $676=HEAP32[(($base1151)>>2)];
      _luaF_close($674, $676);
      label = 218; break;
    case 218: 
      $aux=0;
      label = 219; break;
    case 219: 
      var $677=$nfunc;
      var $678=$aux;
      var $add_ptr1154=(($677+((($678)*(12))&-1))|0);
      var $679=$lim;
      var $cmp1155=(($add_ptr1154)>>>0) < (($679)>>>0);
      if ($cmp1155) { label = 220; break; } else { label = 222; break; }
    case 220: 
      var $680=$nfunc;
      var $681=$aux;
      var $add_ptr1158=(($680+((($681)*(12))&-1))|0);
      $io21157=$add_ptr1158;
      var $682=$ofunc;
      var $683=$aux;
      var $add_ptr1160=(($682+((($683)*(12))&-1))|0);
      $io11159=$add_ptr1160;
      var $684=$io11159;
      var $value_1161=(($684)|0);
      var $685=$io21157;
      var $value_1162=(($685)|0);
      var $686=$value_1161;
      var $687=$value_1162;
      HEAP32[(($686)>>2)]=HEAP32[(($687)>>2)];HEAP32[((($686)+(4))>>2)]=HEAP32[((($687)+(4))>>2)];
      var $688=$io21157;
      var $tt_1163=(($688+8)|0);
      var $689=HEAP32[(($tt_1163)>>2)];
      var $690=$io11159;
      var $tt_1164=(($690+8)|0);
      HEAP32[(($tt_1164)>>2)]=$689;
      label = 221; break;
    case 221: 
      var $691=$aux;
      var $inc=((($691)+(1))|0);
      $aux=$inc;
      label = 219; break;
    case 222: 
      var $692=$ofunc;
      var $693=$nci;
      var $u1165=(($693+24)|0);
      var $l1166=$u1165;
      var $base1167=(($l1166)|0);
      var $694=HEAP32[(($base1167)>>2)];
      var $695=$nfunc;
      var $sub_ptr_lhs_cast=$694;
      var $sub_ptr_rhs_cast=$695;
      var $sub_ptr_sub=((($sub_ptr_lhs_cast)-($sub_ptr_rhs_cast))|0);
      var $sub_ptr_div=((((($sub_ptr_sub)|0))/(12))&-1);
      var $add_ptr1168=(($692+((($sub_ptr_div)*(12))&-1))|0);
      var $696=$oci;
      var $u1169=(($696+24)|0);
      var $l1170=$u1169;
      var $base1171=(($l1170)|0);
      HEAP32[(($base1171)>>2)]=$add_ptr1168;
      var $697=$ofunc;
      var $698=$L_addr;
      var $top1172=(($698+8)|0);
      var $699=HEAP32[(($top1172)>>2)];
      var $700=$nfunc;
      var $sub_ptr_lhs_cast1173=$699;
      var $sub_ptr_rhs_cast1174=$700;
      var $sub_ptr_sub1175=((($sub_ptr_lhs_cast1173)-($sub_ptr_rhs_cast1174))|0);
      var $sub_ptr_div1176=((((($sub_ptr_sub1175)|0))/(12))&-1);
      var $add_ptr1177=(($697+((($sub_ptr_div1176)*(12))&-1))|0);
      var $701=$L_addr;
      var $top1178=(($701+8)|0);
      HEAP32[(($top1178)>>2)]=$add_ptr1177;
      var $702=$oci;
      var $top1179=(($702+4)|0);
      HEAP32[(($top1179)>>2)]=$add_ptr1177;
      var $703=$nci;
      var $u1180=(($703+24)|0);
      var $l1181=$u1180;
      var $savedpc1182=(($l1181+4)|0);
      var $704=HEAP32[(($savedpc1182)>>2)];
      var $705=$oci;
      var $u1183=(($705+24)|0);
      var $l1184=$u1183;
      var $savedpc1185=(($l1184+4)|0);
      HEAP32[(($savedpc1185)>>2)]=$704;
      var $706=$oci;
      var $callstatus1186=(($706+18)|0);
      var $707=HEAP8[($callstatus1186)];
      var $conv1187=(($707)&255);
      var $or1188=$conv1187 | 64;
      var $conv1189=(($or1188) & 255);
      HEAP8[($callstatus1186)]=$conv1189;
      var $708=$oci;
      var $709=$L_addr;
      var $ci1190=(($709+16)|0);
      HEAP32[(($ci1190)>>2)]=$708;
      $ci=$708;
      label = 3; break;
    case 223: 
      label = 290; break;
    case 224: 
      var $710=$i;
      var $shr1194=$710 >>> 23;
      var $and1195=$shr1194 & 511;
      $b1193=$and1195;
      var $711=$b1193;
      var $cmp1196=(($711)|0)!=0;
      if ($cmp1196) { label = 225; break; } else { label = 226; break; }
    case 225: 
      var $712=$ra;
      var $713=$b1193;
      var $add_ptr1199=(($712+((($713)*(12))&-1))|0);
      var $add_ptr1200=((($add_ptr1199)-(12))|0);
      var $714=$L_addr;
      var $top1201=(($714+8)|0);
      HEAP32[(($top1201)>>2)]=$add_ptr1200;
      label = 226; break;
    case 226: 
      var $715=$cl;
      var $p1203=(($715+12)|0);
      var $716=HEAP32[(($p1203)>>2)];
      var $sizep1204=(($716+56)|0);
      var $717=HEAP32[(($sizep1204)>>2)];
      var $cmp1205=(($717)|0) > 0;
      if ($cmp1205) { label = 227; break; } else { label = 228; break; }
    case 227: 
      var $718=$L_addr;
      var $719=$base;
      _luaF_close($718, $719);
      label = 228; break;
    case 228: 
      var $720=$L_addr;
      var $721=$ra;
      var $call1209=_luaD_poscall($720, $721);
      $b1193=$call1209;
      var $722=$ci;
      var $callstatus1210=(($722+18)|0);
      var $723=HEAP8[($callstatus1210)];
      var $conv1211=(($723)&255);
      var $and1212=$conv1211 & 4;
      var $tobool1213=(($and1212)|0)!=0;
      if ($tobool1213) { label = 230; break; } else { label = 229; break; }
    case 229: 
      STACKTOP = __stackBase__;
      Module.print(INDENT + 'Exiting: _luaV_execute');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return;
    case 230: 
      var $724=$L_addr;
      var $ci1216=(($724+16)|0);
      var $725=HEAP32[(($ci1216)>>2)];
      $ci=$725;
      var $726=$b1193;
      var $tobool1217=(($726)|0)!=0;
      if ($tobool1217) { label = 231; break; } else { label = 232; break; }
    case 231: 
      var $727=$ci;
      var $top1219=(($727+4)|0);
      var $728=HEAP32[(($top1219)>>2)];
      var $729=$L_addr;
      var $top1220=(($729+8)|0);
      HEAP32[(($top1220)>>2)]=$728;
      label = 232; break;
    case 232: 
      label = 3; break;
    case 233: 
      var $730=$ra;
      var $add_ptr1223=(($730+24)|0);
      var $value_1224=(($add_ptr1223)|0);
      var $n1225=$value_1224;
      var $731=(HEAP32[((tempDoublePtr)>>2)]=HEAP32[(($n1225)>>2)],HEAP32[(((tempDoublePtr)+(4))>>2)]=HEAP32[((($n1225)+(4))>>2)],HEAPF64[(tempDoublePtr)>>3]);
      $step=$731;
      var $732=$ra;
      var $value_1226=(($732)|0);
      var $n1227=$value_1226;
      var $733=(HEAP32[((tempDoublePtr)>>2)]=HEAP32[(($n1227)>>2)],HEAP32[(((tempDoublePtr)+(4))>>2)]=HEAP32[((($n1227)+(4))>>2)],HEAPF64[(tempDoublePtr)>>3]);
      var $734=$step;
      var $add1228=($733)+($734);
      $idx=$add1228;
      var $735=$ra;
      var $add_ptr1229=(($735+12)|0);
      var $value_1230=(($add_ptr1229)|0);
      var $n1231=$value_1230;
      var $736=(HEAP32[((tempDoublePtr)>>2)]=HEAP32[(($n1231)>>2)],HEAP32[(((tempDoublePtr)+(4))>>2)]=HEAP32[((($n1231)+(4))>>2)],HEAPF64[(tempDoublePtr)>>3]);
      $limit=$736;
      var $737=$step;
      var $cmp1232=0 < $737;
      if ($cmp1232) { label = 234; break; } else { label = 235; break; }
    case 234: 
      var $738=$idx;
      var $739=$limit;
      var $cmp1235=$738 <= $739;
      if ($cmp1235) { label = 236; break; } else { label = 237; break; }
    case 235: 
      var $740=$limit;
      var $741=$idx;
      var $cmp1238=$740 <= $741;
      if ($cmp1238) { label = 236; break; } else { label = 237; break; }
    case 236: 
      var $742=$i;
      var $shr1241=$742 >>> 14;
      var $and1242=$shr1241 & 262143;
      var $sub1243=((($and1242)-(131071))|0);
      var $743=$ci;
      var $u1244=(($743+24)|0);
      var $l1245=$u1244;
      var $savedpc1246=(($l1245+4)|0);
      var $744=HEAP32[(($savedpc1246)>>2)];
      var $add_ptr1247=(($744+($sub1243<<2))|0);
      HEAP32[(($savedpc1246)>>2)]=$add_ptr1247;
      var $745=$ra;
      $io1248=$745;
      var $746=$idx;
      var $747=$io1248;
      var $value_1249=(($747)|0);
      var $n1250=$value_1249;
      (HEAPF64[(tempDoublePtr)>>3]=$746,HEAP32[(($n1250)>>2)]=HEAP32[((tempDoublePtr)>>2)],HEAP32[((($n1250)+(4))>>2)]=HEAP32[(((tempDoublePtr)+(4))>>2)]);
      var $748=$io1248;
      var $tt_1251=(($748+8)|0);
      HEAP32[(($tt_1251)>>2)]=3;
      var $749=$ra;
      var $add_ptr1253=(($749+36)|0);
      $io1252=$add_ptr1253;
      var $750=$idx;
      var $751=$io1252;
      var $value_1254=(($751)|0);
      var $n1255=$value_1254;
      (HEAPF64[(tempDoublePtr)>>3]=$750,HEAP32[(($n1255)>>2)]=HEAP32[((tempDoublePtr)>>2)],HEAP32[((($n1255)+(4))>>2)]=HEAP32[(((tempDoublePtr)+(4))>>2)]);
      var $752=$io1252;
      var $tt_1256=(($752+8)|0);
      HEAP32[(($tt_1256)>>2)]=3;
      label = 237; break;
    case 237: 
      label = 290; break;
    case 238: 
      var $753=$ra;
      $init=$753;
      var $754=$ra;
      var $add_ptr1259=(($754+12)|0);
      $plimit=$add_ptr1259;
      var $755=$ra;
      var $add_ptr1260=(($755+24)|0);
      $pstep=$add_ptr1260;
      var $756=$init;
      var $tt_1261=(($756+8)|0);
      var $757=HEAP32[(($tt_1261)>>2)];
      var $cmp1262=(($757)|0)==3;
      if ($cmp1262) { label = 241; break; } else { label = 239; break; }
    case 239: 
      var $758=$init;
      var $759=$ra;
      var $call1265=_luaV_tonumber($758, $759);
      $init=$call1265;
      var $cmp1266=(($call1265)|0)!=0;
      if ($cmp1266) { label = 241; break; } else { label = 240; break; }
    case 240: 
      var $760=$L_addr;
      _luaG_runerror($760, ((5244500)|0), (tempInt=STACKTOP,_memset(STACKTOP, 0, 1),STACKTOP = (STACKTOP + 1)|0,STACKTOP = ((((STACKTOP)+3)>>2)<<2),HEAP32[((tempInt)>>2)]=0,tempInt));

    case 241: 
      var $761=$plimit;
      var $tt_1270=(($761+8)|0);
      var $762=HEAP32[(($tt_1270)>>2)];
      var $cmp1271=(($762)|0)==3;
      if ($cmp1271) { label = 244; break; } else { label = 242; break; }
    case 242: 
      var $763=$plimit;
      var $764=$ra;
      var $add_ptr1274=(($764+12)|0);
      var $call1275=_luaV_tonumber($763, $add_ptr1274);
      $plimit=$call1275;
      var $cmp1276=(($call1275)|0)!=0;
      if ($cmp1276) { label = 244; break; } else { label = 243; break; }
    case 243: 
      var $765=$L_addr;
      _luaG_runerror($765, ((5244400)|0), (tempInt=STACKTOP,_memset(STACKTOP, 0, 1),STACKTOP = (STACKTOP + 1)|0,STACKTOP = ((((STACKTOP)+3)>>2)<<2),HEAP32[((tempInt)>>2)]=0,tempInt));

    case 244: 
      var $766=$pstep;
      var $tt_1280=(($766+8)|0);
      var $767=HEAP32[(($tt_1280)>>2)];
      var $cmp1281=(($767)|0)==3;
      if ($cmp1281) { label = 247; break; } else { label = 245; break; }
    case 245: 
      var $768=$pstep;
      var $769=$ra;
      var $add_ptr1284=(($769+24)|0);
      var $call1285=_luaV_tonumber($768, $add_ptr1284);
      $pstep=$call1285;
      var $cmp1286=(($call1285)|0)!=0;
      if ($cmp1286) { label = 247; break; } else { label = 246; break; }
    case 246: 
      var $770=$L_addr;
      _luaG_runerror($770, ((5244232)|0), (tempInt=STACKTOP,_memset(STACKTOP, 0, 1),STACKTOP = (STACKTOP + 1)|0,STACKTOP = ((((STACKTOP)+3)>>2)<<2),HEAP32[((tempInt)>>2)]=0,tempInt));

    case 247: 
      label = 248; break;
    case 248: 
      label = 249; break;
    case 249: 
      var $771=$ra;
      $io1292=$771;
      var $772=$ra;
      var $value_1293=(($772)|0);
      var $n1294=$value_1293;
      var $773=(HEAP32[((tempDoublePtr)>>2)]=HEAP32[(($n1294)>>2)],HEAP32[(((tempDoublePtr)+(4))>>2)]=HEAP32[((($n1294)+(4))>>2)],HEAPF64[(tempDoublePtr)>>3]);
      var $774=$pstep;
      var $value_1295=(($774)|0);
      var $n1296=$value_1295;
      var $775=(HEAP32[((tempDoublePtr)>>2)]=HEAP32[(($n1296)>>2)],HEAP32[(((tempDoublePtr)+(4))>>2)]=HEAP32[((($n1296)+(4))>>2)],HEAPF64[(tempDoublePtr)>>3]);
      var $sub1297=($773)-($775);
      var $776=$io1292;
      var $value_1298=(($776)|0);
      var $n1299=$value_1298;
      (HEAPF64[(tempDoublePtr)>>3]=$sub1297,HEAP32[(($n1299)>>2)]=HEAP32[((tempDoublePtr)>>2)],HEAP32[((($n1299)+(4))>>2)]=HEAP32[(((tempDoublePtr)+(4))>>2)]);
      var $777=$io1292;
      var $tt_1300=(($777+8)|0);
      HEAP32[(($tt_1300)>>2)]=3;
      var $778=$i;
      var $shr1301=$778 >>> 14;
      var $and1302=$shr1301 & 262143;
      var $sub1303=((($and1302)-(131071))|0);
      var $779=$ci;
      var $u1304=(($779+24)|0);
      var $l1305=$u1304;
      var $savedpc1306=(($l1305+4)|0);
      var $780=HEAP32[(($savedpc1306)>>2)];
      var $add_ptr1307=(($780+($sub1303<<2))|0);
      HEAP32[(($savedpc1306)>>2)]=$add_ptr1307;
      label = 290; break;
    case 250: 
      var $781=$ra;
      var $add_ptr1309=(($781+36)|0);
      $cb=$add_ptr1309;
      var $782=$ra;
      var $add_ptr1311=(($782+24)|0);
      $io21310=$add_ptr1311;
      var $783=$cb;
      var $add_ptr1313=(($783+24)|0);
      $io11312=$add_ptr1313;
      var $784=$io11312;
      var $value_1314=(($784)|0);
      var $785=$io21310;
      var $value_1315=(($785)|0);
      var $786=$value_1314;
      var $787=$value_1315;
      HEAP32[(($786)>>2)]=HEAP32[(($787)>>2)];HEAP32[((($786)+(4))>>2)]=HEAP32[((($787)+(4))>>2)];
      var $788=$io21310;
      var $tt_1316=(($788+8)|0);
      var $789=HEAP32[(($tt_1316)>>2)];
      var $790=$io11312;
      var $tt_1317=(($790+8)|0);
      HEAP32[(($tt_1317)>>2)]=$789;
      var $791=$ra;
      var $add_ptr1319=(($791+12)|0);
      $io21318=$add_ptr1319;
      var $792=$cb;
      var $add_ptr1321=(($792+12)|0);
      $io11320=$add_ptr1321;
      var $793=$io11320;
      var $value_1322=(($793)|0);
      var $794=$io21318;
      var $value_1323=(($794)|0);
      var $795=$value_1322;
      var $796=$value_1323;
      HEAP32[(($795)>>2)]=HEAP32[(($796)>>2)];HEAP32[((($795)+(4))>>2)]=HEAP32[((($796)+(4))>>2)];
      var $797=$io21318;
      var $tt_1324=(($797+8)|0);
      var $798=HEAP32[(($tt_1324)>>2)];
      var $799=$io11320;
      var $tt_1325=(($799+8)|0);
      HEAP32[(($tt_1325)>>2)]=$798;
      var $800=$ra;
      $io21326=$800;
      var $801=$cb;
      $io11327=$801;
      var $802=$io11327;
      var $value_1328=(($802)|0);
      var $803=$io21326;
      var $value_1329=(($803)|0);
      var $804=$value_1328;
      var $805=$value_1329;
      HEAP32[(($804)>>2)]=HEAP32[(($805)>>2)];HEAP32[((($804)+(4))>>2)]=HEAP32[((($805)+(4))>>2)];
      var $806=$io21326;
      var $tt_1330=(($806+8)|0);
      var $807=HEAP32[(($tt_1330)>>2)];
      var $808=$io11327;
      var $tt_1331=(($808+8)|0);
      HEAP32[(($tt_1331)>>2)]=$807;
      var $809=$cb;
      var $add_ptr1332=(($809+36)|0);
      var $810=$L_addr;
      var $top1333=(($810+8)|0);
      HEAP32[(($top1333)>>2)]=$add_ptr1332;
      var $811=$L_addr;
      var $812=$cb;
      var $813=$i;
      var $shr1334=$813 >>> 14;
      var $and1335=$shr1334 & 511;
      _luaD_call($811, $812, $and1335, 1);
      var $814=$ci;
      var $u1336=(($814+24)|0);
      var $l1337=$u1336;
      var $base1338=(($l1337)|0);
      var $815=HEAP32[(($base1338)>>2)];
      $base=$815;
      var $816=$ci;
      var $top1339=(($816+4)|0);
      var $817=HEAP32[(($top1339)>>2)];
      var $818=$L_addr;
      var $top1340=(($818+8)|0);
      HEAP32[(($top1340)>>2)]=$817;
      var $819=$ci;
      var $u1341=(($819+24)|0);
      var $l1342=$u1341;
      var $savedpc1343=(($l1342+4)|0);
      var $820=HEAP32[(($savedpc1343)>>2)];
      var $incdec_ptr1344=(($820+4)|0);
      HEAP32[(($savedpc1343)>>2)]=$incdec_ptr1344;
      var $821=HEAP32[(($820)>>2)];
      $i=$821;
      var $822=$base;
      var $823=$i;
      var $shr1345=$823 >>> 6;
      var $and1346=$shr1345 & 255;
      var $add_ptr1347=(($822+((($and1346)*(12))&-1))|0);
      $ra=$add_ptr1347;
      label = 252; break;
    case 251: 
      label = 252; break;
    case 252: 
      var $824=$ra;
      var $add_ptr1349=(($824+12)|0);
      var $tt_1350=(($add_ptr1349+8)|0);
      var $825=HEAP32[(($tt_1350)>>2)];
      var $cmp1351=(($825)|0)==0;
      if ($cmp1351) { label = 254; break; } else { label = 253; break; }
    case 253: 
      var $826=$ra;
      var $add_ptr1355=(($826+12)|0);
      $io21354=$add_ptr1355;
      var $827=$ra;
      $io11356=$827;
      var $828=$io11356;
      var $value_1357=(($828)|0);
      var $829=$io21354;
      var $value_1358=(($829)|0);
      var $830=$value_1357;
      var $831=$value_1358;
      HEAP32[(($830)>>2)]=HEAP32[(($831)>>2)];HEAP32[((($830)+(4))>>2)]=HEAP32[((($831)+(4))>>2)];
      var $832=$io21354;
      var $tt_1359=(($832+8)|0);
      var $833=HEAP32[(($tt_1359)>>2)];
      var $834=$io11356;
      var $tt_1360=(($834+8)|0);
      HEAP32[(($tt_1360)>>2)]=$833;
      var $835=$i;
      var $shr1361=$835 >>> 14;
      var $and1362=$shr1361 & 262143;
      var $sub1363=((($and1362)-(131071))|0);
      var $836=$ci;
      var $u1364=(($836+24)|0);
      var $l1365=$u1364;
      var $savedpc1366=(($l1365+4)|0);
      var $837=HEAP32[(($savedpc1366)>>2)];
      var $add_ptr1367=(($837+($sub1363<<2))|0);
      HEAP32[(($savedpc1366)>>2)]=$add_ptr1367;
      label = 254; break;
    case 254: 
      label = 290; break;
    case 255: 
      var $838=$i;
      var $shr1371=$838 >>> 23;
      var $and1372=$shr1371 & 511;
      $n1370=$and1372;
      var $839=$i;
      var $shr1374=$839 >>> 14;
      var $and1375=$shr1374 & 511;
      $c1373=$and1375;
      var $840=$n1370;
      var $cmp1376=(($840)|0)==0;
      if ($cmp1376) { label = 256; break; } else { label = 257; break; }
    case 256: 
      var $841=$L_addr;
      var $top1379=(($841+8)|0);
      var $842=HEAP32[(($top1379)>>2)];
      var $843=$ra;
      var $sub_ptr_lhs_cast1380=$842;
      var $sub_ptr_rhs_cast1381=$843;
      var $sub_ptr_sub1382=((($sub_ptr_lhs_cast1380)-($sub_ptr_rhs_cast1381))|0);
      var $sub_ptr_div1383=((((($sub_ptr_sub1382)|0))/(12))&-1);
      var $sub1384=((($sub_ptr_div1383)-(1))|0);
      $n1370=$sub1384;
      label = 257; break;
    case 257: 
      var $844=$c1373;
      var $cmp1386=(($844)|0)==0;
      if ($cmp1386) { label = 258; break; } else { label = 259; break; }
    case 258: 
      var $845=$ci;
      var $u1389=(($845+24)|0);
      var $l1390=$u1389;
      var $savedpc1391=(($l1390+4)|0);
      var $846=HEAP32[(($savedpc1391)>>2)];
      var $incdec_ptr1392=(($846+4)|0);
      HEAP32[(($savedpc1391)>>2)]=$incdec_ptr1392;
      var $847=HEAP32[(($846)>>2)];
      var $shr1393=$847 >>> 6;
      var $and1394=$shr1393 & 67108863;
      $c1373=$and1394;
      label = 259; break;
    case 259: 
      var $848=$ra;
      var $value_1396=(($848)|0);
      var $gc1397=$value_1396;
      var $849=HEAP32[(($gc1397)>>2)];
      var $h1398=$849;
      $h=$h1398;
      var $850=$c1373;
      var $sub1399=((($850)-(1))|0);
      var $mul1400=((($sub1399)*(50))&-1);
      var $851=$n1370;
      var $add1401=((($mul1400)+($851))|0);
      $last=$add1401;
      var $852=$last;
      var $853=$h;
      var $sizearray=(($853+28)|0);
      var $854=HEAP32[(($sizearray)>>2)];
      var $cmp1402=(($852)|0) > (($854)|0);
      if ($cmp1402) { label = 260; break; } else { label = 261; break; }
    case 260: 
      var $855=$L_addr;
      var $856=$h;
      var $857=$last;
      _luaH_resizearray($855, $856, $857);
      label = 261; break;
    case 261: 
      label = 262; break;
    case 262: 
      var $858=$n1370;
      var $cmp1407=(($858)|0) > 0;
      if ($cmp1407) { label = 263; break; } else { label = 269; break; }
    case 263: 
      var $859=$ra;
      var $860=$n1370;
      var $add_ptr1410=(($859+((($860)*(12))&-1))|0);
      $val=$add_ptr1410;
      var $861=$L_addr;
      var $862=$h;
      var $863=$last;
      var $dec1411=((($863)-(1))|0);
      $last=$dec1411;
      var $864=$val;
      _luaH_setint($861, $862, $863, $864);
      var $865=$val;
      var $tt_1412=(($865+8)|0);
      var $866=HEAP32[(($tt_1412)>>2)];
      var $and1413=$866 & 64;
      var $tobool1414=(($and1413)|0)!=0;
      if ($tobool1414) { label = 264; break; } else { label = 267; break; }
    case 264: 
      var $867=$val;
      var $value_1416=(($867)|0);
      var $gc1417=$value_1416;
      var $868=HEAP32[(($gc1417)>>2)];
      var $gch1418=$868;
      var $marked1419=(($gch1418+5)|0);
      var $869=HEAP8[($marked1419)];
      var $conv1420=(($869)&255);
      var $and1421=$conv1420 & 3;
      var $tobool1422=(($and1421)|0)!=0;
      if ($tobool1422) { label = 265; break; } else { label = 267; break; }
    case 265: 
      var $870=$h;
      var $871=$870;
      var $gch1424=$871;
      var $marked1425=(($gch1424+5)|0);
      var $872=HEAP8[($marked1425)];
      var $conv1426=(($872)&255);
      var $and1427=$conv1426 & 4;
      var $tobool1428=(($and1427)|0)!=0;
      if ($tobool1428) { label = 266; break; } else { label = 267; break; }
    case 266: 
      var $873=$L_addr;
      var $874=$h;
      var $875=$874;
      _luaC_barrierback_($873, $875);
      label = 267; break;
    case 267: 
      label = 268; break;
    case 268: 
      var $876=$n1370;
      var $dec1432=((($876)-(1))|0);
      $n1370=$dec1432;
      label = 262; break;
    case 269: 
      var $877=$ci;
      var $top1434=(($877+4)|0);
      var $878=HEAP32[(($top1434)>>2)];
      var $879=$L_addr;
      var $top1435=(($879+8)|0);
      HEAP32[(($top1435)>>2)]=$878;
      label = 290; break;
    case 270: 
      var $880=$i;
      var $shr1438=$880 >>> 14;
      var $and1439=$shr1438 & 262143;
      var $881=$cl;
      var $p1440=(($881+12)|0);
      var $882=HEAP32[(($p1440)>>2)];
      var $p1441=(($882+16)|0);
      var $883=HEAP32[(($p1441)>>2)];
      var $arrayidx1442=(($883+($and1439<<2))|0);
      var $884=HEAP32[(($arrayidx1442)>>2)];
      $p1437=$884;
      var $885=$p1437;
      var $886=$cl;
      var $upvals1443=(($886+16)|0);
      var $arraydecay=(($upvals1443)|0);
      var $887=$base;
      var $call1444=_getcached($885, $arraydecay, $887);
      $ncl=$call1444;
      var $888=$ncl;
      var $cmp1445=(($888)|0)==0;
      if ($cmp1445) { label = 271; break; } else { label = 272; break; }
    case 271: 
      var $889=$L_addr;
      var $890=$p1437;
      var $891=$cl;
      var $upvals1448=(($891+16)|0);
      var $arraydecay1449=(($upvals1448)|0);
      var $892=$base;
      var $893=$ra;
      _pushclosure($889, $890, $arraydecay1449, $892, $893);
      label = 273; break;
    case 272: 
      var $894=$ra;
      $io1451=$894;
      var $895=$ncl;
      var $896=$895;
      var $897=$io1451;
      var $value_1452=(($897)|0);
      var $gc1453=$value_1452;
      HEAP32[(($gc1453)>>2)]=$896;
      var $898=$io1451;
      var $tt_1454=(($898+8)|0);
      HEAP32[(($tt_1454)>>2)]=70;
      label = 273; break;
    case 273: 
      var $899=$L_addr;
      var $l_G1456=(($899+12)|0);
      var $900=HEAP32[(($l_G1456)>>2)];
      var $GCdebt1457=(($900+12)|0);
      var $901=HEAP32[(($GCdebt1457)>>2)];
      var $cmp1458=(($901)|0) > 0;
      if ($cmp1458) { label = 274; break; } else { label = 275; break; }
    case 274: 
      var $902=$ra;
      var $add_ptr1461=(($902+12)|0);
      var $903=$L_addr;
      var $top1462=(($903+8)|0);
      HEAP32[(($top1462)>>2)]=$add_ptr1461;
      var $904=$L_addr;
      _luaC_step($904);
      var $905=$ci;
      var $top1463=(($905+4)|0);
      var $906=HEAP32[(($top1463)>>2)];
      var $907=$L_addr;
      var $top1464=(($907+8)|0);
      HEAP32[(($top1464)>>2)]=$906;
      label = 275; break;
    case 275: 
      var $908=$ci;
      var $u1466=(($908+24)|0);
      var $l1467=$u1466;
      var $base1468=(($l1467)|0);
      var $909=HEAP32[(($base1468)>>2)];
      $base=$909;
      label = 290; break;
    case 276: 
      var $910=$i;
      var $shr1471=$910 >>> 23;
      var $and1472=$shr1471 & 511;
      var $sub1473=((($and1472)-(1))|0);
      $b1470=$sub1473;
      var $911=$base;
      var $912=$ci;
      var $func1475=(($912)|0);
      var $913=HEAP32[(($func1475)>>2)];
      var $sub_ptr_lhs_cast1476=$911;
      var $sub_ptr_rhs_cast1477=$913;
      var $sub_ptr_sub1478=((($sub_ptr_lhs_cast1476)-($sub_ptr_rhs_cast1477))|0);
      var $sub_ptr_div1479=((((($sub_ptr_sub1478)|0))/(12))&-1);
      var $914=$cl;
      var $p1480=(($914+12)|0);
      var $915=HEAP32[(($p1480)>>2)];
      var $numparams1481=(($915+76)|0);
      var $916=HEAP8[($numparams1481)];
      var $conv1482=(($916)&255);
      var $sub1483=((($sub_ptr_div1479)-($conv1482))|0);
      var $sub1484=((($sub1483)-(1))|0);
      $n1474=$sub1484;
      var $917=$b1470;
      var $cmp1485=(($917)|0) < 0;
      if ($cmp1485) { label = 277; break; } else { label = 281; break; }
    case 277: 
      var $918=$n1474;
      $b1470=$918;
      var $919=$L_addr;
      var $stack_last=(($919+24)|0);
      var $920=HEAP32[(($stack_last)>>2)];
      var $921=$L_addr;
      var $top1488=(($921+8)|0);
      var $922=HEAP32[(($top1488)>>2)];
      var $sub_ptr_lhs_cast1489=$920;
      var $sub_ptr_rhs_cast1490=$922;
      var $sub_ptr_sub1491=((($sub_ptr_lhs_cast1489)-($sub_ptr_rhs_cast1490))|0);
      var $sub_ptr_div1492=((((($sub_ptr_sub1491)|0))/(12))&-1);
      var $923=$n1474;
      var $cmp1493=(($sub_ptr_div1492)|0) <= (($923)|0);
      if ($cmp1493) { label = 278; break; } else { label = 279; break; }
    case 278: 
      var $924=$L_addr;
      var $925=$n1474;
      _luaD_growstack($924, $925);
      label = 280; break;
    case 279: 
      label = 280; break;
    case 280: 
      var $926=$ci;
      var $u1498=(($926+24)|0);
      var $l1499=$u1498;
      var $base1500=(($l1499)|0);
      var $927=HEAP32[(($base1500)>>2)];
      $base=$927;
      var $928=$base;
      var $929=$i;
      var $shr1501=$929 >>> 6;
      var $and1502=$shr1501 & 255;
      var $add_ptr1503=(($928+((($and1502)*(12))&-1))|0);
      $ra=$add_ptr1503;
      var $930=$ra;
      var $931=$n1474;
      var $add_ptr1504=(($930+((($931)*(12))&-1))|0);
      var $932=$L_addr;
      var $top1505=(($932+8)|0);
      HEAP32[(($top1505)>>2)]=$add_ptr1504;
      label = 281; break;
    case 281: 
      $j=0;
      label = 282; break;
    case 282: 
      var $933=$j;
      var $934=$b1470;
      var $cmp1508=(($933)|0) < (($934)|0);
      if ($cmp1508) { label = 283; break; } else { label = 288; break; }
    case 283: 
      var $935=$j;
      var $936=$n1474;
      var $cmp1511=(($935)|0) < (($936)|0);
      if ($cmp1511) { label = 284; break; } else { label = 285; break; }
    case 284: 
      var $937=$base;
      var $938=$n1474;
      var $idx_neg=(((-$938))|0);
      var $add_ptr1515=(($937+((($idx_neg)*(12))&-1))|0);
      var $939=$j;
      var $add_ptr1516=(($add_ptr1515+((($939)*(12))&-1))|0);
      $io21514=$add_ptr1516;
      var $940=$ra;
      var $941=$j;
      var $add_ptr1518=(($940+((($941)*(12))&-1))|0);
      $io11517=$add_ptr1518;
      var $942=$io11517;
      var $value_1519=(($942)|0);
      var $943=$io21514;
      var $value_1520=(($943)|0);
      var $944=$value_1519;
      var $945=$value_1520;
      HEAP32[(($944)>>2)]=HEAP32[(($945)>>2)];HEAP32[((($944)+(4))>>2)]=HEAP32[((($945)+(4))>>2)];
      var $946=$io21514;
      var $tt_1521=(($946+8)|0);
      var $947=HEAP32[(($tt_1521)>>2)];
      var $948=$io11517;
      var $tt_1522=(($948+8)|0);
      HEAP32[(($tt_1522)>>2)]=$947;
      label = 286; break;
    case 285: 
      var $949=$ra;
      var $950=$j;
      var $add_ptr1524=(($949+((($950)*(12))&-1))|0);
      var $tt_1525=(($add_ptr1524+8)|0);
      HEAP32[(($tt_1525)>>2)]=0;
      label = 286; break;
    case 286: 
      label = 287; break;
    case 287: 
      var $951=$j;
      var $inc1528=((($951)+(1))|0);
      $j=$inc1528;
      label = 282; break;
    case 288: 
      label = 290; break;
    case 289: 
      label = 290; break;
    case 290: 
      label = 4; break;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_luaV_execute["X"]=1;

function _getcached($p, $encup, $base) {
  var label = 0;

  Module.print(INDENT + ' Entering: _getcached: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $retval;
      var $p_addr;
      var $encup_addr;
      var $base_addr;
      var $c;
      var $nup;
      var $uv;
      var $i;
      var $v;
      $p_addr=$p;
      $encup_addr=$encup;
      $base_addr=$base;
      var $0=$p_addr;
      var $cache=(($0+32)|0);
      var $1=HEAP32[(($cache)>>2)];
      $c=$1;
      var $2=$c;
      var $cmp=(($2)|0)!=0;
      if ($cmp) { label = 3; break; } else { label = 13; break; }
    case 3: 
      var $3=$p_addr;
      var $sizeupvalues=(($3+40)|0);
      var $4=HEAP32[(($sizeupvalues)>>2)];
      $nup=$4;
      var $5=$p_addr;
      var $upvalues=(($5+28)|0);
      var $6=HEAP32[(($upvalues)>>2)];
      $uv=$6;
      $i=0;
      label = 4; break;
    case 4: 
      var $7=$i;
      var $8=$nup;
      var $cmp1=(($7)|0) < (($8)|0);
      if ($cmp1) { label = 5; break; } else { label = 12; break; }
    case 5: 
      var $9=$i;
      var $10=$uv;
      var $arrayidx=(($10+($9<<3))|0);
      var $instack=(($arrayidx+4)|0);
      var $11=HEAP8[($instack)];
      var $conv=(($11)&255);
      var $tobool=(($conv)|0)!=0;
      if ($tobool) { label = 6; break; } else { label = 7; break; }
    case 6: 
      var $12=$base_addr;
      var $13=$i;
      var $14=$uv;
      var $arrayidx2=(($14+($13<<3))|0);
      var $idx=(($arrayidx2+5)|0);
      var $15=HEAP8[($idx)];
      var $conv3=(($15)&255);
      var $add_ptr=(($12+((($conv3)*(12))&-1))|0);
      var $cond = $add_ptr;label = 8; break;
    case 7: 
      var $16=$i;
      var $17=$uv;
      var $arrayidx4=(($17+($16<<3))|0);
      var $idx5=(($arrayidx4+5)|0);
      var $18=HEAP8[($idx5)];
      var $idxprom=(($18)&255);
      var $19=$encup_addr;
      var $arrayidx6=(($19+($idxprom<<2))|0);
      var $20=HEAP32[(($arrayidx6)>>2)];
      var $v7=(($20+8)|0);
      var $21=HEAP32[(($v7)>>2)];
      var $cond = $21;label = 8; break;
    case 8: 
      var $cond;
      $v=$cond;
      var $22=$i;
      var $23=$c;
      var $l=$23;
      var $upvals=(($l+16)|0);
      var $arrayidx8=(($upvals+($22<<2))|0);
      var $24=HEAP32[(($arrayidx8)>>2)];
      var $v9=(($24+8)|0);
      var $25=HEAP32[(($v9)>>2)];
      var $26=$v;
      var $cmp10=(($25)|0)!=(($26)|0);
      if ($cmp10) { label = 9; break; } else { label = 10; break; }
    case 9: 
      $retval=0;
      label = 14; break;
    case 10: 
      label = 11; break;
    case 11: 
      var $27=$i;
      var $inc=((($27)+(1))|0);
      $i=$inc;
      label = 4; break;
    case 12: 
      label = 13; break;
    case 13: 
      var $28=$c;
      $retval=$28;
      label = 14; break;
    case 14: 
      var $29=$retval;

      Module.print(INDENT + 'Exiting: _getcached');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return $29;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_getcached["X"]=1;

function _luaZ_init($L, $z, $reader, $data) {
  var label = 0;

  Module.print(INDENT + ' Entering: _luaZ_init: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';

  var $L_addr;
  var $z_addr;
  var $reader_addr;
  var $data_addr;
  $L_addr=$L;
  $z_addr=$z;
  $reader_addr=$reader;
  $data_addr=$data;
  var $0=$L_addr;
  var $1=$z_addr;
  var $L1=(($1+16)|0);
  HEAP32[(($L1)>>2)]=$0;
  var $2=$reader_addr;
  var $3=$z_addr;
  var $reader2=(($3+8)|0);
  HEAP32[(($reader2)>>2)]=$2;
  var $4=$data_addr;
  var $5=$z_addr;
  var $data3=(($5+12)|0);
  HEAP32[(($data3)>>2)]=$4;
  var $6=$z_addr;
  var $n=(($6)|0);
  HEAP32[(($n)>>2)]=0;
  var $7=$z_addr;
  var $p=(($7+4)|0);
  HEAP32[(($p)>>2)]=0;

  Module.print(INDENT + 'Exiting: _luaZ_init');
  INDENT = INDENT.substr(0, INDENT.length-2);
  return;
  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _pushclosure($L, $p, $encup, $base, $ra) {
  var label = 0;

  Module.print(INDENT + ' Entering: _pushclosure: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $L_addr;
      var $p_addr;
      var $encup_addr;
      var $base_addr;
      var $ra_addr;
      var $nup;
      var $uv;
      var $i;
      var $ncl;
      var $io;
      $L_addr=$L;
      $p_addr=$p;
      $encup_addr=$encup;
      $base_addr=$base;
      $ra_addr=$ra;
      var $0=$p_addr;
      var $sizeupvalues=(($0+40)|0);
      var $1=HEAP32[(($sizeupvalues)>>2)];
      $nup=$1;
      var $2=$p_addr;
      var $upvalues=(($2+28)|0);
      var $3=HEAP32[(($upvalues)>>2)];
      $uv=$3;
      var $4=$L_addr;
      var $5=$nup;
      var $call=_luaF_newLclosure($4, $5);
      $ncl=$call;
      var $6=$p_addr;
      var $7=$ncl;
      var $l=$7;
      var $p1=(($l+12)|0);
      HEAP32[(($p1)>>2)]=$6;
      var $8=$ra_addr;
      $io=$8;
      var $9=$ncl;
      var $10=$9;
      var $11=$io;
      var $value_=(($11)|0);
      var $gc=$value_;
      HEAP32[(($gc)>>2)]=$10;
      var $12=$io;
      var $tt_=(($12+8)|0);
      HEAP32[(($tt_)>>2)]=70;
      $i=0;
      label = 3; break;
    case 3: 
      var $13=$i;
      var $14=$nup;
      var $cmp=(($13)|0) < (($14)|0);
      if ($cmp) { label = 4; break; } else { label = 9; break; }
    case 4: 
      var $15=$i;
      var $16=$uv;
      var $arrayidx=(($16+($15<<3))|0);
      var $instack=(($arrayidx+4)|0);
      var $17=HEAP8[($instack)];
      var $tobool=(($17 << 24) >> 24)!=0;
      if ($tobool) { label = 5; break; } else { label = 6; break; }
    case 5: 
      var $18=$L_addr;
      var $19=$base_addr;
      var $20=$i;
      var $21=$uv;
      var $arrayidx2=(($21+($20<<3))|0);
      var $idx=(($arrayidx2+5)|0);
      var $22=HEAP8[($idx)];
      var $conv=(($22)&255);
      var $add_ptr=(($19+((($conv)*(12))&-1))|0);
      var $call3=_luaF_findupval($18, $add_ptr);
      var $23=$i;
      var $24=$ncl;
      var $l4=$24;
      var $upvals=(($l4+16)|0);
      var $arrayidx5=(($upvals+($23<<2))|0);
      HEAP32[(($arrayidx5)>>2)]=$call3;
      label = 7; break;
    case 6: 
      var $25=$i;
      var $26=$uv;
      var $arrayidx6=(($26+($25<<3))|0);
      var $idx7=(($arrayidx6+5)|0);
      var $27=HEAP8[($idx7)];
      var $idxprom=(($27)&255);
      var $28=$encup_addr;
      var $arrayidx8=(($28+($idxprom<<2))|0);
      var $29=HEAP32[(($arrayidx8)>>2)];
      var $30=$i;
      var $31=$ncl;
      var $l9=$31;
      var $upvals10=(($l9+16)|0);
      var $arrayidx11=(($upvals10+($30<<2))|0);
      HEAP32[(($arrayidx11)>>2)]=$29;
      label = 7; break;
    case 7: 
      label = 8; break;
    case 8: 
      var $32=$i;
      var $inc=((($32)+(1))|0);
      $i=$inc;
      label = 3; break;
    case 9: 
      var $33=$p_addr;
      var $34=$33;
      var $gch=$34;
      var $marked=(($gch+5)|0);
      var $35=HEAP8[($marked)];
      var $conv12=(($35)&255);
      var $and=$conv12 & 4;
      var $tobool13=(($and)|0)!=0;
      if ($tobool13) { label = 10; break; } else { label = 11; break; }
    case 10: 
      var $36=$L_addr;
      var $37=$p_addr;
      var $38=$ncl;
      _luaC_barrierproto_($36, $37, $38);
      label = 11; break;
    case 11: 
      var $39=$ncl;
      var $40=$p_addr;
      var $cache=(($40+32)|0);
      HEAP32[(($cache)>>2)]=$39;

      Module.print(INDENT + 'Exiting: _pushclosure');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_pushclosure["X"]=1;

function _luaZ_fill($z) {
  var label = 0;
  var __stackBase__  = STACKTOP; STACKTOP = (STACKTOP + 4)|0; _memset(__stackBase__, 0, 4);
  Module.print(INDENT + ' Entering: _luaZ_fill: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $retval;
      var $z_addr;
      var $size=__stackBase__;
      var $L;
      var $buff;
      $z_addr=$z;
      var $0=$z_addr;
      var $L1=(($0+16)|0);
      var $1=HEAP32[(($L1)>>2)];
      $L=$1;
      var $2=$z_addr;
      var $reader=(($2+8)|0);
      var $3=HEAP32[(($reader)>>2)];
      var $4=$L;
      var $5=$z_addr;
      var $data=(($5+12)|0);
      var $6=HEAP32[(($data)>>2)];
      var $call=FUNCTION_TABLE[$3]($4, $6, $size);
      $buff=$call;
      var $7=$buff;
      var $cmp=(($7)|0)==0;
      if ($cmp) { label = 4; break; } else { label = 3; break; }
    case 3: 
      var $8=HEAP32[(($size)>>2)];
      var $cmp2=(($8)|0)==0;
      if ($cmp2) { label = 4; break; } else { label = 5; break; }
    case 4: 
      $retval=-1;
      label = 6; break;
    case 5: 
      var $9=HEAP32[(($size)>>2)];
      var $sub=((($9)-(1))|0);
      var $10=$z_addr;
      var $n=(($10)|0);
      HEAP32[(($n)>>2)]=$sub;
      var $11=$buff;
      var $12=$z_addr;
      var $p=(($12+4)|0);
      HEAP32[(($p)>>2)]=$11;
      var $13=$z_addr;
      var $p3=(($13+4)|0);
      var $14=HEAP32[(($p3)>>2)];
      var $incdec_ptr=(($14+1)|0);
      HEAP32[(($p3)>>2)]=$incdec_ptr;
      var $15=HEAP8[($14)];
      var $conv=(($15)&255);
      $retval=$conv;
      label = 6; break;
    case 6: 
      var $16=$retval;
      STACKTOP = __stackBase__;
      Module.print(INDENT + 'Exiting: _luaZ_fill');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return $16;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}


function _luaZ_read($z, $b, $n) {
  var label = 0;

  Module.print(INDENT + ' Entering: _luaZ_read: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $retval;
      var $z_addr;
      var $b_addr;
      var $n_addr;
      var $m;
      $z_addr=$z;
      $b_addr=$b;
      $n_addr=$n;
      label = 3; break;
    case 3: 
      var $0=$n_addr;
      var $tobool=(($0)|0)!=0;
      if ($tobool) { label = 4; break; } else { label = 13; break; }
    case 4: 
      var $1=$z_addr;
      var $n1=(($1)|0);
      var $2=HEAP32[(($n1)>>2)];
      var $cmp=(($2)|0)==0;
      if ($cmp) { label = 5; break; } else { label = 9; break; }
    case 5: 
      var $3=$z_addr;
      var $call=_luaZ_fill($3);
      var $cmp2=(($call)|0)==-1;
      if ($cmp2) { label = 6; break; } else { label = 7; break; }
    case 6: 
      var $4=$n_addr;
      $retval=$4;
      label = 14; break;
    case 7: 
      var $5=$z_addr;
      var $n4=(($5)|0);
      var $6=HEAP32[(($n4)>>2)];
      var $inc=((($6)+(1))|0);
      HEAP32[(($n4)>>2)]=$inc;
      var $7=$z_addr;
      var $p=(($7+4)|0);
      var $8=HEAP32[(($p)>>2)];
      var $incdec_ptr=((($8)-(1))|0);
      HEAP32[(($p)>>2)]=$incdec_ptr;
      label = 8; break;
    case 8: 
      label = 9; break;
    case 9: 
      var $9=$n_addr;
      var $10=$z_addr;
      var $n6=(($10)|0);
      var $11=HEAP32[(($n6)>>2)];
      var $cmp7=(($9)>>>0) <= (($11)>>>0);
      if ($cmp7) { label = 10; break; } else { label = 11; break; }
    case 10: 
      var $12=$n_addr;
      var $cond = $12;label = 12; break;
    case 11: 
      var $13=$z_addr;
      var $n8=(($13)|0);
      var $14=HEAP32[(($n8)>>2)];
      var $cond = $14;label = 12; break;
    case 12: 
      var $cond;
      $m=$cond;
      var $15=$b_addr;
      var $16=$z_addr;
      var $p9=(($16+4)|0);
      var $17=HEAP32[(($p9)>>2)];
      var $18=$m;
      _memcpy($15, $17, $18);
      var $19=$m;
      var $20=$z_addr;
      var $n10=(($20)|0);
      var $21=HEAP32[(($n10)>>2)];
      var $sub=((($21)-($19))|0);
      HEAP32[(($n10)>>2)]=$sub;
      var $22=$m;
      var $23=$z_addr;
      var $p11=(($23+4)|0);
      var $24=HEAP32[(($p11)>>2)];
      var $add_ptr=(($24+$22)|0);
      HEAP32[(($p11)>>2)]=$add_ptr;
      var $25=$b_addr;
      var $26=$m;
      var $add_ptr12=(($25+$26)|0);
      $b_addr=$add_ptr12;
      var $27=$m;
      var $28=$n_addr;
      var $sub13=((($28)-($27))|0);
      $n_addr=$sub13;
      label = 3; break;
    case 13: 
      $retval=0;
      label = 14; break;
    case 14: 
      var $29=$retval;

      Module.print(INDENT + 'Exiting: _luaZ_read');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return $29;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_luaZ_read["X"]=1;

function _traceexec($L) {
  var label = 0;

  Module.print(INDENT + ' Entering: _traceexec: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $L_addr;
      var $ci;
      var $mask;
      var $counthook;
      var $p;
      var $npc;
      var $newline;
      $L_addr=$L;
      var $0=$L_addr;
      var $ci1=(($0+16)|0);
      var $1=HEAP32[(($ci1)>>2)];
      $ci=$1;
      var $2=$L_addr;
      var $hookmask=(($2+40)|0);
      var $3=HEAP8[($hookmask)];
      $mask=$3;
      var $4=$mask;
      var $conv=(($4)&255);
      var $and=$conv & 8;
      var $tobool=(($and)|0)!=0;
      if ($tobool) { label = 3; break; } else { var $7 = 0;label = 4; break; }
    case 3: 
      var $5=$L_addr;
      var $hookcount=(($5+48)|0);
      var $6=HEAP32[(($hookcount)>>2)];
      var $cmp=(($6)|0)==0;
      var $7 = $cmp;label = 4; break;
    case 4: 
      var $7;
      var $land_ext=(($7)&1);
      $counthook=$land_ext;
      var $8=$counthook;
      var $tobool3=(($8)|0)!=0;
      if ($tobool3) { label = 5; break; } else { label = 6; break; }
    case 5: 
      var $9=$L_addr;
      var $basehookcount=(($9+44)|0);
      var $10=HEAP32[(($basehookcount)>>2)];
      var $11=$L_addr;
      var $hookcount4=(($11+48)|0);
      HEAP32[(($hookcount4)>>2)]=$10;
      label = 6; break;
    case 6: 
      var $12=$ci;
      var $callstatus=(($12+18)|0);
      var $13=HEAP8[($callstatus)];
      var $conv5=(($13)&255);
      var $and6=$conv5 & 128;
      var $tobool7=(($and6)|0)!=0;
      if ($tobool7) { label = 7; break; } else { label = 8; break; }
    case 7: 
      var $14=$ci;
      var $callstatus9=(($14+18)|0);
      var $15=HEAP8[($callstatus9)];
      var $conv10=(($15)&255);
      var $and11=$conv10 & -129;
      var $conv12=(($and11) & 255);
      HEAP8[($callstatus9)]=$conv12;
      label = 26; break;
    case 8: 
      var $16=$counthook;
      var $tobool14=(($16)|0)!=0;
      if ($tobool14) { label = 9; break; } else { label = 10; break; }
    case 9: 
      var $17=$L_addr;
      _luaD_hook($17, 3, -1);
      label = 10; break;
    case 10: 
      var $18=$mask;
      var $conv17=(($18)&255);
      var $and18=$conv17 & 4;
      var $tobool19=(($and18)|0)!=0;
      if ($tobool19) { label = 11; break; } else { label = 22; break; }
    case 11: 
      var $19=$ci;
      var $func=(($19)|0);
      var $20=HEAP32[(($func)>>2)];
      var $value_=(($20)|0);
      var $gc=$value_;
      var $21=HEAP32[(($gc)>>2)];
      var $cl=$21;
      var $l=$cl;
      var $p21=(($l+12)|0);
      var $22=HEAP32[(($p21)>>2)];
      $p=$22;
      var $23=$ci;
      var $u=(($23+24)|0);
      var $l22=$u;
      var $savedpc=(($l22+4)|0);
      var $24=HEAP32[(($savedpc)>>2)];
      var $25=$p;
      var $code=(($25+12)|0);
      var $26=HEAP32[(($code)>>2)];
      var $sub_ptr_lhs_cast=$24;
      var $sub_ptr_rhs_cast=$26;
      var $sub_ptr_sub=((($sub_ptr_lhs_cast)-($sub_ptr_rhs_cast))|0);
      var $sub_ptr_div=((((($sub_ptr_sub)|0))/(4))&-1);
      var $sub=((($sub_ptr_div)-(1))|0);
      $npc=$sub;
      var $27=$p;
      var $lineinfo=(($27+20)|0);
      var $28=HEAP32[(($lineinfo)>>2)];
      var $tobool23=(($28)|0)!=0;
      if ($tobool23) { label = 12; break; } else { label = 13; break; }
    case 12: 
      var $29=$npc;
      var $30=$p;
      var $lineinfo24=(($30+20)|0);
      var $31=HEAP32[(($lineinfo24)>>2)];
      var $arrayidx=(($31+($29<<2))|0);
      var $32=HEAP32[(($arrayidx)>>2)];
      var $cond = $32;label = 14; break;
    case 13: 
      var $cond = 0;label = 14; break;
    case 14: 
      var $cond;
      $newline=$cond;
      var $33=$npc;
      var $cmp25=(($33)|0)==0;
      if ($cmp25) { label = 20; break; } else { label = 15; break; }
    case 15: 
      var $34=$ci;
      var $u27=(($34+24)|0);
      var $l28=$u27;
      var $savedpc29=(($l28+4)|0);
      var $35=HEAP32[(($savedpc29)>>2)];
      var $36=$L_addr;
      var $oldpc=(($36+20)|0);
      var $37=HEAP32[(($oldpc)>>2)];
      var $cmp30=(($35)>>>0) <= (($37)>>>0);
      if ($cmp30) { label = 20; break; } else { label = 16; break; }
    case 16: 
      var $38=$newline;
      var $39=$p;
      var $lineinfo33=(($39+20)|0);
      var $40=HEAP32[(($lineinfo33)>>2)];
      var $tobool34=(($40)|0)!=0;
      if ($tobool34) { label = 17; break; } else { label = 18; break; }
    case 17: 
      var $41=$L_addr;
      var $oldpc36=(($41+20)|0);
      var $42=HEAP32[(($oldpc36)>>2)];
      var $43=$p;
      var $code37=(($43+12)|0);
      var $44=HEAP32[(($code37)>>2)];
      var $sub_ptr_lhs_cast38=$42;
      var $sub_ptr_rhs_cast39=$44;
      var $sub_ptr_sub40=((($sub_ptr_lhs_cast38)-($sub_ptr_rhs_cast39))|0);
      var $sub_ptr_div41=((((($sub_ptr_sub40)|0))/(4))&-1);
      var $sub42=((($sub_ptr_div41)-(1))|0);
      var $45=$p;
      var $lineinfo43=(($45+20)|0);
      var $46=HEAP32[(($lineinfo43)>>2)];
      var $arrayidx44=(($46+($sub42<<2))|0);
      var $47=HEAP32[(($arrayidx44)>>2)];
      var $cond47 = $47;label = 19; break;
    case 18: 
      var $cond47 = 0;label = 19; break;
    case 19: 
      var $cond47;
      var $cmp48=(($38)|0)!=(($cond47)|0);
      if ($cmp48) { label = 20; break; } else { label = 21; break; }
    case 20: 
      var $48=$L_addr;
      var $49=$newline;
      _luaD_hook($48, 2, $49);
      label = 21; break;
    case 21: 
      label = 22; break;
    case 22: 
      var $50=$ci;
      var $u53=(($50+24)|0);
      var $l54=$u53;
      var $savedpc55=(($l54+4)|0);
      var $51=HEAP32[(($savedpc55)>>2)];
      var $52=$L_addr;
      var $oldpc56=(($52+20)|0);
      HEAP32[(($oldpc56)>>2)]=$51;
      var $53=$L_addr;
      var $status=(($53+6)|0);
      var $54=HEAP8[($status)];
      var $conv57=(($54)&255);
      var $cmp58=(($conv57)|0)==1;
      if ($cmp58) { label = 23; break; } else { label = 26; break; }
    case 23: 
      var $55=$counthook;
      var $tobool61=(($55)|0)!=0;
      if ($tobool61) { label = 24; break; } else { label = 25; break; }
    case 24: 
      var $56=$L_addr;
      var $hookcount63=(($56+48)|0);
      HEAP32[(($hookcount63)>>2)]=1;
      label = 25; break;
    case 25: 
      var $57=$ci;
      var $u65=(($57+24)|0);
      var $l66=$u65;
      var $savedpc67=(($l66+4)|0);
      var $58=HEAP32[(($savedpc67)>>2)];
      var $incdec_ptr=((($58)-(4))|0);
      HEAP32[(($savedpc67)>>2)]=$incdec_ptr;
      var $59=$ci;
      var $callstatus68=(($59+18)|0);
      var $60=HEAP8[($callstatus68)];
      var $conv69=(($60)&255);
      var $or=$conv69 | 128;
      var $conv70=(($or) & 255);
      HEAP8[($callstatus68)]=$conv70;
      var $61=$L_addr;
      var $top=(($61+8)|0);
      var $62=HEAP32[(($top)>>2)];
      var $add_ptr=((($62)-(12))|0);
      var $63=$ci;
      var $func71=(($63)|0);
      HEAP32[(($func71)>>2)]=$add_ptr;
      var $64=$L_addr;
      _luaD_throw($64, 1);

    case 26: 

      Module.print(INDENT + 'Exiting: _traceexec');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_traceexec["X"]=1;

function _luaZ_openspace($L, $buff, $n) {
  var label = 0;

  Module.print(INDENT + ' Entering: _luaZ_openspace: ' + Array.prototype.slice.call(arguments)); INDENT += '  ';
  label = 2; 
  while(1) switch(label) {
    case 2: 
      var $L_addr;
      var $buff_addr;
      var $n_addr;
      $L_addr=$L;
      $buff_addr=$buff;
      $n_addr=$n;
      var $0=$n_addr;
      var $1=$buff_addr;
      var $buffsize=(($1+8)|0);
      var $2=HEAP32[(($buffsize)>>2)];
      var $cmp=(($0)>>>0) > (($2)>>>0);
      if ($cmp) { label = 3; break; } else { label = 9; break; }
    case 3: 
      var $3=$n_addr;
      var $cmp1=(($3)>>>0) < 32;
      if ($cmp1) { label = 4; break; } else { label = 5; break; }
    case 4: 
      $n_addr=32;
      label = 5; break;
    case 5: 
      var $4=$n_addr;
      var $add=((($4)+(1))|0);
      var $cmp3=(($add)>>>0) > 4294967293;
      if ($cmp3) { label = 6; break; } else { label = 7; break; }
    case 6: 
      var $5=$L_addr;
      _luaM_toobig($5);

      label = 8; break;
    case 7: 
      var $7=$L_addr;
      var $8=$buff_addr;
      var $buffer=(($8)|0);
      var $9=HEAP32[(($buffer)>>2)];
      var $10=$buff_addr;
      var $buffsize4=(($10+8)|0);
      var $11=HEAP32[(($buffsize4)>>2)];
      var $mul=$11;
      var $12=$n_addr;
      var $mul5=$12;
      var $call=_luaM_realloc_($7, $9, $mul, $mul5);
      var $cond = $call;label = 8; break;
    case 8: 
      var $cond;
      var $13=$buff_addr;
      var $buffer6=(($13)|0);
      HEAP32[(($buffer6)>>2)]=$cond;
      var $14=$n_addr;
      var $15=$buff_addr;
      var $buffsize7=(($15+8)|0);
      HEAP32[(($buffsize7)>>2)]=$14;
      label = 9; break;
    case 9: 
      var $16=$buff_addr;
      var $buffer9=(($16)|0);
      var $17=HEAP32[(($buffer9)>>2)];

      Module.print(INDENT + 'Exiting: _luaZ_openspace');
      INDENT = INDENT.substr(0, INDENT.length-2);
      return $17;
  }

  INDENT = INDENT.substr(0, INDENT.length-2);
}
_luaZ_openspace["X"]=1;

// Warning: printing of i64 values may be slightly rounded! No deep i64 math used, so precise i64 code not included
var i64Math = null;

// === Auto-generated postamble setup entry stuff ===

Module.callMain = function callMain(args) {
  var argc = args.length+1;
  function pad() {
    for (var i = 0; i < 4-1; i++) {
      argv.push(0);
    }
  }
  var argv = [allocate(intArrayFromString("/bin/this.program"), 'i8', ALLOC_STATIC) ];
  pad();
  for (var i = 0; i < argc-1; i = i + 1) {
    argv.push(allocate(intArrayFromString(args[i]), 'i8', ALLOC_STATIC));
    pad();
  }
  argv.push(0);
  argv = allocate(argv, 'i32', ALLOC_STATIC);


  var ret;

  ret = Module['_main'](argc, argv, 0);


  return ret;
}




function run(args) {
  args = args || Module['arguments'];

  if (runDependencies > 0) {
    Module.printErr('run() called, but dependencies remain, so not running');
    return 0;
  }

  if (Module['preRun']) {
    if (typeof Module['preRun'] == 'function') Module['preRun'] = [Module['preRun']];
    var toRun = Module['preRun'];
    Module['preRun'] = [];
    for (var i = toRun.length-1; i >= 0; i--) {
      toRun[i]();
    }
    if (runDependencies > 0) {
      // a preRun added a dependency, run will be called later
      return 0;
    }
  }

  function doRun() {
    var ret = 0;
    calledRun = true;
    if (Module['_main']) {
      preMain();
      ret = Module.callMain(args);
      if (!Module['noExitRuntime']) {
        exitRuntime();
      }
    }
    if (Module['postRun']) {
      if (typeof Module['postRun'] == 'function') Module['postRun'] = [Module['postRun']];
      while (Module['postRun'].length > 0) {
        Module['postRun'].pop()();
      }
    }
    return ret;
  }

  if (Module['setStatus']) {
    Module['setStatus']('Running...');
    setTimeout(function() {
      setTimeout(function() {
        Module['setStatus']('');
      }, 1);
      doRun();
    }, 1);
    return 0;
  } else {
    return doRun();
  }
}
Module['run'] = Module.run = run;

// {{PRE_RUN_ADDITIONS}}

if (Module['preInit']) {
  if (typeof Module['preInit'] == 'function') Module['preInit'] = [Module['preInit']];
  while (Module['preInit'].length > 0) {
    Module['preInit'].pop()();
  }
}

initRuntime();

var shouldRunNow = false;
if (Module['noInitialRun']) {
  shouldRunNow = false;
}

if (shouldRunNow) {
  var ret = run();
}

// {{POST_RUN_ADDITIONS}}






  // {{MODULE_ADDITIONS}}


// EMSCRIPTEN_GENERATED_FUNCTIONS: ["_computesizes","_txtToken","_dothecall","_luaV_settable","_assignment","_lua_pushlightuserdata","_lua_rawset","_luaK_storevar","_lua_setmetatable","_freeobj","_str_checkname","_luaX_lookahead","_internshrstr","_luaC_barrierback_","_test_then_block","_moveto","_lua_setupvalue","_findvararg","_read_numeral","_new_localvar","_freestack","_lua_xmove","_luaC_fullgc","_luaH_new","_aux_upvalue","_lua_touserdata","_luaX_syntaxerror","_findindex","_retstat","_ifstat","_markupval","_codestring","_error_expected","_luaO_arith","_DumpChar","_lua_remove","_closelistfield","_luaZ_openspace","_lua_len","_luaK_self","_field","_lua_pushvfstring","_lua_rawequal","_traceexec","_luaZ_fill","_checkmode","_llex","_f_parser","_luaS_new","_luaH_get","_luaD_throw","_luaV_tonumber","_check_next","_resume","_luaC_newobj","_init_registry","_lua_pushfstring","_findgotos","_sweeptolive","_lua_tolstring","_luaK_jump","_LoadString","_propagateall","_subexpr","_luaK_codeABC","_luaV_arith","_codenot","_separatetobefnz","_lua_settable","_mainfunc","_patchtestreg","_lua_gethook","_lua_gethookcount","_luaK_codeABx","_primaryexp","_lua_tounsignedx","_luaK_infix","_atomic","_luaH_free","_save","_freeexp","_luaV_equalobj_","_luaD_shrinkstack","_luaX_init","_cond","_addinfo","_luaK_posfix","_resume_error","_lua_sethook","_forbody","_luaS_newlstr","_pushstr","_luaF_newproto","_luaG_aritherror","_generationalcollection","_luaV_finishOp","_luaV_lessthan","_DumpDebug","_lua_close","_LoadUpvalues","_statlist","_discharge2anyreg","_traversestack","_adjust_assign","_luaV_execute","_recfield","_luaT_gettmbyobj","_unlinkupval","_callallpendingfinalizers","_getcached","_read_string","_luaG_typeerror","_localstat","_luaZ_init","_luaF_newCclosure","_luaX_setinput","_luaO_pushfstring","_breaklabel","_getupvalref","_lua_gethookmask","_traverseproto","_whilestat","_buffreplace","_check_conflict","_luaK_getlabel","_luaF_getlocalname","_luaH_newkey","_isnumeral","_lua_arith","_luaG_ordererror","_traverseweakvalue","_luaF_freeproto","_singlevar","_codeextraarg","_undefgoto","_lua_load","_luaO_pushvfstring","_skipnoopstat","_lua_pcallk","_traverseLclosure","_parlist","_findlocal","_getupvalname","_funcname","_luaC_step","_traversetable","_lua_isuserdata","_luaU_undump","_lua_resume","_lua_iscfunction","_luaC_checkfinalizer","_DumpBlock","_forlist","_luaT_init","_lua_rawlen","_luaK_checkstack","_need_value","_lua_isnumber","_enterblock","_luaM_toobig","_lexerror","_removevalues","_luaO_chunkid","_luaU_header","_luaF_findupval","_luaX_newstring","_luaH_setint","_luaK_goiftrue","_luaF_close","_luaK_setreturns","_singlestep","_lua_strx2number","_block_follow","_propagatelist","_DumpUpvalues","_suffixedexp","_luaD_hook","_luaO_hexavalue","_read_long_string","_unbound_search","_block","_hashnum","_lua_getstack","_lua_gettop","_lua_getlocal","_lua_setuservalue","_getlocvar","_readdecesc","_luaG_errormsg","_lua_toboolean","_DumpHeader","_luaK_concat","_l_strcmp","_lua_tothread","_isneg","_lua_getctx","_remarkupvals","_luaC_freeallobjects","_iscleared","_luaK_indexed","_closegoto","_LoadNumber","_currentline","_luaK_goiffalse","_luaV_concat","_makeseed","_codecomp","_LoadChar","_luaE_setdebt","_exprstat","_luaC_barrierproto_","_upvalname","_growstack","_luaT_gettm","_luaS_eqlngstr","_luaH_set","_countint","_callTM","_lua_atpanic","_getbinopr","_luaE_freethread","_lua_getinfo","_luaK_patchclose","_lua_setfield","_statement","_sweeplist","_lua_next","_lua_concat","_luaD_reallocstack","_funcargs","_luaF_newupval","_seterrorobj","_lua_rawseti","_collectvalidlines","_getobjname","_luaM_realloc_","_lua_absindex","_stackinuse","_boolK","_LoadFunction","_luaK_dischargevars","_luaU_dump","_f_call","_fornum","_code_label","_checklimit","_traverseCclosure","_entersweep","_new_localvarliteral_","_lua_copy","_constfolding","_errorlimit","_luaH_next","_lua_pushnil","_removeentry","_LoadInt","_DumpInt","_luaO_int2fb","_callhook","_newupvalue","_addk","_explist","_searchupvalue","_lua_rawget","_get_equalTM","_constructor","_condjump","_f_luaopen","_newlabelentry","_index2addr","_luaG_concaterror","_luaS_eqstr","_readhexaesc","_LoadDebug","_currentpc","_getjump","_patchlistaux","_incstep","_luaK_prefix","_listfield","_freereg","_init_exp","_lua_pushlstring","_findsetreg","_lastlistfield","_findlabel","_setnodevector","_reallymarkobject","_checkname","_sweepthread","_luaK_patchlist","_close_func","_convergeephemerons","_luaD_poscall","_lua_insert","_enterlevel","_finishCcall","_luaK_ret","_lua_getupvalue","_fieldsel","_LoadBlock","_lua_checkstack","_movegotosout","_lua_error","_lua_upvalueid","_clearvalues","_checknext","_luaK_exp2RK","_getfuncname","_checkrepeated","_yindex","_codearith","_luaH_resizearray","_lua_setlocal","_lua_yieldk","_lua_newstate","_markbeingfnz","_setarrayvector","_lua_tocfunction","_luaK_exp2anyreg","_luaE_freeCI","_gotostat","_unroll","_luaO_str2d","_checkSizes","_addprototype","_pushclosure","_inclinenumber","_luaD_precall","_lua_getfield","_createstrobj","_tryfuncTM","_luaK_numberK","_luaD_protectedparser","_DumpNumber","_traverseephemeron","_DumpFunction","_lua_settop","_lua_pushboolean","_lua_replace","_retraversegrays","_adjust_varargs","_luaK_codek","_luaO_fb2int","_luaV_objlen","_numusehash","_luaD_call","_discharge2reg","_localfunc","_readhexa","_lua_getuservalue","_labelstat","_luaY_parser","_lua_status","_lua_tonumberx","_luaZ_read","_recover","_jumponcond","_getfreepos","_lua_setglobal","_getjumpcontrol","_luaK_reserveregs","_leaveblock","_clearkeys","_call_binTM","_lua_createtable","_kname","_funcinfo","_luaF_freeupval","_luaC_forcestep","_lua_pushthread","_call_orderTM","_exp1","_luaK_stringK","_singlevaraux","_correctstack","_luaK_exp2anyregup","_codeclosure","_luaF_newLclosure","_udata2finalize","_traversestrongtable","_luaS_resize","_luaM_growaux_","_getunopr","_lua_getglobal","_error","_lua_pushcclosure","_lua_pushstring","_luaH_getstr","_lua_upvaluejoin","_exp2reg","_expr","_luaK_exp2val","_luaK_setlist","_mainposition","_preinit_state","_testnext","_body","_trydecpoint","_DumpVector","_GCTM","_luaD_growstack","_escerror","_luaX_token2str","_isinstack","_lua_isstring","_luaD_pcall","_searchvar","_luaH_getn","_nilK","_luaS_hash","_luaK_code","_simpleexp","_lua_callk","_luaK_setoneret","_luaC_checkupvalcolor","_invertjump","_luaV_lessequal","_check","_removevars","_luaO_ceillog2","_skip_sep","_newshrstr","_lua_newthread","_DumpConstants","_markroot","_markmt","_luaE_extendCI","_luaH_getint","_lua_pushnumber","_lua_topointer","_luaC_barrier_","_luaV_tostring","_luaK_patchtohere","_lua_gettable","_fixjump","_lua_compare","_luaX_next","_close_state","_lua_gc","_lua_newuserdata","_lua_setallocf","_lua_tointegerx","_lua_version","_registerlocalvar","_luaG_runerror","_lua_rawgetp","_DumpString","_lua_pushvalue","_luaH_resize","_lua_typename","_luaC_changemode","_luaS_newudata","_lua_rawgeti","_propagatemark","_auxgetinfo","_luaD_rawrunprotected","_lua_getallocf","_luaK_exp2nextreg","_lua_type","_lua_dump","_LoadConstants","_stack_init","_luaK_nil","_luaK_fixline","_lua_getmetatable","_lua_pushunsigned","_findpcall","_forstat","_anchor_token","_rehash","_dischargejpc","_funcstat","_LoadCode","_LoadHeader","_luaV_gettable","_lua_rawsetp","_semerror","_repeatstat","_lua_pushinteger","_adjustlocalvars","_check_match","_open_func","_luaC_runtilstate","_arrayindex","_numusearray"]


// This file is appended to the end of build/liblua.js

// WEBLUA API =================================================================
// 
// Written by Philip Horger
// Based on https://github.com/replit/jsrepl/blob/master/extern/lua/entry_point.js
// 
// ============================================================================

this['Lua'] = {
    isInitialized: false,
    state: null,
    initialize: function (stdout, stderr) {
        if (this.isInitialized) throw new Error('Lua already initialized');
        run();
        this.state = _luaL_newstate();
        _luaL_openlibs(this.state);
        this.isInitialized = true;
    },
    eval: function (command) {
        throw "Not implemented yet: Lua.eval";
    },
    lua_to_js: function (name, object) {
        throw "Not implemented yet: Lua.lua_to_js";
    },
    js_to_lua: function (command) {
        throw "Not implemented yet: Lua.js_to_lua";
    },
}
